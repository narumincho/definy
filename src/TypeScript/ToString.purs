module TypeScript.ToString
  ( TypeScriptCodeError(..)
  , TypeScriptCodeErrorWithLocation(..)
  , documentToString
  , typeScriptModuleMapToString
  ) where

import Data.Array as Array
import Data.Array.NonEmpty (NonEmptyArray)
import Data.Either as Either
import Data.Map as Map
import Data.Maybe (Maybe(..))
import Data.Set as Set
import Data.String as String
import Data.String.NonEmpty as NonEmptyString
import Data.Tuple as Tuple
import FileSystem.Name as Name
import Prelude as Prelude
import TypeScript.Data as Data
import TypeScript.Identifier as Identifier
import TypeScript.ModuleName as ModuleName

newtype TypeScriptCodeErrorWithLocation
  = TypeScriptCodeErrorWithLocation
  { error :: TypeScriptCodeError
  }

data TypeScriptCodeError
  = NotImplemented

typeScriptModuleMapToString ::
  Data.TypeScriptModuleMap ->
  (Map.Map Name.Name (Either.Either (NonEmptyArray TypeScriptCodeErrorWithLocation) String))
typeScriptModuleMapToString (Data.TypeScriptModuleMap moduleMap) =
  Map.fromFoldable
    ( Prelude.map
        typeScriptModuleToString
        ((Map.toUnfoldable moduleMap) :: Array _)
    )

typeScriptModuleToString ::
  Tuple.Tuple ModuleName.ModuleName Data.TypeScriptModule ->
  Tuple.Tuple
    Name.Name
    (Either.Either (NonEmptyArray TypeScriptCodeErrorWithLocation) String)
typeScriptModuleToString (Tuple.Tuple moduleName moduleContent) =
  Tuple.Tuple (ModuleName.toFileSystemName moduleName)
    (typeScriptModuleContentToString moduleContent)

typeScriptModuleContentToString ::
  Data.TypeScriptModule ->
  Either.Either (NonEmptyArray TypeScriptCodeErrorWithLocation) String
typeScriptModuleContentToString (Data.TypeScriptModule { exportDefinitionList }) =
  Either.Right
    ( append3
        """/* eslint-disable */
/* generated by definy. Do not edit! */

"""
        (String.joinWith "" (Prelude.map definitionToString exportDefinitionList))
        "\n"
    )

definitionToString :: Data.ExportDefinition -> String
definitionToString = case _ of
  Data.ExportDefinitionTypeAlias typeAlias -> typeAliasToString typeAlias
  Data.ExportDefinitionFunction _ -> ""
  Data.ExportDefinitionVariable _ -> ""

typeAliasToString :: Data.TypeAlias -> String
typeAliasToString (Data.TypeAlias rec) =
  String.joinWith ""
    [ documentToString rec.document
    , "export type "
    , Identifier.toString rec.name
    , typeParameterListToString rec.typeParameterList
    , " = "
    , typeToString rec.type
    , ";\n\n"
    ]

typeToString :: Data.TsType -> String
typeToString = case _ of
  Data.TsTypeNumber -> "number"
  Data.TsTypeString -> "string"
  Data.TsTypeBoolean -> "boolean"
  Data.TsTypeUndefined -> "undefined"
  Data.TsTypeNull -> "null"
  Data.TsTypeNever -> "never"
  Data.TsTypeVoid -> "void"
  Data.TsTypeObject memberList -> typeObjectToString memberList
  Data.TsTypeFunction functionType -> functionTypeToString functionType
  Data.TsTypeUnion typeList ->
    String.joinWith
      " | "
      (Prelude.map typeToString typeList)
  Data.TsTypeIntersection (Tuple.Tuple left right) ->
    append3
      (typeToString left)
      " & "
      (typeToString right)
  Data.TsTypeImportedType (Data.ImportedType { typeNameAndTypeParameter }) ->
    Prelude.append
      "(!!!!scope!!!!)."
      (typeNameAndTypeParameterToString typeNameAndTypeParameter)
  Data.TsTypeScopeInFile typeNameAndTypeParameter -> typeNameAndTypeParameterToString typeNameAndTypeParameter
  Data.TsTypeScopeInGlobal typeNameAndTypeParameter ->
    Prelude.append
      "globalThis."
      (typeNameAndTypeParameterToString typeNameAndTypeParameter)
  Data.TsTypeStringLiteral str -> stringLiteralValueToString str

typeObjectToString :: Array Data.TsMemberType -> String
typeObjectToString memberList =
  append3
    "{ "
    ( String.joinWith "; "
        ( Prelude.map
            ( \(Data.TsMemberType member) ->
                String.joinWith ""
                  [ documentToString member.document
                  , "readonly "
                  , if Identifier.isSafePropertyName member.name then
                      member.name
                    else
                      stringLiteralValueToString member.name
                  , if member.required then "" else "?"
                  , ": "
                  , typeToString member.type
                  ]
            )
            memberList
        )
    )
    " }"

functionTypeToString :: Data.FunctionType -> String
functionTypeToString (Data.FunctionType rec) =
  String.joinWith ""
    [ typeParameterListToString rec.typeParameterList
    , "("
    , String.joinWith ", "
        ( Array.foldl
              ( \indexAndList parameterType ->
                  let
                    { identifier, nextIdentifierIndex } = Identifier.createIdentifier indexAndList.identifierIndex Set.empty
                  in
                    { list:
                        Array.snoc
                          indexAndList.list
                          (identifierAndTypeToString identifier parameterType)
                    , identifierIndex: nextIdentifierIndex
                    }
              )
              { list: []
              , identifierIndex: Identifier.initialIdentifierIndex
              }
              rec.parameterList
          )
          .list
    , ") => "
    , typeToString rec.return
    ]

identifierAndTypeToString :: Identifier.TsIdentifier -> Data.TsType -> String
identifierAndTypeToString identifier parameterType =
  append3
    (Identifier.toString identifier)
    ": "
    (typeToString parameterType)

typeNameAndTypeParameterToString :: Data.TypeNameAndTypeParameter -> String
typeNameAndTypeParameterToString (Data.TypeNameAndTypeParameter { name, typeParameterList }) =
  Prelude.append
    (Identifier.toString name)
    ( if Array.null typeParameterList then
        ""
      else
        append3
          "<"
          (String.joinWith ", " (Prelude.map typeToString typeParameterList))
          ">"
    )

-- | 文字列を`"`で囲んでエスケープする
stringLiteralValueToString :: String -> String
stringLiteralValueToString value =
  append3
    "\""
    ( String.replaceAll (String.Pattern "\n") (String.Replacement "\\n")
        ( String.replaceAll (String.Pattern "\r\n") (String.Replacement "\\n")
            ( String.replaceAll (String.Pattern "\"") (String.Replacement "\\\"")
                (String.replaceAll (String.Pattern "\\") (String.Replacement "\\\\") value)
            )
        )
    )
    "\""

-- | 型パラメーターを文字列にする `<T extends unknown>` `<ok extends unknown, error extends unknown>`
-- | extends unknown をつけた理由はJSXでも解釈できるようにするため
documentToString :: String -> String
documentToString document = case NonEmptyString.fromString (String.trim document) of
  Just nonEmptyDocument ->
    append3
      """
/**
"""
      ( String.joinWith "\n"
          ( Prelude.map
              ( \line ->
                  Prelude.append
                    (if Prelude.eq line "" then " *" else " * ")
                    (String.replaceAll (String.Pattern "*/") (String.Replacement "* /") line)
              )
              (String.split (String.Pattern "\n") (NonEmptyString.toString nonEmptyDocument))
          )
      )
      """
 */
"""
  Nothing -> ""

typeParameterListToString :: Array Identifier.TsIdentifier -> String
typeParameterListToString = case _ of
  [] -> ""
  list ->
    append3
      "<"
      ( String.joinWith ", "
          ( Prelude.map
              ( \typeParameter ->
                  Prelude.append
                    (Identifier.toString typeParameter)
                    " extends unknown"
              )
              list
          )
      )
      ">"

append3 :: String -> String -> String -> String
append3 a b c =
  Prelude.append
    (Prelude.append a b)
    c
