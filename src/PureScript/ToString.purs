module PureScript.ToString where

import Data.Array as Array
import Data.Array.NonEmpty as NonEmptyArray
import Data.Map as Map
import Data.Maybe as Maybe
import Data.Set as Set
import Data.String as String
import Data.String.NonEmpty as NonEmptyString
import Data.Tuple as Tuple
import Prelude as Prelude
import PureScript.Data as Data

toString :: Data.Module -> String
toString pModule@(Data.Module { definitionList }) =
  let
    importedModuleQualifiedNameDict :: ModuleQualifiedNameDict
    importedModuleQualifiedNameDict =
      importedModuleSetToQualifiedNameDict
        (collectInportModule pModule)
  in
    String.joinWith "\n\n"
      ( Array.concat
          [ [ "-- generated by definy. Do not edit!"
            , moduleNameCode pModule
            , String.joinWith "\n"
                ( Prelude.map
                    ( \(Tuple.Tuple moduleName qualifiedName) ->
                        String.joinWith
                          ""
                          [ "import "
                          , moduleNameToString moduleName
                          , " as "
                          , NonEmptyString.toString qualifiedName
                          ]
                    )
                    (dictToTupleArray importedModuleQualifiedNameDict)
                )
            ]
          , Prelude.map (definitionToString importedModuleQualifiedNameDict) definitionList
          , [ "" ]
          ]
      )

newtype ModuleQualifiedNameDict
  = ModuleQualifiedNameDict (Map.Map Data.ModuleName NonEmptyString.NonEmptyString)

dictToTupleArray :: ModuleQualifiedNameDict -> Array (Tuple.Tuple Data.ModuleName NonEmptyString.NonEmptyString)
dictToTupleArray (ModuleQualifiedNameDict map) = Map.toUnfoldable map

dicGetQualifiedName :: Data.ModuleName -> ModuleQualifiedNameDict -> Maybe.Maybe NonEmptyString.NonEmptyString
dicGetQualifiedName moduleName (ModuleQualifiedNameDict map) = Map.lookup moduleName map

importedModuleSetToQualifiedNameDict :: Set.Set Data.ModuleName -> ModuleQualifiedNameDict
importedModuleSetToQualifiedNameDict moduleNameSet =
  ModuleQualifiedNameDict
    ( Map.fromFoldable
        ( Array.mapWithIndex
            ( \i moduleName ->
                Tuple.Tuple
                  moduleName
                  ( NonEmptyString.cons
                      (String.codePointFromChar 'M')
                      (Prelude.show i)
                  )
            )
            ((Set.toUnfoldable moduleNameSet) :: Array Data.ModuleName)
        )
    )

moduleNameCode :: Data.Module -> String
moduleNameCode (Data.Module { name, definitionList }) = String.joinWith "" ([ "module ", moduleNameToString name, "(", String.joinWith ", " (collectExportDefinition definitionList), ") where" ])

moduleNameToString :: Data.ModuleName -> String
moduleNameToString (Data.ModuleName stringList) =
  String.joinWith "."
    (Prelude.map NonEmptyString.toString (NonEmptyArray.toArray stringList))

collectInportModule :: Data.Module -> Set.Set Data.ModuleName
collectInportModule (Data.Module { name, definitionList }) =
  Set.delete name
    ( Set.unions
        (Prelude.map collectInportModuleInDefinition definitionList)
    )

collectInportModuleInDefinition :: Data.Definition -> Set.Set Data.ModuleName
collectInportModuleInDefinition (Data.Definition { pType, expr }) =
  Set.union
    (collectInportModuleInType pType)
    (collectInportModuleInExpr expr)

collectInportModuleInType :: Data.PType -> Set.Set Data.ModuleName
collectInportModuleInType (Data.PType { moduleName, argument }) =
  Set.insert
    moduleName
    ( case argument of
        Maybe.Just argumentType -> collectInportModuleInType argumentType
        Maybe.Nothing -> Set.empty
    )

collectInportModuleInExpr :: Data.Expr -> Set.Set Data.ModuleName
collectInportModuleInExpr = case _ of
  Data.Call { function, arguments } ->
    Set.unions
      ( Prelude.map collectInportModuleInExpr
          (Array.cons function (NonEmptyArray.toArray arguments))
      )
  Data.Variable { moduleName } -> Set.singleton moduleName
  Data.StringLiteral _ -> Set.empty
  Data.ArrayLiteral list -> Set.unions (Prelude.map collectInportModuleInExpr list)

collectExportDefinition :: Array Data.Definition -> Array String
collectExportDefinition list =
  Array.mapMaybe
    ( case _ of
        Data.Definition { isExport: true, name } -> Maybe.Just (NonEmptyString.toString name)
        Data.Definition _ -> Maybe.Nothing
    )
    list

definitionToString :: ModuleQualifiedNameDict -> Data.Definition -> String
definitionToString importedModuleQualifiedNameDict (Data.Definition { name, document, pType, expr }) =
  String.joinWith ""
    [ documentToString document
    , NonEmptyString.toString name
    , " :: "
    , typeToString importedModuleQualifiedNameDict pType
    , "\n"
    , NonEmptyString.toString name
    , " = "
    , exprToString importedModuleQualifiedNameDict expr
    ]

typeToString :: ModuleQualifiedNameDict -> Data.PType -> String
typeToString importedModuleQualifiedNameDict (Data.PType { moduleName, name, argument }) =
  String.joinWith ""
    ( Array.concat
        [ [ moduleNameToStringSelfEmpty importedModuleQualifiedNameDict moduleName, name ]
        , case argument of
            Maybe.Just argumentType ->
              [ "("
              , typeToString importedModuleQualifiedNameDict argumentType
              , ")"
              ]
            Maybe.Nothing -> []
        ]
    )

exprToString :: ModuleQualifiedNameDict -> Data.Expr -> String
exprToString importedModuleQualifiedNameDict = case _ of
  Data.Call { function, arguments } ->
    String.joinWith " "
      ( Prelude.map
          ( \expr ->
              String.joinWith ""
                [ "("
                , exprToString importedModuleQualifiedNameDict expr
                , ")"
                ]
          )
          (Array.cons function (NonEmptyArray.toArray arguments))
      )
  Data.Variable { moduleName, name } ->
    String.joinWith ""
      [ moduleNameToStringSelfEmpty importedModuleQualifiedNameDict moduleName
      , NonEmptyString.toString name
      ]
  Data.StringLiteral value ->
    String.joinWith ""
      [ "\""
      , String.replaceAll (String.Pattern "\n") (String.Replacement "\\n")
          ( String.replaceAll (String.Pattern "\"") (String.Replacement "\\\"")
              ( String.replaceAll (String.Pattern "\\") (String.Replacement "\\\\") value
              )
          )
      , "\""
      ]
  Data.ArrayLiteral list ->
    String.joinWith ""
      [ "[ "
      , String.joinWith ", " (Prelude.map (exprToString importedModuleQualifiedNameDict) list)
      , " ]"
      ]

moduleNameToStringSelfEmpty :: ModuleQualifiedNameDict -> Data.ModuleName -> String
moduleNameToStringSelfEmpty importedModuleQualifiedNameDict moduleName = case dicGetQualifiedName moduleName importedModuleQualifiedNameDict of
  Maybe.Just qualifiedName ->
    NonEmptyString.toString
      (NonEmptyString.appendString qualifiedName ".")
  Maybe.Nothing -> ""

documentToString :: String -> String
documentToString document =
  let
    documentTrimmed = String.trim document
  in
    if String.null documentTrimmed then
      ""
    else
      Prelude.append
        ( String.joinWith "\n"
            ( Prelude.map
                ( \line ->
                    Prelude.append "-- |"
                      ( if String.null line then
                          ""
                        else
                          (Prelude.append " " line)
                      )
                )
                (String.split (String.Pattern "\n") documentTrimmed)
            )
        )
        "\n"
