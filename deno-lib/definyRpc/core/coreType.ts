/* eslint-disable */
/* generated by definy. Do not edit! */

/**
 * 構造化されたJSON
 */
export type StructuredJsonValue =
  | {
    /**
     * string
     */
    readonly type: "string";
    /**
     * string
     */
    readonly value: string;
    readonly [Symbol.toStringTag]: "*coreType.StructuredJsonValue";
  }
  | {
    /**
     * array
     */
    readonly type: "array";
    /**
     * array
     */
    readonly value: globalThis.ReadonlyArray<StructuredJsonValue>;
    readonly [Symbol.toStringTag]: "*coreType.StructuredJsonValue";
  }
  | {
    /**
     * boolean
     */
    readonly type: "boolean";
    /**
     * boolean
     */
    readonly value: boolean;
    readonly [Symbol.toStringTag]: "*coreType.StructuredJsonValue";
  }
  | {
    /**
     * null
     */
    readonly type: "null";
    readonly [Symbol.toStringTag]: "*coreType.StructuredJsonValue";
  }
  | {
    /**
     * number
     */
    readonly type: "number";
    /**
     * number
     */
    readonly value: number;
    readonly [Symbol.toStringTag]: "*coreType.StructuredJsonValue";
  }
  | {
    /**
     * object
     */
    readonly type: "object";
    /**
     * object
     */
    readonly value: globalThis.ReadonlyMap<string, StructuredJsonValue>;
    readonly [Symbol.toStringTag]: "*coreType.StructuredJsonValue";
  };

export type Maybe<element extends unknown> =
  | {
    readonly type: "just";
    readonly value: element;
    readonly [Symbol.toStringTag]: "*coreType.Maybe";
  }
  | {
    readonly type: "nothing";
    readonly [Symbol.toStringTag]: "*coreType.Maybe";
  };

export type Result<ok extends unknown, error extends unknown> =
  | {
    readonly type: "ok";
    readonly value: ok;
    readonly [Symbol.toStringTag]: "*coreType.Result";
  }
  | {
    readonly type: "error";
    readonly value: error;
    readonly [Symbol.toStringTag]: "*coreType.Result";
  };

/**
 * 名前空間. ユーザーが生成するものがこっちが用意するものか
 */
export type Namespace =
  | {
    /**
     * ユーザーが作ったAPIがあるところ
     */
    readonly type: "local";
    /**
     * ユーザーが作ったAPIがあるところ
     */
    readonly value: globalThis.ReadonlyArray<string>;
    readonly [Symbol.toStringTag]: "*coreType.Namespace";
  }
  | {
    /**
     * definyRpc 共通で使われる型
     */
    readonly type: "coreType";
    readonly [Symbol.toStringTag]: "*coreType.Namespace";
  }
  | {
    /**
     * 型安全なJSONのコーデック
     */
    readonly type: "typedJson";
    readonly [Symbol.toStringTag]: "*coreType.Namespace";
  }
  | {
    /**
     * HTTP経路でAPI呼ぶときに使うコード
     */
    readonly type: "request";
    readonly [Symbol.toStringTag]: "*coreType.Namespace";
  }
  | {
    /**
     * 各サーバーにアクセスし型情報を取得する
     */
    readonly type: "meta";
    readonly [Symbol.toStringTag]: "*coreType.Namespace";
  };

/**
 * definy RPC 型の構造
 */
export type DefinyRpcTypeInfo = {
  /**
   * 型が所属する名前空間
   */
  readonly namespace: Namespace;
  /**
   * 型の名前
   */
  readonly name: string;
  /**
   * 説明文. コメントなどに出力される
   */
  readonly description: string;
  /**
   * パラメーター
   */
  readonly parameter: globalThis.ReadonlyArray<TypeParameterInfo>;
  /**
   * 特殊な扱いをする
   */
  readonly attribute: Maybe<TypeAttribute>;
  /**
   * 型の構造を表現する
   */
  readonly body: TypeBody;
  readonly [Symbol.toStringTag]: "*coreType.DefinyRpcTypeInfo";
};

/**
 * 型パラメータ名と説明文
 */
export type TypeParameterInfo = {
  /**
   * 型パラメーター名
   */
  readonly name: string;
  /**
   * 型パラメーター説明
   */
  readonly description: string;
  readonly [Symbol.toStringTag]: "*coreType.TypeParameterInfo";
};

/**
 * 型をどのような特殊な扱いをするかどうか
 */
export type TypeAttribute = {
  /**
   * 型のデータ. 型パラメータを付与する
   */
  readonly type: "asType";
  readonly [Symbol.toStringTag]: "*coreType.TypeAttribute";
};

/**
 * 型の構造を表現する
 */
export type TypeBody =
  | {
    /**
     * string
     */
    readonly type: "string";
    readonly [Symbol.toStringTag]: "*coreType.TypeBody";
  }
  | {
    /**
     * number
     */
    readonly type: "number";
    readonly [Symbol.toStringTag]: "*coreType.TypeBody";
  }
  | {
    /**
     * boolean
     */
    readonly type: "boolean";
    readonly [Symbol.toStringTag]: "*coreType.TypeBody";
  }
  | {
    /**
     * unit
     */
    readonly type: "unit";
    readonly [Symbol.toStringTag]: "*coreType.TypeBody";
  }
  | {
    /**
     * list
     */
    readonly type: "list";
    readonly [Symbol.toStringTag]: "*coreType.TypeBody";
  }
  | {
    /**
     * set
     */
    readonly type: "set";
    readonly [Symbol.toStringTag]: "*coreType.TypeBody";
  }
  | {
    /**
     * map
     */
    readonly type: "map";
    readonly [Symbol.toStringTag]: "*coreType.TypeBody";
  }
  | {
    /**
     * url
     */
    readonly type: "url";
    readonly [Symbol.toStringTag]: "*coreType.TypeBody";
  }
  | {
    /**
     * product
     */
    readonly type: "product";
    /**
     * product
     */
    readonly value: globalThis.ReadonlyArray<Field>;
    readonly [Symbol.toStringTag]: "*coreType.TypeBody";
  }
  | {
    /**
     * sum
     */
    readonly type: "sum";
    /**
     * sum
     */
    readonly value: globalThis.ReadonlyArray<Pattern>;
    readonly [Symbol.toStringTag]: "*coreType.TypeBody";
  };

/**
 * product 直積型で使う
 */
export type Field = {
  /**
   * フィールド名
   */
  readonly name: string;
  /**
   * フィールドの説明
   */
  readonly description: string;
  /**
   * 型
   */
  readonly type: Type<unknown>;
  readonly [Symbol.toStringTag]: "*coreType.Field";
};

/**
 * 直和型の表現
 */
export type Pattern = {
  /**
   * パターン名
   */
  readonly name: string;
  /**
   * 説明
   */
  readonly description: string;
  /**
   * パラメーター
   */
  readonly parameter: Maybe<Type<unknown>>;
  readonly [Symbol.toStringTag]: "*coreType.Pattern";
};

/**
 * 型
 */
export type Type<p0 extends unknown> = {
  /**
   * 名前空間
   */
  readonly namespace: Namespace;
  /**
   * 型の名前
   */
  readonly name: string;
  /**
   * 型パラメータ
   */
  readonly parameters: globalThis.ReadonlyArray<Type<unknown>>;
  readonly [Symbol.toStringTag]: "*coreType.Type";
  /**
   * TypeScript で区別するために用意したパラメータ. 実行時には型の要件を満たさなくて意味のない値が入る
   */
  readonly __typeVariable: p0;
};

/**
 * 出力されるAPI関数のモジュール名
 */
export type FunctionNamespace =
  | {
    /**
     * APIがどんな構造で表現されているかを取得するためのAPI
     */
    readonly type: "meta";
    readonly [Symbol.toStringTag]: "*coreType.FunctionNamespace";
  }
  | {
    /**
     * definy RPC を利用するユーザーが定義したモジュール
     */
    readonly type: "local";
    /**
     * definy RPC を利用するユーザーが定義したモジュール
     */
    readonly value: globalThis.ReadonlyArray<string>;
    readonly [Symbol.toStringTag]: "*coreType.FunctionNamespace";
  };

/**
 * 関数のデータ functionByNameの結果
 */
export type FunctionDetail = {
  /**
   * 名前空間
   */
  readonly namespace: FunctionNamespace;
  /**
   * api名
   */
  readonly name: string;
  /**
   * 説明文
   */
  readonly description: string;
  /**
   * 入力の型
   */
  readonly input: Type<unknown>;
  /**
   * 出力の型
   */
  readonly output: Type<unknown>;
  /**
   * 認証が必要かどうか (キャッシュしなくなる)
   */
  readonly needAuthentication: boolean;
  /**
   * 単なるデータの取得ではなく, 変更するようなものか
   */
  readonly isMutation: boolean;
  readonly [Symbol.toStringTag]: "*coreType.FunctionDetail";
};

/**
 * 文字列
 */
export const String: {
  /**
   * String の型
   */
  readonly type: () => Type<string>;
} = {
  type: (): Type<string> =>
    Type.from({
      namespace: Namespace.coreType,
      name: "String",
      parameters: [],
    }),
};

/**
 * 値が1つだけ
 */
export const Unit: {
  /**
   * Unit の型
   */
  readonly type: () => Type<undefined>;
} = {
  type: (): Type<undefined> =>
    Type.from({ namespace: Namespace.coreType, name: "Unit", parameters: [] }),
};

/**
 * Bool. boolean. 真偽値. True か False
 */
export const Bool: {
  /**
   * Bool の型
   */
  readonly type: () => Type<boolean>;
} = {
  type: (): Type<boolean> =>
    Type.from({ namespace: Namespace.coreType, name: "Bool", parameters: [] }),
};

/**
 * 64bit 浮動小数点数
 */
export const Number: {
  /**
   * Number の型
   */
  readonly type: () => Type<number>;
} = {
  type: (): Type<number> =>
    Type.from({
      namespace: Namespace.coreType,
      name: "Number",
      parameters: [],
    }),
};

/**
 * 構造化されたJSON
 */
export const StructuredJsonValue: {
  /**
   * StructuredJsonValue の型
   */
  readonly type: () => Type<StructuredJsonValue>;
  /**
   * string
   */
  readonly string: (a: string) => StructuredJsonValue;
  /**
   * array
   */
  readonly array: (
    a: globalThis.ReadonlyArray<StructuredJsonValue>,
  ) => StructuredJsonValue;
  /**
   * boolean
   */
  readonly boolean: (a: boolean) => StructuredJsonValue;
  /**
   * null
   */
  readonly null: StructuredJsonValue;
  /**
   * number
   */
  readonly number: (a: number) => StructuredJsonValue;
  /**
   * object
   */
  readonly object: (
    a: globalThis.ReadonlyMap<string, StructuredJsonValue>,
  ) => StructuredJsonValue;
} = {
  type: (): Type<StructuredJsonValue> =>
    Type.from({
      namespace: Namespace.coreType,
      name: "StructuredJsonValue",
      parameters: [],
    }),
  string: (p: string): StructuredJsonValue => ({
    type: "string",
    value: p,
    [Symbol.toStringTag]: "*coreType.StructuredJsonValue",
  }),
  array: (
    p: globalThis.ReadonlyArray<StructuredJsonValue>,
  ): StructuredJsonValue => ({
    type: "array",
    value: p,
    [Symbol.toStringTag]: "*coreType.StructuredJsonValue",
  }),
  boolean: (p: boolean): StructuredJsonValue => ({
    type: "boolean",
    value: p,
    [Symbol.toStringTag]: "*coreType.StructuredJsonValue",
  }),
  null: { type: "null", [Symbol.toStringTag]: "*coreType.StructuredJsonValue" },
  number: (p: number): StructuredJsonValue => ({
    type: "number",
    value: p,
    [Symbol.toStringTag]: "*coreType.StructuredJsonValue",
  }),
  object: (
    p: globalThis.ReadonlyMap<string, StructuredJsonValue>,
  ): StructuredJsonValue => ({
    type: "object",
    value: p,
    [Symbol.toStringTag]: "*coreType.StructuredJsonValue",
  }),
};

/**
 * リスト
 */
export const List: {
  /**
   * List の型
   */
  readonly type: <element extends unknown>(
    a: Type<element>,
  ) => Type<globalThis.ReadonlyArray<element>>;
} = {
  type: <element extends unknown>(
    element: Type<element>,
  ): Type<globalThis.ReadonlyArray<element>> =>
    Type.from({
      namespace: Namespace.coreType,
      name: "List",
      parameters: [element],
    }),
};

/**
 * 辞書型. Map, Dictionary
 */
export const Map: {
  /**
   * Map の型
   */
  readonly type: <key extends unknown, value extends unknown>(
    a: Type<key>,
    b: Type<value>,
  ) => Type<globalThis.ReadonlyMap<key, value>>;
} = {
  type: <key extends unknown, value extends unknown>(
    key: Type<key>,
    value: Type<value>,
  ): Type<globalThis.ReadonlyMap<key, value>> =>
    Type.from({
      namespace: Namespace.coreType,
      name: "Map",
      parameters: [key, value],
    }),
};

/**
 * Set. 集合
 */
export const Set: {
  /**
   * Set の型
   */
  readonly type: <element extends unknown>(
    a: Type<element>,
  ) => Type<globalThis.ReadonlySet<element>>;
} = {
  type: <element extends unknown>(
    element: Type<element>,
  ): Type<globalThis.ReadonlySet<element>> =>
    Type.from({
      namespace: Namespace.coreType,
      name: "Set",
      parameters: [element],
    }),
};

export const Maybe: {
  /**
   * Maybe の型
   */
  readonly type: <element extends unknown>(
    a: Type<element>,
  ) => Type<Maybe<element>>;
  readonly just: <element extends unknown>(a: element) => Maybe<element>;
  readonly nothing: <element extends unknown>() => Maybe<element>;
} = {
  type: <element extends unknown>(
    element: Type<element>,
  ): Type<Maybe<element>> =>
    Type.from({
      namespace: Namespace.coreType,
      name: "Maybe",
      parameters: [element],
    }),
  just: <element extends unknown>(p: element): Maybe<element> => ({
    type: "just",
    value: p,
    [Symbol.toStringTag]: "*coreType.Maybe",
  }),
  nothing: <element extends unknown>(): Maybe<element> => ({
    type: "nothing",
    [Symbol.toStringTag]: "*coreType.Maybe",
  }),
};

export const Result: {
  /**
   * Result の型
   */
  readonly type: <ok extends unknown, error extends unknown>(
    a: Type<ok>,
    b: Type<error>,
  ) => Type<Result<ok, error>>;
  readonly ok: <ok extends unknown, error extends unknown>(
    a: ok,
  ) => Result<ok, error>;
  readonly error: <ok extends unknown, error extends unknown>(
    a: error,
  ) => Result<ok, error>;
} = {
  type: <ok extends unknown, error extends unknown>(
    ok: Type<ok>,
    error: Type<error>,
  ): Type<Result<ok, error>> =>
    Type.from({
      namespace: Namespace.coreType,
      name: "Result",
      parameters: [ok, error],
    }),
  ok: <ok extends unknown, error extends unknown>(
    p: ok,
  ): Result<ok, error> => ({
    type: "ok",
    value: p,
    [Symbol.toStringTag]: "*coreType.Result",
  }),
  error: <ok extends unknown, error extends unknown>(
    p: error,
  ): Result<ok, error> => ({
    type: "error",
    value: p,
    [Symbol.toStringTag]: "*coreType.Result",
  }),
};

/**
 * 名前空間. ユーザーが生成するものがこっちが用意するものか
 */
export const Namespace: {
  /**
   * Namespace の型
   */
  readonly type: () => Type<Namespace>;
  /**
   * ユーザーが作ったAPIがあるところ
   */
  readonly local: (a: globalThis.ReadonlyArray<string>) => Namespace;
  /**
   * definyRpc 共通で使われる型
   */
  readonly coreType: Namespace;
  /**
   * 型安全なJSONのコーデック
   */
  readonly typedJson: Namespace;
  /**
   * HTTP経路でAPI呼ぶときに使うコード
   */
  readonly request: Namespace;
  /**
   * 各サーバーにアクセスし型情報を取得する
   */
  readonly meta: Namespace;
} = {
  type: (): Type<Namespace> =>
    Type.from({
      namespace: Namespace.coreType,
      name: "Namespace",
      parameters: [],
    }),
  local: (p: globalThis.ReadonlyArray<string>): Namespace => ({
    type: "local",
    value: p,
    [Symbol.toStringTag]: "*coreType.Namespace",
  }),
  coreType: { type: "coreType", [Symbol.toStringTag]: "*coreType.Namespace" },
  typedJson: { type: "typedJson", [Symbol.toStringTag]: "*coreType.Namespace" },
  request: { type: "request", [Symbol.toStringTag]: "*coreType.Namespace" },
  meta: { type: "meta", [Symbol.toStringTag]: "*coreType.Namespace" },
};

/**
 * definy RPC 型の構造
 */
export const DefinyRpcTypeInfo: {
  /**
   * DefinyRpcTypeInfo の型
   */
  readonly type: () => Type<DefinyRpcTypeInfo>;
  /**
   * オブジェクトから作成する. 余計なフィールドがレスポンスに含まれてしまうのを防ぐ. 型のチェックはしない
   */
  readonly from: (
    a: globalThis.Omit<DefinyRpcTypeInfo, typeof Symbol.toStringTag>,
  ) => DefinyRpcTypeInfo;
} = {
  type: (): Type<DefinyRpcTypeInfo> =>
    Type.from({
      namespace: Namespace.coreType,
      name: "DefinyRpcTypeInfo",
      parameters: [],
    }),
  from: (
    obj: globalThis.Omit<DefinyRpcTypeInfo, typeof Symbol.toStringTag>,
  ): DefinyRpcTypeInfo => ({
    namespace: obj.namespace,
    name: obj.name,
    description: obj.description,
    parameter: obj.parameter,
    attribute: obj.attribute,
    body: obj.body,
    [Symbol.toStringTag]: "*coreType.DefinyRpcTypeInfo",
  }),
};

/**
 * 型パラメータ名と説明文
 */
export const TypeParameterInfo: {
  /**
   * TypeParameterInfo の型
   */
  readonly type: () => Type<TypeParameterInfo>;
  /**
   * オブジェクトから作成する. 余計なフィールドがレスポンスに含まれてしまうのを防ぐ. 型のチェックはしない
   */
  readonly from: (
    a: globalThis.Omit<TypeParameterInfo, typeof Symbol.toStringTag>,
  ) => TypeParameterInfo;
} = {
  type: (): Type<TypeParameterInfo> =>
    Type.from({
      namespace: Namespace.coreType,
      name: "TypeParameterInfo",
      parameters: [],
    }),
  from: (
    obj: globalThis.Omit<TypeParameterInfo, typeof Symbol.toStringTag>,
  ): TypeParameterInfo => ({
    name: obj.name,
    description: obj.description,
    [Symbol.toStringTag]: "*coreType.TypeParameterInfo",
  }),
};

/**
 * 型をどのような特殊な扱いをするかどうか
 */
export const TypeAttribute: {
  /**
   * TypeAttribute の型
   */
  readonly type: () => Type<TypeAttribute>;
  /**
   * 型のデータ. 型パラメータを付与する
   */
  readonly asType: TypeAttribute;
} = {
  type: (): Type<TypeAttribute> =>
    Type.from({
      namespace: Namespace.coreType,
      name: "TypeAttribute",
      parameters: [],
    }),
  asType: { type: "asType", [Symbol.toStringTag]: "*coreType.TypeAttribute" },
};

/**
 * 型の構造を表現する
 */
export const TypeBody: {
  /**
   * TypeBody の型
   */
  readonly type: () => Type<TypeBody>;
  /**
   * string
   */
  readonly string: TypeBody;
  /**
   * number
   */
  readonly number: TypeBody;
  /**
   * boolean
   */
  readonly boolean: TypeBody;
  /**
   * unit
   */
  readonly unit: TypeBody;
  /**
   * list
   */
  readonly list: TypeBody;
  /**
   * set
   */
  readonly set: TypeBody;
  /**
   * map
   */
  readonly map: TypeBody;
  /**
   * url
   */
  readonly url: TypeBody;
  /**
   * product
   */
  readonly product: (a: globalThis.ReadonlyArray<Field>) => TypeBody;
  /**
   * sum
   */
  readonly sum: (a: globalThis.ReadonlyArray<Pattern>) => TypeBody;
} = {
  type: (): Type<TypeBody> =>
    Type.from({
      namespace: Namespace.coreType,
      name: "TypeBody",
      parameters: [],
    }),
  string: { type: "string", [Symbol.toStringTag]: "*coreType.TypeBody" },
  number: { type: "number", [Symbol.toStringTag]: "*coreType.TypeBody" },
  boolean: { type: "boolean", [Symbol.toStringTag]: "*coreType.TypeBody" },
  unit: { type: "unit", [Symbol.toStringTag]: "*coreType.TypeBody" },
  list: { type: "list", [Symbol.toStringTag]: "*coreType.TypeBody" },
  set: { type: "set", [Symbol.toStringTag]: "*coreType.TypeBody" },
  map: { type: "map", [Symbol.toStringTag]: "*coreType.TypeBody" },
  url: { type: "url", [Symbol.toStringTag]: "*coreType.TypeBody" },
  product: (p: globalThis.ReadonlyArray<Field>): TypeBody => ({
    type: "product",
    value: p,
    [Symbol.toStringTag]: "*coreType.TypeBody",
  }),
  sum: (p: globalThis.ReadonlyArray<Pattern>): TypeBody => ({
    type: "sum",
    value: p,
    [Symbol.toStringTag]: "*coreType.TypeBody",
  }),
};

/**
 * product 直積型で使う
 */
export const Field: {
  /**
   * Field の型
   */
  readonly type: () => Type<Field>;
  /**
   * オブジェクトから作成する. 余計なフィールドがレスポンスに含まれてしまうのを防ぐ. 型のチェックはしない
   */
  readonly from: (
    a: globalThis.Omit<Field, typeof Symbol.toStringTag>,
  ) => Field;
} = {
  type: (): Type<Field> =>
    Type.from({ namespace: Namespace.coreType, name: "Field", parameters: [] }),
  from: (obj: globalThis.Omit<Field, typeof Symbol.toStringTag>): Field => ({
    name: obj.name,
    description: obj.description,
    type: obj.type,
    [Symbol.toStringTag]: "*coreType.Field",
  }),
};

/**
 * 直和型の表現
 */
export const Pattern: {
  /**
   * Pattern の型
   */
  readonly type: () => Type<Pattern>;
  /**
   * オブジェクトから作成する. 余計なフィールドがレスポンスに含まれてしまうのを防ぐ. 型のチェックはしない
   */
  readonly from: (
    a: globalThis.Omit<Pattern, typeof Symbol.toStringTag>,
  ) => Pattern;
} = {
  type: (): Type<Pattern> =>
    Type.from({
      namespace: Namespace.coreType,
      name: "Pattern",
      parameters: [],
    }),
  from: (
    obj: globalThis.Omit<Pattern, typeof Symbol.toStringTag>,
  ): Pattern => ({
    name: obj.name,
    description: obj.description,
    parameter: obj.parameter,
    [Symbol.toStringTag]: "*coreType.Pattern",
  }),
};

/**
 * 型
 */
export const Type: {
  /**
   * Type の型
   */
  readonly type: () => Type<Type<unknown>>;
  /**
   * オブジェクトから作成する. 余計なフィールドがレスポンスに含まれてしまうのを防ぐ. 型のチェックはしない
   */
  readonly from: <p0 extends unknown>(
    a: globalThis.Omit<Type<p0>, "__typeVariable" | typeof Symbol.toStringTag>,
  ) => Type<p0>;
} = {
  type: (): Type<Type<unknown>> =>
    Type.from({ namespace: Namespace.coreType, name: "Type", parameters: [] }),
  from: <p0 extends unknown>(
    obj: globalThis.Omit<
      Type<p0>,
      "__typeVariable" | typeof Symbol.toStringTag
    >,
  ): Type<p0> => ({
    namespace: obj.namespace,
    name: obj.name,
    parameters: obj.parameters,
    [Symbol.toStringTag]: "*coreType.Type",
    __typeVariable: {} as p0,
  }),
};

/**
 * 出力されるAPI関数のモジュール名
 */
export const FunctionNamespace: {
  /**
   * FunctionNamespace の型
   */
  readonly type: () => Type<FunctionNamespace>;
  /**
   * APIがどんな構造で表現されているかを取得するためのAPI
   */
  readonly meta: FunctionNamespace;
  /**
   * definy RPC を利用するユーザーが定義したモジュール
   */
  readonly local: (a: globalThis.ReadonlyArray<string>) => FunctionNamespace;
} = {
  type: (): Type<FunctionNamespace> =>
    Type.from({
      namespace: Namespace.coreType,
      name: "FunctionNamespace",
      parameters: [],
    }),
  meta: { type: "meta", [Symbol.toStringTag]: "*coreType.FunctionNamespace" },
  local: (p: globalThis.ReadonlyArray<string>): FunctionNamespace => ({
    type: "local",
    value: p,
    [Symbol.toStringTag]: "*coreType.FunctionNamespace",
  }),
};

/**
 * 関数のデータ functionByNameの結果
 */
export const FunctionDetail: {
  /**
   * FunctionDetail の型
   */
  readonly type: () => Type<FunctionDetail>;
  /**
   * オブジェクトから作成する. 余計なフィールドがレスポンスに含まれてしまうのを防ぐ. 型のチェックはしない
   */
  readonly from: (
    a: globalThis.Omit<FunctionDetail, typeof Symbol.toStringTag>,
  ) => FunctionDetail;
} = {
  type: (): Type<FunctionDetail> =>
    Type.from({
      namespace: Namespace.coreType,
      name: "FunctionDetail",
      parameters: [],
    }),
  from: (
    obj: globalThis.Omit<FunctionDetail, typeof Symbol.toStringTag>,
  ): FunctionDetail => ({
    namespace: obj.namespace,
    name: obj.name,
    description: obj.description,
    input: obj.input,
    output: obj.output,
    needAuthentication: obj.needAuthentication,
    isMutation: obj.isMutation,
    [Symbol.toStringTag]: "*coreType.FunctionDetail",
  }),
};
