{
  "iconContent": "iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAACXBIWXMAADXUAAA11AFeZeUIAAATuElEQVR4nO1dbXCU13U+u0haraTVB+gDJBAgBMhCyCGW+YYEu0BM7HjsJu6H03YyaTv50x/tdDr91Zl2/M/tTJsf/ZGkTTP1lElDYsdNcPAHTgwGjI0p2MKAJcYgQBL6XElodyVn3v54d1f33nPuuffuvrsIu/eX7rt37/Oc89x7znveD23osQMHQGihUEjqAoBwhOgKR4QP5FnwtHzXBoUClbpoXkRqUbSwJ/c9TzrgAYBwhOgKR4QPPMO0qOu5olCgUhfBIFKLooXNzoJCacAMSKPwTs8MuK81CAOkV6B4tHAacDBYAzyt0emex2+3xaZBOPuXUQPnKJGZxRB9ZEJmDWDB6Z7ctUTx0IK7hy0sdvjQDKQGeYdmVw2YlGDMMyzsvWlhp9Cc7gYdmo0a2Kdl+2mpz+9BC4NjaAbZHQ5RwngmZA2qxbXTYFGlhEwIClQD27TsGCXy0WDRpmUhB+SngVNaliY1i4ISD4+ibD7QqqIDLWYLe7x35NH/XyIE3tI7YDFoYI+bo9MXpQZhkrdraL5vSgTTuUDxS4SFJAyKd1xCM5AaWJ8pcTAy3c9eiRBm3FGQEkHsUqCuGlhtOLvTU/bzQrUwsO4IvkQQIp7DCrUG5XAtNCh+SiCSMATnDoco8XktEcKBhwVAGlh5h0RxyUNOGtgbW2gNwlkSQNHivCNPdD+VCAgU7p0G4QVaVGiGxaGBPa6V071FVKalk7A9UdfQvFhKBGPyN+WhApUIwg0ZgZbKTPGOS2iGXDWAQDXgUwJvDAubbwvn5o5cSgQRxRipKVBXDazENqKYYfNq4ZyXpHOJYJMe+ShBT8qCQmAaFCglZHJA4cMCyO5wiBKf6RKBvilfNA3s95+b0/PQwN7YQDRAN+ULHJqBdEcOGhidnmuZBsXVICw6XSGKQ7NCi1uhMsz9VKZpjNWh5qlB5mIcr4HAgyGab2jOVQN77XN0uikP5aOBcDFOr4HtDnUPzYulTBNs8eSuJUrOZZpciOXkDoVoAGVagfMQnla7M4woBlhzk5MwIKcHpAHjjnQ36NBs1MDKOiOKGdbQ0JNxiFZup6fOZRqe1i4P5awBUMYSuHYaMOuPb2GSliFKYJY2RAtRphlRFn2ZlknCNvmzwKEZkAb2MdDN6bmWCJ6LsZYalCgziO/xeJ4nvi3kAYQ8z+96/stAPkYo5GXfDfI8vwvCEX/Sv3z+GQX7n//mJwSogEJ3MygLXTwLZQvoB6RRMsbSKLKxS5titfVVFdXl2w48QHrWb//x3DHmUwAo8eT3quzdoXW6xjsMicJpAOqCYjXA01IrbMXa+q7ta1ZvbGIs0mOqrcS8dlgNwJq3E1E/LKgr1E4DEJcUsakdNcgc8Q3o2bdhy5fW87Zg00D/imB4YQj6zkIXUJTMLS3zKIu+RHjI3ft62HTTPJ5eRA0MuEanF0AD0rrW9Q1fzNX7GlgAKQe4xyI1SoBh/2p5WeMaIzUIA7xcYxE2tjRScvDZrZj7R+9dv9Y7NJeYSyXm04fYPIRTQgnIzvKAy1uK05UBvAaYvdZ6Rw1ArwrndAtjs6C1DVWY9c9/8PbIzUnyBXHQa6+ghPGGdQrNYBMlhCPSF5lJ2RioixIkLjaGt4UsEZa3LlXIv3Hk/Ts3J7OgHjKWgRF7YfILTqEZkHcAd8mWR5lGd0lcC1sMadnzth/sVLiPDU7xoABWGmgeT7fhDVp3LNDCq0Np904De9zSSAmgFh+dUUEVH9ppwD2enqcGiju0zTVKUCtU6oJWA1MkpXmVlZfqmKsrDGvAonieRz+e7rB/Admvd4fKX5zUJTQrA+w1kLokjMJQv3rwCqM10BiT7YVJDRXexdDAMTQr3TSo3blAUBpogVxiCfV0NBXOAtCAoK8SdQrN6S7vdGOUoCflQFUjdLgWGngLhZj/KXVdkykRGlvq6ptq6pfX7Dy42T/Y9+HNgf47w7cmhgbG55LzYomgoZ9LxdTQXLu0MVZVHW1pa2jrbM5+dOKXF+/GExMj06NDC6cogZQIOuZZ62gUyjSQj6iFGKeBwHP1+qaeLz+wvmulwqq9a2V75uCbP3//wpn++dSnnBl6orgbq61YsXrZoWe362ba89Xu7N+/Onz2+pWhudSntHdklJa2+ie/vdvAU25//g9P2Az7wd8fXVgHQBibPsGy1yBaGdl76MEtuzcYsfc9+cVV6xpPvHJx9PYkWQkzKFiDtZ3NT37LwUdf+YOtAPDi90/cvDZio0GhGgUqGltiHCF2G5vrvv23j9uj+xvih88fHb09SdOzuJMTrYzsOLjpwR3tDmZn2lN/tufs8cvvvHaJ1yCHmR0aG96lp6O1ZwueBwCxugon72fbnse6o1URHTMpPSLc8srI/mcezs37ftv6SMe2/Z0AmmwJpiSbX+Nc6idh/yhzn8vvRiIlB79OXA4EgPMnr/ZfujU1cTeZmAtBqLYhVlcf+8rvbcsOaO9auan/joYghxutihz4Rs86Ic2K7a1fXLhzazI5m5pLzgNAZXU0WhlZ07G8e/s6ZeTWRzpmJmd73/2E2Qc0vSCaci6gRNrQ7l27IDtC/78gtz3S+ehTPcrUH38w8NbRCyNyePGDaqS8tGPLalEG3J7/q8MZPBp318Gu7fs34S/+8oXT168O+35XcAGgfkXNjgOb2pBsh//ljdGh+AKKAFoWKSkrL9X948vKWPnT39mrzPbCP74mggrTSsPuxpPkP9xUkzBk9wEQ0SpWV0l6/+jhM7MzSfJmdyo5f+F031xy/mt/wmVOZkmuWt+Evd9/6fapX30wOhgHxXohoY4Oxv/nR6d2HNi09VHpdvn2/Q/84j/PSKAZY+dSn875Z2uaa8u4zcQTmc/l4fJXjKen2leUxND8wBdaMYNjR87OziTTpssfZQ98dP768ZfeJw0gQbPdsvLSZ76zDw8+/uL7ae+zuABw+tXea5dui5+u7Wxe2VYvgQJhrLEuU/kba1JQrRPzgfkVpYqq8t95+mEF9aUfvjU1MSvlMQ3ti2f6WP406NqOFXjY4e++Pj1x175qPf1qrzJD++aVIoptWjZliHw00DyeLhxpXlOPIT+5OkReSFBoeZ6XSs6//KOTWt6aCwmP/9FOZfCFU32DN8ZoGDwtAACMDsYvnukXP9q8va2mvsrsHWpagrzcdb4+6HnAPJ6ePdK+SS13z528kg0+gDTA7hi6Oa41g6K1At1+AoALp/uZFarT4JPLQ8o8dQ0xK+9Q06rk2f2XRjFdqpIeT8dbKRIpeWjPRgW4v/cWjqE0CwAAGL8z1ffhTa0ZiFbL2gZlzIVTfSODk8B4R+OL0UG1AGxaWaeAQh4a8DFQu/ClHMAaUlEdxaBjw3GFJZg0uNE3zFkhs/zy17YoA659dJss03AUUA5MTyaUqbKnRvdSA1hwGvV0tLBxqmsrMOLdqQRR14lpDU06TEYhKmjGKMTxkWkFaAGFXUCe573z+iVltqraqATKRwmZp0RYh2rSgMoBHn2TvTJG7ICUXwHhEzjEO/t34m6KtgGB1tXH8MiJkWlmw/F3clJyvZaewRSaVVsI9rZ5CLJeolQxvKKE1+O5E1e0TtdHiWRijrYCgZaULSFHKtMC0oB3h9gqq6M48TC2aKdyvX0EhAYlygj87JsCOj4ytTA4O8B0J4dpPkq2nlzaQOyAv/6n32fncGslpUtANtZDJSvIR/Tsc3/Yy++aX1EiUdVPNSkh25Kz9A6QmRe7KftAFyVMs5jzEFMi0K8o8ajE/gWDBkQgJndw0WUgA6/UBdobhmhjXSKE8ceYB8/bfh8Q8xC47BeCaIplVhpQs2AXO6Vl/5D+FzRMYcFJg4ju2SZSg8I33lgnDQzRR4+bTsKecPXV/9j+LimRx4BIwhAKlUW1AgDKVEo79eqHF0/3mX/YCoiLyeTvZfnxEBvrKU96GzMwIGOxMcg2BcXwilIKnT7W1cfEcwNeAxDPlAyGpEHnUmq2SCXmpiZnievskIsGursIuOtlb5CQhF2eKGA8bHhFaXx0Wv4EevZ20EGTrcvKo2WkDRh0AiFKKMp3jTHQMTSDfC6Q+YCWQTE2t1hkeEUpMUNUsJHyUit3CKpEK+mb8pgnrplrM7UxEakxKOTljoWp8LSIvErD4mwUf67+goaydhKzhACV1VGFJZjc0bSSuMJM8oyPzSgDtuxaLz6fvHg1IFFMoqi/oKHgxcdVdwBAfVMNZgmsO1rbubdqRVqp5Pz5k1eVAcsaY+p4vAARKASnAcFZj2sOcUJDrygh3seOvKNgi7dosAZ47SxtrN6weZXWhgytbLf/0i1lZNfWNt3lQgApCJC2cCtUoVQsDbJ96hUlOZwN9KuX8nv2doiXqT2WtwewfJU+/lA0b18fVYZt2bWhobmW2HD6hc+o4hYlIDANSBjzK0oj6KYSAKzrbLHkHSkvfepbX9LQp0FnZ1LHXzqnjN176EFA7lA0sA1HFqGZJkwaoQf1NC4Vu+ZXlFLJ+ZdfUO+qP/HN3Usbq/mLOb53vrCTfblZEyUu/+91ZWB718o9j3UDqwGw7igrL90gPF9jcc7CyhBQHjL8gob/hf5e4o7ugd/dWhErZ0IzAHQ+tHY/eqRFGixYItKIT8we+d6byvidBzfveay7oiriqkFdQ2zztra/eO7px7+5Q7SOCc3kAJq8yRZgNVjS0tysVo+omEwm5+eS8+2d0uMR9U019U01I4OTM9MJXKZGomXd29qf/OM9OgMA4MQrFxjc8ZHpcDiknD6tam/a9kjn+PDU1OTsbz/9LVBXGrIc6hpiazYs332o+9GnH1q3qcU/7j8spP0a7gJEoqVb9qiP47/z+kdgKsiVIyRKCQCAZ3gnADzv3Mkrazas2NgtPSK3sbt1Y3fre29d/vjDganxu4nEHAAsbaiua4g98ewuceRrP3uX2Ao8rue995vLjS11+DUQ/3HHU8c+GB2Kz95NTWTuGJeULqmurSwtW1LXWL0P3dmnQQHAfOWAngkgc0HCM722r0cpEafAvoDMkVRi7o2XzykC+K1nb0fP3g4tR4CrHwycf/sqHYtYDWZnkkf/6/ShP9yBNQCA7HtRzs1dA90kkHW6J18fAzsNpF9Rwidwmen8Njww9q/PvehoKwDAKz8+k0rOv/azd7WW6IPm7EzyyPfefAOdFOXb3EsEdQIAcWvYnwso08qvKHnoHilI93uHB8a++3c/Ofj1beRWwO3KxRuv/PjM9OSszgbmCra4Qs8ev3Tz2sjOA13kVrBsx/77rP+6EjhGCV3z8MJ33wfoFSXkdMUdY8Pxn/77m+u7Wr/xp/t4g3/6b7/u673pX3wPhUJDA2O0DRQK1uD2JyNHvv/rltX1m7e22byh5re+3lv9vbcGb4yN3J4UEyZjLI4STPMXfj7/2Sv0cE9PllaaoUCUOTWKRMsaV9Q2tixd0brs4b3px82uXLxx/eOhG/3Do4OTc/L7kcQFfePVfM25REVVpHZZrGZZZaymorW9qV3YFuffvjo5OjMdT8THZ2biiZnJ2QDv5DBHqDc1Qlw3C9rT0wOkdzAtzQskHC08rR0KzzsoUIzLaOCEa6+B/p93Z4441HU4k+Fp9Sj2pY0raG5XsJ3v5JDkNbZkj7BPxmFaGg089QBNi0chidK4FlfQmAH2GhhPjZw0IHHRK0rWGvBrR0eLRyGBbFFsLrHxK5RCyVMDo7HUK0quUYLi7aoBsXbwtMYowTodSBQ9qLThGIz8Fpz+FzSsw5nC256W1V3AQuYhbAujSoE0MCdhkigIA6SuTMQpNAPpHRIlUA3sjVVBXfKQzsNWSRgTtXeHVWiWedtroPVOfmGBwXW9i2DUwPALGgzRvJaka6QWUGyjRIE0IJ3O47LhXRIAyCihJ5qvBrw7jKHZGCUKqUHOxiooqgC2vDGtQEMzJso4XenahzhAC85eg3zSsohCC2DDm6ClYcntXzxtTqEZeBSXc4GiaeB3tQKATZTAtKj0CLx38LSF0WCxlWl+lxOA/AJoiHpi19U7JIrQJfYvntYYqVmnA4mit8WTZtFjmIw1CIC/QK8Oi9CsELlvyjRhWsZYvN0sQc0C0CxZonQXEbmPyzQK17Xc8fgkrDSjBko4olkiIk6hGZB3aBRjlHDRAChjddblUKbZCkDSYojmtSSNyd8Ymo1Rooga8LgOAgAZJfRECxQWMArjdKXrCprb6alTmeYmgCVvgpZGA27t4Gnzz0MW6bHIJUIuAoBNlMC0qNCs8P4clgg5CgA671BEPRfen7cSIXcBgPQOSdSOt5Y2QlkMp6fKtMwK40HzEoBmiXlYpEeF2X1cIlDG4pCX7eUrAM1ST9TeHZ+pEkFvSwACkLQYonktSWPyN4ZmY5QokAbkTghKACCjhJ5ogcICRskxSliABlUiBCZAFkDqAucdHUsoRIlgkYfuSYkQsABgEyUwLSo0AwStgR5Xi1L4EiF4ASCQKAEW3jGhiEecNDCEI2Py14PioFcQAUDnHZ6oMUo4hmYgvYOnDTQPYVsYVbzCCUCzZImCMEDqfqZLhAIKQLPUE7V3h1Vo1tAwaoCjhM20dNcCt7ACkLQYonktSddIDcjpmijBoWBbHDUouABgCs0QrAa8O4yhmYoSBdWgGAJkEIuiAZ42iDxkH+IALTheg+IJAIFq4KkH2GndQ7P5BMzlXIABLaoAYBMlQOsLB+/gaQujQf5lWrEFADY0A9LANkq4ayAecdLAEAONyV+25f8AJ//UhBx0RBsAAAAASUVORK5CYII=",
  "iconHash": "e1254cf71f95643d991eeb935c95934416ea7676c558f1f4fc6f69a4a26f586a",
  "scriptHash": "d58b5cdfd5d294216411d2e1a8299dd800aea05c77d1150a7b11e84c9f8a5bc5",
  "scriptContent": "var __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\")\n    return require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\n// https://esm.sh/stable/react@18.2.0/deno/react.js\nvar U = Object.create;\nvar C = Object.defineProperty;\nvar q = Object.getOwnPropertyDescriptor;\nvar A = Object.getOwnPropertyNames;\nvar M = Object.getPrototypeOf;\nvar z = Object.prototype.hasOwnProperty;\nvar k = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);\nvar B = (e, t, r, o) => {\n  if (t && typeof t == \"object\" || typeof t == \"function\")\n    for (let u of A(t))\n      !z.call(e, u) && u !== r && C(e, u, { get: () => t[u], enumerable: !(o = q(t, u)) || o.enumerable });\n  return e;\n};\nvar H = (e, t, r) => (r = e != null ? U(M(e)) : {}, B(t || !e || !e.__esModule ? C(r, \"default\", { value: e, enumerable: true }) : r, e));\nvar D = k((n) => {\n  \"use strict\";\n  var y = Symbol.for(\"react.element\"), W = Symbol.for(\"react.portal\"), Y = Symbol.for(\"react.fragment\"), G = Symbol.for(\"react.strict_mode\"), J2 = Symbol.for(\"react.profiler\"), K = Symbol.for(\"react.provider\"), Q2 = Symbol.for(\"react.context\"), X2 = Symbol.for(\"react.forward_ref\"), Z2 = Symbol.for(\"react.suspense\"), ee2 = Symbol.for(\"react.memo\"), te2 = Symbol.for(\"react.lazy\"), w = Symbol.iterator;\n  function re(e) {\n    return e === null || typeof e != \"object\" ? null : (e = w && e[w] || e[\"@@iterator\"], typeof e == \"function\" ? e : null);\n  }\n  var x = { isMounted: function() {\n    return false;\n  }, enqueueForceUpdate: function() {\n  }, enqueueReplaceState: function() {\n  }, enqueueSetState: function() {\n  } }, O = Object.assign, j = {};\n  function p(e, t, r) {\n    this.props = e, this.context = t, this.refs = j, this.updater = r || x;\n  }\n  p.prototype.isReactComponent = {};\n  p.prototype.setState = function(e, t) {\n    if (typeof e != \"object\" && typeof e != \"function\" && e != null)\n      throw Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");\n    this.updater.enqueueSetState(this, e, t, \"setState\");\n  };\n  p.prototype.forceUpdate = function(e) {\n    this.updater.enqueueForceUpdate(this, e, \"forceUpdate\");\n  };\n  function I() {\n  }\n  I.prototype = p.prototype;\n  function v(e, t, r) {\n    this.props = e, this.context = t, this.refs = j, this.updater = r || x;\n  }\n  var S2 = v.prototype = new I();\n  S2.constructor = v;\n  O(S2, p.prototype);\n  S2.isPureReactComponent = true;\n  var b = Array.isArray, g = Object.prototype.hasOwnProperty, E = { current: null }, P = { key: true, ref: true, __self: true, __source: true };\n  function T(e, t, r) {\n    var o, u = {}, c3 = null, f = null;\n    if (t != null)\n      for (o in t.ref !== void 0 && (f = t.ref), t.key !== void 0 && (c3 = \"\" + t.key), t)\n        g.call(t, o) && !P.hasOwnProperty(o) && (u[o] = t[o]);\n    var i = arguments.length - 2;\n    if (i === 1)\n      u.children = r;\n    else if (1 < i) {\n      for (var s = Array(i), a = 0; a < i; a++)\n        s[a] = arguments[a + 2];\n      u.children = s;\n    }\n    if (e && e.defaultProps)\n      for (o in i = e.defaultProps, i)\n        u[o] === void 0 && (u[o] = i[o]);\n    return { $$typeof: y, type: e, key: c3, ref: f, props: u, _owner: E.current };\n  }\n  function ne2(e, t) {\n    return { $$typeof: y, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner };\n  }\n  function R3(e) {\n    return typeof e == \"object\" && e !== null && e.$$typeof === y;\n  }\n  function ue(e) {\n    var t = { \"=\": \"=0\", \":\": \"=2\" };\n    return \"$\" + e.replace(/[=:]/g, function(r) {\n      return t[r];\n    });\n  }\n  var $4 = /\\/+/g;\n  function h(e, t) {\n    return typeof e == \"object\" && e !== null && e.key != null ? ue(\"\" + e.key) : t.toString(36);\n  }\n  function _(e, t, r, o, u) {\n    var c3 = typeof e;\n    (c3 === \"undefined\" || c3 === \"boolean\") && (e = null);\n    var f = false;\n    if (e === null)\n      f = true;\n    else\n      switch (c3) {\n        case \"string\":\n        case \"number\":\n          f = true;\n          break;\n        case \"object\":\n          switch (e.$$typeof) {\n            case y:\n            case W:\n              f = true;\n          }\n      }\n    if (f)\n      return f = e, u = u(f), e = o === \"\" ? \".\" + h(f, 0) : o, b(u) ? (r = \"\", e != null && (r = e.replace($4, \"$&/\") + \"/\"), _(u, t, r, \"\", function(a) {\n        return a;\n      })) : u != null && (R3(u) && (u = ne2(u, r + (!u.key || f && f.key === u.key ? \"\" : (\"\" + u.key).replace($4, \"$&/\") + \"/\") + e)), t.push(u)), 1;\n    if (f = 0, o = o === \"\" ? \".\" : o + \":\", b(e))\n      for (var i = 0; i < e.length; i++) {\n        c3 = e[i];\n        var s = o + h(c3, i);\n        f += _(c3, t, r, s, u);\n      }\n    else if (s = re(e), typeof s == \"function\")\n      for (e = s.call(e), i = 0; !(c3 = e.next()).done; )\n        c3 = c3.value, s = o + h(c3, i++), f += _(c3, t, r, s, u);\n    else if (c3 === \"object\")\n      throw t = String(e), Error(\"Objects are not valid as a React child (found: \" + (t === \"[object Object]\" ? \"object with keys {\" + Object.keys(e).join(\", \") + \"}\" : t) + \"). If you meant to render a collection of children, use an array instead.\");\n    return f;\n  }\n  function d(e, t, r) {\n    if (e == null)\n      return e;\n    var o = [], u = 0;\n    return _(e, o, \"\", \"\", function(c3) {\n      return t.call(r, c3, u++);\n    }), o;\n  }\n  function oe2(e) {\n    if (e._status === -1) {\n      var t = e._result;\n      t = t(), t.then(function(r) {\n        (e._status === 0 || e._status === -1) && (e._status = 1, e._result = r);\n      }, function(r) {\n        (e._status === 0 || e._status === -1) && (e._status = 2, e._result = r);\n      }), e._status === -1 && (e._status = 0, e._result = t);\n    }\n    if (e._status === 1)\n      return e._result.default;\n    throw e._result;\n  }\n  var l = { current: null }, m = { transition: null }, se2 = { ReactCurrentDispatcher: l, ReactCurrentBatchConfig: m, ReactCurrentOwner: E };\n  n.Children = { map: d, forEach: function(e, t, r) {\n    d(e, function() {\n      t.apply(this, arguments);\n    }, r);\n  }, count: function(e) {\n    var t = 0;\n    return d(e, function() {\n      t++;\n    }), t;\n  }, toArray: function(e) {\n    return d(e, function(t) {\n      return t;\n    }) || [];\n  }, only: function(e) {\n    if (!R3(e))\n      throw Error(\"React.Children.only expected to receive a single React element child.\");\n    return e;\n  } };\n  n.Component = p;\n  n.Fragment = Y;\n  n.Profiler = J2;\n  n.PureComponent = v;\n  n.StrictMode = G;\n  n.Suspense = Z2;\n  n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = se2;\n  n.cloneElement = function(e, t, r) {\n    if (e == null)\n      throw Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + e + \".\");\n    var o = O({}, e.props), u = e.key, c3 = e.ref, f = e._owner;\n    if (t != null) {\n      if (t.ref !== void 0 && (c3 = t.ref, f = E.current), t.key !== void 0 && (u = \"\" + t.key), e.type && e.type.defaultProps)\n        var i = e.type.defaultProps;\n      for (s in t)\n        g.call(t, s) && !P.hasOwnProperty(s) && (o[s] = t[s] === void 0 && i !== void 0 ? i[s] : t[s]);\n    }\n    var s = arguments.length - 2;\n    if (s === 1)\n      o.children = r;\n    else if (1 < s) {\n      i = Array(s);\n      for (var a = 0; a < s; a++)\n        i[a] = arguments[a + 2];\n      o.children = i;\n    }\n    return { $$typeof: y, type: e.type, key: u, ref: c3, props: o, _owner: f };\n  };\n  n.createContext = function(e) {\n    return e = { $$typeof: Q2, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: K, _context: e }, e.Consumer = e;\n  };\n  n.createElement = T;\n  n.createFactory = function(e) {\n    var t = T.bind(null, e);\n    return t.type = e, t;\n  };\n  n.createRef = function() {\n    return { current: null };\n  };\n  n.forwardRef = function(e) {\n    return { $$typeof: X2, render: e };\n  };\n  n.isValidElement = R3;\n  n.lazy = function(e) {\n    return { $$typeof: te2, _payload: { _status: -1, _result: e }, _init: oe2 };\n  };\n  n.memo = function(e, t) {\n    return { $$typeof: ee2, type: e, compare: t === void 0 ? null : t };\n  };\n  n.startTransition = function(e) {\n    var t = m.transition;\n    m.transition = {};\n    try {\n      e();\n    } finally {\n      m.transition = t;\n    }\n  };\n  n.unstable_act = function() {\n    throw Error(\"act(...) is not supported in production builds of React.\");\n  };\n  n.useCallback = function(e, t) {\n    return l.current.useCallback(e, t);\n  };\n  n.useContext = function(e) {\n    return l.current.useContext(e);\n  };\n  n.useDebugValue = function() {\n  };\n  n.useDeferredValue = function(e) {\n    return l.current.useDeferredValue(e);\n  };\n  n.useEffect = function(e, t) {\n    return l.current.useEffect(e, t);\n  };\n  n.useId = function() {\n    return l.current.useId();\n  };\n  n.useImperativeHandle = function(e, t, r) {\n    return l.current.useImperativeHandle(e, t, r);\n  };\n  n.useInsertionEffect = function(e, t) {\n    return l.current.useInsertionEffect(e, t);\n  };\n  n.useLayoutEffect = function(e, t) {\n    return l.current.useLayoutEffect(e, t);\n  };\n  n.useMemo = function(e, t) {\n    return l.current.useMemo(e, t);\n  };\n  n.useReducer = function(e, t, r) {\n    return l.current.useReducer(e, t, r);\n  };\n  n.useRef = function(e) {\n    return l.current.useRef(e);\n  };\n  n.useState = function(e) {\n    return l.current.useState(e);\n  };\n  n.useSyncExternalStore = function(e, t, r) {\n    return l.current.useSyncExternalStore(e, t, r);\n  };\n  n.useTransition = function() {\n    return l.current.useTransition();\n  };\n  n.version = \"18.2.0\";\n});\nvar L = k((le2, V2) => {\n  \"use strict\";\n  V2.exports = D();\n});\nvar F = H(L());\nvar { Children: ae, Component: pe, Fragment: ye, Profiler: de, PureComponent: _e, StrictMode: me, Suspense: he, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ve, cloneElement: Se, createContext: Ee, createElement: Re, createFactory: Ce, createRef: ke, forwardRef: we, isValidElement: be, lazy: $e, memo: xe, startTransition: Oe, unstable_act: je, useCallback: Ie, useContext: ge, useDebugValue: Pe, useDeferredValue: Te, useEffect: De, useId: Ve, useImperativeHandle: Le, useInsertionEffect: Ne, useLayoutEffect: Fe, useMemo: Ue, useReducer: qe, useRef: Ae, useState: Me, useSyncExternalStore: ze, useTransition: Be, version: He } = F;\nvar { default: N, ...ce } = F;\nvar We = N !== void 0 ? N : ce;\n\n// https://esm.sh/v99/scheduler@0.23.0/deno/scheduler.js\nvar __setImmediate$ = (cb, ...args) => setTimeout(cb, 0, ...args);\nvar U2 = Object.create;\nvar R = Object.defineProperty;\nvar X = Object.getOwnPropertyDescriptor;\nvar Z = Object.getOwnPropertyNames;\nvar $ = Object.getPrototypeOf;\nvar ee = Object.prototype.hasOwnProperty;\nvar B2 = (e, n) => () => (n || e((n = { exports: {} }).exports, n), n.exports);\nvar ne = (e, n, t, l) => {\n  if (n && typeof n == \"object\" || typeof n == \"function\")\n    for (let i of Z(n))\n      !ee.call(e, i) && i !== t && R(e, i, { get: () => n[i], enumerable: !(l = X(n, i)) || l.enumerable });\n  return e;\n};\nvar te = (e, n, t) => (t = e != null ? U2($(e)) : {}, ne(n || !e || !e.__esModule ? R(t, \"default\", { value: e, enumerable: true }) : t, e));\nvar J = B2((r) => {\n  \"use strict\";\n  function T(e, n) {\n    var t = e.length;\n    e.push(n);\n    e:\n      for (; 0 < t; ) {\n        var l = t - 1 >>> 1, i = e[l];\n        if (0 < g(i, n))\n          e[l] = n, e[t] = i, t = l;\n        else\n          break e;\n      }\n  }\n  function o(e) {\n    return e.length === 0 ? null : e[0];\n  }\n  function k2(e) {\n    if (e.length === 0)\n      return null;\n    var n = e[0], t = e.pop();\n    if (t !== n) {\n      e[0] = t;\n      e:\n        for (var l = 0, i = e.length, y = i >>> 1; l < y; ) {\n          var f = 2 * (l + 1) - 1, x = e[f], b = f + 1, m = e[b];\n          if (0 > g(x, t))\n            b < i && 0 > g(m, x) ? (e[l] = m, e[b] = t, l = b) : (e[l] = x, e[f] = t, l = f);\n          else if (b < i && 0 > g(m, t))\n            e[l] = m, e[b] = t, l = b;\n          else\n            break e;\n        }\n    }\n    return n;\n  }\n  function g(e, n) {\n    var t = e.sortIndex - n.sortIndex;\n    return t !== 0 ? t : e.id - n.id;\n  }\n  typeof performance == \"object\" && typeof performance.now == \"function\" ? (D2 = performance, r.unstable_now = function() {\n    return D2.now();\n  }) : (I = Date, q2 = I.now(), r.unstable_now = function() {\n    return I.now() - q2;\n  });\n  var D2, I, q2, s = [], c3 = [], re = 1, a = null, u = 3, P = false, _ = false, p = false, Y = typeof setTimeout == \"function\" ? setTimeout : null, z2 = typeof clearTimeout == \"function\" ? clearTimeout : null, O = typeof __setImmediate$ < \"u\" ? __setImmediate$ : null;\n  typeof navigator < \"u\" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);\n  function L2(e) {\n    for (var n = o(c3); n !== null; ) {\n      if (n.callback === null)\n        k2(c3);\n      else if (n.startTime <= e)\n        k2(c3), n.sortIndex = n.expirationTime, T(s, n);\n      else\n        break;\n      n = o(c3);\n    }\n  }\n  function N3(e) {\n    if (p = false, L2(e), !_)\n      if (o(s) !== null)\n        _ = true, M3(F2);\n      else {\n        var n = o(c3);\n        n !== null && j(N3, n.startTime - e);\n      }\n  }\n  function F2(e, n) {\n    _ = false, p && (p = false, z2(v), v = -1), P = true;\n    var t = u;\n    try {\n      for (L2(n), a = o(s); a !== null && (!(a.expirationTime > n) || e && !H2()); ) {\n        var l = a.callback;\n        if (typeof l == \"function\") {\n          a.callback = null, u = a.priorityLevel;\n          var i = l(a.expirationTime <= n);\n          n = r.unstable_now(), typeof i == \"function\" ? a.callback = i : a === o(s) && k2(s), L2(n);\n        } else\n          k2(s);\n        a = o(s);\n      }\n      if (a !== null)\n        var y = true;\n      else {\n        var f = o(c3);\n        f !== null && j(N3, f.startTime - n), y = false;\n      }\n      return y;\n    } finally {\n      a = null, u = t, P = false;\n    }\n  }\n  var w = false, h = null, v = -1, A2 = 5, G = -1;\n  function H2() {\n    return !(r.unstable_now() - G < A2);\n  }\n  function C3() {\n    if (h !== null) {\n      var e = r.unstable_now();\n      G = e;\n      var n = true;\n      try {\n        n = h(true, e);\n      } finally {\n        n ? d() : (w = false, h = null);\n      }\n    } else\n      w = false;\n  }\n  var d;\n  typeof O == \"function\" ? d = function() {\n    O(C3);\n  } : typeof MessageChannel < \"u\" ? (E = new MessageChannel(), W = E.port2, E.port1.onmessage = C3, d = function() {\n    W.postMessage(null);\n  }) : d = function() {\n    Y(C3, 0);\n  };\n  var E, W;\n  function M3(e) {\n    h = e, w || (w = true, d());\n  }\n  function j(e, n) {\n    v = Y(function() {\n      e(r.unstable_now());\n    }, n);\n  }\n  r.unstable_IdlePriority = 5;\n  r.unstable_ImmediatePriority = 1;\n  r.unstable_LowPriority = 4;\n  r.unstable_NormalPriority = 3;\n  r.unstable_Profiling = null;\n  r.unstable_UserBlockingPriority = 2;\n  r.unstable_cancelCallback = function(e) {\n    e.callback = null;\n  };\n  r.unstable_continueExecution = function() {\n    _ || P || (_ = true, M3(F2));\n  };\n  r.unstable_forceFrameRate = function(e) {\n    0 > e || 125 < e ? console.error(\"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\") : A2 = 0 < e ? Math.floor(1e3 / e) : 5;\n  };\n  r.unstable_getCurrentPriorityLevel = function() {\n    return u;\n  };\n  r.unstable_getFirstCallbackNode = function() {\n    return o(s);\n  };\n  r.unstable_next = function(e) {\n    switch (u) {\n      case 1:\n      case 2:\n      case 3:\n        var n = 3;\n        break;\n      default:\n        n = u;\n    }\n    var t = u;\n    u = n;\n    try {\n      return e();\n    } finally {\n      u = t;\n    }\n  };\n  r.unstable_pauseExecution = function() {\n  };\n  r.unstable_requestPaint = function() {\n  };\n  r.unstable_runWithPriority = function(e, n) {\n    switch (e) {\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n        break;\n      default:\n        e = 3;\n    }\n    var t = u;\n    u = e;\n    try {\n      return n();\n    } finally {\n      u = t;\n    }\n  };\n  r.unstable_scheduleCallback = function(e, n, t) {\n    var l = r.unstable_now();\n    switch (typeof t == \"object\" && t !== null ? (t = t.delay, t = typeof t == \"number\" && 0 < t ? l + t : l) : t = l, e) {\n      case 1:\n        var i = -1;\n        break;\n      case 2:\n        i = 250;\n        break;\n      case 5:\n        i = 1073741823;\n        break;\n      case 4:\n        i = 1e4;\n        break;\n      default:\n        i = 5e3;\n    }\n    return i = t + i, e = { id: re++, callback: n, priorityLevel: e, startTime: t, expirationTime: i, sortIndex: -1 }, t > l ? (e.sortIndex = t, T(c3, e), o(s) === null && e === o(c3) && (p ? (z2(v), v = -1) : p = true, j(N3, t - l))) : (e.sortIndex = i, T(s, e), _ || P || (_ = true, M3(F2))), e;\n  };\n  r.unstable_shouldYield = H2;\n  r.unstable_wrapCallback = function(e) {\n    var n = u;\n    return function() {\n      var t = u;\n      u = n;\n      try {\n        return e.apply(this, arguments);\n      } finally {\n        u = t;\n      }\n    };\n  };\n});\nvar Q = B2((ae2, K) => {\n  \"use strict\";\n  K.exports = J();\n});\nvar V = te(Q());\nvar { unstable_now: oe, unstable_IdlePriority: se, unstable_ImmediatePriority: ce2, unstable_LowPriority: fe, unstable_NormalPriority: be2, unstable_Profiling: _e2, unstable_UserBlockingPriority: de2, unstable_cancelCallback: pe2, unstable_continueExecution: ve2, unstable_forceFrameRate: ye2, unstable_getCurrentPriorityLevel: me2, unstable_getFirstCallbackNode: ge2, unstable_next: he2, unstable_pauseExecution: ke2, unstable_requestPaint: Pe2, unstable_runWithPriority: we2, unstable_scheduleCallback: xe2, unstable_shouldYield: Ie2, unstable_wrapCallback: Ce2 } = V;\nvar { default: S, ...le } = V;\nvar Ee2 = S !== void 0 ? S : le;\n\n// https://esm.sh/v99/react-dom@18.2.0/deno/client.js\nvar Ea = Object.create;\nvar iu = Object.defineProperty;\nvar Ca = Object.getOwnPropertyDescriptor;\nvar xa = Object.getOwnPropertyNames;\nvar Na = Object.getPrototypeOf;\nvar _a = Object.prototype.hasOwnProperty;\nvar uu = ((e) => typeof __require < \"u\" ? __require : typeof Proxy < \"u\" ? new Proxy(e, { get: (n, t) => (typeof __require < \"u\" ? __require : n)[t] }) : e)(function(e) {\n  if (typeof __require < \"u\")\n    return __require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + e + '\" is not supported');\n});\nvar br = (e, n) => () => (n || e((n = { exports: {} }).exports, n), n.exports);\nvar za = (e, n, t, r) => {\n  if (n && typeof n == \"object\" || typeof n == \"function\")\n    for (let l of xa(n))\n      !_a.call(e, l) && l !== t && iu(e, l, { get: () => n[l], enumerable: !(r = Ca(n, l)) || r.enumerable });\n  return e;\n};\nvar Pa = (e, n, t) => (t = e != null ? Ea(Na(e)) : {}, za(n || !e || !e.__esModule ? iu(t, \"default\", { value: e, enumerable: true }) : t, e));\nvar pa = br((fe2) => {\n  \"use strict\";\n  var mo = We, ae2 = Ee2;\n  function v(e) {\n    for (var n = \"https://reactjs.org/docs/error-decoder.html?invariant=\" + e, t = 1; t < arguments.length; t++)\n      n += \"&args[]=\" + encodeURIComponent(arguments[t]);\n    return \"Minified React error #\" + e + \"; visit \" + n + \" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\";\n  }\n  var ho = /* @__PURE__ */ new Set(), gt = {};\n  function Sn(e, n) {\n    Hn(e, n), Hn(e + \"Capture\", n);\n  }\n  function Hn(e, n) {\n    for (gt[e] = n, e = 0; e < n.length; e++)\n      ho.add(n[e]);\n  }\n  var Fe2 = !(typeof window > \"u\" || typeof window.document > \"u\" || typeof window.document.createElement > \"u\"), El = Object.prototype.hasOwnProperty, La = /^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$/, ou = {}, su = {};\n  function Ta(e) {\n    return El.call(su, e) ? true : El.call(ou, e) ? false : La.test(e) ? su[e] = true : (ou[e] = true, false);\n  }\n  function Ra(e, n, t, r) {\n    if (t !== null && t.type === 0)\n      return false;\n    switch (typeof n) {\n      case \"function\":\n      case \"symbol\":\n        return true;\n      case \"boolean\":\n        return r ? false : t !== null ? !t.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== \"data-\" && e !== \"aria-\");\n      default:\n        return false;\n    }\n  }\n  function Da(e, n, t, r) {\n    if (n === null || typeof n > \"u\" || Ra(e, n, t, r))\n      return true;\n    if (r)\n      return false;\n    if (t !== null)\n      switch (t.type) {\n        case 3:\n          return !n;\n        case 4:\n          return n === false;\n        case 5:\n          return isNaN(n);\n        case 6:\n          return isNaN(n) || 1 > n;\n      }\n    return false;\n  }\n  function ee2(e, n, t, r, l, i, u) {\n    this.acceptsBooleans = n === 2 || n === 3 || n === 4, this.attributeName = r, this.attributeNamespace = l, this.mustUseProperty = t, this.propertyName = e, this.type = n, this.sanitizeURL = i, this.removeEmptyString = u;\n  }\n  var Y = {};\n  \"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style\".split(\" \").forEach(function(e) {\n    Y[e] = new ee2(e, 0, false, e, null, false, false);\n  });\n  [[\"acceptCharset\", \"accept-charset\"], [\"className\", \"class\"], [\"htmlFor\", \"for\"], [\"httpEquiv\", \"http-equiv\"]].forEach(function(e) {\n    var n = e[0];\n    Y[n] = new ee2(n, 1, false, e[1], null, false, false);\n  });\n  [\"contentEditable\", \"draggable\", \"spellCheck\", \"value\"].forEach(function(e) {\n    Y[e] = new ee2(e, 2, false, e.toLowerCase(), null, false, false);\n  });\n  [\"autoReverse\", \"externalResourcesRequired\", \"focusable\", \"preserveAlpha\"].forEach(function(e) {\n    Y[e] = new ee2(e, 2, false, e, null, false, false);\n  });\n  \"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope\".split(\" \").forEach(function(e) {\n    Y[e] = new ee2(e, 3, false, e.toLowerCase(), null, false, false);\n  });\n  [\"checked\", \"multiple\", \"muted\", \"selected\"].forEach(function(e) {\n    Y[e] = new ee2(e, 3, true, e, null, false, false);\n  });\n  [\"capture\", \"download\"].forEach(function(e) {\n    Y[e] = new ee2(e, 4, false, e, null, false, false);\n  });\n  [\"cols\", \"rows\", \"size\", \"span\"].forEach(function(e) {\n    Y[e] = new ee2(e, 6, false, e, null, false, false);\n  });\n  [\"rowSpan\", \"start\"].forEach(function(e) {\n    Y[e] = new ee2(e, 5, false, e.toLowerCase(), null, false, false);\n  });\n  var mi = /[\\-:]([a-z])/g;\n  function hi3(e) {\n    return e[1].toUpperCase();\n  }\n  \"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height\".split(\" \").forEach(function(e) {\n    var n = e.replace(mi, hi3);\n    Y[n] = new ee2(n, 1, false, e, null, false, false);\n  });\n  \"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type\".split(\" \").forEach(function(e) {\n    var n = e.replace(mi, hi3);\n    Y[n] = new ee2(n, 1, false, e, \"http://www.w3.org/1999/xlink\", false, false);\n  });\n  [\"xml:base\", \"xml:lang\", \"xml:space\"].forEach(function(e) {\n    var n = e.replace(mi, hi3);\n    Y[n] = new ee2(n, 1, false, e, \"http://www.w3.org/XML/1998/namespace\", false, false);\n  });\n  [\"tabIndex\", \"crossOrigin\"].forEach(function(e) {\n    Y[e] = new ee2(e, 1, false, e.toLowerCase(), null, false, false);\n  });\n  Y.xlinkHref = new ee2(\"xlinkHref\", 1, false, \"xlink:href\", \"http://www.w3.org/1999/xlink\", true, false);\n  [\"src\", \"href\", \"action\", \"formAction\"].forEach(function(e) {\n    Y[e] = new ee2(e, 1, false, e.toLowerCase(), null, true, true);\n  });\n  function vi(e, n, t, r) {\n    var l = Y.hasOwnProperty(n) ? Y[n] : null;\n    (l !== null ? l.type !== 0 : r || !(2 < n.length) || n[0] !== \"o\" && n[0] !== \"O\" || n[1] !== \"n\" && n[1] !== \"N\") && (Da(n, t, l, r) && (t = null), r || l === null ? Ta(n) && (t === null ? e.removeAttribute(n) : e.setAttribute(n, \"\" + t)) : l.mustUseProperty ? e[l.propertyName] = t === null ? l.type === 3 ? false : \"\" : t : (n = l.attributeName, r = l.attributeNamespace, t === null ? e.removeAttribute(n) : (l = l.type, t = l === 3 || l === 4 && t === true ? \"\" : \"\" + t, r ? e.setAttributeNS(r, n, t) : e.setAttribute(n, t))));\n  }\n  var Ve2 = mo.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Vt = Symbol.for(\"react.element\"), xn = Symbol.for(\"react.portal\"), Nn = Symbol.for(\"react.fragment\"), yi = Symbol.for(\"react.strict_mode\"), Cl = Symbol.for(\"react.profiler\"), vo = Symbol.for(\"react.provider\"), yo = Symbol.for(\"react.context\"), gi = Symbol.for(\"react.forward_ref\"), xl = Symbol.for(\"react.suspense\"), Nl = Symbol.for(\"react.suspense_list\"), wi = Symbol.for(\"react.memo\"), He2 = Symbol.for(\"react.lazy\");\n  Symbol.for(\"react.scope\");\n  Symbol.for(\"react.debug_trace_mode\");\n  var go = Symbol.for(\"react.offscreen\");\n  Symbol.for(\"react.legacy_hidden\");\n  Symbol.for(\"react.cache\");\n  Symbol.for(\"react.tracing_marker\");\n  var au = Symbol.iterator;\n  function Jn(e) {\n    return e === null || typeof e != \"object\" ? null : (e = au && e[au] || e[\"@@iterator\"], typeof e == \"function\" ? e : null);\n  }\n  var F2 = Object.assign, el;\n  function it2(e) {\n    if (el === void 0)\n      try {\n        throw Error();\n      } catch (t) {\n        var n = t.stack.trim().match(/\\n( *(at )?)/);\n        el = n && n[1] || \"\";\n      }\n    return `\n` + el + e;\n  }\n  var nl2 = false;\n  function tl(e, n) {\n    if (!e || nl2)\n      return \"\";\n    nl2 = true;\n    var t = Error.prepareStackTrace;\n    Error.prepareStackTrace = void 0;\n    try {\n      if (n)\n        if (n = function() {\n          throw Error();\n        }, Object.defineProperty(n.prototype, \"props\", { set: function() {\n          throw Error();\n        } }), typeof Reflect == \"object\" && Reflect.construct) {\n          try {\n            Reflect.construct(n, []);\n          } catch (d) {\n            var r = d;\n          }\n          Reflect.construct(e, [], n);\n        } else {\n          try {\n            n.call();\n          } catch (d) {\n            r = d;\n          }\n          e.call(n.prototype);\n        }\n      else {\n        try {\n          throw Error();\n        } catch (d) {\n          r = d;\n        }\n        e();\n      }\n    } catch (d) {\n      if (d && r && typeof d.stack == \"string\") {\n        for (var l = d.stack.split(`\n`), i = r.stack.split(`\n`), u = l.length - 1, o = i.length - 1; 1 <= u && 0 <= o && l[u] !== i[o]; )\n          o--;\n        for (; 1 <= u && 0 <= o; u--, o--)\n          if (l[u] !== i[o]) {\n            if (u !== 1 || o !== 1)\n              do\n                if (u--, o--, 0 > o || l[u] !== i[o]) {\n                  var s = `\n` + l[u].replace(\" at new \", \" at \");\n                  return e.displayName && s.includes(\"<anonymous>\") && (s = s.replace(\"<anonymous>\", e.displayName)), s;\n                }\n              while (1 <= u && 0 <= o);\n            break;\n          }\n      }\n    } finally {\n      nl2 = false, Error.prepareStackTrace = t;\n    }\n    return (e = e ? e.displayName || e.name : \"\") ? it2(e) : \"\";\n  }\n  function Ma(e) {\n    switch (e.tag) {\n      case 5:\n        return it2(e.type);\n      case 16:\n        return it2(\"Lazy\");\n      case 13:\n        return it2(\"Suspense\");\n      case 19:\n        return it2(\"SuspenseList\");\n      case 0:\n      case 2:\n      case 15:\n        return e = tl(e.type, false), e;\n      case 11:\n        return e = tl(e.type.render, false), e;\n      case 1:\n        return e = tl(e.type, true), e;\n      default:\n        return \"\";\n    }\n  }\n  function _l(e) {\n    if (e == null)\n      return null;\n    if (typeof e == \"function\")\n      return e.displayName || e.name || null;\n    if (typeof e == \"string\")\n      return e;\n    switch (e) {\n      case Nn:\n        return \"Fragment\";\n      case xn:\n        return \"Portal\";\n      case Cl:\n        return \"Profiler\";\n      case yi:\n        return \"StrictMode\";\n      case xl:\n        return \"Suspense\";\n      case Nl:\n        return \"SuspenseList\";\n    }\n    if (typeof e == \"object\")\n      switch (e.$$typeof) {\n        case yo:\n          return (e.displayName || \"Context\") + \".Consumer\";\n        case vo:\n          return (e._context.displayName || \"Context\") + \".Provider\";\n        case gi:\n          var n = e.render;\n          return e = e.displayName, e || (e = n.displayName || n.name || \"\", e = e !== \"\" ? \"ForwardRef(\" + e + \")\" : \"ForwardRef\"), e;\n        case wi:\n          return n = e.displayName || null, n !== null ? n : _l(e.type) || \"Memo\";\n        case He2:\n          n = e._payload, e = e._init;\n          try {\n            return _l(e(n));\n          } catch {\n          }\n      }\n    return null;\n  }\n  function Oa(e) {\n    var n = e.type;\n    switch (e.tag) {\n      case 24:\n        return \"Cache\";\n      case 9:\n        return (n.displayName || \"Context\") + \".Consumer\";\n      case 10:\n        return (n._context.displayName || \"Context\") + \".Provider\";\n      case 18:\n        return \"DehydratedFragment\";\n      case 11:\n        return e = n.render, e = e.displayName || e.name || \"\", n.displayName || (e !== \"\" ? \"ForwardRef(\" + e + \")\" : \"ForwardRef\");\n      case 7:\n        return \"Fragment\";\n      case 5:\n        return n;\n      case 4:\n        return \"Portal\";\n      case 3:\n        return \"Root\";\n      case 6:\n        return \"Text\";\n      case 16:\n        return _l(n);\n      case 8:\n        return n === yi ? \"StrictMode\" : \"Mode\";\n      case 22:\n        return \"Offscreen\";\n      case 12:\n        return \"Profiler\";\n      case 21:\n        return \"Scope\";\n      case 13:\n        return \"Suspense\";\n      case 19:\n        return \"SuspenseList\";\n      case 25:\n        return \"TracingMarker\";\n      case 1:\n      case 0:\n      case 17:\n      case 2:\n      case 14:\n      case 15:\n        if (typeof n == \"function\")\n          return n.displayName || n.name || null;\n        if (typeof n == \"string\")\n          return n;\n    }\n    return null;\n  }\n  function tn(e) {\n    switch (typeof e) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n      case \"undefined\":\n        return e;\n      case \"object\":\n        return e;\n      default:\n        return \"\";\n    }\n  }\n  function wo(e) {\n    var n = e.type;\n    return (e = e.nodeName) && e.toLowerCase() === \"input\" && (n === \"checkbox\" || n === \"radio\");\n  }\n  function Fa(e) {\n    var n = wo(e) ? \"checked\" : \"value\", t = Object.getOwnPropertyDescriptor(e.constructor.prototype, n), r = \"\" + e[n];\n    if (!e.hasOwnProperty(n) && typeof t < \"u\" && typeof t.get == \"function\" && typeof t.set == \"function\") {\n      var l = t.get, i = t.set;\n      return Object.defineProperty(e, n, { configurable: true, get: function() {\n        return l.call(this);\n      }, set: function(u) {\n        r = \"\" + u, i.call(this, u);\n      } }), Object.defineProperty(e, n, { enumerable: t.enumerable }), { getValue: function() {\n        return r;\n      }, setValue: function(u) {\n        r = \"\" + u;\n      }, stopTracking: function() {\n        e._valueTracker = null, delete e[n];\n      } };\n    }\n  }\n  function At(e) {\n    e._valueTracker || (e._valueTracker = Fa(e));\n  }\n  function So(e) {\n    if (!e)\n      return false;\n    var n = e._valueTracker;\n    if (!n)\n      return true;\n    var t = n.getValue(), r = \"\";\n    return e && (r = wo(e) ? e.checked ? \"true\" : \"false\" : e.value), e = r, e !== t ? (n.setValue(e), true) : false;\n  }\n  function mr(e) {\n    if (e = e || (typeof document < \"u\" ? document : void 0), typeof e > \"u\")\n      return null;\n    try {\n      return e.activeElement || e.body;\n    } catch {\n      return e.body;\n    }\n  }\n  function zl(e, n) {\n    var t = n.checked;\n    return F2({}, n, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: t ?? e._wrapperState.initialChecked });\n  }\n  function cu(e, n) {\n    var t = n.defaultValue == null ? \"\" : n.defaultValue, r = n.checked != null ? n.checked : n.defaultChecked;\n    t = tn(n.value != null ? n.value : t), e._wrapperState = { initialChecked: r, initialValue: t, controlled: n.type === \"checkbox\" || n.type === \"radio\" ? n.checked != null : n.value != null };\n  }\n  function ko(e, n) {\n    n = n.checked, n != null && vi(e, \"checked\", n, false);\n  }\n  function Pl(e, n) {\n    ko(e, n);\n    var t = tn(n.value), r = n.type;\n    if (t != null)\n      r === \"number\" ? (t === 0 && e.value === \"\" || e.value != t) && (e.value = \"\" + t) : e.value !== \"\" + t && (e.value = \"\" + t);\n    else if (r === \"submit\" || r === \"reset\") {\n      e.removeAttribute(\"value\");\n      return;\n    }\n    n.hasOwnProperty(\"value\") ? Ll(e, n.type, t) : n.hasOwnProperty(\"defaultValue\") && Ll(e, n.type, tn(n.defaultValue)), n.checked == null && n.defaultChecked != null && (e.defaultChecked = !!n.defaultChecked);\n  }\n  function fu(e, n, t) {\n    if (n.hasOwnProperty(\"value\") || n.hasOwnProperty(\"defaultValue\")) {\n      var r = n.type;\n      if (!(r !== \"submit\" && r !== \"reset\" || n.value !== void 0 && n.value !== null))\n        return;\n      n = \"\" + e._wrapperState.initialValue, t || n === e.value || (e.value = n), e.defaultValue = n;\n    }\n    t = e.name, t !== \"\" && (e.name = \"\"), e.defaultChecked = !!e._wrapperState.initialChecked, t !== \"\" && (e.name = t);\n  }\n  function Ll(e, n, t) {\n    (n !== \"number\" || mr(e.ownerDocument) !== e) && (t == null ? e.defaultValue = \"\" + e._wrapperState.initialValue : e.defaultValue !== \"\" + t && (e.defaultValue = \"\" + t));\n  }\n  var ut = Array.isArray;\n  function In(e, n, t, r) {\n    if (e = e.options, n) {\n      n = {};\n      for (var l = 0; l < t.length; l++)\n        n[\"$\" + t[l]] = true;\n      for (t = 0; t < e.length; t++)\n        l = n.hasOwnProperty(\"$\" + e[t].value), e[t].selected !== l && (e[t].selected = l), l && r && (e[t].defaultSelected = true);\n    } else {\n      for (t = \"\" + tn(t), n = null, l = 0; l < e.length; l++) {\n        if (e[l].value === t) {\n          e[l].selected = true, r && (e[l].defaultSelected = true);\n          return;\n        }\n        n !== null || e[l].disabled || (n = e[l]);\n      }\n      n !== null && (n.selected = true);\n    }\n  }\n  function Tl(e, n) {\n    if (n.dangerouslySetInnerHTML != null)\n      throw Error(v(91));\n    return F2({}, n, { value: void 0, defaultValue: void 0, children: \"\" + e._wrapperState.initialValue });\n  }\n  function du(e, n) {\n    var t = n.value;\n    if (t == null) {\n      if (t = n.children, n = n.defaultValue, t != null) {\n        if (n != null)\n          throw Error(v(92));\n        if (ut(t)) {\n          if (1 < t.length)\n            throw Error(v(93));\n          t = t[0];\n        }\n        n = t;\n      }\n      n == null && (n = \"\"), t = n;\n    }\n    e._wrapperState = { initialValue: tn(t) };\n  }\n  function Eo(e, n) {\n    var t = tn(n.value), r = tn(n.defaultValue);\n    t != null && (t = \"\" + t, t !== e.value && (e.value = t), n.defaultValue == null && e.defaultValue !== t && (e.defaultValue = t)), r != null && (e.defaultValue = \"\" + r);\n  }\n  function pu(e) {\n    var n = e.textContent;\n    n === e._wrapperState.initialValue && n !== \"\" && n !== null && (e.value = n);\n  }\n  function Co(e) {\n    switch (e) {\n      case \"svg\":\n        return \"http://www.w3.org/2000/svg\";\n      case \"math\":\n        return \"http://www.w3.org/1998/Math/MathML\";\n      default:\n        return \"http://www.w3.org/1999/xhtml\";\n    }\n  }\n  function Rl(e, n) {\n    return e == null || e === \"http://www.w3.org/1999/xhtml\" ? Co(n) : e === \"http://www.w3.org/2000/svg\" && n === \"foreignObject\" ? \"http://www.w3.org/1999/xhtml\" : e;\n  }\n  var Bt, xo = function(e) {\n    return typeof MSApp < \"u\" && MSApp.execUnsafeLocalFunction ? function(n, t, r, l) {\n      MSApp.execUnsafeLocalFunction(function() {\n        return e(n, t, r, l);\n      });\n    } : e;\n  }(function(e, n) {\n    if (e.namespaceURI !== \"http://www.w3.org/2000/svg\" || \"innerHTML\" in e)\n      e.innerHTML = n;\n    else {\n      for (Bt = Bt || document.createElement(\"div\"), Bt.innerHTML = \"<svg>\" + n.valueOf().toString() + \"</svg>\", n = Bt.firstChild; e.firstChild; )\n        e.removeChild(e.firstChild);\n      for (; n.firstChild; )\n        e.appendChild(n.firstChild);\n    }\n  });\n  function wt(e, n) {\n    if (n) {\n      var t = e.firstChild;\n      if (t && t === e.lastChild && t.nodeType === 3) {\n        t.nodeValue = n;\n        return;\n      }\n    }\n    e.textContent = n;\n  }\n  var at = { animationIterationCount: true, aspectRatio: true, borderImageOutset: true, borderImageSlice: true, borderImageWidth: true, boxFlex: true, boxFlexGroup: true, boxOrdinalGroup: true, columnCount: true, columns: true, flex: true, flexGrow: true, flexPositive: true, flexShrink: true, flexNegative: true, flexOrder: true, gridArea: true, gridRow: true, gridRowEnd: true, gridRowSpan: true, gridRowStart: true, gridColumn: true, gridColumnEnd: true, gridColumnSpan: true, gridColumnStart: true, fontWeight: true, lineClamp: true, lineHeight: true, opacity: true, order: true, orphans: true, tabSize: true, widows: true, zIndex: true, zoom: true, fillOpacity: true, floodOpacity: true, stopOpacity: true, strokeDasharray: true, strokeDashoffset: true, strokeMiterlimit: true, strokeOpacity: true, strokeWidth: true }, Ia = [\"Webkit\", \"ms\", \"Moz\", \"O\"];\n  Object.keys(at).forEach(function(e) {\n    Ia.forEach(function(n) {\n      n = n + e.charAt(0).toUpperCase() + e.substring(1), at[n] = at[e];\n    });\n  });\n  function No(e, n, t) {\n    return n == null || typeof n == \"boolean\" || n === \"\" ? \"\" : t || typeof n != \"number\" || n === 0 || at.hasOwnProperty(e) && at[e] ? (\"\" + n).trim() : n + \"px\";\n  }\n  function _o(e, n) {\n    e = e.style;\n    for (var t in n)\n      if (n.hasOwnProperty(t)) {\n        var r = t.indexOf(\"--\") === 0, l = No(t, n[t], r);\n        t === \"float\" && (t = \"cssFloat\"), r ? e.setProperty(t, l) : e[t] = l;\n      }\n  }\n  var ja = F2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });\n  function Dl(e, n) {\n    if (n) {\n      if (ja[e] && (n.children != null || n.dangerouslySetInnerHTML != null))\n        throw Error(v(137, e));\n      if (n.dangerouslySetInnerHTML != null) {\n        if (n.children != null)\n          throw Error(v(60));\n        if (typeof n.dangerouslySetInnerHTML != \"object\" || !(\"__html\" in n.dangerouslySetInnerHTML))\n          throw Error(v(61));\n      }\n      if (n.style != null && typeof n.style != \"object\")\n        throw Error(v(62));\n    }\n  }\n  function Ml(e, n) {\n    if (e.indexOf(\"-\") === -1)\n      return typeof n.is == \"string\";\n    switch (e) {\n      case \"annotation-xml\":\n      case \"color-profile\":\n      case \"font-face\":\n      case \"font-face-src\":\n      case \"font-face-uri\":\n      case \"font-face-format\":\n      case \"font-face-name\":\n      case \"missing-glyph\":\n        return false;\n      default:\n        return true;\n    }\n  }\n  var Ol = null;\n  function Si(e) {\n    return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e;\n  }\n  var Fl = null, jn = null, Un = null;\n  function mu(e) {\n    if (e = jt(e)) {\n      if (typeof Fl != \"function\")\n        throw Error(v(280));\n      var n = e.stateNode;\n      n && (n = Hr(n), Fl(e.stateNode, e.type, n));\n    }\n  }\n  function zo(e) {\n    jn ? Un ? Un.push(e) : Un = [e] : jn = e;\n  }\n  function Po() {\n    if (jn) {\n      var e = jn, n = Un;\n      if (Un = jn = null, mu(e), n)\n        for (e = 0; e < n.length; e++)\n          mu(n[e]);\n    }\n  }\n  function Lo(e, n) {\n    return e(n);\n  }\n  function To() {\n  }\n  var rl = false;\n  function Ro(e, n, t) {\n    if (rl)\n      return e(n, t);\n    rl = true;\n    try {\n      return Lo(e, n, t);\n    } finally {\n      rl = false, (jn !== null || Un !== null) && (To(), Po());\n    }\n  }\n  function St(e, n) {\n    var t = e.stateNode;\n    if (t === null)\n      return null;\n    var r = Hr(t);\n    if (r === null)\n      return null;\n    t = r[n];\n    e:\n      switch (n) {\n        case \"onClick\":\n        case \"onClickCapture\":\n        case \"onDoubleClick\":\n        case \"onDoubleClickCapture\":\n        case \"onMouseDown\":\n        case \"onMouseDownCapture\":\n        case \"onMouseMove\":\n        case \"onMouseMoveCapture\":\n        case \"onMouseUp\":\n        case \"onMouseUpCapture\":\n        case \"onMouseEnter\":\n          (r = !r.disabled) || (e = e.type, r = !(e === \"button\" || e === \"input\" || e === \"select\" || e === \"textarea\")), e = !r;\n          break e;\n        default:\n          e = false;\n      }\n    if (e)\n      return null;\n    if (t && typeof t != \"function\")\n      throw Error(v(231, n, typeof t));\n    return t;\n  }\n  var Il = false;\n  if (Fe2)\n    try {\n      En = {}, Object.defineProperty(En, \"passive\", { get: function() {\n        Il = true;\n      } }), window.addEventListener(\"test\", En, En), window.removeEventListener(\"test\", En, En);\n    } catch {\n      Il = false;\n    }\n  var En;\n  function Ua(e, n, t, r, l, i, u, o, s) {\n    var d = Array.prototype.slice.call(arguments, 3);\n    try {\n      n.apply(t, d);\n    } catch (m) {\n      this.onError(m);\n    }\n  }\n  var ct = false, hr = null, vr = false, jl = null, Va = { onError: function(e) {\n    ct = true, hr = e;\n  } };\n  function Aa(e, n, t, r, l, i, u, o, s) {\n    ct = false, hr = null, Ua.apply(Va, arguments);\n  }\n  function Ba(e, n, t, r, l, i, u, o, s) {\n    if (Aa.apply(this, arguments), ct) {\n      if (ct) {\n        var d = hr;\n        ct = false, hr = null;\n      } else\n        throw Error(v(198));\n      vr || (vr = true, jl = d);\n    }\n  }\n  function kn(e) {\n    var n = e, t = e;\n    if (e.alternate)\n      for (; n.return; )\n        n = n.return;\n    else {\n      e = n;\n      do\n        n = e, (n.flags & 4098) !== 0 && (t = n.return), e = n.return;\n      while (e);\n    }\n    return n.tag === 3 ? t : null;\n  }\n  function Do(e) {\n    if (e.tag === 13) {\n      var n = e.memoizedState;\n      if (n === null && (e = e.alternate, e !== null && (n = e.memoizedState)), n !== null)\n        return n.dehydrated;\n    }\n    return null;\n  }\n  function hu(e) {\n    if (kn(e) !== e)\n      throw Error(v(188));\n  }\n  function Ha(e) {\n    var n = e.alternate;\n    if (!n) {\n      if (n = kn(e), n === null)\n        throw Error(v(188));\n      return n !== e ? null : e;\n    }\n    for (var t = e, r = n; ; ) {\n      var l = t.return;\n      if (l === null)\n        break;\n      var i = l.alternate;\n      if (i === null) {\n        if (r = l.return, r !== null) {\n          t = r;\n          continue;\n        }\n        break;\n      }\n      if (l.child === i.child) {\n        for (i = l.child; i; ) {\n          if (i === t)\n            return hu(l), e;\n          if (i === r)\n            return hu(l), n;\n          i = i.sibling;\n        }\n        throw Error(v(188));\n      }\n      if (t.return !== r.return)\n        t = l, r = i;\n      else {\n        for (var u = false, o = l.child; o; ) {\n          if (o === t) {\n            u = true, t = l, r = i;\n            break;\n          }\n          if (o === r) {\n            u = true, r = l, t = i;\n            break;\n          }\n          o = o.sibling;\n        }\n        if (!u) {\n          for (o = i.child; o; ) {\n            if (o === t) {\n              u = true, t = i, r = l;\n              break;\n            }\n            if (o === r) {\n              u = true, r = i, t = l;\n              break;\n            }\n            o = o.sibling;\n          }\n          if (!u)\n            throw Error(v(189));\n        }\n      }\n      if (t.alternate !== r)\n        throw Error(v(190));\n    }\n    if (t.tag !== 3)\n      throw Error(v(188));\n    return t.stateNode.current === t ? e : n;\n  }\n  function Mo(e) {\n    return e = Ha(e), e !== null ? Oo(e) : null;\n  }\n  function Oo(e) {\n    if (e.tag === 5 || e.tag === 6)\n      return e;\n    for (e = e.child; e !== null; ) {\n      var n = Oo(e);\n      if (n !== null)\n        return n;\n      e = e.sibling;\n    }\n    return null;\n  }\n  var Fo = ae2.unstable_scheduleCallback, vu = ae2.unstable_cancelCallback, Wa = ae2.unstable_shouldYield, Qa = ae2.unstable_requestPaint, U3 = ae2.unstable_now, $a = ae2.unstable_getCurrentPriorityLevel, ki = ae2.unstable_ImmediatePriority, Io = ae2.unstable_UserBlockingPriority, yr = ae2.unstable_NormalPriority, Ka = ae2.unstable_LowPriority, jo = ae2.unstable_IdlePriority, Ur = null, Pe3 = null;\n  function Ya(e) {\n    if (Pe3 && typeof Pe3.onCommitFiberRoot == \"function\")\n      try {\n        Pe3.onCommitFiberRoot(Ur, e, void 0, (e.current.flags & 128) === 128);\n      } catch {\n      }\n  }\n  var Ee3 = Math.clz32 ? Math.clz32 : Za, Xa = Math.log, Ga = Math.LN2;\n  function Za(e) {\n    return e >>>= 0, e === 0 ? 32 : 31 - (Xa(e) / Ga | 0) | 0;\n  }\n  var Ht = 64, Wt = 4194304;\n  function ot(e) {\n    switch (e & -e) {\n      case 1:\n        return 1;\n      case 2:\n        return 2;\n      case 4:\n        return 4;\n      case 8:\n        return 8;\n      case 16:\n        return 16;\n      case 32:\n        return 32;\n      case 64:\n      case 128:\n      case 256:\n      case 512:\n      case 1024:\n      case 2048:\n      case 4096:\n      case 8192:\n      case 16384:\n      case 32768:\n      case 65536:\n      case 131072:\n      case 262144:\n      case 524288:\n      case 1048576:\n      case 2097152:\n        return e & 4194240;\n      case 4194304:\n      case 8388608:\n      case 16777216:\n      case 33554432:\n      case 67108864:\n        return e & 130023424;\n      case 134217728:\n        return 134217728;\n      case 268435456:\n        return 268435456;\n      case 536870912:\n        return 536870912;\n      case 1073741824:\n        return 1073741824;\n      default:\n        return e;\n    }\n  }\n  function gr(e, n) {\n    var t = e.pendingLanes;\n    if (t === 0)\n      return 0;\n    var r = 0, l = e.suspendedLanes, i = e.pingedLanes, u = t & 268435455;\n    if (u !== 0) {\n      var o = u & ~l;\n      o !== 0 ? r = ot(o) : (i &= u, i !== 0 && (r = ot(i)));\n    } else\n      u = t & ~l, u !== 0 ? r = ot(u) : i !== 0 && (r = ot(i));\n    if (r === 0)\n      return 0;\n    if (n !== 0 && n !== r && (n & l) === 0 && (l = r & -r, i = n & -n, l >= i || l === 16 && (i & 4194240) !== 0))\n      return n;\n    if ((r & 4) !== 0 && (r |= t & 16), n = e.entangledLanes, n !== 0)\n      for (e = e.entanglements, n &= r; 0 < n; )\n        t = 31 - Ee3(n), l = 1 << t, r |= e[t], n &= ~l;\n    return r;\n  }\n  function Ja(e, n) {\n    switch (e) {\n      case 1:\n      case 2:\n      case 4:\n        return n + 250;\n      case 8:\n      case 16:\n      case 32:\n      case 64:\n      case 128:\n      case 256:\n      case 512:\n      case 1024:\n      case 2048:\n      case 4096:\n      case 8192:\n      case 16384:\n      case 32768:\n      case 65536:\n      case 131072:\n      case 262144:\n      case 524288:\n      case 1048576:\n      case 2097152:\n        return n + 5e3;\n      case 4194304:\n      case 8388608:\n      case 16777216:\n      case 33554432:\n      case 67108864:\n        return -1;\n      case 134217728:\n      case 268435456:\n      case 536870912:\n      case 1073741824:\n        return -1;\n      default:\n        return -1;\n    }\n  }\n  function qa(e, n) {\n    for (var t = e.suspendedLanes, r = e.pingedLanes, l = e.expirationTimes, i = e.pendingLanes; 0 < i; ) {\n      var u = 31 - Ee3(i), o = 1 << u, s = l[u];\n      s === -1 ? ((o & t) === 0 || (o & r) !== 0) && (l[u] = Ja(o, n)) : s <= n && (e.expiredLanes |= o), i &= ~o;\n    }\n  }\n  function Ul(e) {\n    return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0;\n  }\n  function Uo() {\n    var e = Ht;\n    return Ht <<= 1, (Ht & 4194240) === 0 && (Ht = 64), e;\n  }\n  function ll(e) {\n    for (var n = [], t = 0; 31 > t; t++)\n      n.push(e);\n    return n;\n  }\n  function Ft(e, n, t) {\n    e.pendingLanes |= n, n !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, n = 31 - Ee3(n), e[n] = t;\n  }\n  function ba(e, n) {\n    var t = e.pendingLanes & ~n;\n    e.pendingLanes = n, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= n, e.mutableReadLanes &= n, e.entangledLanes &= n, n = e.entanglements;\n    var r = e.eventTimes;\n    for (e = e.expirationTimes; 0 < t; ) {\n      var l = 31 - Ee3(t), i = 1 << l;\n      n[l] = 0, r[l] = -1, e[l] = -1, t &= ~i;\n    }\n  }\n  function Ei(e, n) {\n    var t = e.entangledLanes |= n;\n    for (e = e.entanglements; t; ) {\n      var r = 31 - Ee3(t), l = 1 << r;\n      l & n | e[r] & n && (e[r] |= n), t &= ~l;\n    }\n  }\n  var P = 0;\n  function Vo(e) {\n    return e &= -e, 1 < e ? 4 < e ? (e & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;\n  }\n  var Ao, Ci, Bo, Ho, Wo, Vl = false, Qt = [], Xe = null, Ge = null, Ze = null, kt = /* @__PURE__ */ new Map(), Et = /* @__PURE__ */ new Map(), Qe = [], ec = \"mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit\".split(\" \");\n  function yu(e, n) {\n    switch (e) {\n      case \"focusin\":\n      case \"focusout\":\n        Xe = null;\n        break;\n      case \"dragenter\":\n      case \"dragleave\":\n        Ge = null;\n        break;\n      case \"mouseover\":\n      case \"mouseout\":\n        Ze = null;\n        break;\n      case \"pointerover\":\n      case \"pointerout\":\n        kt.delete(n.pointerId);\n        break;\n      case \"gotpointercapture\":\n      case \"lostpointercapture\":\n        Et.delete(n.pointerId);\n    }\n  }\n  function qn(e, n, t, r, l, i) {\n    return e === null || e.nativeEvent !== i ? (e = { blockedOn: n, domEventName: t, eventSystemFlags: r, nativeEvent: i, targetContainers: [l] }, n !== null && (n = jt(n), n !== null && Ci(n)), e) : (e.eventSystemFlags |= r, n = e.targetContainers, l !== null && n.indexOf(l) === -1 && n.push(l), e);\n  }\n  function nc(e, n, t, r, l) {\n    switch (n) {\n      case \"focusin\":\n        return Xe = qn(Xe, e, n, t, r, l), true;\n      case \"dragenter\":\n        return Ge = qn(Ge, e, n, t, r, l), true;\n      case \"mouseover\":\n        return Ze = qn(Ze, e, n, t, r, l), true;\n      case \"pointerover\":\n        var i = l.pointerId;\n        return kt.set(i, qn(kt.get(i) || null, e, n, t, r, l)), true;\n      case \"gotpointercapture\":\n        return i = l.pointerId, Et.set(i, qn(Et.get(i) || null, e, n, t, r, l)), true;\n    }\n    return false;\n  }\n  function Qo(e) {\n    var n = cn2(e.target);\n    if (n !== null) {\n      var t = kn(n);\n      if (t !== null) {\n        if (n = t.tag, n === 13) {\n          if (n = Do(t), n !== null) {\n            e.blockedOn = n, Wo(e.priority, function() {\n              Bo(t);\n            });\n            return;\n          }\n        } else if (n === 3 && t.stateNode.current.memoizedState.isDehydrated) {\n          e.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;\n          return;\n        }\n      }\n    }\n    e.blockedOn = null;\n  }\n  function lr(e) {\n    if (e.blockedOn !== null)\n      return false;\n    for (var n = e.targetContainers; 0 < n.length; ) {\n      var t = Al(e.domEventName, e.eventSystemFlags, n[0], e.nativeEvent);\n      if (t === null) {\n        t = e.nativeEvent;\n        var r = new t.constructor(t.type, t);\n        Ol = r, t.target.dispatchEvent(r), Ol = null;\n      } else\n        return n = jt(t), n !== null && Ci(n), e.blockedOn = t, false;\n      n.shift();\n    }\n    return true;\n  }\n  function gu(e, n, t) {\n    lr(e) && t.delete(n);\n  }\n  function tc() {\n    Vl = false, Xe !== null && lr(Xe) && (Xe = null), Ge !== null && lr(Ge) && (Ge = null), Ze !== null && lr(Ze) && (Ze = null), kt.forEach(gu), Et.forEach(gu);\n  }\n  function bn(e, n) {\n    e.blockedOn === n && (e.blockedOn = null, Vl || (Vl = true, ae2.unstable_scheduleCallback(ae2.unstable_NormalPriority, tc)));\n  }\n  function Ct(e) {\n    function n(l) {\n      return bn(l, e);\n    }\n    if (0 < Qt.length) {\n      bn(Qt[0], e);\n      for (var t = 1; t < Qt.length; t++) {\n        var r = Qt[t];\n        r.blockedOn === e && (r.blockedOn = null);\n      }\n    }\n    for (Xe !== null && bn(Xe, e), Ge !== null && bn(Ge, e), Ze !== null && bn(Ze, e), kt.forEach(n), Et.forEach(n), t = 0; t < Qe.length; t++)\n      r = Qe[t], r.blockedOn === e && (r.blockedOn = null);\n    for (; 0 < Qe.length && (t = Qe[0], t.blockedOn === null); )\n      Qo(t), t.blockedOn === null && Qe.shift();\n  }\n  var Vn = Ve2.ReactCurrentBatchConfig, wr = true;\n  function rc(e, n, t, r) {\n    var l = P, i = Vn.transition;\n    Vn.transition = null;\n    try {\n      P = 1, xi(e, n, t, r);\n    } finally {\n      P = l, Vn.transition = i;\n    }\n  }\n  function lc(e, n, t, r) {\n    var l = P, i = Vn.transition;\n    Vn.transition = null;\n    try {\n      P = 4, xi(e, n, t, r);\n    } finally {\n      P = l, Vn.transition = i;\n    }\n  }\n  function xi(e, n, t, r) {\n    if (wr) {\n      var l = Al(e, n, t, r);\n      if (l === null)\n        fl(e, n, r, Sr, t), yu(e, r);\n      else if (nc(l, e, n, t, r))\n        r.stopPropagation();\n      else if (yu(e, r), n & 4 && -1 < ec.indexOf(e)) {\n        for (; l !== null; ) {\n          var i = jt(l);\n          if (i !== null && Ao(i), i = Al(e, n, t, r), i === null && fl(e, n, r, Sr, t), i === l)\n            break;\n          l = i;\n        }\n        l !== null && r.stopPropagation();\n      } else\n        fl(e, n, r, null, t);\n    }\n  }\n  var Sr = null;\n  function Al(e, n, t, r) {\n    if (Sr = null, e = Si(r), e = cn2(e), e !== null)\n      if (n = kn(e), n === null)\n        e = null;\n      else if (t = n.tag, t === 13) {\n        if (e = Do(n), e !== null)\n          return e;\n        e = null;\n      } else if (t === 3) {\n        if (n.stateNode.current.memoizedState.isDehydrated)\n          return n.tag === 3 ? n.stateNode.containerInfo : null;\n        e = null;\n      } else\n        n !== e && (e = null);\n    return Sr = e, null;\n  }\n  function $o(e) {\n    switch (e) {\n      case \"cancel\":\n      case \"click\":\n      case \"close\":\n      case \"contextmenu\":\n      case \"copy\":\n      case \"cut\":\n      case \"auxclick\":\n      case \"dblclick\":\n      case \"dragend\":\n      case \"dragstart\":\n      case \"drop\":\n      case \"focusin\":\n      case \"focusout\":\n      case \"input\":\n      case \"invalid\":\n      case \"keydown\":\n      case \"keypress\":\n      case \"keyup\":\n      case \"mousedown\":\n      case \"mouseup\":\n      case \"paste\":\n      case \"pause\":\n      case \"play\":\n      case \"pointercancel\":\n      case \"pointerdown\":\n      case \"pointerup\":\n      case \"ratechange\":\n      case \"reset\":\n      case \"resize\":\n      case \"seeked\":\n      case \"submit\":\n      case \"touchcancel\":\n      case \"touchend\":\n      case \"touchstart\":\n      case \"volumechange\":\n      case \"change\":\n      case \"selectionchange\":\n      case \"textInput\":\n      case \"compositionstart\":\n      case \"compositionend\":\n      case \"compositionupdate\":\n      case \"beforeblur\":\n      case \"afterblur\":\n      case \"beforeinput\":\n      case \"blur\":\n      case \"fullscreenchange\":\n      case \"focus\":\n      case \"hashchange\":\n      case \"popstate\":\n      case \"select\":\n      case \"selectstart\":\n        return 1;\n      case \"drag\":\n      case \"dragenter\":\n      case \"dragexit\":\n      case \"dragleave\":\n      case \"dragover\":\n      case \"mousemove\":\n      case \"mouseout\":\n      case \"mouseover\":\n      case \"pointermove\":\n      case \"pointerout\":\n      case \"pointerover\":\n      case \"scroll\":\n      case \"toggle\":\n      case \"touchmove\":\n      case \"wheel\":\n      case \"mouseenter\":\n      case \"mouseleave\":\n      case \"pointerenter\":\n      case \"pointerleave\":\n        return 4;\n      case \"message\":\n        switch ($a()) {\n          case ki:\n            return 1;\n          case Io:\n            return 4;\n          case yr:\n          case Ka:\n            return 16;\n          case jo:\n            return 536870912;\n          default:\n            return 16;\n        }\n      default:\n        return 16;\n    }\n  }\n  var Ke = null, Ni = null, ir = null;\n  function Ko() {\n    if (ir)\n      return ir;\n    var e, n = Ni, t = n.length, r, l = \"value\" in Ke ? Ke.value : Ke.textContent, i = l.length;\n    for (e = 0; e < t && n[e] === l[e]; e++)\n      ;\n    var u = t - e;\n    for (r = 1; r <= u && n[t - r] === l[i - r]; r++)\n      ;\n    return ir = l.slice(e, 1 < r ? 1 - r : void 0);\n  }\n  function ur(e) {\n    var n = e.keyCode;\n    return \"charCode\" in e ? (e = e.charCode, e === 0 && n === 13 && (e = 13)) : e = n, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0;\n  }\n  function $t() {\n    return true;\n  }\n  function wu() {\n    return false;\n  }\n  function ce3(e) {\n    function n(t, r, l, i, u) {\n      this._reactName = t, this._targetInst = l, this.type = r, this.nativeEvent = i, this.target = u, this.currentTarget = null;\n      for (var o in e)\n        e.hasOwnProperty(o) && (t = e[o], this[o] = t ? t(i) : i[o]);\n      return this.isDefaultPrevented = (i.defaultPrevented != null ? i.defaultPrevented : i.returnValue === false) ? $t : wu, this.isPropagationStopped = wu, this;\n    }\n    return F2(n.prototype, { preventDefault: function() {\n      this.defaultPrevented = true;\n      var t = this.nativeEvent;\n      t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != \"unknown\" && (t.returnValue = false), this.isDefaultPrevented = $t);\n    }, stopPropagation: function() {\n      var t = this.nativeEvent;\n      t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != \"unknown\" && (t.cancelBubble = true), this.isPropagationStopped = $t);\n    }, persist: function() {\n    }, isPersistent: $t }), n;\n  }\n  var Gn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(e) {\n    return e.timeStamp || Date.now();\n  }, defaultPrevented: 0, isTrusted: 0 }, _i = ce3(Gn), It = F2({}, Gn, { view: 0, detail: 0 }), ic = ce3(It), il, ul, et, Vr = F2({}, It, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zi, button: 0, buttons: 0, relatedTarget: function(e) {\n    return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;\n  }, movementX: function(e) {\n    return \"movementX\" in e ? e.movementX : (e !== et && (et && e.type === \"mousemove\" ? (il = e.screenX - et.screenX, ul = e.screenY - et.screenY) : ul = il = 0, et = e), il);\n  }, movementY: function(e) {\n    return \"movementY\" in e ? e.movementY : ul;\n  } }), Su = ce3(Vr), uc = F2({}, Vr, { dataTransfer: 0 }), oc = ce3(uc), sc = F2({}, It, { relatedTarget: 0 }), ol = ce3(sc), ac = F2({}, Gn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), cc = ce3(ac), fc = F2({}, Gn, { clipboardData: function(e) {\n    return \"clipboardData\" in e ? e.clipboardData : window.clipboardData;\n  } }), dc = ce3(fc), pc = F2({}, Gn, { data: 0 }), ku = ce3(pc), mc = { Esc: \"Escape\", Spacebar: \" \", Left: \"ArrowLeft\", Up: \"ArrowUp\", Right: \"ArrowRight\", Down: \"ArrowDown\", Del: \"Delete\", Win: \"OS\", Menu: \"ContextMenu\", Apps: \"ContextMenu\", Scroll: \"ScrollLock\", MozPrintableKey: \"Unidentified\" }, hc = { 8: \"Backspace\", 9: \"Tab\", 12: \"Clear\", 13: \"Enter\", 16: \"Shift\", 17: \"Control\", 18: \"Alt\", 19: \"Pause\", 20: \"CapsLock\", 27: \"Escape\", 32: \" \", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\", 36: \"Home\", 37: \"ArrowLeft\", 38: \"ArrowUp\", 39: \"ArrowRight\", 40: \"ArrowDown\", 45: \"Insert\", 46: \"Delete\", 112: \"F1\", 113: \"F2\", 114: \"F3\", 115: \"F4\", 116: \"F5\", 117: \"F6\", 118: \"F7\", 119: \"F8\", 120: \"F9\", 121: \"F10\", 122: \"F11\", 123: \"F12\", 144: \"NumLock\", 145: \"ScrollLock\", 224: \"Meta\" }, vc = { Alt: \"altKey\", Control: \"ctrlKey\", Meta: \"metaKey\", Shift: \"shiftKey\" };\n  function yc(e) {\n    var n = this.nativeEvent;\n    return n.getModifierState ? n.getModifierState(e) : (e = vc[e]) ? !!n[e] : false;\n  }\n  function zi() {\n    return yc;\n  }\n  var gc = F2({}, It, { key: function(e) {\n    if (e.key) {\n      var n = mc[e.key] || e.key;\n      if (n !== \"Unidentified\")\n        return n;\n    }\n    return e.type === \"keypress\" ? (e = ur(e), e === 13 ? \"Enter\" : String.fromCharCode(e)) : e.type === \"keydown\" || e.type === \"keyup\" ? hc[e.keyCode] || \"Unidentified\" : \"\";\n  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zi, charCode: function(e) {\n    return e.type === \"keypress\" ? ur(e) : 0;\n  }, keyCode: function(e) {\n    return e.type === \"keydown\" || e.type === \"keyup\" ? e.keyCode : 0;\n  }, which: function(e) {\n    return e.type === \"keypress\" ? ur(e) : e.type === \"keydown\" || e.type === \"keyup\" ? e.keyCode : 0;\n  } }), wc = ce3(gc), Sc = F2({}, Vr, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Eu = ce3(Sc), kc = F2({}, It, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zi }), Ec = ce3(kc), Cc = F2({}, Gn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), xc = ce3(Cc), Nc = F2({}, Vr, { deltaX: function(e) {\n    return \"deltaX\" in e ? e.deltaX : \"wheelDeltaX\" in e ? -e.wheelDeltaX : 0;\n  }, deltaY: function(e) {\n    return \"deltaY\" in e ? e.deltaY : \"wheelDeltaY\" in e ? -e.wheelDeltaY : \"wheelDelta\" in e ? -e.wheelDelta : 0;\n  }, deltaZ: 0, deltaMode: 0 }), _c = ce3(Nc), zc = [9, 13, 27, 32], Pi = Fe2 && \"CompositionEvent\" in window, ft = null;\n  Fe2 && \"documentMode\" in document && (ft = document.documentMode);\n  var Pc = Fe2 && \"TextEvent\" in window && !ft, Yo = Fe2 && (!Pi || ft && 8 < ft && 11 >= ft), Cu = String.fromCharCode(32), xu = false;\n  function Xo(e, n) {\n    switch (e) {\n      case \"keyup\":\n        return zc.indexOf(n.keyCode) !== -1;\n      case \"keydown\":\n        return n.keyCode !== 229;\n      case \"keypress\":\n      case \"mousedown\":\n      case \"focusout\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  function Go(e) {\n    return e = e.detail, typeof e == \"object\" && \"data\" in e ? e.data : null;\n  }\n  var _n = false;\n  function Lc(e, n) {\n    switch (e) {\n      case \"compositionend\":\n        return Go(n);\n      case \"keypress\":\n        return n.which !== 32 ? null : (xu = true, Cu);\n      case \"textInput\":\n        return e = n.data, e === Cu && xu ? null : e;\n      default:\n        return null;\n    }\n  }\n  function Tc(e, n) {\n    if (_n)\n      return e === \"compositionend\" || !Pi && Xo(e, n) ? (e = Ko(), ir = Ni = Ke = null, _n = false, e) : null;\n    switch (e) {\n      case \"paste\":\n        return null;\n      case \"keypress\":\n        if (!(n.ctrlKey || n.altKey || n.metaKey) || n.ctrlKey && n.altKey) {\n          if (n.char && 1 < n.char.length)\n            return n.char;\n          if (n.which)\n            return String.fromCharCode(n.which);\n        }\n        return null;\n      case \"compositionend\":\n        return Yo && n.locale !== \"ko\" ? null : n.data;\n      default:\n        return null;\n    }\n  }\n  var Rc = { color: true, date: true, datetime: true, \"datetime-local\": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };\n  function Nu(e) {\n    var n = e && e.nodeName && e.nodeName.toLowerCase();\n    return n === \"input\" ? !!Rc[e.type] : n === \"textarea\";\n  }\n  function Zo(e, n, t, r) {\n    zo(r), n = kr(n, \"onChange\"), 0 < n.length && (t = new _i(\"onChange\", \"change\", null, t, r), e.push({ event: t, listeners: n }));\n  }\n  var dt = null, xt = null;\n  function Dc(e) {\n    os(e, 0);\n  }\n  function Ar(e) {\n    var n = Ln(e);\n    if (So(n))\n      return e;\n  }\n  function Mc(e, n) {\n    if (e === \"change\")\n      return n;\n  }\n  var Jo = false;\n  Fe2 && (Fe2 ? (Yt = \"oninput\" in document, Yt || (sl = document.createElement(\"div\"), sl.setAttribute(\"oninput\", \"return;\"), Yt = typeof sl.oninput == \"function\"), Kt = Yt) : Kt = false, Jo = Kt && (!document.documentMode || 9 < document.documentMode));\n  var Kt, Yt, sl;\n  function _u() {\n    dt && (dt.detachEvent(\"onpropertychange\", qo), xt = dt = null);\n  }\n  function qo(e) {\n    if (e.propertyName === \"value\" && Ar(xt)) {\n      var n = [];\n      Zo(n, xt, e, Si(e)), Ro(Dc, n);\n    }\n  }\n  function Oc(e, n, t) {\n    e === \"focusin\" ? (_u(), dt = n, xt = t, dt.attachEvent(\"onpropertychange\", qo)) : e === \"focusout\" && _u();\n  }\n  function Fc(e) {\n    if (e === \"selectionchange\" || e === \"keyup\" || e === \"keydown\")\n      return Ar(xt);\n  }\n  function Ic(e, n) {\n    if (e === \"click\")\n      return Ar(n);\n  }\n  function jc(e, n) {\n    if (e === \"input\" || e === \"change\")\n      return Ar(n);\n  }\n  function Uc(e, n) {\n    return e === n && (e !== 0 || 1 / e === 1 / n) || e !== e && n !== n;\n  }\n  var xe3 = typeof Object.is == \"function\" ? Object.is : Uc;\n  function Nt(e, n) {\n    if (xe3(e, n))\n      return true;\n    if (typeof e != \"object\" || e === null || typeof n != \"object\" || n === null)\n      return false;\n    var t = Object.keys(e), r = Object.keys(n);\n    if (t.length !== r.length)\n      return false;\n    for (r = 0; r < t.length; r++) {\n      var l = t[r];\n      if (!El.call(n, l) || !xe3(e[l], n[l]))\n        return false;\n    }\n    return true;\n  }\n  function zu(e) {\n    for (; e && e.firstChild; )\n      e = e.firstChild;\n    return e;\n  }\n  function Pu(e, n) {\n    var t = zu(e);\n    e = 0;\n    for (var r; t; ) {\n      if (t.nodeType === 3) {\n        if (r = e + t.textContent.length, e <= n && r >= n)\n          return { node: t, offset: n - e };\n        e = r;\n      }\n      e: {\n        for (; t; ) {\n          if (t.nextSibling) {\n            t = t.nextSibling;\n            break e;\n          }\n          t = t.parentNode;\n        }\n        t = void 0;\n      }\n      t = zu(t);\n    }\n  }\n  function bo(e, n) {\n    return e && n ? e === n ? true : e && e.nodeType === 3 ? false : n && n.nodeType === 3 ? bo(e, n.parentNode) : \"contains\" in e ? e.contains(n) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(n) & 16) : false : false;\n  }\n  function es2() {\n    for (var e = window, n = mr(); n instanceof e.HTMLIFrameElement; ) {\n      try {\n        var t = typeof n.contentWindow.location.href == \"string\";\n      } catch {\n        t = false;\n      }\n      if (t)\n        e = n.contentWindow;\n      else\n        break;\n      n = mr(e.document);\n    }\n    return n;\n  }\n  function Li(e) {\n    var n = e && e.nodeName && e.nodeName.toLowerCase();\n    return n && (n === \"input\" && (e.type === \"text\" || e.type === \"search\" || e.type === \"tel\" || e.type === \"url\" || e.type === \"password\") || n === \"textarea\" || e.contentEditable === \"true\");\n  }\n  function Vc(e) {\n    var n = es2(), t = e.focusedElem, r = e.selectionRange;\n    if (n !== t && t && t.ownerDocument && bo(t.ownerDocument.documentElement, t)) {\n      if (r !== null && Li(t)) {\n        if (n = r.start, e = r.end, e === void 0 && (e = n), \"selectionStart\" in t)\n          t.selectionStart = n, t.selectionEnd = Math.min(e, t.value.length);\n        else if (e = (n = t.ownerDocument || document) && n.defaultView || window, e.getSelection) {\n          e = e.getSelection();\n          var l = t.textContent.length, i = Math.min(r.start, l);\n          r = r.end === void 0 ? i : Math.min(r.end, l), !e.extend && i > r && (l = r, r = i, i = l), l = Pu(t, i);\n          var u = Pu(t, r);\n          l && u && (e.rangeCount !== 1 || e.anchorNode !== l.node || e.anchorOffset !== l.offset || e.focusNode !== u.node || e.focusOffset !== u.offset) && (n = n.createRange(), n.setStart(l.node, l.offset), e.removeAllRanges(), i > r ? (e.addRange(n), e.extend(u.node, u.offset)) : (n.setEnd(u.node, u.offset), e.addRange(n)));\n        }\n      }\n      for (n = [], e = t; e = e.parentNode; )\n        e.nodeType === 1 && n.push({ element: e, left: e.scrollLeft, top: e.scrollTop });\n      for (typeof t.focus == \"function\" && t.focus(), t = 0; t < n.length; t++)\n        e = n[t], e.element.scrollLeft = e.left, e.element.scrollTop = e.top;\n    }\n  }\n  var Ac = Fe2 && \"documentMode\" in document && 11 >= document.documentMode, zn = null, Bl = null, pt2 = null, Hl = false;\n  function Lu(e, n, t) {\n    var r = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;\n    Hl || zn == null || zn !== mr(r) || (r = zn, \"selectionStart\" in r && Li(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), pt2 && Nt(pt2, r) || (pt2 = r, r = kr(Bl, \"onSelect\"), 0 < r.length && (n = new _i(\"onSelect\", \"select\", null, n, t), e.push({ event: n, listeners: r }), n.target = zn)));\n  }\n  function Xt(e, n) {\n    var t = {};\n    return t[e.toLowerCase()] = n.toLowerCase(), t[\"Webkit\" + e] = \"webkit\" + n, t[\"Moz\" + e] = \"moz\" + n, t;\n  }\n  var Pn = { animationend: Xt(\"Animation\", \"AnimationEnd\"), animationiteration: Xt(\"Animation\", \"AnimationIteration\"), animationstart: Xt(\"Animation\", \"AnimationStart\"), transitionend: Xt(\"Transition\", \"TransitionEnd\") }, al = {}, ns = {};\n  Fe2 && (ns = document.createElement(\"div\").style, \"AnimationEvent\" in window || (delete Pn.animationend.animation, delete Pn.animationiteration.animation, delete Pn.animationstart.animation), \"TransitionEvent\" in window || delete Pn.transitionend.transition);\n  function Br(e) {\n    if (al[e])\n      return al[e];\n    if (!Pn[e])\n      return e;\n    var n = Pn[e], t;\n    for (t in n)\n      if (n.hasOwnProperty(t) && t in ns)\n        return al[e] = n[t];\n    return e;\n  }\n  var ts = Br(\"animationend\"), rs = Br(\"animationiteration\"), ls = Br(\"animationstart\"), is = Br(\"transitionend\"), us = /* @__PURE__ */ new Map(), Tu = \"abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel\".split(\" \");\n  function ln(e, n) {\n    us.set(e, n), Sn(n, [e]);\n  }\n  for (Gt = 0; Gt < Tu.length; Gt++)\n    Zt = Tu[Gt], Ru = Zt.toLowerCase(), Du = Zt[0].toUpperCase() + Zt.slice(1), ln(Ru, \"on\" + Du);\n  var Zt, Ru, Du, Gt;\n  ln(ts, \"onAnimationEnd\");\n  ln(rs, \"onAnimationIteration\");\n  ln(ls, \"onAnimationStart\");\n  ln(\"dblclick\", \"onDoubleClick\");\n  ln(\"focusin\", \"onFocus\");\n  ln(\"focusout\", \"onBlur\");\n  ln(is, \"onTransitionEnd\");\n  Hn(\"onMouseEnter\", [\"mouseout\", \"mouseover\"]);\n  Hn(\"onMouseLeave\", [\"mouseout\", \"mouseover\"]);\n  Hn(\"onPointerEnter\", [\"pointerout\", \"pointerover\"]);\n  Hn(\"onPointerLeave\", [\"pointerout\", \"pointerover\"]);\n  Sn(\"onChange\", \"change click focusin focusout input keydown keyup selectionchange\".split(\" \"));\n  Sn(\"onSelect\", \"focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange\".split(\" \"));\n  Sn(\"onBeforeInput\", [\"compositionend\", \"keypress\", \"textInput\", \"paste\"]);\n  Sn(\"onCompositionEnd\", \"compositionend focusout keydown keypress keyup mousedown\".split(\" \"));\n  Sn(\"onCompositionStart\", \"compositionstart focusout keydown keypress keyup mousedown\".split(\" \"));\n  Sn(\"onCompositionUpdate\", \"compositionupdate focusout keydown keypress keyup mousedown\".split(\" \"));\n  var st = \"abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting\".split(\" \"), Bc = new Set(\"cancel close invalid load scroll toggle\".split(\" \").concat(st));\n  function Mu(e, n, t) {\n    var r = e.type || \"unknown-event\";\n    e.currentTarget = t, Ba(r, n, void 0, e), e.currentTarget = null;\n  }\n  function os(e, n) {\n    n = (n & 4) !== 0;\n    for (var t = 0; t < e.length; t++) {\n      var r = e[t], l = r.event;\n      r = r.listeners;\n      e: {\n        var i = void 0;\n        if (n)\n          for (var u = r.length - 1; 0 <= u; u--) {\n            var o = r[u], s = o.instance, d = o.currentTarget;\n            if (o = o.listener, s !== i && l.isPropagationStopped())\n              break e;\n            Mu(l, o, d), i = s;\n          }\n        else\n          for (u = 0; u < r.length; u++) {\n            if (o = r[u], s = o.instance, d = o.currentTarget, o = o.listener, s !== i && l.isPropagationStopped())\n              break e;\n            Mu(l, o, d), i = s;\n          }\n      }\n    }\n    if (vr)\n      throw e = jl, vr = false, jl = null, e;\n  }\n  function T(e, n) {\n    var t = n[Yl];\n    t === void 0 && (t = n[Yl] = /* @__PURE__ */ new Set());\n    var r = e + \"__bubble\";\n    t.has(r) || (ss(n, e, 2, false), t.add(r));\n  }\n  function cl(e, n, t) {\n    var r = 0;\n    n && (r |= 4), ss(t, e, r, n);\n  }\n  var Jt = \"_reactListening\" + Math.random().toString(36).slice(2);\n  function _t(e) {\n    if (!e[Jt]) {\n      e[Jt] = true, ho.forEach(function(t) {\n        t !== \"selectionchange\" && (Bc.has(t) || cl(t, false, e), cl(t, true, e));\n      });\n      var n = e.nodeType === 9 ? e : e.ownerDocument;\n      n === null || n[Jt] || (n[Jt] = true, cl(\"selectionchange\", false, n));\n    }\n  }\n  function ss(e, n, t, r) {\n    switch ($o(n)) {\n      case 1:\n        var l = rc;\n        break;\n      case 4:\n        l = lc;\n        break;\n      default:\n        l = xi;\n    }\n    t = l.bind(null, n, t, e), l = void 0, !Il || n !== \"touchstart\" && n !== \"touchmove\" && n !== \"wheel\" || (l = true), r ? l !== void 0 ? e.addEventListener(n, t, { capture: true, passive: l }) : e.addEventListener(n, t, true) : l !== void 0 ? e.addEventListener(n, t, { passive: l }) : e.addEventListener(n, t, false);\n  }\n  function fl(e, n, t, r, l) {\n    var i = r;\n    if ((n & 1) === 0 && (n & 2) === 0 && r !== null)\n      e:\n        for (; ; ) {\n          if (r === null)\n            return;\n          var u = r.tag;\n          if (u === 3 || u === 4) {\n            var o = r.stateNode.containerInfo;\n            if (o === l || o.nodeType === 8 && o.parentNode === l)\n              break;\n            if (u === 4)\n              for (u = r.return; u !== null; ) {\n                var s = u.tag;\n                if ((s === 3 || s === 4) && (s = u.stateNode.containerInfo, s === l || s.nodeType === 8 && s.parentNode === l))\n                  return;\n                u = u.return;\n              }\n            for (; o !== null; ) {\n              if (u = cn2(o), u === null)\n                return;\n              if (s = u.tag, s === 5 || s === 6) {\n                r = i = u;\n                continue e;\n              }\n              o = o.parentNode;\n            }\n          }\n          r = r.return;\n        }\n    Ro(function() {\n      var d = i, m = Si(t), h = [];\n      e: {\n        var p = us.get(e);\n        if (p !== void 0) {\n          var g = _i, S2 = e;\n          switch (e) {\n            case \"keypress\":\n              if (ur(t) === 0)\n                break e;\n            case \"keydown\":\n            case \"keyup\":\n              g = wc;\n              break;\n            case \"focusin\":\n              S2 = \"focus\", g = ol;\n              break;\n            case \"focusout\":\n              S2 = \"blur\", g = ol;\n              break;\n            case \"beforeblur\":\n            case \"afterblur\":\n              g = ol;\n              break;\n            case \"click\":\n              if (t.button === 2)\n                break e;\n            case \"auxclick\":\n            case \"dblclick\":\n            case \"mousedown\":\n            case \"mousemove\":\n            case \"mouseup\":\n            case \"mouseout\":\n            case \"mouseover\":\n            case \"contextmenu\":\n              g = Su;\n              break;\n            case \"drag\":\n            case \"dragend\":\n            case \"dragenter\":\n            case \"dragexit\":\n            case \"dragleave\":\n            case \"dragover\":\n            case \"dragstart\":\n            case \"drop\":\n              g = oc;\n              break;\n            case \"touchcancel\":\n            case \"touchend\":\n            case \"touchmove\":\n            case \"touchstart\":\n              g = Ec;\n              break;\n            case ts:\n            case rs:\n            case ls:\n              g = cc;\n              break;\n            case is:\n              g = xc;\n              break;\n            case \"scroll\":\n              g = ic;\n              break;\n            case \"wheel\":\n              g = _c;\n              break;\n            case \"copy\":\n            case \"cut\":\n            case \"paste\":\n              g = dc;\n              break;\n            case \"gotpointercapture\":\n            case \"lostpointercapture\":\n            case \"pointercancel\":\n            case \"pointerdown\":\n            case \"pointermove\":\n            case \"pointerout\":\n            case \"pointerover\":\n            case \"pointerup\":\n              g = Eu;\n          }\n          var k2 = (n & 4) !== 0, j = !k2 && e === \"scroll\", c3 = k2 ? p !== null ? p + \"Capture\" : null : p;\n          k2 = [];\n          for (var a = d, f; a !== null; ) {\n            f = a;\n            var y = f.stateNode;\n            if (f.tag === 5 && y !== null && (f = y, c3 !== null && (y = St(a, c3), y != null && k2.push(zt(a, y, f)))), j)\n              break;\n            a = a.return;\n          }\n          0 < k2.length && (p = new g(p, S2, null, t, m), h.push({ event: p, listeners: k2 }));\n        }\n      }\n      if ((n & 7) === 0) {\n        e: {\n          if (p = e === \"mouseover\" || e === \"pointerover\", g = e === \"mouseout\" || e === \"pointerout\", p && t !== Ol && (S2 = t.relatedTarget || t.fromElement) && (cn2(S2) || S2[Ie3]))\n            break e;\n          if ((g || p) && (p = m.window === m ? m : (p = m.ownerDocument) ? p.defaultView || p.parentWindow : window, g ? (S2 = t.relatedTarget || t.toElement, g = d, S2 = S2 ? cn2(S2) : null, S2 !== null && (j = kn(S2), S2 !== j || S2.tag !== 5 && S2.tag !== 6) && (S2 = null)) : (g = null, S2 = d), g !== S2)) {\n            if (k2 = Su, y = \"onMouseLeave\", c3 = \"onMouseEnter\", a = \"mouse\", (e === \"pointerout\" || e === \"pointerover\") && (k2 = Eu, y = \"onPointerLeave\", c3 = \"onPointerEnter\", a = \"pointer\"), j = g == null ? p : Ln(g), f = S2 == null ? p : Ln(S2), p = new k2(y, a + \"leave\", g, t, m), p.target = j, p.relatedTarget = f, y = null, cn2(m) === d && (k2 = new k2(c3, a + \"enter\", S2, t, m), k2.target = f, k2.relatedTarget = j, y = k2), j = y, g && S2)\n              n: {\n                for (k2 = g, c3 = S2, a = 0, f = k2; f; f = Cn(f))\n                  a++;\n                for (f = 0, y = c3; y; y = Cn(y))\n                  f++;\n                for (; 0 < a - f; )\n                  k2 = Cn(k2), a--;\n                for (; 0 < f - a; )\n                  c3 = Cn(c3), f--;\n                for (; a--; ) {\n                  if (k2 === c3 || c3 !== null && k2 === c3.alternate)\n                    break n;\n                  k2 = Cn(k2), c3 = Cn(c3);\n                }\n                k2 = null;\n              }\n            else\n              k2 = null;\n            g !== null && Ou(h, p, g, k2, false), S2 !== null && j !== null && Ou(h, j, S2, k2, true);\n          }\n        }\n        e: {\n          if (p = d ? Ln(d) : window, g = p.nodeName && p.nodeName.toLowerCase(), g === \"select\" || g === \"input\" && p.type === \"file\")\n            var E = Mc;\n          else if (Nu(p))\n            if (Jo)\n              E = jc;\n            else {\n              E = Fc;\n              var C3 = Oc;\n            }\n          else\n            (g = p.nodeName) && g.toLowerCase() === \"input\" && (p.type === \"checkbox\" || p.type === \"radio\") && (E = Ic);\n          if (E && (E = E(e, d))) {\n            Zo(h, E, t, m);\n            break e;\n          }\n          C3 && C3(e, p, d), e === \"focusout\" && (C3 = p._wrapperState) && C3.controlled && p.type === \"number\" && Ll(p, \"number\", p.value);\n        }\n        switch (C3 = d ? Ln(d) : window, e) {\n          case \"focusin\":\n            (Nu(C3) || C3.contentEditable === \"true\") && (zn = C3, Bl = d, pt2 = null);\n            break;\n          case \"focusout\":\n            pt2 = Bl = zn = null;\n            break;\n          case \"mousedown\":\n            Hl = true;\n            break;\n          case \"contextmenu\":\n          case \"mouseup\":\n          case \"dragend\":\n            Hl = false, Lu(h, t, m);\n            break;\n          case \"selectionchange\":\n            if (Ac)\n              break;\n          case \"keydown\":\n          case \"keyup\":\n            Lu(h, t, m);\n        }\n        var x;\n        if (Pi)\n          e: {\n            switch (e) {\n              case \"compositionstart\":\n                var N3 = \"onCompositionStart\";\n                break e;\n              case \"compositionend\":\n                N3 = \"onCompositionEnd\";\n                break e;\n              case \"compositionupdate\":\n                N3 = \"onCompositionUpdate\";\n                break e;\n            }\n            N3 = void 0;\n          }\n        else\n          _n ? Xo(e, t) && (N3 = \"onCompositionEnd\") : e === \"keydown\" && t.keyCode === 229 && (N3 = \"onCompositionStart\");\n        N3 && (Yo && t.locale !== \"ko\" && (_n || N3 !== \"onCompositionStart\" ? N3 === \"onCompositionEnd\" && _n && (x = Ko()) : (Ke = m, Ni = \"value\" in Ke ? Ke.value : Ke.textContent, _n = true)), C3 = kr(d, N3), 0 < C3.length && (N3 = new ku(N3, e, null, t, m), h.push({ event: N3, listeners: C3 }), x ? N3.data = x : (x = Go(t), x !== null && (N3.data = x)))), (x = Pc ? Lc(e, t) : Tc(e, t)) && (d = kr(d, \"onBeforeInput\"), 0 < d.length && (m = new ku(\"onBeforeInput\", \"beforeinput\", null, t, m), h.push({ event: m, listeners: d }), m.data = x));\n      }\n      os(h, n);\n    });\n  }\n  function zt(e, n, t) {\n    return { instance: e, listener: n, currentTarget: t };\n  }\n  function kr(e, n) {\n    for (var t = n + \"Capture\", r = []; e !== null; ) {\n      var l = e, i = l.stateNode;\n      l.tag === 5 && i !== null && (l = i, i = St(e, t), i != null && r.unshift(zt(e, i, l)), i = St(e, n), i != null && r.push(zt(e, i, l))), e = e.return;\n    }\n    return r;\n  }\n  function Cn(e) {\n    if (e === null)\n      return null;\n    do\n      e = e.return;\n    while (e && e.tag !== 5);\n    return e || null;\n  }\n  function Ou(e, n, t, r, l) {\n    for (var i = n._reactName, u = []; t !== null && t !== r; ) {\n      var o = t, s = o.alternate, d = o.stateNode;\n      if (s !== null && s === r)\n        break;\n      o.tag === 5 && d !== null && (o = d, l ? (s = St(t, i), s != null && u.unshift(zt(t, s, o))) : l || (s = St(t, i), s != null && u.push(zt(t, s, o)))), t = t.return;\n    }\n    u.length !== 0 && e.push({ event: n, listeners: u });\n  }\n  var Hc = /\\r\\n?/g, Wc = /\\u0000|\\uFFFD/g;\n  function Fu(e) {\n    return (typeof e == \"string\" ? e : \"\" + e).replace(Hc, `\n`).replace(Wc, \"\");\n  }\n  function qt(e, n, t) {\n    if (n = Fu(n), Fu(e) !== n && t)\n      throw Error(v(425));\n  }\n  function Er() {\n  }\n  var Wl = null, Ql = null;\n  function $l(e, n) {\n    return e === \"textarea\" || e === \"noscript\" || typeof n.children == \"string\" || typeof n.children == \"number\" || typeof n.dangerouslySetInnerHTML == \"object\" && n.dangerouslySetInnerHTML !== null && n.dangerouslySetInnerHTML.__html != null;\n  }\n  var Kl = typeof setTimeout == \"function\" ? setTimeout : void 0, Qc = typeof clearTimeout == \"function\" ? clearTimeout : void 0, Iu = typeof Promise == \"function\" ? Promise : void 0, $c = typeof queueMicrotask == \"function\" ? queueMicrotask : typeof Iu < \"u\" ? function(e) {\n    return Iu.resolve(null).then(e).catch(Kc);\n  } : Kl;\n  function Kc(e) {\n    setTimeout(function() {\n      throw e;\n    });\n  }\n  function dl(e, n) {\n    var t = n, r = 0;\n    do {\n      var l = t.nextSibling;\n      if (e.removeChild(t), l && l.nodeType === 8)\n        if (t = l.data, t === \"/$\") {\n          if (r === 0) {\n            e.removeChild(l), Ct(n);\n            return;\n          }\n          r--;\n        } else\n          t !== \"$\" && t !== \"$?\" && t !== \"$!\" || r++;\n      t = l;\n    } while (t);\n    Ct(n);\n  }\n  function Je(e) {\n    for (; e != null; e = e.nextSibling) {\n      var n = e.nodeType;\n      if (n === 1 || n === 3)\n        break;\n      if (n === 8) {\n        if (n = e.data, n === \"$\" || n === \"$!\" || n === \"$?\")\n          break;\n        if (n === \"/$\")\n          return null;\n      }\n    }\n    return e;\n  }\n  function ju(e) {\n    e = e.previousSibling;\n    for (var n = 0; e; ) {\n      if (e.nodeType === 8) {\n        var t = e.data;\n        if (t === \"$\" || t === \"$!\" || t === \"$?\") {\n          if (n === 0)\n            return e;\n          n--;\n        } else\n          t === \"/$\" && n++;\n      }\n      e = e.previousSibling;\n    }\n    return null;\n  }\n  var Zn = Math.random().toString(36).slice(2), ze2 = \"__reactFiber$\" + Zn, Pt = \"__reactProps$\" + Zn, Ie3 = \"__reactContainer$\" + Zn, Yl = \"__reactEvents$\" + Zn, Yc = \"__reactListeners$\" + Zn, Xc = \"__reactHandles$\" + Zn;\n  function cn2(e) {\n    var n = e[ze2];\n    if (n)\n      return n;\n    for (var t = e.parentNode; t; ) {\n      if (n = t[Ie3] || t[ze2]) {\n        if (t = n.alternate, n.child !== null || t !== null && t.child !== null)\n          for (e = ju(e); e !== null; ) {\n            if (t = e[ze2])\n              return t;\n            e = ju(e);\n          }\n        return n;\n      }\n      e = t, t = e.parentNode;\n    }\n    return null;\n  }\n  function jt(e) {\n    return e = e[ze2] || e[Ie3], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e;\n  }\n  function Ln(e) {\n    if (e.tag === 5 || e.tag === 6)\n      return e.stateNode;\n    throw Error(v(33));\n  }\n  function Hr(e) {\n    return e[Pt] || null;\n  }\n  var Xl = [], Tn = -1;\n  function un(e) {\n    return { current: e };\n  }\n  function R3(e) {\n    0 > Tn || (e.current = Xl[Tn], Xl[Tn] = null, Tn--);\n  }\n  function L2(e, n) {\n    Tn++, Xl[Tn] = e.current, e.current = n;\n  }\n  var rn = {}, J2 = un(rn), re = un(false), hn = rn;\n  function Wn(e, n) {\n    var t = e.type.contextTypes;\n    if (!t)\n      return rn;\n    var r = e.stateNode;\n    if (r && r.__reactInternalMemoizedUnmaskedChildContext === n)\n      return r.__reactInternalMemoizedMaskedChildContext;\n    var l = {}, i;\n    for (i in t)\n      l[i] = n[i];\n    return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = n, e.__reactInternalMemoizedMaskedChildContext = l), l;\n  }\n  function le2(e) {\n    return e = e.childContextTypes, e != null;\n  }\n  function Cr() {\n    R3(re), R3(J2);\n  }\n  function Uu(e, n, t) {\n    if (J2.current !== rn)\n      throw Error(v(168));\n    L2(J2, n), L2(re, t);\n  }\n  function as(e, n, t) {\n    var r = e.stateNode;\n    if (n = n.childContextTypes, typeof r.getChildContext != \"function\")\n      return t;\n    r = r.getChildContext();\n    for (var l in r)\n      if (!(l in n))\n        throw Error(v(108, Oa(e) || \"Unknown\", l));\n    return F2({}, t, r);\n  }\n  function xr(e) {\n    return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || rn, hn = J2.current, L2(J2, e), L2(re, re.current), true;\n  }\n  function Vu(e, n, t) {\n    var r = e.stateNode;\n    if (!r)\n      throw Error(v(169));\n    t ? (e = as(e, n, hn), r.__reactInternalMemoizedMergedChildContext = e, R3(re), R3(J2), L2(J2, e)) : R3(re), L2(re, t);\n  }\n  var Re2 = null, Wr = false, pl = false;\n  function cs2(e) {\n    Re2 === null ? Re2 = [e] : Re2.push(e);\n  }\n  function Gc(e) {\n    Wr = true, cs2(e);\n  }\n  function on() {\n    if (!pl && Re2 !== null) {\n      pl = true;\n      var e = 0, n = P;\n      try {\n        var t = Re2;\n        for (P = 1; e < t.length; e++) {\n          var r = t[e];\n          do\n            r = r(true);\n          while (r !== null);\n        }\n        Re2 = null, Wr = false;\n      } catch (l) {\n        throw Re2 !== null && (Re2 = Re2.slice(e + 1)), Fo(ki, on), l;\n      } finally {\n        P = n, pl = false;\n      }\n    }\n    return null;\n  }\n  var Rn = [], Dn = 0, Nr = null, _r = 0, de4 = [], pe3 = 0, vn = null, De2 = 1, Me2 = \"\";\n  function sn(e, n) {\n    Rn[Dn++] = _r, Rn[Dn++] = Nr, Nr = e, _r = n;\n  }\n  function fs(e, n, t) {\n    de4[pe3++] = De2, de4[pe3++] = Me2, de4[pe3++] = vn, vn = e;\n    var r = De2;\n    e = Me2;\n    var l = 32 - Ee3(r) - 1;\n    r &= ~(1 << l), t += 1;\n    var i = 32 - Ee3(n) + l;\n    if (30 < i) {\n      var u = l - l % 5;\n      i = (r & (1 << u) - 1).toString(32), r >>= u, l -= u, De2 = 1 << 32 - Ee3(n) + l | t << l | r, Me2 = i + e;\n    } else\n      De2 = 1 << i | t << l | r, Me2 = e;\n  }\n  function Ti(e) {\n    e.return !== null && (sn(e, 1), fs(e, 1, 0));\n  }\n  function Ri(e) {\n    for (; e === Nr; )\n      Nr = Rn[--Dn], Rn[Dn] = null, _r = Rn[--Dn], Rn[Dn] = null;\n    for (; e === vn; )\n      vn = de4[--pe3], de4[pe3] = null, Me2 = de4[--pe3], de4[pe3] = null, De2 = de4[--pe3], de4[pe3] = null;\n  }\n  var se2 = null, oe2 = null, D2 = false, ke3 = null;\n  function ds(e, n) {\n    var t = me3(5, null, null, 0);\n    t.elementType = \"DELETED\", t.stateNode = n, t.return = e, n = e.deletions, n === null ? (e.deletions = [t], e.flags |= 16) : n.push(t);\n  }\n  function Au(e, n) {\n    switch (e.tag) {\n      case 5:\n        var t = e.type;\n        return n = n.nodeType !== 1 || t.toLowerCase() !== n.nodeName.toLowerCase() ? null : n, n !== null ? (e.stateNode = n, se2 = e, oe2 = Je(n.firstChild), true) : false;\n      case 6:\n        return n = e.pendingProps === \"\" || n.nodeType !== 3 ? null : n, n !== null ? (e.stateNode = n, se2 = e, oe2 = null, true) : false;\n      case 13:\n        return n = n.nodeType !== 8 ? null : n, n !== null ? (t = vn !== null ? { id: De2, overflow: Me2 } : null, e.memoizedState = { dehydrated: n, treeContext: t, retryLane: 1073741824 }, t = me3(18, null, null, 0), t.stateNode = n, t.return = e, e.child = t, se2 = e, oe2 = null, true) : false;\n      default:\n        return false;\n    }\n  }\n  function Gl(e) {\n    return (e.mode & 1) !== 0 && (e.flags & 128) === 0;\n  }\n  function Zl(e) {\n    if (D2) {\n      var n = oe2;\n      if (n) {\n        var t = n;\n        if (!Au(e, n)) {\n          if (Gl(e))\n            throw Error(v(418));\n          n = Je(t.nextSibling);\n          var r = se2;\n          n && Au(e, n) ? ds(r, t) : (e.flags = e.flags & -4097 | 2, D2 = false, se2 = e);\n        }\n      } else {\n        if (Gl(e))\n          throw Error(v(418));\n        e.flags = e.flags & -4097 | 2, D2 = false, se2 = e;\n      }\n    }\n  }\n  function Bu(e) {\n    for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; )\n      e = e.return;\n    se2 = e;\n  }\n  function bt(e) {\n    if (e !== se2)\n      return false;\n    if (!D2)\n      return Bu(e), D2 = true, false;\n    var n;\n    if ((n = e.tag !== 3) && !(n = e.tag !== 5) && (n = e.type, n = n !== \"head\" && n !== \"body\" && !$l(e.type, e.memoizedProps)), n && (n = oe2)) {\n      if (Gl(e))\n        throw ps(), Error(v(418));\n      for (; n; )\n        ds(e, n), n = Je(n.nextSibling);\n    }\n    if (Bu(e), e.tag === 13) {\n      if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e)\n        throw Error(v(317));\n      e: {\n        for (e = e.nextSibling, n = 0; e; ) {\n          if (e.nodeType === 8) {\n            var t = e.data;\n            if (t === \"/$\") {\n              if (n === 0) {\n                oe2 = Je(e.nextSibling);\n                break e;\n              }\n              n--;\n            } else\n              t !== \"$\" && t !== \"$!\" && t !== \"$?\" || n++;\n          }\n          e = e.nextSibling;\n        }\n        oe2 = null;\n      }\n    } else\n      oe2 = se2 ? Je(e.stateNode.nextSibling) : null;\n    return true;\n  }\n  function ps() {\n    for (var e = oe2; e; )\n      e = Je(e.nextSibling);\n  }\n  function Qn() {\n    oe2 = se2 = null, D2 = false;\n  }\n  function Di(e) {\n    ke3 === null ? ke3 = [e] : ke3.push(e);\n  }\n  var Zc = Ve2.ReactCurrentBatchConfig;\n  function we3(e, n) {\n    if (e && e.defaultProps) {\n      n = F2({}, n), e = e.defaultProps;\n      for (var t in e)\n        n[t] === void 0 && (n[t] = e[t]);\n      return n;\n    }\n    return n;\n  }\n  var zr = un(null), Pr = null, Mn = null, Mi = null;\n  function Oi() {\n    Mi = Mn = Pr = null;\n  }\n  function Fi(e) {\n    var n = zr.current;\n    R3(zr), e._currentValue = n;\n  }\n  function Jl(e, n, t) {\n    for (; e !== null; ) {\n      var r = e.alternate;\n      if ((e.childLanes & n) !== n ? (e.childLanes |= n, r !== null && (r.childLanes |= n)) : r !== null && (r.childLanes & n) !== n && (r.childLanes |= n), e === t)\n        break;\n      e = e.return;\n    }\n  }\n  function An(e, n) {\n    Pr = e, Mi = Mn = null, e = e.dependencies, e !== null && e.firstContext !== null && ((e.lanes & n) !== 0 && (te2 = true), e.firstContext = null);\n  }\n  function ve3(e) {\n    var n = e._currentValue;\n    if (Mi !== e)\n      if (e = { context: e, memoizedValue: n, next: null }, Mn === null) {\n        if (Pr === null)\n          throw Error(v(308));\n        Mn = e, Pr.dependencies = { lanes: 0, firstContext: e };\n      } else\n        Mn = Mn.next = e;\n    return n;\n  }\n  var fn = null;\n  function Ii(e) {\n    fn === null ? fn = [e] : fn.push(e);\n  }\n  function ms(e, n, t, r) {\n    var l = n.interleaved;\n    return l === null ? (t.next = t, Ii(n)) : (t.next = l.next, l.next = t), n.interleaved = t, je2(e, r);\n  }\n  function je2(e, n) {\n    e.lanes |= n;\n    var t = e.alternate;\n    for (t !== null && (t.lanes |= n), t = e, e = e.return; e !== null; )\n      e.childLanes |= n, t = e.alternate, t !== null && (t.childLanes |= n), t = e, e = e.return;\n    return t.tag === 3 ? t.stateNode : null;\n  }\n  var We2 = false;\n  function ji(e) {\n    e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };\n  }\n  function hs(e, n) {\n    e = e.updateQueue, n.updateQueue === e && (n.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects });\n  }\n  function Oe2(e, n) {\n    return { eventTime: e, lane: n, tag: 0, payload: null, callback: null, next: null };\n  }\n  function qe2(e, n, t) {\n    var r = e.updateQueue;\n    if (r === null)\n      return null;\n    if (r = r.shared, (_ & 2) !== 0) {\n      var l = r.pending;\n      return l === null ? n.next = n : (n.next = l.next, l.next = n), r.pending = n, je2(e, t);\n    }\n    return l = r.interleaved, l === null ? (n.next = n, Ii(r)) : (n.next = l.next, l.next = n), r.interleaved = n, je2(e, t);\n  }\n  function or(e, n, t) {\n    if (n = n.updateQueue, n !== null && (n = n.shared, (t & 4194240) !== 0)) {\n      var r = n.lanes;\n      r &= e.pendingLanes, t |= r, n.lanes = t, Ei(e, t);\n    }\n  }\n  function Hu(e, n) {\n    var t = e.updateQueue, r = e.alternate;\n    if (r !== null && (r = r.updateQueue, t === r)) {\n      var l = null, i = null;\n      if (t = t.firstBaseUpdate, t !== null) {\n        do {\n          var u = { eventTime: t.eventTime, lane: t.lane, tag: t.tag, payload: t.payload, callback: t.callback, next: null };\n          i === null ? l = i = u : i = i.next = u, t = t.next;\n        } while (t !== null);\n        i === null ? l = i = n : i = i.next = n;\n      } else\n        l = i = n;\n      t = { baseState: r.baseState, firstBaseUpdate: l, lastBaseUpdate: i, shared: r.shared, effects: r.effects }, e.updateQueue = t;\n      return;\n    }\n    e = t.lastBaseUpdate, e === null ? t.firstBaseUpdate = n : e.next = n, t.lastBaseUpdate = n;\n  }\n  function Lr(e, n, t, r) {\n    var l = e.updateQueue;\n    We2 = false;\n    var i = l.firstBaseUpdate, u = l.lastBaseUpdate, o = l.shared.pending;\n    if (o !== null) {\n      l.shared.pending = null;\n      var s = o, d = s.next;\n      s.next = null, u === null ? i = d : u.next = d, u = s;\n      var m = e.alternate;\n      m !== null && (m = m.updateQueue, o = m.lastBaseUpdate, o !== u && (o === null ? m.firstBaseUpdate = d : o.next = d, m.lastBaseUpdate = s));\n    }\n    if (i !== null) {\n      var h = l.baseState;\n      u = 0, m = d = s = null, o = i;\n      do {\n        var p = o.lane, g = o.eventTime;\n        if ((r & p) === p) {\n          m !== null && (m = m.next = { eventTime: g, lane: 0, tag: o.tag, payload: o.payload, callback: o.callback, next: null });\n          e: {\n            var S2 = e, k2 = o;\n            switch (p = n, g = t, k2.tag) {\n              case 1:\n                if (S2 = k2.payload, typeof S2 == \"function\") {\n                  h = S2.call(g, h, p);\n                  break e;\n                }\n                h = S2;\n                break e;\n              case 3:\n                S2.flags = S2.flags & -65537 | 128;\n              case 0:\n                if (S2 = k2.payload, p = typeof S2 == \"function\" ? S2.call(g, h, p) : S2, p == null)\n                  break e;\n                h = F2({}, h, p);\n                break e;\n              case 2:\n                We2 = true;\n            }\n          }\n          o.callback !== null && o.lane !== 0 && (e.flags |= 64, p = l.effects, p === null ? l.effects = [o] : p.push(o));\n        } else\n          g = { eventTime: g, lane: p, tag: o.tag, payload: o.payload, callback: o.callback, next: null }, m === null ? (d = m = g, s = h) : m = m.next = g, u |= p;\n        if (o = o.next, o === null) {\n          if (o = l.shared.pending, o === null)\n            break;\n          p = o, o = p.next, p.next = null, l.lastBaseUpdate = p, l.shared.pending = null;\n        }\n      } while (1);\n      if (m === null && (s = h), l.baseState = s, l.firstBaseUpdate = d, l.lastBaseUpdate = m, n = l.shared.interleaved, n !== null) {\n        l = n;\n        do\n          u |= l.lane, l = l.next;\n        while (l !== n);\n      } else\n        i === null && (l.shared.lanes = 0);\n      gn |= u, e.lanes = u, e.memoizedState = h;\n    }\n  }\n  function Wu(e, n, t) {\n    if (e = n.effects, n.effects = null, e !== null)\n      for (n = 0; n < e.length; n++) {\n        var r = e[n], l = r.callback;\n        if (l !== null) {\n          if (r.callback = null, r = t, typeof l != \"function\")\n            throw Error(v(191, l));\n          l.call(r);\n        }\n      }\n  }\n  var vs = new mo.Component().refs;\n  function ql(e, n, t, r) {\n    n = e.memoizedState, t = t(r, n), t = t == null ? n : F2({}, n, t), e.memoizedState = t, e.lanes === 0 && (e.updateQueue.baseState = t);\n  }\n  var Qr = { isMounted: function(e) {\n    return (e = e._reactInternals) ? kn(e) === e : false;\n  }, enqueueSetState: function(e, n, t) {\n    e = e._reactInternals;\n    var r = b(), l = en2(e), i = Oe2(r, l);\n    i.payload = n, t != null && (i.callback = t), n = qe2(e, i, l), n !== null && (Ce3(n, e, l, r), or(n, e, l));\n  }, enqueueReplaceState: function(e, n, t) {\n    e = e._reactInternals;\n    var r = b(), l = en2(e), i = Oe2(r, l);\n    i.tag = 1, i.payload = n, t != null && (i.callback = t), n = qe2(e, i, l), n !== null && (Ce3(n, e, l, r), or(n, e, l));\n  }, enqueueForceUpdate: function(e, n) {\n    e = e._reactInternals;\n    var t = b(), r = en2(e), l = Oe2(t, r);\n    l.tag = 2, n != null && (l.callback = n), n = qe2(e, l, r), n !== null && (Ce3(n, e, r, t), or(n, e, r));\n  } };\n  function Qu(e, n, t, r, l, i, u) {\n    return e = e.stateNode, typeof e.shouldComponentUpdate == \"function\" ? e.shouldComponentUpdate(r, i, u) : n.prototype && n.prototype.isPureReactComponent ? !Nt(t, r) || !Nt(l, i) : true;\n  }\n  function ys(e, n, t) {\n    var r = false, l = rn, i = n.contextType;\n    return typeof i == \"object\" && i !== null ? i = ve3(i) : (l = le2(n) ? hn : J2.current, r = n.contextTypes, i = (r = r != null) ? Wn(e, l) : rn), n = new n(t, i), e.memoizedState = n.state !== null && n.state !== void 0 ? n.state : null, n.updater = Qr, e.stateNode = n, n._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = l, e.__reactInternalMemoizedMaskedChildContext = i), n;\n  }\n  function $u(e, n, t, r) {\n    e = n.state, typeof n.componentWillReceiveProps == \"function\" && n.componentWillReceiveProps(t, r), typeof n.UNSAFE_componentWillReceiveProps == \"function\" && n.UNSAFE_componentWillReceiveProps(t, r), n.state !== e && Qr.enqueueReplaceState(n, n.state, null);\n  }\n  function bl(e, n, t, r) {\n    var l = e.stateNode;\n    l.props = t, l.state = e.memoizedState, l.refs = vs, ji(e);\n    var i = n.contextType;\n    typeof i == \"object\" && i !== null ? l.context = ve3(i) : (i = le2(n) ? hn : J2.current, l.context = Wn(e, i)), l.state = e.memoizedState, i = n.getDerivedStateFromProps, typeof i == \"function\" && (ql(e, n, i, t), l.state = e.memoizedState), typeof n.getDerivedStateFromProps == \"function\" || typeof l.getSnapshotBeforeUpdate == \"function\" || typeof l.UNSAFE_componentWillMount != \"function\" && typeof l.componentWillMount != \"function\" || (n = l.state, typeof l.componentWillMount == \"function\" && l.componentWillMount(), typeof l.UNSAFE_componentWillMount == \"function\" && l.UNSAFE_componentWillMount(), n !== l.state && Qr.enqueueReplaceState(l, l.state, null), Lr(e, t, l, r), l.state = e.memoizedState), typeof l.componentDidMount == \"function\" && (e.flags |= 4194308);\n  }\n  function nt(e, n, t) {\n    if (e = t.ref, e !== null && typeof e != \"function\" && typeof e != \"object\") {\n      if (t._owner) {\n        if (t = t._owner, t) {\n          if (t.tag !== 1)\n            throw Error(v(309));\n          var r = t.stateNode;\n        }\n        if (!r)\n          throw Error(v(147, e));\n        var l = r, i = \"\" + e;\n        return n !== null && n.ref !== null && typeof n.ref == \"function\" && n.ref._stringRef === i ? n.ref : (n = function(u) {\n          var o = l.refs;\n          o === vs && (o = l.refs = {}), u === null ? delete o[i] : o[i] = u;\n        }, n._stringRef = i, n);\n      }\n      if (typeof e != \"string\")\n        throw Error(v(284));\n      if (!t._owner)\n        throw Error(v(290, e));\n    }\n    return e;\n  }\n  function er(e, n) {\n    throw e = Object.prototype.toString.call(n), Error(v(31, e === \"[object Object]\" ? \"object with keys {\" + Object.keys(n).join(\", \") + \"}\" : e));\n  }\n  function Ku(e) {\n    var n = e._init;\n    return n(e._payload);\n  }\n  function gs(e) {\n    function n(c3, a) {\n      if (e) {\n        var f = c3.deletions;\n        f === null ? (c3.deletions = [a], c3.flags |= 16) : f.push(a);\n      }\n    }\n    function t(c3, a) {\n      if (!e)\n        return null;\n      for (; a !== null; )\n        n(c3, a), a = a.sibling;\n      return null;\n    }\n    function r(c3, a) {\n      for (c3 = /* @__PURE__ */ new Map(); a !== null; )\n        a.key !== null ? c3.set(a.key, a) : c3.set(a.index, a), a = a.sibling;\n      return c3;\n    }\n    function l(c3, a) {\n      return c3 = nn(c3, a), c3.index = 0, c3.sibling = null, c3;\n    }\n    function i(c3, a, f) {\n      return c3.index = f, e ? (f = c3.alternate, f !== null ? (f = f.index, f < a ? (c3.flags |= 2, a) : f) : (c3.flags |= 2, a)) : (c3.flags |= 1048576, a);\n    }\n    function u(c3) {\n      return e && c3.alternate === null && (c3.flags |= 2), c3;\n    }\n    function o(c3, a, f, y) {\n      return a === null || a.tag !== 6 ? (a = Sl(f, c3.mode, y), a.return = c3, a) : (a = l(a, f), a.return = c3, a);\n    }\n    function s(c3, a, f, y) {\n      var E = f.type;\n      return E === Nn ? m(c3, a, f.props.children, y, f.key) : a !== null && (a.elementType === E || typeof E == \"object\" && E !== null && E.$$typeof === He2 && Ku(E) === a.type) ? (y = l(a, f.props), y.ref = nt(c3, a, f), y.return = c3, y) : (y = pr(f.type, f.key, f.props, null, c3.mode, y), y.ref = nt(c3, a, f), y.return = c3, y);\n    }\n    function d(c3, a, f, y) {\n      return a === null || a.tag !== 4 || a.stateNode.containerInfo !== f.containerInfo || a.stateNode.implementation !== f.implementation ? (a = kl(f, c3.mode, y), a.return = c3, a) : (a = l(a, f.children || []), a.return = c3, a);\n    }\n    function m(c3, a, f, y, E) {\n      return a === null || a.tag !== 7 ? (a = mn(f, c3.mode, y, E), a.return = c3, a) : (a = l(a, f), a.return = c3, a);\n    }\n    function h(c3, a, f) {\n      if (typeof a == \"string\" && a !== \"\" || typeof a == \"number\")\n        return a = Sl(\"\" + a, c3.mode, f), a.return = c3, a;\n      if (typeof a == \"object\" && a !== null) {\n        switch (a.$$typeof) {\n          case Vt:\n            return f = pr(a.type, a.key, a.props, null, c3.mode, f), f.ref = nt(c3, null, a), f.return = c3, f;\n          case xn:\n            return a = kl(a, c3.mode, f), a.return = c3, a;\n          case He2:\n            var y = a._init;\n            return h(c3, y(a._payload), f);\n        }\n        if (ut(a) || Jn(a))\n          return a = mn(a, c3.mode, f, null), a.return = c3, a;\n        er(c3, a);\n      }\n      return null;\n    }\n    function p(c3, a, f, y) {\n      var E = a !== null ? a.key : null;\n      if (typeof f == \"string\" && f !== \"\" || typeof f == \"number\")\n        return E !== null ? null : o(c3, a, \"\" + f, y);\n      if (typeof f == \"object\" && f !== null) {\n        switch (f.$$typeof) {\n          case Vt:\n            return f.key === E ? s(c3, a, f, y) : null;\n          case xn:\n            return f.key === E ? d(c3, a, f, y) : null;\n          case He2:\n            return E = f._init, p(c3, a, E(f._payload), y);\n        }\n        if (ut(f) || Jn(f))\n          return E !== null ? null : m(c3, a, f, y, null);\n        er(c3, f);\n      }\n      return null;\n    }\n    function g(c3, a, f, y, E) {\n      if (typeof y == \"string\" && y !== \"\" || typeof y == \"number\")\n        return c3 = c3.get(f) || null, o(a, c3, \"\" + y, E);\n      if (typeof y == \"object\" && y !== null) {\n        switch (y.$$typeof) {\n          case Vt:\n            return c3 = c3.get(y.key === null ? f : y.key) || null, s(a, c3, y, E);\n          case xn:\n            return c3 = c3.get(y.key === null ? f : y.key) || null, d(a, c3, y, E);\n          case He2:\n            var C3 = y._init;\n            return g(c3, a, f, C3(y._payload), E);\n        }\n        if (ut(y) || Jn(y))\n          return c3 = c3.get(f) || null, m(a, c3, y, E, null);\n        er(a, y);\n      }\n      return null;\n    }\n    function S2(c3, a, f, y) {\n      for (var E = null, C3 = null, x = a, N3 = a = 0, H2 = null; x !== null && N3 < f.length; N3++) {\n        x.index > N3 ? (H2 = x, x = null) : H2 = x.sibling;\n        var z2 = p(c3, x, f[N3], y);\n        if (z2 === null) {\n          x === null && (x = H2);\n          break;\n        }\n        e && x && z2.alternate === null && n(c3, x), a = i(z2, a, N3), C3 === null ? E = z2 : C3.sibling = z2, C3 = z2, x = H2;\n      }\n      if (N3 === f.length)\n        return t(c3, x), D2 && sn(c3, N3), E;\n      if (x === null) {\n        for (; N3 < f.length; N3++)\n          x = h(c3, f[N3], y), x !== null && (a = i(x, a, N3), C3 === null ? E = x : C3.sibling = x, C3 = x);\n        return D2 && sn(c3, N3), E;\n      }\n      for (x = r(c3, x); N3 < f.length; N3++)\n        H2 = g(x, c3, N3, f[N3], y), H2 !== null && (e && H2.alternate !== null && x.delete(H2.key === null ? N3 : H2.key), a = i(H2, a, N3), C3 === null ? E = H2 : C3.sibling = H2, C3 = H2);\n      return e && x.forEach(function(Ae2) {\n        return n(c3, Ae2);\n      }), D2 && sn(c3, N3), E;\n    }\n    function k2(c3, a, f, y) {\n      var E = Jn(f);\n      if (typeof E != \"function\")\n        throw Error(v(150));\n      if (f = E.call(f), f == null)\n        throw Error(v(151));\n      for (var C3 = E = null, x = a, N3 = a = 0, H2 = null, z2 = f.next(); x !== null && !z2.done; N3++, z2 = f.next()) {\n        x.index > N3 ? (H2 = x, x = null) : H2 = x.sibling;\n        var Ae2 = p(c3, x, z2.value, y);\n        if (Ae2 === null) {\n          x === null && (x = H2);\n          break;\n        }\n        e && x && Ae2.alternate === null && n(c3, x), a = i(Ae2, a, N3), C3 === null ? E = Ae2 : C3.sibling = Ae2, C3 = Ae2, x = H2;\n      }\n      if (z2.done)\n        return t(c3, x), D2 && sn(c3, N3), E;\n      if (x === null) {\n        for (; !z2.done; N3++, z2 = f.next())\n          z2 = h(c3, z2.value, y), z2 !== null && (a = i(z2, a, N3), C3 === null ? E = z2 : C3.sibling = z2, C3 = z2);\n        return D2 && sn(c3, N3), E;\n      }\n      for (x = r(c3, x); !z2.done; N3++, z2 = f.next())\n        z2 = g(x, c3, N3, z2.value, y), z2 !== null && (e && z2.alternate !== null && x.delete(z2.key === null ? N3 : z2.key), a = i(z2, a, N3), C3 === null ? E = z2 : C3.sibling = z2, C3 = z2);\n      return e && x.forEach(function(ka) {\n        return n(c3, ka);\n      }), D2 && sn(c3, N3), E;\n    }\n    function j(c3, a, f, y) {\n      if (typeof f == \"object\" && f !== null && f.type === Nn && f.key === null && (f = f.props.children), typeof f == \"object\" && f !== null) {\n        switch (f.$$typeof) {\n          case Vt:\n            e: {\n              for (var E = f.key, C3 = a; C3 !== null; ) {\n                if (C3.key === E) {\n                  if (E = f.type, E === Nn) {\n                    if (C3.tag === 7) {\n                      t(c3, C3.sibling), a = l(C3, f.props.children), a.return = c3, c3 = a;\n                      break e;\n                    }\n                  } else if (C3.elementType === E || typeof E == \"object\" && E !== null && E.$$typeof === He2 && Ku(E) === C3.type) {\n                    t(c3, C3.sibling), a = l(C3, f.props), a.ref = nt(c3, C3, f), a.return = c3, c3 = a;\n                    break e;\n                  }\n                  t(c3, C3);\n                  break;\n                } else\n                  n(c3, C3);\n                C3 = C3.sibling;\n              }\n              f.type === Nn ? (a = mn(f.props.children, c3.mode, y, f.key), a.return = c3, c3 = a) : (y = pr(f.type, f.key, f.props, null, c3.mode, y), y.ref = nt(c3, a, f), y.return = c3, c3 = y);\n            }\n            return u(c3);\n          case xn:\n            e: {\n              for (C3 = f.key; a !== null; ) {\n                if (a.key === C3)\n                  if (a.tag === 4 && a.stateNode.containerInfo === f.containerInfo && a.stateNode.implementation === f.implementation) {\n                    t(c3, a.sibling), a = l(a, f.children || []), a.return = c3, c3 = a;\n                    break e;\n                  } else {\n                    t(c3, a);\n                    break;\n                  }\n                else\n                  n(c3, a);\n                a = a.sibling;\n              }\n              a = kl(f, c3.mode, y), a.return = c3, c3 = a;\n            }\n            return u(c3);\n          case He2:\n            return C3 = f._init, j(c3, a, C3(f._payload), y);\n        }\n        if (ut(f))\n          return S2(c3, a, f, y);\n        if (Jn(f))\n          return k2(c3, a, f, y);\n        er(c3, f);\n      }\n      return typeof f == \"string\" && f !== \"\" || typeof f == \"number\" ? (f = \"\" + f, a !== null && a.tag === 6 ? (t(c3, a.sibling), a = l(a, f), a.return = c3, c3 = a) : (t(c3, a), a = Sl(f, c3.mode, y), a.return = c3, c3 = a), u(c3)) : t(c3, a);\n    }\n    return j;\n  }\n  var $n = gs(true), ws = gs(false), Ut = {}, Le2 = un(Ut), Lt = un(Ut), Tt = un(Ut);\n  function dn(e) {\n    if (e === Ut)\n      throw Error(v(174));\n    return e;\n  }\n  function Ui(e, n) {\n    switch (L2(Tt, n), L2(Lt, e), L2(Le2, Ut), e = n.nodeType, e) {\n      case 9:\n      case 11:\n        n = (n = n.documentElement) ? n.namespaceURI : Rl(null, \"\");\n        break;\n      default:\n        e = e === 8 ? n.parentNode : n, n = e.namespaceURI || null, e = e.tagName, n = Rl(n, e);\n    }\n    R3(Le2), L2(Le2, n);\n  }\n  function Kn() {\n    R3(Le2), R3(Lt), R3(Tt);\n  }\n  function Ss(e) {\n    dn(Tt.current);\n    var n = dn(Le2.current), t = Rl(n, e.type);\n    n !== t && (L2(Lt, e), L2(Le2, t));\n  }\n  function Vi(e) {\n    Lt.current === e && (R3(Le2), R3(Lt));\n  }\n  var M3 = un(0);\n  function Tr(e) {\n    for (var n = e; n !== null; ) {\n      if (n.tag === 13) {\n        var t = n.memoizedState;\n        if (t !== null && (t = t.dehydrated, t === null || t.data === \"$?\" || t.data === \"$!\"))\n          return n;\n      } else if (n.tag === 19 && n.memoizedProps.revealOrder !== void 0) {\n        if ((n.flags & 128) !== 0)\n          return n;\n      } else if (n.child !== null) {\n        n.child.return = n, n = n.child;\n        continue;\n      }\n      if (n === e)\n        break;\n      for (; n.sibling === null; ) {\n        if (n.return === null || n.return === e)\n          return null;\n        n = n.return;\n      }\n      n.sibling.return = n.return, n = n.sibling;\n    }\n    return null;\n  }\n  var ml = [];\n  function Ai() {\n    for (var e = 0; e < ml.length; e++)\n      ml[e]._workInProgressVersionPrimary = null;\n    ml.length = 0;\n  }\n  var sr = Ve2.ReactCurrentDispatcher, hl = Ve2.ReactCurrentBatchConfig, yn = 0, O = null, A2 = null, W = null, Rr = false, mt = false, Rt = 0, Jc = 0;\n  function X2() {\n    throw Error(v(321));\n  }\n  function Bi(e, n) {\n    if (n === null)\n      return false;\n    for (var t = 0; t < n.length && t < e.length; t++)\n      if (!xe3(e[t], n[t]))\n        return false;\n    return true;\n  }\n  function Hi(e, n, t, r, l, i) {\n    if (yn = i, O = n, n.memoizedState = null, n.updateQueue = null, n.lanes = 0, sr.current = e === null || e.memoizedState === null ? nf : tf, e = t(r, l), mt) {\n      i = 0;\n      do {\n        if (mt = false, Rt = 0, 25 <= i)\n          throw Error(v(301));\n        i += 1, W = A2 = null, n.updateQueue = null, sr.current = rf, e = t(r, l);\n      } while (mt);\n    }\n    if (sr.current = Dr, n = A2 !== null && A2.next !== null, yn = 0, W = A2 = O = null, Rr = false, n)\n      throw Error(v(300));\n    return e;\n  }\n  function Wi() {\n    var e = Rt !== 0;\n    return Rt = 0, e;\n  }\n  function _e3() {\n    var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };\n    return W === null ? O.memoizedState = W = e : W = W.next = e, W;\n  }\n  function ye3() {\n    if (A2 === null) {\n      var e = O.alternate;\n      e = e !== null ? e.memoizedState : null;\n    } else\n      e = A2.next;\n    var n = W === null ? O.memoizedState : W.next;\n    if (n !== null)\n      W = n, A2 = e;\n    else {\n      if (e === null)\n        throw Error(v(310));\n      A2 = e, e = { memoizedState: A2.memoizedState, baseState: A2.baseState, baseQueue: A2.baseQueue, queue: A2.queue, next: null }, W === null ? O.memoizedState = W = e : W = W.next = e;\n    }\n    return W;\n  }\n  function Dt(e, n) {\n    return typeof n == \"function\" ? n(e) : n;\n  }\n  function vl(e) {\n    var n = ye3(), t = n.queue;\n    if (t === null)\n      throw Error(v(311));\n    t.lastRenderedReducer = e;\n    var r = A2, l = r.baseQueue, i = t.pending;\n    if (i !== null) {\n      if (l !== null) {\n        var u = l.next;\n        l.next = i.next, i.next = u;\n      }\n      r.baseQueue = l = i, t.pending = null;\n    }\n    if (l !== null) {\n      i = l.next, r = r.baseState;\n      var o = u = null, s = null, d = i;\n      do {\n        var m = d.lane;\n        if ((yn & m) === m)\n          s !== null && (s = s.next = { lane: 0, action: d.action, hasEagerState: d.hasEagerState, eagerState: d.eagerState, next: null }), r = d.hasEagerState ? d.eagerState : e(r, d.action);\n        else {\n          var h = { lane: m, action: d.action, hasEagerState: d.hasEagerState, eagerState: d.eagerState, next: null };\n          s === null ? (o = s = h, u = r) : s = s.next = h, O.lanes |= m, gn |= m;\n        }\n        d = d.next;\n      } while (d !== null && d !== i);\n      s === null ? u = r : s.next = o, xe3(r, n.memoizedState) || (te2 = true), n.memoizedState = r, n.baseState = u, n.baseQueue = s, t.lastRenderedState = r;\n    }\n    if (e = t.interleaved, e !== null) {\n      l = e;\n      do\n        i = l.lane, O.lanes |= i, gn |= i, l = l.next;\n      while (l !== e);\n    } else\n      l === null && (t.lanes = 0);\n    return [n.memoizedState, t.dispatch];\n  }\n  function yl(e) {\n    var n = ye3(), t = n.queue;\n    if (t === null)\n      throw Error(v(311));\n    t.lastRenderedReducer = e;\n    var r = t.dispatch, l = t.pending, i = n.memoizedState;\n    if (l !== null) {\n      t.pending = null;\n      var u = l = l.next;\n      do\n        i = e(i, u.action), u = u.next;\n      while (u !== l);\n      xe3(i, n.memoizedState) || (te2 = true), n.memoizedState = i, n.baseQueue === null && (n.baseState = i), t.lastRenderedState = i;\n    }\n    return [i, r];\n  }\n  function ks() {\n  }\n  function Es(e, n) {\n    var t = O, r = ye3(), l = n(), i = !xe3(r.memoizedState, l);\n    if (i && (r.memoizedState = l, te2 = true), r = r.queue, Qi(Ns.bind(null, t, r, e), [e]), r.getSnapshot !== n || i || W !== null && W.memoizedState.tag & 1) {\n      if (t.flags |= 2048, Mt(9, xs.bind(null, t, r, l, n), void 0, null), Q2 === null)\n        throw Error(v(349));\n      (yn & 30) !== 0 || Cs(t, n, l);\n    }\n    return l;\n  }\n  function Cs(e, n, t) {\n    e.flags |= 16384, e = { getSnapshot: n, value: t }, n = O.updateQueue, n === null ? (n = { lastEffect: null, stores: null }, O.updateQueue = n, n.stores = [e]) : (t = n.stores, t === null ? n.stores = [e] : t.push(e));\n  }\n  function xs(e, n, t, r) {\n    n.value = t, n.getSnapshot = r, _s(n) && zs(e);\n  }\n  function Ns(e, n, t) {\n    return t(function() {\n      _s(n) && zs(e);\n    });\n  }\n  function _s(e) {\n    var n = e.getSnapshot;\n    e = e.value;\n    try {\n      var t = n();\n      return !xe3(e, t);\n    } catch {\n      return true;\n    }\n  }\n  function zs(e) {\n    var n = je2(e, 1);\n    n !== null && Ce3(n, e, 1, -1);\n  }\n  function Yu(e) {\n    var n = _e3();\n    return typeof e == \"function\" && (e = e()), n.memoizedState = n.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Dt, lastRenderedState: e }, n.queue = e, e = e.dispatch = ef.bind(null, O, e), [n.memoizedState, e];\n  }\n  function Mt(e, n, t, r) {\n    return e = { tag: e, create: n, destroy: t, deps: r, next: null }, n = O.updateQueue, n === null ? (n = { lastEffect: null, stores: null }, O.updateQueue = n, n.lastEffect = e.next = e) : (t = n.lastEffect, t === null ? n.lastEffect = e.next = e : (r = t.next, t.next = e, e.next = r, n.lastEffect = e)), e;\n  }\n  function Ps() {\n    return ye3().memoizedState;\n  }\n  function ar(e, n, t, r) {\n    var l = _e3();\n    O.flags |= e, l.memoizedState = Mt(1 | n, t, void 0, r === void 0 ? null : r);\n  }\n  function $r(e, n, t, r) {\n    var l = ye3();\n    r = r === void 0 ? null : r;\n    var i = void 0;\n    if (A2 !== null) {\n      var u = A2.memoizedState;\n      if (i = u.destroy, r !== null && Bi(r, u.deps)) {\n        l.memoizedState = Mt(n, t, i, r);\n        return;\n      }\n    }\n    O.flags |= e, l.memoizedState = Mt(1 | n, t, i, r);\n  }\n  function Xu(e, n) {\n    return ar(8390656, 8, e, n);\n  }\n  function Qi(e, n) {\n    return $r(2048, 8, e, n);\n  }\n  function Ls(e, n) {\n    return $r(4, 2, e, n);\n  }\n  function Ts(e, n) {\n    return $r(4, 4, e, n);\n  }\n  function Rs(e, n) {\n    if (typeof n == \"function\")\n      return e = e(), n(e), function() {\n        n(null);\n      };\n    if (n != null)\n      return e = e(), n.current = e, function() {\n        n.current = null;\n      };\n  }\n  function Ds(e, n, t) {\n    return t = t != null ? t.concat([e]) : null, $r(4, 4, Rs.bind(null, n, e), t);\n  }\n  function $i() {\n  }\n  function Ms(e, n) {\n    var t = ye3();\n    n = n === void 0 ? null : n;\n    var r = t.memoizedState;\n    return r !== null && n !== null && Bi(n, r[1]) ? r[0] : (t.memoizedState = [e, n], e);\n  }\n  function Os(e, n) {\n    var t = ye3();\n    n = n === void 0 ? null : n;\n    var r = t.memoizedState;\n    return r !== null && n !== null && Bi(n, r[1]) ? r[0] : (e = e(), t.memoizedState = [e, n], e);\n  }\n  function Fs(e, n, t) {\n    return (yn & 21) === 0 ? (e.baseState && (e.baseState = false, te2 = true), e.memoizedState = t) : (xe3(t, n) || (t = Uo(), O.lanes |= t, gn |= t, e.baseState = true), n);\n  }\n  function qc(e, n) {\n    var t = P;\n    P = t !== 0 && 4 > t ? t : 4, e(true);\n    var r = hl.transition;\n    hl.transition = {};\n    try {\n      e(false), n();\n    } finally {\n      P = t, hl.transition = r;\n    }\n  }\n  function Is() {\n    return ye3().memoizedState;\n  }\n  function bc(e, n, t) {\n    var r = en2(e);\n    if (t = { lane: r, action: t, hasEagerState: false, eagerState: null, next: null }, js(e))\n      Us(n, t);\n    else if (t = ms(e, n, t, r), t !== null) {\n      var l = b();\n      Ce3(t, e, r, l), Vs(t, n, r);\n    }\n  }\n  function ef(e, n, t) {\n    var r = en2(e), l = { lane: r, action: t, hasEagerState: false, eagerState: null, next: null };\n    if (js(e))\n      Us(n, l);\n    else {\n      var i = e.alternate;\n      if (e.lanes === 0 && (i === null || i.lanes === 0) && (i = n.lastRenderedReducer, i !== null))\n        try {\n          var u = n.lastRenderedState, o = i(u, t);\n          if (l.hasEagerState = true, l.eagerState = o, xe3(o, u)) {\n            var s = n.interleaved;\n            s === null ? (l.next = l, Ii(n)) : (l.next = s.next, s.next = l), n.interleaved = l;\n            return;\n          }\n        } catch {\n        } finally {\n        }\n      t = ms(e, n, l, r), t !== null && (l = b(), Ce3(t, e, r, l), Vs(t, n, r));\n    }\n  }\n  function js(e) {\n    var n = e.alternate;\n    return e === O || n !== null && n === O;\n  }\n  function Us(e, n) {\n    mt = Rr = true;\n    var t = e.pending;\n    t === null ? n.next = n : (n.next = t.next, t.next = n), e.pending = n;\n  }\n  function Vs(e, n, t) {\n    if ((t & 4194240) !== 0) {\n      var r = n.lanes;\n      r &= e.pendingLanes, t |= r, n.lanes = t, Ei(e, t);\n    }\n  }\n  var Dr = { readContext: ve3, useCallback: X2, useContext: X2, useEffect: X2, useImperativeHandle: X2, useInsertionEffect: X2, useLayoutEffect: X2, useMemo: X2, useReducer: X2, useRef: X2, useState: X2, useDebugValue: X2, useDeferredValue: X2, useTransition: X2, useMutableSource: X2, useSyncExternalStore: X2, useId: X2, unstable_isNewReconciler: false }, nf = { readContext: ve3, useCallback: function(e, n) {\n    return _e3().memoizedState = [e, n === void 0 ? null : n], e;\n  }, useContext: ve3, useEffect: Xu, useImperativeHandle: function(e, n, t) {\n    return t = t != null ? t.concat([e]) : null, ar(4194308, 4, Rs.bind(null, n, e), t);\n  }, useLayoutEffect: function(e, n) {\n    return ar(4194308, 4, e, n);\n  }, useInsertionEffect: function(e, n) {\n    return ar(4, 2, e, n);\n  }, useMemo: function(e, n) {\n    var t = _e3();\n    return n = n === void 0 ? null : n, e = e(), t.memoizedState = [e, n], e;\n  }, useReducer: function(e, n, t) {\n    var r = _e3();\n    return n = t !== void 0 ? t(n) : n, r.memoizedState = r.baseState = n, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: n }, r.queue = e, e = e.dispatch = bc.bind(null, O, e), [r.memoizedState, e];\n  }, useRef: function(e) {\n    var n = _e3();\n    return e = { current: e }, n.memoizedState = e;\n  }, useState: Yu, useDebugValue: $i, useDeferredValue: function(e) {\n    return _e3().memoizedState = e;\n  }, useTransition: function() {\n    var e = Yu(false), n = e[0];\n    return e = qc.bind(null, e[1]), _e3().memoizedState = e, [n, e];\n  }, useMutableSource: function() {\n  }, useSyncExternalStore: function(e, n, t) {\n    var r = O, l = _e3();\n    if (D2) {\n      if (t === void 0)\n        throw Error(v(407));\n      t = t();\n    } else {\n      if (t = n(), Q2 === null)\n        throw Error(v(349));\n      (yn & 30) !== 0 || Cs(r, n, t);\n    }\n    l.memoizedState = t;\n    var i = { value: t, getSnapshot: n };\n    return l.queue = i, Xu(Ns.bind(null, r, i, e), [e]), r.flags |= 2048, Mt(9, xs.bind(null, r, i, t, n), void 0, null), t;\n  }, useId: function() {\n    var e = _e3(), n = Q2.identifierPrefix;\n    if (D2) {\n      var t = Me2, r = De2;\n      t = (r & ~(1 << 32 - Ee3(r) - 1)).toString(32) + t, n = \":\" + n + \"R\" + t, t = Rt++, 0 < t && (n += \"H\" + t.toString(32)), n += \":\";\n    } else\n      t = Jc++, n = \":\" + n + \"r\" + t.toString(32) + \":\";\n    return e.memoizedState = n;\n  }, unstable_isNewReconciler: false }, tf = { readContext: ve3, useCallback: Ms, useContext: ve3, useEffect: Qi, useImperativeHandle: Ds, useInsertionEffect: Ls, useLayoutEffect: Ts, useMemo: Os, useReducer: vl, useRef: Ps, useState: function() {\n    return vl(Dt);\n  }, useDebugValue: $i, useDeferredValue: function(e) {\n    var n = ye3();\n    return Fs(n, A2.memoizedState, e);\n  }, useTransition: function() {\n    var e = vl(Dt)[0], n = ye3().memoizedState;\n    return [e, n];\n  }, useMutableSource: ks, useSyncExternalStore: Es, useId: Is, unstable_isNewReconciler: false }, rf = { readContext: ve3, useCallback: Ms, useContext: ve3, useEffect: Qi, useImperativeHandle: Ds, useInsertionEffect: Ls, useLayoutEffect: Ts, useMemo: Os, useReducer: yl, useRef: Ps, useState: function() {\n    return yl(Dt);\n  }, useDebugValue: $i, useDeferredValue: function(e) {\n    var n = ye3();\n    return A2 === null ? n.memoizedState = e : Fs(n, A2.memoizedState, e);\n  }, useTransition: function() {\n    var e = yl(Dt)[0], n = ye3().memoizedState;\n    return [e, n];\n  }, useMutableSource: ks, useSyncExternalStore: Es, useId: Is, unstable_isNewReconciler: false };\n  function Yn(e, n) {\n    try {\n      var t = \"\", r = n;\n      do\n        t += Ma(r), r = r.return;\n      while (r);\n      var l = t;\n    } catch (i) {\n      l = `\nError generating stack: ` + i.message + `\n` + i.stack;\n    }\n    return { value: e, source: n, stack: l, digest: null };\n  }\n  function gl(e, n, t) {\n    return { value: e, source: null, stack: t ?? null, digest: n ?? null };\n  }\n  function ei(e, n) {\n    try {\n      console.error(n.value);\n    } catch (t) {\n      setTimeout(function() {\n        throw t;\n      });\n    }\n  }\n  var lf = typeof WeakMap == \"function\" ? WeakMap : Map;\n  function As(e, n, t) {\n    t = Oe2(-1, t), t.tag = 3, t.payload = { element: null };\n    var r = n.value;\n    return t.callback = function() {\n      Or || (Or = true, ci = r), ei(e, n);\n    }, t;\n  }\n  function Bs(e, n, t) {\n    t = Oe2(-1, t), t.tag = 3;\n    var r = e.type.getDerivedStateFromError;\n    if (typeof r == \"function\") {\n      var l = n.value;\n      t.payload = function() {\n        return r(l);\n      }, t.callback = function() {\n        ei(e, n);\n      };\n    }\n    var i = e.stateNode;\n    return i !== null && typeof i.componentDidCatch == \"function\" && (t.callback = function() {\n      ei(e, n), typeof r != \"function\" && (be3 === null ? be3 = /* @__PURE__ */ new Set([this]) : be3.add(this));\n      var u = n.stack;\n      this.componentDidCatch(n.value, { componentStack: u !== null ? u : \"\" });\n    }), t;\n  }\n  function Gu(e, n, t) {\n    var r = e.pingCache;\n    if (r === null) {\n      r = e.pingCache = new lf();\n      var l = /* @__PURE__ */ new Set();\n      r.set(n, l);\n    } else\n      l = r.get(n), l === void 0 && (l = /* @__PURE__ */ new Set(), r.set(n, l));\n    l.has(t) || (l.add(t), e = wf.bind(null, e, n, t), n.then(e, e));\n  }\n  function Zu(e) {\n    do {\n      var n;\n      if ((n = e.tag === 13) && (n = e.memoizedState, n = n !== null ? n.dehydrated !== null : true), n)\n        return e;\n      e = e.return;\n    } while (e !== null);\n    return null;\n  }\n  function Ju(e, n, t, r, l) {\n    return (e.mode & 1) === 0 ? (e === n ? e.flags |= 65536 : (e.flags |= 128, t.flags |= 131072, t.flags &= -52805, t.tag === 1 && (t.alternate === null ? t.tag = 17 : (n = Oe2(-1, 1), n.tag = 2, qe2(t, n, 1))), t.lanes |= 1), e) : (e.flags |= 65536, e.lanes = l, e);\n  }\n  var uf = Ve2.ReactCurrentOwner, te2 = false;\n  function q2(e, n, t, r) {\n    n.child = e === null ? ws(n, null, t, r) : $n(n, e.child, t, r);\n  }\n  function qu(e, n, t, r, l) {\n    t = t.render;\n    var i = n.ref;\n    return An(n, l), r = Hi(e, n, t, r, i, l), t = Wi(), e !== null && !te2 ? (n.updateQueue = e.updateQueue, n.flags &= -2053, e.lanes &= ~l, Ue2(e, n, l)) : (D2 && t && Ti(n), n.flags |= 1, q2(e, n, r, l), n.child);\n  }\n  function bu(e, n, t, r, l) {\n    if (e === null) {\n      var i = t.type;\n      return typeof i == \"function\" && !bi(i) && i.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (n.tag = 15, n.type = i, Hs(e, n, i, r, l)) : (e = pr(t.type, null, r, n, n.mode, l), e.ref = n.ref, e.return = n, n.child = e);\n    }\n    if (i = e.child, (e.lanes & l) === 0) {\n      var u = i.memoizedProps;\n      if (t = t.compare, t = t !== null ? t : Nt, t(u, r) && e.ref === n.ref)\n        return Ue2(e, n, l);\n    }\n    return n.flags |= 1, e = nn(i, r), e.ref = n.ref, e.return = n, n.child = e;\n  }\n  function Hs(e, n, t, r, l) {\n    if (e !== null) {\n      var i = e.memoizedProps;\n      if (Nt(i, r) && e.ref === n.ref)\n        if (te2 = false, n.pendingProps = r = i, (e.lanes & l) !== 0)\n          (e.flags & 131072) !== 0 && (te2 = true);\n        else\n          return n.lanes = e.lanes, Ue2(e, n, l);\n    }\n    return ni(e, n, t, r, l);\n  }\n  function Ws(e, n, t) {\n    var r = n.pendingProps, l = r.children, i = e !== null ? e.memoizedState : null;\n    if (r.mode === \"hidden\")\n      if ((n.mode & 1) === 0)\n        n.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, L2(Fn, ue), ue |= t;\n      else {\n        if ((t & 1073741824) === 0)\n          return e = i !== null ? i.baseLanes | t : t, n.lanes = n.childLanes = 1073741824, n.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, n.updateQueue = null, L2(Fn, ue), ue |= e, null;\n        n.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = i !== null ? i.baseLanes : t, L2(Fn, ue), ue |= r;\n      }\n    else\n      i !== null ? (r = i.baseLanes | t, n.memoizedState = null) : r = t, L2(Fn, ue), ue |= r;\n    return q2(e, n, l, t), n.child;\n  }\n  function Qs(e, n) {\n    var t = n.ref;\n    (e === null && t !== null || e !== null && e.ref !== t) && (n.flags |= 512, n.flags |= 2097152);\n  }\n  function ni(e, n, t, r, l) {\n    var i = le2(t) ? hn : J2.current;\n    return i = Wn(n, i), An(n, l), t = Hi(e, n, t, r, i, l), r = Wi(), e !== null && !te2 ? (n.updateQueue = e.updateQueue, n.flags &= -2053, e.lanes &= ~l, Ue2(e, n, l)) : (D2 && r && Ti(n), n.flags |= 1, q2(e, n, t, l), n.child);\n  }\n  function eo(e, n, t, r, l) {\n    if (le2(t)) {\n      var i = true;\n      xr(n);\n    } else\n      i = false;\n    if (An(n, l), n.stateNode === null)\n      cr(e, n), ys(n, t, r), bl(n, t, r, l), r = true;\n    else if (e === null) {\n      var u = n.stateNode, o = n.memoizedProps;\n      u.props = o;\n      var s = u.context, d = t.contextType;\n      typeof d == \"object\" && d !== null ? d = ve3(d) : (d = le2(t) ? hn : J2.current, d = Wn(n, d));\n      var m = t.getDerivedStateFromProps, h = typeof m == \"function\" || typeof u.getSnapshotBeforeUpdate == \"function\";\n      h || typeof u.UNSAFE_componentWillReceiveProps != \"function\" && typeof u.componentWillReceiveProps != \"function\" || (o !== r || s !== d) && $u(n, u, r, d), We2 = false;\n      var p = n.memoizedState;\n      u.state = p, Lr(n, r, u, l), s = n.memoizedState, o !== r || p !== s || re.current || We2 ? (typeof m == \"function\" && (ql(n, t, m, r), s = n.memoizedState), (o = We2 || Qu(n, t, o, r, p, s, d)) ? (h || typeof u.UNSAFE_componentWillMount != \"function\" && typeof u.componentWillMount != \"function\" || (typeof u.componentWillMount == \"function\" && u.componentWillMount(), typeof u.UNSAFE_componentWillMount == \"function\" && u.UNSAFE_componentWillMount()), typeof u.componentDidMount == \"function\" && (n.flags |= 4194308)) : (typeof u.componentDidMount == \"function\" && (n.flags |= 4194308), n.memoizedProps = r, n.memoizedState = s), u.props = r, u.state = s, u.context = d, r = o) : (typeof u.componentDidMount == \"function\" && (n.flags |= 4194308), r = false);\n    } else {\n      u = n.stateNode, hs(e, n), o = n.memoizedProps, d = n.type === n.elementType ? o : we3(n.type, o), u.props = d, h = n.pendingProps, p = u.context, s = t.contextType, typeof s == \"object\" && s !== null ? s = ve3(s) : (s = le2(t) ? hn : J2.current, s = Wn(n, s));\n      var g = t.getDerivedStateFromProps;\n      (m = typeof g == \"function\" || typeof u.getSnapshotBeforeUpdate == \"function\") || typeof u.UNSAFE_componentWillReceiveProps != \"function\" && typeof u.componentWillReceiveProps != \"function\" || (o !== h || p !== s) && $u(n, u, r, s), We2 = false, p = n.memoizedState, u.state = p, Lr(n, r, u, l);\n      var S2 = n.memoizedState;\n      o !== h || p !== S2 || re.current || We2 ? (typeof g == \"function\" && (ql(n, t, g, r), S2 = n.memoizedState), (d = We2 || Qu(n, t, d, r, p, S2, s) || false) ? (m || typeof u.UNSAFE_componentWillUpdate != \"function\" && typeof u.componentWillUpdate != \"function\" || (typeof u.componentWillUpdate == \"function\" && u.componentWillUpdate(r, S2, s), typeof u.UNSAFE_componentWillUpdate == \"function\" && u.UNSAFE_componentWillUpdate(r, S2, s)), typeof u.componentDidUpdate == \"function\" && (n.flags |= 4), typeof u.getSnapshotBeforeUpdate == \"function\" && (n.flags |= 1024)) : (typeof u.componentDidUpdate != \"function\" || o === e.memoizedProps && p === e.memoizedState || (n.flags |= 4), typeof u.getSnapshotBeforeUpdate != \"function\" || o === e.memoizedProps && p === e.memoizedState || (n.flags |= 1024), n.memoizedProps = r, n.memoizedState = S2), u.props = r, u.state = S2, u.context = s, r = d) : (typeof u.componentDidUpdate != \"function\" || o === e.memoizedProps && p === e.memoizedState || (n.flags |= 4), typeof u.getSnapshotBeforeUpdate != \"function\" || o === e.memoizedProps && p === e.memoizedState || (n.flags |= 1024), r = false);\n    }\n    return ti(e, n, t, r, i, l);\n  }\n  function ti(e, n, t, r, l, i) {\n    Qs(e, n);\n    var u = (n.flags & 128) !== 0;\n    if (!r && !u)\n      return l && Vu(n, t, false), Ue2(e, n, i);\n    r = n.stateNode, uf.current = n;\n    var o = u && typeof t.getDerivedStateFromError != \"function\" ? null : r.render();\n    return n.flags |= 1, e !== null && u ? (n.child = $n(n, e.child, null, i), n.child = $n(n, null, o, i)) : q2(e, n, o, i), n.memoizedState = r.state, l && Vu(n, t, true), n.child;\n  }\n  function $s(e) {\n    var n = e.stateNode;\n    n.pendingContext ? Uu(e, n.pendingContext, n.pendingContext !== n.context) : n.context && Uu(e, n.context, false), Ui(e, n.containerInfo);\n  }\n  function no(e, n, t, r, l) {\n    return Qn(), Di(l), n.flags |= 256, q2(e, n, t, r), n.child;\n  }\n  var ri = { dehydrated: null, treeContext: null, retryLane: 0 };\n  function li(e) {\n    return { baseLanes: e, cachePool: null, transitions: null };\n  }\n  function Ks(e, n, t) {\n    var r = n.pendingProps, l = M3.current, i = false, u = (n.flags & 128) !== 0, o;\n    if ((o = u) || (o = e !== null && e.memoizedState === null ? false : (l & 2) !== 0), o ? (i = true, n.flags &= -129) : (e === null || e.memoizedState !== null) && (l |= 1), L2(M3, l & 1), e === null)\n      return Zl(n), e = n.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? ((n.mode & 1) === 0 ? n.lanes = 1 : e.data === \"$!\" ? n.lanes = 8 : n.lanes = 1073741824, null) : (u = r.children, e = r.fallback, i ? (r = n.mode, i = n.child, u = { mode: \"hidden\", children: u }, (r & 1) === 0 && i !== null ? (i.childLanes = 0, i.pendingProps = u) : i = Xr(u, r, 0, null), e = mn(e, r, t, null), i.return = n, e.return = n, i.sibling = e, n.child = i, n.child.memoizedState = li(t), n.memoizedState = ri, e) : Ki(n, u));\n    if (l = e.memoizedState, l !== null && (o = l.dehydrated, o !== null))\n      return of(e, n, u, r, o, l, t);\n    if (i) {\n      i = r.fallback, u = n.mode, l = e.child, o = l.sibling;\n      var s = { mode: \"hidden\", children: r.children };\n      return (u & 1) === 0 && n.child !== l ? (r = n.child, r.childLanes = 0, r.pendingProps = s, n.deletions = null) : (r = nn(l, s), r.subtreeFlags = l.subtreeFlags & 14680064), o !== null ? i = nn(o, i) : (i = mn(i, u, t, null), i.flags |= 2), i.return = n, r.return = n, r.sibling = i, n.child = r, r = i, i = n.child, u = e.child.memoizedState, u = u === null ? li(t) : { baseLanes: u.baseLanes | t, cachePool: null, transitions: u.transitions }, i.memoizedState = u, i.childLanes = e.childLanes & ~t, n.memoizedState = ri, r;\n    }\n    return i = e.child, e = i.sibling, r = nn(i, { mode: \"visible\", children: r.children }), (n.mode & 1) === 0 && (r.lanes = t), r.return = n, r.sibling = null, e !== null && (t = n.deletions, t === null ? (n.deletions = [e], n.flags |= 16) : t.push(e)), n.child = r, n.memoizedState = null, r;\n  }\n  function Ki(e, n) {\n    return n = Xr({ mode: \"visible\", children: n }, e.mode, 0, null), n.return = e, e.child = n;\n  }\n  function nr(e, n, t, r) {\n    return r !== null && Di(r), $n(n, e.child, null, t), e = Ki(n, n.pendingProps.children), e.flags |= 2, n.memoizedState = null, e;\n  }\n  function of(e, n, t, r, l, i, u) {\n    if (t)\n      return n.flags & 256 ? (n.flags &= -257, r = gl(Error(v(422))), nr(e, n, u, r)) : n.memoizedState !== null ? (n.child = e.child, n.flags |= 128, null) : (i = r.fallback, l = n.mode, r = Xr({ mode: \"visible\", children: r.children }, l, 0, null), i = mn(i, l, u, null), i.flags |= 2, r.return = n, i.return = n, r.sibling = i, n.child = r, (n.mode & 1) !== 0 && $n(n, e.child, null, u), n.child.memoizedState = li(u), n.memoizedState = ri, i);\n    if ((n.mode & 1) === 0)\n      return nr(e, n, u, null);\n    if (l.data === \"$!\") {\n      if (r = l.nextSibling && l.nextSibling.dataset, r)\n        var o = r.dgst;\n      return r = o, i = Error(v(419)), r = gl(i, r, void 0), nr(e, n, u, r);\n    }\n    if (o = (u & e.childLanes) !== 0, te2 || o) {\n      if (r = Q2, r !== null) {\n        switch (u & -u) {\n          case 4:\n            l = 2;\n            break;\n          case 16:\n            l = 8;\n            break;\n          case 64:\n          case 128:\n          case 256:\n          case 512:\n          case 1024:\n          case 2048:\n          case 4096:\n          case 8192:\n          case 16384:\n          case 32768:\n          case 65536:\n          case 131072:\n          case 262144:\n          case 524288:\n          case 1048576:\n          case 2097152:\n          case 4194304:\n          case 8388608:\n          case 16777216:\n          case 33554432:\n          case 67108864:\n            l = 32;\n            break;\n          case 536870912:\n            l = 268435456;\n            break;\n          default:\n            l = 0;\n        }\n        l = (l & (r.suspendedLanes | u)) !== 0 ? 0 : l, l !== 0 && l !== i.retryLane && (i.retryLane = l, je2(e, l), Ce3(r, e, l, -1));\n      }\n      return qi(), r = gl(Error(v(421))), nr(e, n, u, r);\n    }\n    return l.data === \"$?\" ? (n.flags |= 128, n.child = e.child, n = Sf.bind(null, e), l._reactRetry = n, null) : (e = i.treeContext, oe2 = Je(l.nextSibling), se2 = n, D2 = true, ke3 = null, e !== null && (de4[pe3++] = De2, de4[pe3++] = Me2, de4[pe3++] = vn, De2 = e.id, Me2 = e.overflow, vn = n), n = Ki(n, r.children), n.flags |= 4096, n);\n  }\n  function to(e, n, t) {\n    e.lanes |= n;\n    var r = e.alternate;\n    r !== null && (r.lanes |= n), Jl(e.return, n, t);\n  }\n  function wl(e, n, t, r, l) {\n    var i = e.memoizedState;\n    i === null ? e.memoizedState = { isBackwards: n, rendering: null, renderingStartTime: 0, last: r, tail: t, tailMode: l } : (i.isBackwards = n, i.rendering = null, i.renderingStartTime = 0, i.last = r, i.tail = t, i.tailMode = l);\n  }\n  function Ys(e, n, t) {\n    var r = n.pendingProps, l = r.revealOrder, i = r.tail;\n    if (q2(e, n, r.children, t), r = M3.current, (r & 2) !== 0)\n      r = r & 1 | 2, n.flags |= 128;\n    else {\n      if (e !== null && (e.flags & 128) !== 0)\n        e:\n          for (e = n.child; e !== null; ) {\n            if (e.tag === 13)\n              e.memoizedState !== null && to(e, t, n);\n            else if (e.tag === 19)\n              to(e, t, n);\n            else if (e.child !== null) {\n              e.child.return = e, e = e.child;\n              continue;\n            }\n            if (e === n)\n              break e;\n            for (; e.sibling === null; ) {\n              if (e.return === null || e.return === n)\n                break e;\n              e = e.return;\n            }\n            e.sibling.return = e.return, e = e.sibling;\n          }\n      r &= 1;\n    }\n    if (L2(M3, r), (n.mode & 1) === 0)\n      n.memoizedState = null;\n    else\n      switch (l) {\n        case \"forwards\":\n          for (t = n.child, l = null; t !== null; )\n            e = t.alternate, e !== null && Tr(e) === null && (l = t), t = t.sibling;\n          t = l, t === null ? (l = n.child, n.child = null) : (l = t.sibling, t.sibling = null), wl(n, false, l, t, i);\n          break;\n        case \"backwards\":\n          for (t = null, l = n.child, n.child = null; l !== null; ) {\n            if (e = l.alternate, e !== null && Tr(e) === null) {\n              n.child = l;\n              break;\n            }\n            e = l.sibling, l.sibling = t, t = l, l = e;\n          }\n          wl(n, true, t, null, i);\n          break;\n        case \"together\":\n          wl(n, false, null, null, void 0);\n          break;\n        default:\n          n.memoizedState = null;\n      }\n    return n.child;\n  }\n  function cr(e, n) {\n    (n.mode & 1) === 0 && e !== null && (e.alternate = null, n.alternate = null, n.flags |= 2);\n  }\n  function Ue2(e, n, t) {\n    if (e !== null && (n.dependencies = e.dependencies), gn |= n.lanes, (t & n.childLanes) === 0)\n      return null;\n    if (e !== null && n.child !== e.child)\n      throw Error(v(153));\n    if (n.child !== null) {\n      for (e = n.child, t = nn(e, e.pendingProps), n.child = t, t.return = n; e.sibling !== null; )\n        e = e.sibling, t = t.sibling = nn(e, e.pendingProps), t.return = n;\n      t.sibling = null;\n    }\n    return n.child;\n  }\n  function sf(e, n, t) {\n    switch (n.tag) {\n      case 3:\n        $s(n), Qn();\n        break;\n      case 5:\n        Ss(n);\n        break;\n      case 1:\n        le2(n.type) && xr(n);\n        break;\n      case 4:\n        Ui(n, n.stateNode.containerInfo);\n        break;\n      case 10:\n        var r = n.type._context, l = n.memoizedProps.value;\n        L2(zr, r._currentValue), r._currentValue = l;\n        break;\n      case 13:\n        if (r = n.memoizedState, r !== null)\n          return r.dehydrated !== null ? (L2(M3, M3.current & 1), n.flags |= 128, null) : (t & n.child.childLanes) !== 0 ? Ks(e, n, t) : (L2(M3, M3.current & 1), e = Ue2(e, n, t), e !== null ? e.sibling : null);\n        L2(M3, M3.current & 1);\n        break;\n      case 19:\n        if (r = (t & n.childLanes) !== 0, (e.flags & 128) !== 0) {\n          if (r)\n            return Ys(e, n, t);\n          n.flags |= 128;\n        }\n        if (l = n.memoizedState, l !== null && (l.rendering = null, l.tail = null, l.lastEffect = null), L2(M3, M3.current), r)\n          break;\n        return null;\n      case 22:\n      case 23:\n        return n.lanes = 0, Ws(e, n, t);\n    }\n    return Ue2(e, n, t);\n  }\n  var Xs, ii, Gs, Zs;\n  Xs = function(e, n) {\n    for (var t = n.child; t !== null; ) {\n      if (t.tag === 5 || t.tag === 6)\n        e.appendChild(t.stateNode);\n      else if (t.tag !== 4 && t.child !== null) {\n        t.child.return = t, t = t.child;\n        continue;\n      }\n      if (t === n)\n        break;\n      for (; t.sibling === null; ) {\n        if (t.return === null || t.return === n)\n          return;\n        t = t.return;\n      }\n      t.sibling.return = t.return, t = t.sibling;\n    }\n  };\n  ii = function() {\n  };\n  Gs = function(e, n, t, r) {\n    var l = e.memoizedProps;\n    if (l !== r) {\n      e = n.stateNode, dn(Le2.current);\n      var i = null;\n      switch (t) {\n        case \"input\":\n          l = zl(e, l), r = zl(e, r), i = [];\n          break;\n        case \"select\":\n          l = F2({}, l, { value: void 0 }), r = F2({}, r, { value: void 0 }), i = [];\n          break;\n        case \"textarea\":\n          l = Tl(e, l), r = Tl(e, r), i = [];\n          break;\n        default:\n          typeof l.onClick != \"function\" && typeof r.onClick == \"function\" && (e.onclick = Er);\n      }\n      Dl(t, r);\n      var u;\n      t = null;\n      for (d in l)\n        if (!r.hasOwnProperty(d) && l.hasOwnProperty(d) && l[d] != null)\n          if (d === \"style\") {\n            var o = l[d];\n            for (u in o)\n              o.hasOwnProperty(u) && (t || (t = {}), t[u] = \"\");\n          } else\n            d !== \"dangerouslySetInnerHTML\" && d !== \"children\" && d !== \"suppressContentEditableWarning\" && d !== \"suppressHydrationWarning\" && d !== \"autoFocus\" && (gt.hasOwnProperty(d) ? i || (i = []) : (i = i || []).push(d, null));\n      for (d in r) {\n        var s = r[d];\n        if (o = l?.[d], r.hasOwnProperty(d) && s !== o && (s != null || o != null))\n          if (d === \"style\")\n            if (o) {\n              for (u in o)\n                !o.hasOwnProperty(u) || s && s.hasOwnProperty(u) || (t || (t = {}), t[u] = \"\");\n              for (u in s)\n                s.hasOwnProperty(u) && o[u] !== s[u] && (t || (t = {}), t[u] = s[u]);\n            } else\n              t || (i || (i = []), i.push(d, t)), t = s;\n          else\n            d === \"dangerouslySetInnerHTML\" ? (s = s ? s.__html : void 0, o = o ? o.__html : void 0, s != null && o !== s && (i = i || []).push(d, s)) : d === \"children\" ? typeof s != \"string\" && typeof s != \"number\" || (i = i || []).push(d, \"\" + s) : d !== \"suppressContentEditableWarning\" && d !== \"suppressHydrationWarning\" && (gt.hasOwnProperty(d) ? (s != null && d === \"onScroll\" && T(\"scroll\", e), i || o === s || (i = [])) : (i = i || []).push(d, s));\n      }\n      t && (i = i || []).push(\"style\", t);\n      var d = i;\n      (n.updateQueue = d) && (n.flags |= 4);\n    }\n  };\n  Zs = function(e, n, t, r) {\n    t !== r && (n.flags |= 4);\n  };\n  function tt(e, n) {\n    if (!D2)\n      switch (e.tailMode) {\n        case \"hidden\":\n          n = e.tail;\n          for (var t = null; n !== null; )\n            n.alternate !== null && (t = n), n = n.sibling;\n          t === null ? e.tail = null : t.sibling = null;\n          break;\n        case \"collapsed\":\n          t = e.tail;\n          for (var r = null; t !== null; )\n            t.alternate !== null && (r = t), t = t.sibling;\n          r === null ? n || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null;\n      }\n  }\n  function G(e) {\n    var n = e.alternate !== null && e.alternate.child === e.child, t = 0, r = 0;\n    if (n)\n      for (var l = e.child; l !== null; )\n        t |= l.lanes | l.childLanes, r |= l.subtreeFlags & 14680064, r |= l.flags & 14680064, l.return = e, l = l.sibling;\n    else\n      for (l = e.child; l !== null; )\n        t |= l.lanes | l.childLanes, r |= l.subtreeFlags, r |= l.flags, l.return = e, l = l.sibling;\n    return e.subtreeFlags |= r, e.childLanes = t, n;\n  }\n  function af(e, n, t) {\n    var r = n.pendingProps;\n    switch (Ri(n), n.tag) {\n      case 2:\n      case 16:\n      case 15:\n      case 0:\n      case 11:\n      case 7:\n      case 8:\n      case 12:\n      case 9:\n      case 14:\n        return G(n), null;\n      case 1:\n        return le2(n.type) && Cr(), G(n), null;\n      case 3:\n        return r = n.stateNode, Kn(), R3(re), R3(J2), Ai(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (bt(n) ? n.flags |= 4 : e === null || e.memoizedState.isDehydrated && (n.flags & 256) === 0 || (n.flags |= 1024, ke3 !== null && (pi(ke3), ke3 = null))), ii(e, n), G(n), null;\n      case 5:\n        Vi(n);\n        var l = dn(Tt.current);\n        if (t = n.type, e !== null && n.stateNode != null)\n          Gs(e, n, t, r, l), e.ref !== n.ref && (n.flags |= 512, n.flags |= 2097152);\n        else {\n          if (!r) {\n            if (n.stateNode === null)\n              throw Error(v(166));\n            return G(n), null;\n          }\n          if (e = dn(Le2.current), bt(n)) {\n            r = n.stateNode, t = n.type;\n            var i = n.memoizedProps;\n            switch (r[ze2] = n, r[Pt] = i, e = (n.mode & 1) !== 0, t) {\n              case \"dialog\":\n                T(\"cancel\", r), T(\"close\", r);\n                break;\n              case \"iframe\":\n              case \"object\":\n              case \"embed\":\n                T(\"load\", r);\n                break;\n              case \"video\":\n              case \"audio\":\n                for (l = 0; l < st.length; l++)\n                  T(st[l], r);\n                break;\n              case \"source\":\n                T(\"error\", r);\n                break;\n              case \"img\":\n              case \"image\":\n              case \"link\":\n                T(\"error\", r), T(\"load\", r);\n                break;\n              case \"details\":\n                T(\"toggle\", r);\n                break;\n              case \"input\":\n                cu(r, i), T(\"invalid\", r);\n                break;\n              case \"select\":\n                r._wrapperState = { wasMultiple: !!i.multiple }, T(\"invalid\", r);\n                break;\n              case \"textarea\":\n                du(r, i), T(\"invalid\", r);\n            }\n            Dl(t, i), l = null;\n            for (var u in i)\n              if (i.hasOwnProperty(u)) {\n                var o = i[u];\n                u === \"children\" ? typeof o == \"string\" ? r.textContent !== o && (i.suppressHydrationWarning !== true && qt(r.textContent, o, e), l = [\"children\", o]) : typeof o == \"number\" && r.textContent !== \"\" + o && (i.suppressHydrationWarning !== true && qt(r.textContent, o, e), l = [\"children\", \"\" + o]) : gt.hasOwnProperty(u) && o != null && u === \"onScroll\" && T(\"scroll\", r);\n              }\n            switch (t) {\n              case \"input\":\n                At(r), fu(r, i, true);\n                break;\n              case \"textarea\":\n                At(r), pu(r);\n                break;\n              case \"select\":\n              case \"option\":\n                break;\n              default:\n                typeof i.onClick == \"function\" && (r.onclick = Er);\n            }\n            r = l, n.updateQueue = r, r !== null && (n.flags |= 4);\n          } else {\n            u = l.nodeType === 9 ? l : l.ownerDocument, e === \"http://www.w3.org/1999/xhtml\" && (e = Co(t)), e === \"http://www.w3.org/1999/xhtml\" ? t === \"script\" ? (e = u.createElement(\"div\"), e.innerHTML = \"<script><\\/script>\", e = e.removeChild(e.firstChild)) : typeof r.is == \"string\" ? e = u.createElement(t, { is: r.is }) : (e = u.createElement(t), t === \"select\" && (u = e, r.multiple ? u.multiple = true : r.size && (u.size = r.size))) : e = u.createElementNS(e, t), e[ze2] = n, e[Pt] = r, Xs(e, n, false, false), n.stateNode = e;\n            e: {\n              switch (u = Ml(t, r), t) {\n                case \"dialog\":\n                  T(\"cancel\", e), T(\"close\", e), l = r;\n                  break;\n                case \"iframe\":\n                case \"object\":\n                case \"embed\":\n                  T(\"load\", e), l = r;\n                  break;\n                case \"video\":\n                case \"audio\":\n                  for (l = 0; l < st.length; l++)\n                    T(st[l], e);\n                  l = r;\n                  break;\n                case \"source\":\n                  T(\"error\", e), l = r;\n                  break;\n                case \"img\":\n                case \"image\":\n                case \"link\":\n                  T(\"error\", e), T(\"load\", e), l = r;\n                  break;\n                case \"details\":\n                  T(\"toggle\", e), l = r;\n                  break;\n                case \"input\":\n                  cu(e, r), l = zl(e, r), T(\"invalid\", e);\n                  break;\n                case \"option\":\n                  l = r;\n                  break;\n                case \"select\":\n                  e._wrapperState = { wasMultiple: !!r.multiple }, l = F2({}, r, { value: void 0 }), T(\"invalid\", e);\n                  break;\n                case \"textarea\":\n                  du(e, r), l = Tl(e, r), T(\"invalid\", e);\n                  break;\n                default:\n                  l = r;\n              }\n              Dl(t, l), o = l;\n              for (i in o)\n                if (o.hasOwnProperty(i)) {\n                  var s = o[i];\n                  i === \"style\" ? _o(e, s) : i === \"dangerouslySetInnerHTML\" ? (s = s ? s.__html : void 0, s != null && xo(e, s)) : i === \"children\" ? typeof s == \"string\" ? (t !== \"textarea\" || s !== \"\") && wt(e, s) : typeof s == \"number\" && wt(e, \"\" + s) : i !== \"suppressContentEditableWarning\" && i !== \"suppressHydrationWarning\" && i !== \"autoFocus\" && (gt.hasOwnProperty(i) ? s != null && i === \"onScroll\" && T(\"scroll\", e) : s != null && vi(e, i, s, u));\n                }\n              switch (t) {\n                case \"input\":\n                  At(e), fu(e, r, false);\n                  break;\n                case \"textarea\":\n                  At(e), pu(e);\n                  break;\n                case \"option\":\n                  r.value != null && e.setAttribute(\"value\", \"\" + tn(r.value));\n                  break;\n                case \"select\":\n                  e.multiple = !!r.multiple, i = r.value, i != null ? In(e, !!r.multiple, i, false) : r.defaultValue != null && In(e, !!r.multiple, r.defaultValue, true);\n                  break;\n                default:\n                  typeof l.onClick == \"function\" && (e.onclick = Er);\n              }\n              switch (t) {\n                case \"button\":\n                case \"input\":\n                case \"select\":\n                case \"textarea\":\n                  r = !!r.autoFocus;\n                  break e;\n                case \"img\":\n                  r = true;\n                  break e;\n                default:\n                  r = false;\n              }\n            }\n            r && (n.flags |= 4);\n          }\n          n.ref !== null && (n.flags |= 512, n.flags |= 2097152);\n        }\n        return G(n), null;\n      case 6:\n        if (e && n.stateNode != null)\n          Zs(e, n, e.memoizedProps, r);\n        else {\n          if (typeof r != \"string\" && n.stateNode === null)\n            throw Error(v(166));\n          if (t = dn(Tt.current), dn(Le2.current), bt(n)) {\n            if (r = n.stateNode, t = n.memoizedProps, r[ze2] = n, (i = r.nodeValue !== t) && (e = se2, e !== null))\n              switch (e.tag) {\n                case 3:\n                  qt(r.nodeValue, t, (e.mode & 1) !== 0);\n                  break;\n                case 5:\n                  e.memoizedProps.suppressHydrationWarning !== true && qt(r.nodeValue, t, (e.mode & 1) !== 0);\n              }\n            i && (n.flags |= 4);\n          } else\n            r = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(r), r[ze2] = n, n.stateNode = r;\n        }\n        return G(n), null;\n      case 13:\n        if (R3(M3), r = n.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {\n          if (D2 && oe2 !== null && (n.mode & 1) !== 0 && (n.flags & 128) === 0)\n            ps(), Qn(), n.flags |= 98560, i = false;\n          else if (i = bt(n), r !== null && r.dehydrated !== null) {\n            if (e === null) {\n              if (!i)\n                throw Error(v(318));\n              if (i = n.memoizedState, i = i !== null ? i.dehydrated : null, !i)\n                throw Error(v(317));\n              i[ze2] = n;\n            } else\n              Qn(), (n.flags & 128) === 0 && (n.memoizedState = null), n.flags |= 4;\n            G(n), i = false;\n          } else\n            ke3 !== null && (pi(ke3), ke3 = null), i = true;\n          if (!i)\n            return n.flags & 65536 ? n : null;\n        }\n        return (n.flags & 128) !== 0 ? (n.lanes = t, n) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (n.child.flags |= 8192, (n.mode & 1) !== 0 && (e === null || (M3.current & 1) !== 0 ? B3 === 0 && (B3 = 3) : qi())), n.updateQueue !== null && (n.flags |= 4), G(n), null);\n      case 4:\n        return Kn(), ii(e, n), e === null && _t(n.stateNode.containerInfo), G(n), null;\n      case 10:\n        return Fi(n.type._context), G(n), null;\n      case 17:\n        return le2(n.type) && Cr(), G(n), null;\n      case 19:\n        if (R3(M3), i = n.memoizedState, i === null)\n          return G(n), null;\n        if (r = (n.flags & 128) !== 0, u = i.rendering, u === null)\n          if (r)\n            tt(i, false);\n          else {\n            if (B3 !== 0 || e !== null && (e.flags & 128) !== 0)\n              for (e = n.child; e !== null; ) {\n                if (u = Tr(e), u !== null) {\n                  for (n.flags |= 128, tt(i, false), r = u.updateQueue, r !== null && (n.updateQueue = r, n.flags |= 4), n.subtreeFlags = 0, r = t, t = n.child; t !== null; )\n                    i = t, e = r, i.flags &= 14680066, u = i.alternate, u === null ? (i.childLanes = 0, i.lanes = e, i.child = null, i.subtreeFlags = 0, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null) : (i.childLanes = u.childLanes, i.lanes = u.lanes, i.child = u.child, i.subtreeFlags = 0, i.deletions = null, i.memoizedProps = u.memoizedProps, i.memoizedState = u.memoizedState, i.updateQueue = u.updateQueue, i.type = u.type, e = u.dependencies, i.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), t = t.sibling;\n                  return L2(M3, M3.current & 1 | 2), n.child;\n                }\n                e = e.sibling;\n              }\n            i.tail !== null && U3() > Xn && (n.flags |= 128, r = true, tt(i, false), n.lanes = 4194304);\n          }\n        else {\n          if (!r)\n            if (e = Tr(u), e !== null) {\n              if (n.flags |= 128, r = true, t = e.updateQueue, t !== null && (n.updateQueue = t, n.flags |= 4), tt(i, true), i.tail === null && i.tailMode === \"hidden\" && !u.alternate && !D2)\n                return G(n), null;\n            } else\n              2 * U3() - i.renderingStartTime > Xn && t !== 1073741824 && (n.flags |= 128, r = true, tt(i, false), n.lanes = 4194304);\n          i.isBackwards ? (u.sibling = n.child, n.child = u) : (t = i.last, t !== null ? t.sibling = u : n.child = u, i.last = u);\n        }\n        return i.tail !== null ? (n = i.tail, i.rendering = n, i.tail = n.sibling, i.renderingStartTime = U3(), n.sibling = null, t = M3.current, L2(M3, r ? t & 1 | 2 : t & 1), n) : (G(n), null);\n      case 22:\n      case 23:\n        return Ji(), r = n.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (n.flags |= 8192), r && (n.mode & 1) !== 0 ? (ue & 1073741824) !== 0 && (G(n), n.subtreeFlags & 6 && (n.flags |= 8192)) : G(n), null;\n      case 24:\n        return null;\n      case 25:\n        return null;\n    }\n    throw Error(v(156, n.tag));\n  }\n  function cf(e, n) {\n    switch (Ri(n), n.tag) {\n      case 1:\n        return le2(n.type) && Cr(), e = n.flags, e & 65536 ? (n.flags = e & -65537 | 128, n) : null;\n      case 3:\n        return Kn(), R3(re), R3(J2), Ai(), e = n.flags, (e & 65536) !== 0 && (e & 128) === 0 ? (n.flags = e & -65537 | 128, n) : null;\n      case 5:\n        return Vi(n), null;\n      case 13:\n        if (R3(M3), e = n.memoizedState, e !== null && e.dehydrated !== null) {\n          if (n.alternate === null)\n            throw Error(v(340));\n          Qn();\n        }\n        return e = n.flags, e & 65536 ? (n.flags = e & -65537 | 128, n) : null;\n      case 19:\n        return R3(M3), null;\n      case 4:\n        return Kn(), null;\n      case 10:\n        return Fi(n.type._context), null;\n      case 22:\n      case 23:\n        return Ji(), null;\n      case 24:\n        return null;\n      default:\n        return null;\n    }\n  }\n  var tr = false, Z2 = false, ff = typeof WeakSet == \"function\" ? WeakSet : Set, w = null;\n  function On(e, n) {\n    var t = e.ref;\n    if (t !== null)\n      if (typeof t == \"function\")\n        try {\n          t(null);\n        } catch (r) {\n          I(e, n, r);\n        }\n      else\n        t.current = null;\n  }\n  function ui(e, n, t) {\n    try {\n      t();\n    } catch (r) {\n      I(e, n, r);\n    }\n  }\n  var ro = false;\n  function df(e, n) {\n    if (Wl = wr, e = es2(), Li(e)) {\n      if (\"selectionStart\" in e)\n        var t = { start: e.selectionStart, end: e.selectionEnd };\n      else\n        e: {\n          t = (t = e.ownerDocument) && t.defaultView || window;\n          var r = t.getSelection && t.getSelection();\n          if (r && r.rangeCount !== 0) {\n            t = r.anchorNode;\n            var l = r.anchorOffset, i = r.focusNode;\n            r = r.focusOffset;\n            try {\n              t.nodeType, i.nodeType;\n            } catch {\n              t = null;\n              break e;\n            }\n            var u = 0, o = -1, s = -1, d = 0, m = 0, h = e, p = null;\n            n:\n              for (; ; ) {\n                for (var g; h !== t || l !== 0 && h.nodeType !== 3 || (o = u + l), h !== i || r !== 0 && h.nodeType !== 3 || (s = u + r), h.nodeType === 3 && (u += h.nodeValue.length), (g = h.firstChild) !== null; )\n                  p = h, h = g;\n                for (; ; ) {\n                  if (h === e)\n                    break n;\n                  if (p === t && ++d === l && (o = u), p === i && ++m === r && (s = u), (g = h.nextSibling) !== null)\n                    break;\n                  h = p, p = h.parentNode;\n                }\n                h = g;\n              }\n            t = o === -1 || s === -1 ? null : { start: o, end: s };\n          } else\n            t = null;\n        }\n      t = t || { start: 0, end: 0 };\n    } else\n      t = null;\n    for (Ql = { focusedElem: e, selectionRange: t }, wr = false, w = n; w !== null; )\n      if (n = w, e = n.child, (n.subtreeFlags & 1028) !== 0 && e !== null)\n        e.return = n, w = e;\n      else\n        for (; w !== null; ) {\n          n = w;\n          try {\n            var S2 = n.alternate;\n            if ((n.flags & 1024) !== 0)\n              switch (n.tag) {\n                case 0:\n                case 11:\n                case 15:\n                  break;\n                case 1:\n                  if (S2 !== null) {\n                    var k2 = S2.memoizedProps, j = S2.memoizedState, c3 = n.stateNode, a = c3.getSnapshotBeforeUpdate(n.elementType === n.type ? k2 : we3(n.type, k2), j);\n                    c3.__reactInternalSnapshotBeforeUpdate = a;\n                  }\n                  break;\n                case 3:\n                  var f = n.stateNode.containerInfo;\n                  f.nodeType === 1 ? f.textContent = \"\" : f.nodeType === 9 && f.documentElement && f.removeChild(f.documentElement);\n                  break;\n                case 5:\n                case 6:\n                case 4:\n                case 17:\n                  break;\n                default:\n                  throw Error(v(163));\n              }\n          } catch (y) {\n            I(n, n.return, y);\n          }\n          if (e = n.sibling, e !== null) {\n            e.return = n.return, w = e;\n            break;\n          }\n          w = n.return;\n        }\n    return S2 = ro, ro = false, S2;\n  }\n  function ht(e, n, t) {\n    var r = n.updateQueue;\n    if (r = r !== null ? r.lastEffect : null, r !== null) {\n      var l = r = r.next;\n      do {\n        if ((l.tag & e) === e) {\n          var i = l.destroy;\n          l.destroy = void 0, i !== void 0 && ui(n, t, i);\n        }\n        l = l.next;\n      } while (l !== r);\n    }\n  }\n  function Kr(e, n) {\n    if (n = n.updateQueue, n = n !== null ? n.lastEffect : null, n !== null) {\n      var t = n = n.next;\n      do {\n        if ((t.tag & e) === e) {\n          var r = t.create;\n          t.destroy = r();\n        }\n        t = t.next;\n      } while (t !== n);\n    }\n  }\n  function oi(e) {\n    var n = e.ref;\n    if (n !== null) {\n      var t = e.stateNode;\n      switch (e.tag) {\n        case 5:\n          e = t;\n          break;\n        default:\n          e = t;\n      }\n      typeof n == \"function\" ? n(e) : n.current = e;\n    }\n  }\n  function Js(e) {\n    var n = e.alternate;\n    n !== null && (e.alternate = null, Js(n)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (n = e.stateNode, n !== null && (delete n[ze2], delete n[Pt], delete n[Yl], delete n[Yc], delete n[Xc])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;\n  }\n  function qs(e) {\n    return e.tag === 5 || e.tag === 3 || e.tag === 4;\n  }\n  function lo(e) {\n    e:\n      for (; ; ) {\n        for (; e.sibling === null; ) {\n          if (e.return === null || qs(e.return))\n            return null;\n          e = e.return;\n        }\n        for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18; ) {\n          if (e.flags & 2 || e.child === null || e.tag === 4)\n            continue e;\n          e.child.return = e, e = e.child;\n        }\n        if (!(e.flags & 2))\n          return e.stateNode;\n      }\n  }\n  function si(e, n, t) {\n    var r = e.tag;\n    if (r === 5 || r === 6)\n      e = e.stateNode, n ? t.nodeType === 8 ? t.parentNode.insertBefore(e, n) : t.insertBefore(e, n) : (t.nodeType === 8 ? (n = t.parentNode, n.insertBefore(e, t)) : (n = t, n.appendChild(e)), t = t._reactRootContainer, t != null || n.onclick !== null || (n.onclick = Er));\n    else if (r !== 4 && (e = e.child, e !== null))\n      for (si(e, n, t), e = e.sibling; e !== null; )\n        si(e, n, t), e = e.sibling;\n  }\n  function ai(e, n, t) {\n    var r = e.tag;\n    if (r === 5 || r === 6)\n      e = e.stateNode, n ? t.insertBefore(e, n) : t.appendChild(e);\n    else if (r !== 4 && (e = e.child, e !== null))\n      for (ai(e, n, t), e = e.sibling; e !== null; )\n        ai(e, n, t), e = e.sibling;\n  }\n  var $4 = null, Se2 = false;\n  function Be2(e, n, t) {\n    for (t = t.child; t !== null; )\n      bs(e, n, t), t = t.sibling;\n  }\n  function bs(e, n, t) {\n    if (Pe3 && typeof Pe3.onCommitFiberUnmount == \"function\")\n      try {\n        Pe3.onCommitFiberUnmount(Ur, t);\n      } catch {\n      }\n    switch (t.tag) {\n      case 5:\n        Z2 || On(t, n);\n      case 6:\n        var r = $4, l = Se2;\n        $4 = null, Be2(e, n, t), $4 = r, Se2 = l, $4 !== null && (Se2 ? (e = $4, t = t.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(t) : e.removeChild(t)) : $4.removeChild(t.stateNode));\n        break;\n      case 18:\n        $4 !== null && (Se2 ? (e = $4, t = t.stateNode, e.nodeType === 8 ? dl(e.parentNode, t) : e.nodeType === 1 && dl(e, t), Ct(e)) : dl($4, t.stateNode));\n        break;\n      case 4:\n        r = $4, l = Se2, $4 = t.stateNode.containerInfo, Se2 = true, Be2(e, n, t), $4 = r, Se2 = l;\n        break;\n      case 0:\n      case 11:\n      case 14:\n      case 15:\n        if (!Z2 && (r = t.updateQueue, r !== null && (r = r.lastEffect, r !== null))) {\n          l = r = r.next;\n          do {\n            var i = l, u = i.destroy;\n            i = i.tag, u !== void 0 && ((i & 2) !== 0 || (i & 4) !== 0) && ui(t, n, u), l = l.next;\n          } while (l !== r);\n        }\n        Be2(e, n, t);\n        break;\n      case 1:\n        if (!Z2 && (On(t, n), r = t.stateNode, typeof r.componentWillUnmount == \"function\"))\n          try {\n            r.props = t.memoizedProps, r.state = t.memoizedState, r.componentWillUnmount();\n          } catch (o) {\n            I(t, n, o);\n          }\n        Be2(e, n, t);\n        break;\n      case 21:\n        Be2(e, n, t);\n        break;\n      case 22:\n        t.mode & 1 ? (Z2 = (r = Z2) || t.memoizedState !== null, Be2(e, n, t), Z2 = r) : Be2(e, n, t);\n        break;\n      default:\n        Be2(e, n, t);\n    }\n  }\n  function io(e) {\n    var n = e.updateQueue;\n    if (n !== null) {\n      e.updateQueue = null;\n      var t = e.stateNode;\n      t === null && (t = e.stateNode = new ff()), n.forEach(function(r) {\n        var l = kf.bind(null, e, r);\n        t.has(r) || (t.add(r), r.then(l, l));\n      });\n    }\n  }\n  function ge3(e, n) {\n    var t = n.deletions;\n    if (t !== null)\n      for (var r = 0; r < t.length; r++) {\n        var l = t[r];\n        try {\n          var i = e, u = n, o = u;\n          e:\n            for (; o !== null; ) {\n              switch (o.tag) {\n                case 5:\n                  $4 = o.stateNode, Se2 = false;\n                  break e;\n                case 3:\n                  $4 = o.stateNode.containerInfo, Se2 = true;\n                  break e;\n                case 4:\n                  $4 = o.stateNode.containerInfo, Se2 = true;\n                  break e;\n              }\n              o = o.return;\n            }\n          if ($4 === null)\n            throw Error(v(160));\n          bs(i, u, l), $4 = null, Se2 = false;\n          var s = l.alternate;\n          s !== null && (s.return = null), l.return = null;\n        } catch (d) {\n          I(l, n, d);\n        }\n      }\n    if (n.subtreeFlags & 12854)\n      for (n = n.child; n !== null; )\n        ea(n, e), n = n.sibling;\n  }\n  function ea(e, n) {\n    var t = e.alternate, r = e.flags;\n    switch (e.tag) {\n      case 0:\n      case 11:\n      case 14:\n      case 15:\n        if (ge3(n, e), Ne2(e), r & 4) {\n          try {\n            ht(3, e, e.return), Kr(3, e);\n          } catch (k2) {\n            I(e, e.return, k2);\n          }\n          try {\n            ht(5, e, e.return);\n          } catch (k2) {\n            I(e, e.return, k2);\n          }\n        }\n        break;\n      case 1:\n        ge3(n, e), Ne2(e), r & 512 && t !== null && On(t, t.return);\n        break;\n      case 5:\n        if (ge3(n, e), Ne2(e), r & 512 && t !== null && On(t, t.return), e.flags & 32) {\n          var l = e.stateNode;\n          try {\n            wt(l, \"\");\n          } catch (k2) {\n            I(e, e.return, k2);\n          }\n        }\n        if (r & 4 && (l = e.stateNode, l != null)) {\n          var i = e.memoizedProps, u = t !== null ? t.memoizedProps : i, o = e.type, s = e.updateQueue;\n          if (e.updateQueue = null, s !== null)\n            try {\n              o === \"input\" && i.type === \"radio\" && i.name != null && ko(l, i), Ml(o, u);\n              var d = Ml(o, i);\n              for (u = 0; u < s.length; u += 2) {\n                var m = s[u], h = s[u + 1];\n                m === \"style\" ? _o(l, h) : m === \"dangerouslySetInnerHTML\" ? xo(l, h) : m === \"children\" ? wt(l, h) : vi(l, m, h, d);\n              }\n              switch (o) {\n                case \"input\":\n                  Pl(l, i);\n                  break;\n                case \"textarea\":\n                  Eo(l, i);\n                  break;\n                case \"select\":\n                  var p = l._wrapperState.wasMultiple;\n                  l._wrapperState.wasMultiple = !!i.multiple;\n                  var g = i.value;\n                  g != null ? In(l, !!i.multiple, g, false) : p !== !!i.multiple && (i.defaultValue != null ? In(l, !!i.multiple, i.defaultValue, true) : In(l, !!i.multiple, i.multiple ? [] : \"\", false));\n              }\n              l[Pt] = i;\n            } catch (k2) {\n              I(e, e.return, k2);\n            }\n        }\n        break;\n      case 6:\n        if (ge3(n, e), Ne2(e), r & 4) {\n          if (e.stateNode === null)\n            throw Error(v(162));\n          l = e.stateNode, i = e.memoizedProps;\n          try {\n            l.nodeValue = i;\n          } catch (k2) {\n            I(e, e.return, k2);\n          }\n        }\n        break;\n      case 3:\n        if (ge3(n, e), Ne2(e), r & 4 && t !== null && t.memoizedState.isDehydrated)\n          try {\n            Ct(n.containerInfo);\n          } catch (k2) {\n            I(e, e.return, k2);\n          }\n        break;\n      case 4:\n        ge3(n, e), Ne2(e);\n        break;\n      case 13:\n        ge3(n, e), Ne2(e), l = e.child, l.flags & 8192 && (i = l.memoizedState !== null, l.stateNode.isHidden = i, !i || l.alternate !== null && l.alternate.memoizedState !== null || (Gi = U3())), r & 4 && io(e);\n        break;\n      case 22:\n        if (m = t !== null && t.memoizedState !== null, e.mode & 1 ? (Z2 = (d = Z2) || m, ge3(n, e), Z2 = d) : ge3(n, e), Ne2(e), r & 8192) {\n          if (d = e.memoizedState !== null, (e.stateNode.isHidden = d) && !m && (e.mode & 1) !== 0)\n            for (w = e, m = e.child; m !== null; ) {\n              for (h = w = m; w !== null; ) {\n                switch (p = w, g = p.child, p.tag) {\n                  case 0:\n                  case 11:\n                  case 14:\n                  case 15:\n                    ht(4, p, p.return);\n                    break;\n                  case 1:\n                    On(p, p.return);\n                    var S2 = p.stateNode;\n                    if (typeof S2.componentWillUnmount == \"function\") {\n                      r = p, t = p.return;\n                      try {\n                        n = r, S2.props = n.memoizedProps, S2.state = n.memoizedState, S2.componentWillUnmount();\n                      } catch (k2) {\n                        I(r, t, k2);\n                      }\n                    }\n                    break;\n                  case 5:\n                    On(p, p.return);\n                    break;\n                  case 22:\n                    if (p.memoizedState !== null) {\n                      oo(h);\n                      continue;\n                    }\n                }\n                g !== null ? (g.return = p, w = g) : oo(h);\n              }\n              m = m.sibling;\n            }\n          e:\n            for (m = null, h = e; ; ) {\n              if (h.tag === 5) {\n                if (m === null) {\n                  m = h;\n                  try {\n                    l = h.stateNode, d ? (i = l.style, typeof i.setProperty == \"function\" ? i.setProperty(\"display\", \"none\", \"important\") : i.display = \"none\") : (o = h.stateNode, s = h.memoizedProps.style, u = s != null && s.hasOwnProperty(\"display\") ? s.display : null, o.style.display = No(\"display\", u));\n                  } catch (k2) {\n                    I(e, e.return, k2);\n                  }\n                }\n              } else if (h.tag === 6) {\n                if (m === null)\n                  try {\n                    h.stateNode.nodeValue = d ? \"\" : h.memoizedProps;\n                  } catch (k2) {\n                    I(e, e.return, k2);\n                  }\n              } else if ((h.tag !== 22 && h.tag !== 23 || h.memoizedState === null || h === e) && h.child !== null) {\n                h.child.return = h, h = h.child;\n                continue;\n              }\n              if (h === e)\n                break e;\n              for (; h.sibling === null; ) {\n                if (h.return === null || h.return === e)\n                  break e;\n                m === h && (m = null), h = h.return;\n              }\n              m === h && (m = null), h.sibling.return = h.return, h = h.sibling;\n            }\n        }\n        break;\n      case 19:\n        ge3(n, e), Ne2(e), r & 4 && io(e);\n        break;\n      case 21:\n        break;\n      default:\n        ge3(n, e), Ne2(e);\n    }\n  }\n  function Ne2(e) {\n    var n = e.flags;\n    if (n & 2) {\n      try {\n        e: {\n          for (var t = e.return; t !== null; ) {\n            if (qs(t)) {\n              var r = t;\n              break e;\n            }\n            t = t.return;\n          }\n          throw Error(v(160));\n        }\n        switch (r.tag) {\n          case 5:\n            var l = r.stateNode;\n            r.flags & 32 && (wt(l, \"\"), r.flags &= -33);\n            var i = lo(e);\n            ai(e, i, l);\n            break;\n          case 3:\n          case 4:\n            var u = r.stateNode.containerInfo, o = lo(e);\n            si(e, o, u);\n            break;\n          default:\n            throw Error(v(161));\n        }\n      } catch (s) {\n        I(e, e.return, s);\n      }\n      e.flags &= -3;\n    }\n    n & 4096 && (e.flags &= -4097);\n  }\n  function pf(e, n, t) {\n    w = e, na(e, n, t);\n  }\n  function na(e, n, t) {\n    for (var r = (e.mode & 1) !== 0; w !== null; ) {\n      var l = w, i = l.child;\n      if (l.tag === 22 && r) {\n        var u = l.memoizedState !== null || tr;\n        if (!u) {\n          var o = l.alternate, s = o !== null && o.memoizedState !== null || Z2;\n          o = tr;\n          var d = Z2;\n          if (tr = u, (Z2 = s) && !d)\n            for (w = l; w !== null; )\n              u = w, s = u.child, u.tag === 22 && u.memoizedState !== null ? so(l) : s !== null ? (s.return = u, w = s) : so(l);\n          for (; i !== null; )\n            w = i, na(i, n, t), i = i.sibling;\n          w = l, tr = o, Z2 = d;\n        }\n        uo(e, n, t);\n      } else\n        (l.subtreeFlags & 8772) !== 0 && i !== null ? (i.return = l, w = i) : uo(e, n, t);\n    }\n  }\n  function uo(e) {\n    for (; w !== null; ) {\n      var n = w;\n      if ((n.flags & 8772) !== 0) {\n        var t = n.alternate;\n        try {\n          if ((n.flags & 8772) !== 0)\n            switch (n.tag) {\n              case 0:\n              case 11:\n              case 15:\n                Z2 || Kr(5, n);\n                break;\n              case 1:\n                var r = n.stateNode;\n                if (n.flags & 4 && !Z2)\n                  if (t === null)\n                    r.componentDidMount();\n                  else {\n                    var l = n.elementType === n.type ? t.memoizedProps : we3(n.type, t.memoizedProps);\n                    r.componentDidUpdate(l, t.memoizedState, r.__reactInternalSnapshotBeforeUpdate);\n                  }\n                var i = n.updateQueue;\n                i !== null && Wu(n, i, r);\n                break;\n              case 3:\n                var u = n.updateQueue;\n                if (u !== null) {\n                  if (t = null, n.child !== null)\n                    switch (n.child.tag) {\n                      case 5:\n                        t = n.child.stateNode;\n                        break;\n                      case 1:\n                        t = n.child.stateNode;\n                    }\n                  Wu(n, u, t);\n                }\n                break;\n              case 5:\n                var o = n.stateNode;\n                if (t === null && n.flags & 4) {\n                  t = o;\n                  var s = n.memoizedProps;\n                  switch (n.type) {\n                    case \"button\":\n                    case \"input\":\n                    case \"select\":\n                    case \"textarea\":\n                      s.autoFocus && t.focus();\n                      break;\n                    case \"img\":\n                      s.src && (t.src = s.src);\n                  }\n                }\n                break;\n              case 6:\n                break;\n              case 4:\n                break;\n              case 12:\n                break;\n              case 13:\n                if (n.memoizedState === null) {\n                  var d = n.alternate;\n                  if (d !== null) {\n                    var m = d.memoizedState;\n                    if (m !== null) {\n                      var h = m.dehydrated;\n                      h !== null && Ct(h);\n                    }\n                  }\n                }\n                break;\n              case 19:\n              case 17:\n              case 21:\n              case 22:\n              case 23:\n              case 25:\n                break;\n              default:\n                throw Error(v(163));\n            }\n          Z2 || n.flags & 512 && oi(n);\n        } catch (p) {\n          I(n, n.return, p);\n        }\n      }\n      if (n === e) {\n        w = null;\n        break;\n      }\n      if (t = n.sibling, t !== null) {\n        t.return = n.return, w = t;\n        break;\n      }\n      w = n.return;\n    }\n  }\n  function oo(e) {\n    for (; w !== null; ) {\n      var n = w;\n      if (n === e) {\n        w = null;\n        break;\n      }\n      var t = n.sibling;\n      if (t !== null) {\n        t.return = n.return, w = t;\n        break;\n      }\n      w = n.return;\n    }\n  }\n  function so(e) {\n    for (; w !== null; ) {\n      var n = w;\n      try {\n        switch (n.tag) {\n          case 0:\n          case 11:\n          case 15:\n            var t = n.return;\n            try {\n              Kr(4, n);\n            } catch (s) {\n              I(n, t, s);\n            }\n            break;\n          case 1:\n            var r = n.stateNode;\n            if (typeof r.componentDidMount == \"function\") {\n              var l = n.return;\n              try {\n                r.componentDidMount();\n              } catch (s) {\n                I(n, l, s);\n              }\n            }\n            var i = n.return;\n            try {\n              oi(n);\n            } catch (s) {\n              I(n, i, s);\n            }\n            break;\n          case 5:\n            var u = n.return;\n            try {\n              oi(n);\n            } catch (s) {\n              I(n, u, s);\n            }\n        }\n      } catch (s) {\n        I(n, n.return, s);\n      }\n      if (n === e) {\n        w = null;\n        break;\n      }\n      var o = n.sibling;\n      if (o !== null) {\n        o.return = n.return, w = o;\n        break;\n      }\n      w = n.return;\n    }\n  }\n  var mf = Math.ceil, Mr = Ve2.ReactCurrentDispatcher, Yi = Ve2.ReactCurrentOwner, he3 = Ve2.ReactCurrentBatchConfig, _ = 0, Q2 = null, V2 = null, K = 0, ue = 0, Fn = un(0), B3 = 0, Ot = null, gn = 0, Yr = 0, Xi = 0, vt = null, ne2 = null, Gi = 0, Xn = 1 / 0, Te2 = null, Or = false, ci = null, be3 = null, rr = false, Ye = null, Fr = 0, yt = 0, fi = null, fr2 = -1, dr = 0;\n  function b() {\n    return (_ & 6) !== 0 ? U3() : fr2 !== -1 ? fr2 : fr2 = U3();\n  }\n  function en2(e) {\n    return (e.mode & 1) === 0 ? 1 : (_ & 2) !== 0 && K !== 0 ? K & -K : Zc.transition !== null ? (dr === 0 && (dr = Uo()), dr) : (e = P, e !== 0 || (e = window.event, e = e === void 0 ? 16 : $o(e.type)), e);\n  }\n  function Ce3(e, n, t, r) {\n    if (50 < yt)\n      throw yt = 0, fi = null, Error(v(185));\n    Ft(e, t, r), ((_ & 2) === 0 || e !== Q2) && (e === Q2 && ((_ & 2) === 0 && (Yr |= t), B3 === 4 && $e2(e, K)), ie(e, r), t === 1 && _ === 0 && (n.mode & 1) === 0 && (Xn = U3() + 500, Wr && on()));\n  }\n  function ie(e, n) {\n    var t = e.callbackNode;\n    qa(e, n);\n    var r = gr(e, e === Q2 ? K : 0);\n    if (r === 0)\n      t !== null && vu(t), e.callbackNode = null, e.callbackPriority = 0;\n    else if (n = r & -r, e.callbackPriority !== n) {\n      if (t != null && vu(t), n === 1)\n        e.tag === 0 ? Gc(ao.bind(null, e)) : cs2(ao.bind(null, e)), $c(function() {\n          (_ & 6) === 0 && on();\n        }), t = null;\n      else {\n        switch (Vo(r)) {\n          case 1:\n            t = ki;\n            break;\n          case 4:\n            t = Io;\n            break;\n          case 16:\n            t = yr;\n            break;\n          case 536870912:\n            t = jo;\n            break;\n          default:\n            t = yr;\n        }\n        t = aa(t, ta.bind(null, e));\n      }\n      e.callbackPriority = n, e.callbackNode = t;\n    }\n  }\n  function ta(e, n) {\n    if (fr2 = -1, dr = 0, (_ & 6) !== 0)\n      throw Error(v(327));\n    var t = e.callbackNode;\n    if (Bn() && e.callbackNode !== t)\n      return null;\n    var r = gr(e, e === Q2 ? K : 0);\n    if (r === 0)\n      return null;\n    if ((r & 30) !== 0 || (r & e.expiredLanes) !== 0 || n)\n      n = Ir(e, r);\n    else {\n      n = r;\n      var l = _;\n      _ |= 2;\n      var i = la();\n      (Q2 !== e || K !== n) && (Te2 = null, Xn = U3() + 500, pn(e, n));\n      do\n        try {\n          yf();\n          break;\n        } catch (o) {\n          ra(e, o);\n        }\n      while (1);\n      Oi(), Mr.current = i, _ = l, V2 !== null ? n = 0 : (Q2 = null, K = 0, n = B3);\n    }\n    if (n !== 0) {\n      if (n === 2 && (l = Ul(e), l !== 0 && (r = l, n = di(e, l))), n === 1)\n        throw t = Ot, pn(e, 0), $e2(e, r), ie(e, U3()), t;\n      if (n === 6)\n        $e2(e, r);\n      else {\n        if (l = e.current.alternate, (r & 30) === 0 && !hf(l) && (n = Ir(e, r), n === 2 && (i = Ul(e), i !== 0 && (r = i, n = di(e, i))), n === 1))\n          throw t = Ot, pn(e, 0), $e2(e, r), ie(e, U3()), t;\n        switch (e.finishedWork = l, e.finishedLanes = r, n) {\n          case 0:\n          case 1:\n            throw Error(v(345));\n          case 2:\n            an(e, ne2, Te2);\n            break;\n          case 3:\n            if ($e2(e, r), (r & 130023424) === r && (n = Gi + 500 - U3(), 10 < n)) {\n              if (gr(e, 0) !== 0)\n                break;\n              if (l = e.suspendedLanes, (l & r) !== r) {\n                b(), e.pingedLanes |= e.suspendedLanes & l;\n                break;\n              }\n              e.timeoutHandle = Kl(an.bind(null, e, ne2, Te2), n);\n              break;\n            }\n            an(e, ne2, Te2);\n            break;\n          case 4:\n            if ($e2(e, r), (r & 4194240) === r)\n              break;\n            for (n = e.eventTimes, l = -1; 0 < r; ) {\n              var u = 31 - Ee3(r);\n              i = 1 << u, u = n[u], u > l && (l = u), r &= ~i;\n            }\n            if (r = l, r = U3() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * mf(r / 1960)) - r, 10 < r) {\n              e.timeoutHandle = Kl(an.bind(null, e, ne2, Te2), r);\n              break;\n            }\n            an(e, ne2, Te2);\n            break;\n          case 5:\n            an(e, ne2, Te2);\n            break;\n          default:\n            throw Error(v(329));\n        }\n      }\n    }\n    return ie(e, U3()), e.callbackNode === t ? ta.bind(null, e) : null;\n  }\n  function di(e, n) {\n    var t = vt;\n    return e.current.memoizedState.isDehydrated && (pn(e, n).flags |= 256), e = Ir(e, n), e !== 2 && (n = ne2, ne2 = t, n !== null && pi(n)), e;\n  }\n  function pi(e) {\n    ne2 === null ? ne2 = e : ne2.push.apply(ne2, e);\n  }\n  function hf(e) {\n    for (var n = e; ; ) {\n      if (n.flags & 16384) {\n        var t = n.updateQueue;\n        if (t !== null && (t = t.stores, t !== null))\n          for (var r = 0; r < t.length; r++) {\n            var l = t[r], i = l.getSnapshot;\n            l = l.value;\n            try {\n              if (!xe3(i(), l))\n                return false;\n            } catch {\n              return false;\n            }\n          }\n      }\n      if (t = n.child, n.subtreeFlags & 16384 && t !== null)\n        t.return = n, n = t;\n      else {\n        if (n === e)\n          break;\n        for (; n.sibling === null; ) {\n          if (n.return === null || n.return === e)\n            return true;\n          n = n.return;\n        }\n        n.sibling.return = n.return, n = n.sibling;\n      }\n    }\n    return true;\n  }\n  function $e2(e, n) {\n    for (n &= ~Xi, n &= ~Yr, e.suspendedLanes |= n, e.pingedLanes &= ~n, e = e.expirationTimes; 0 < n; ) {\n      var t = 31 - Ee3(n), r = 1 << t;\n      e[t] = -1, n &= ~r;\n    }\n  }\n  function ao(e) {\n    if ((_ & 6) !== 0)\n      throw Error(v(327));\n    Bn();\n    var n = gr(e, 0);\n    if ((n & 1) === 0)\n      return ie(e, U3()), null;\n    var t = Ir(e, n);\n    if (e.tag !== 0 && t === 2) {\n      var r = Ul(e);\n      r !== 0 && (n = r, t = di(e, r));\n    }\n    if (t === 1)\n      throw t = Ot, pn(e, 0), $e2(e, n), ie(e, U3()), t;\n    if (t === 6)\n      throw Error(v(345));\n    return e.finishedWork = e.current.alternate, e.finishedLanes = n, an(e, ne2, Te2), ie(e, U3()), null;\n  }\n  function Zi(e, n) {\n    var t = _;\n    _ |= 1;\n    try {\n      return e(n);\n    } finally {\n      _ = t, _ === 0 && (Xn = U3() + 500, Wr && on());\n    }\n  }\n  function wn(e) {\n    Ye !== null && Ye.tag === 0 && (_ & 6) === 0 && Bn();\n    var n = _;\n    _ |= 1;\n    var t = he3.transition, r = P;\n    try {\n      if (he3.transition = null, P = 1, e)\n        return e();\n    } finally {\n      P = r, he3.transition = t, _ = n, (_ & 6) === 0 && on();\n    }\n  }\n  function Ji() {\n    ue = Fn.current, R3(Fn);\n  }\n  function pn(e, n) {\n    e.finishedWork = null, e.finishedLanes = 0;\n    var t = e.timeoutHandle;\n    if (t !== -1 && (e.timeoutHandle = -1, Qc(t)), V2 !== null)\n      for (t = V2.return; t !== null; ) {\n        var r = t;\n        switch (Ri(r), r.tag) {\n          case 1:\n            r = r.type.childContextTypes, r != null && Cr();\n            break;\n          case 3:\n            Kn(), R3(re), R3(J2), Ai();\n            break;\n          case 5:\n            Vi(r);\n            break;\n          case 4:\n            Kn();\n            break;\n          case 13:\n            R3(M3);\n            break;\n          case 19:\n            R3(M3);\n            break;\n          case 10:\n            Fi(r.type._context);\n            break;\n          case 22:\n          case 23:\n            Ji();\n        }\n        t = t.return;\n      }\n    if (Q2 = e, V2 = e = nn(e.current, null), K = ue = n, B3 = 0, Ot = null, Xi = Yr = gn = 0, ne2 = vt = null, fn !== null) {\n      for (n = 0; n < fn.length; n++)\n        if (t = fn[n], r = t.interleaved, r !== null) {\n          t.interleaved = null;\n          var l = r.next, i = t.pending;\n          if (i !== null) {\n            var u = i.next;\n            i.next = l, r.next = u;\n          }\n          t.pending = r;\n        }\n      fn = null;\n    }\n    return e;\n  }\n  function ra(e, n) {\n    do {\n      var t = V2;\n      try {\n        if (Oi(), sr.current = Dr, Rr) {\n          for (var r = O.memoizedState; r !== null; ) {\n            var l = r.queue;\n            l !== null && (l.pending = null), r = r.next;\n          }\n          Rr = false;\n        }\n        if (yn = 0, W = A2 = O = null, mt = false, Rt = 0, Yi.current = null, t === null || t.return === null) {\n          B3 = 1, Ot = n, V2 = null;\n          break;\n        }\n        e: {\n          var i = e, u = t.return, o = t, s = n;\n          if (n = K, o.flags |= 32768, s !== null && typeof s == \"object\" && typeof s.then == \"function\") {\n            var d = s, m = o, h = m.tag;\n            if ((m.mode & 1) === 0 && (h === 0 || h === 11 || h === 15)) {\n              var p = m.alternate;\n              p ? (m.updateQueue = p.updateQueue, m.memoizedState = p.memoizedState, m.lanes = p.lanes) : (m.updateQueue = null, m.memoizedState = null);\n            }\n            var g = Zu(u);\n            if (g !== null) {\n              g.flags &= -257, Ju(g, u, o, i, n), g.mode & 1 && Gu(i, d, n), n = g, s = d;\n              var S2 = n.updateQueue;\n              if (S2 === null) {\n                var k2 = /* @__PURE__ */ new Set();\n                k2.add(s), n.updateQueue = k2;\n              } else\n                S2.add(s);\n              break e;\n            } else {\n              if ((n & 1) === 0) {\n                Gu(i, d, n), qi();\n                break e;\n              }\n              s = Error(v(426));\n            }\n          } else if (D2 && o.mode & 1) {\n            var j = Zu(u);\n            if (j !== null) {\n              (j.flags & 65536) === 0 && (j.flags |= 256), Ju(j, u, o, i, n), Di(Yn(s, o));\n              break e;\n            }\n          }\n          i = s = Yn(s, o), B3 !== 4 && (B3 = 2), vt === null ? vt = [i] : vt.push(i), i = u;\n          do {\n            switch (i.tag) {\n              case 3:\n                i.flags |= 65536, n &= -n, i.lanes |= n;\n                var c3 = As(i, s, n);\n                Hu(i, c3);\n                break e;\n              case 1:\n                o = s;\n                var a = i.type, f = i.stateNode;\n                if ((i.flags & 128) === 0 && (typeof a.getDerivedStateFromError == \"function\" || f !== null && typeof f.componentDidCatch == \"function\" && (be3 === null || !be3.has(f)))) {\n                  i.flags |= 65536, n &= -n, i.lanes |= n;\n                  var y = Bs(i, o, n);\n                  Hu(i, y);\n                  break e;\n                }\n            }\n            i = i.return;\n          } while (i !== null);\n        }\n        ua(t);\n      } catch (E) {\n        n = E, V2 === t && t !== null && (V2 = t = t.return);\n        continue;\n      }\n      break;\n    } while (1);\n  }\n  function la() {\n    var e = Mr.current;\n    return Mr.current = Dr, e === null ? Dr : e;\n  }\n  function qi() {\n    (B3 === 0 || B3 === 3 || B3 === 2) && (B3 = 4), Q2 === null || (gn & 268435455) === 0 && (Yr & 268435455) === 0 || $e2(Q2, K);\n  }\n  function Ir(e, n) {\n    var t = _;\n    _ |= 2;\n    var r = la();\n    (Q2 !== e || K !== n) && (Te2 = null, pn(e, n));\n    do\n      try {\n        vf();\n        break;\n      } catch (l) {\n        ra(e, l);\n      }\n    while (1);\n    if (Oi(), _ = t, Mr.current = r, V2 !== null)\n      throw Error(v(261));\n    return Q2 = null, K = 0, B3;\n  }\n  function vf() {\n    for (; V2 !== null; )\n      ia(V2);\n  }\n  function yf() {\n    for (; V2 !== null && !Wa(); )\n      ia(V2);\n  }\n  function ia(e) {\n    var n = sa(e.alternate, e, ue);\n    e.memoizedProps = e.pendingProps, n === null ? ua(e) : V2 = n, Yi.current = null;\n  }\n  function ua(e) {\n    var n = e;\n    do {\n      var t = n.alternate;\n      if (e = n.return, (n.flags & 32768) === 0) {\n        if (t = af(t, n, ue), t !== null) {\n          V2 = t;\n          return;\n        }\n      } else {\n        if (t = cf(t, n), t !== null) {\n          t.flags &= 32767, V2 = t;\n          return;\n        }\n        if (e !== null)\n          e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null;\n        else {\n          B3 = 6, V2 = null;\n          return;\n        }\n      }\n      if (n = n.sibling, n !== null) {\n        V2 = n;\n        return;\n      }\n      V2 = n = e;\n    } while (n !== null);\n    B3 === 0 && (B3 = 5);\n  }\n  function an(e, n, t) {\n    var r = P, l = he3.transition;\n    try {\n      he3.transition = null, P = 1, gf(e, n, t, r);\n    } finally {\n      he3.transition = l, P = r;\n    }\n    return null;\n  }\n  function gf(e, n, t, r) {\n    do\n      Bn();\n    while (Ye !== null);\n    if ((_ & 6) !== 0)\n      throw Error(v(327));\n    t = e.finishedWork;\n    var l = e.finishedLanes;\n    if (t === null)\n      return null;\n    if (e.finishedWork = null, e.finishedLanes = 0, t === e.current)\n      throw Error(v(177));\n    e.callbackNode = null, e.callbackPriority = 0;\n    var i = t.lanes | t.childLanes;\n    if (ba(e, i), e === Q2 && (V2 = Q2 = null, K = 0), (t.subtreeFlags & 2064) === 0 && (t.flags & 2064) === 0 || rr || (rr = true, aa(yr, function() {\n      return Bn(), null;\n    })), i = (t.flags & 15990) !== 0, (t.subtreeFlags & 15990) !== 0 || i) {\n      i = he3.transition, he3.transition = null;\n      var u = P;\n      P = 1;\n      var o = _;\n      _ |= 4, Yi.current = null, df(e, t), ea(t, e), Vc(Ql), wr = !!Wl, Ql = Wl = null, e.current = t, pf(t, e, l), Qa(), _ = o, P = u, he3.transition = i;\n    } else\n      e.current = t;\n    if (rr && (rr = false, Ye = e, Fr = l), i = e.pendingLanes, i === 0 && (be3 = null), Ya(t.stateNode, r), ie(e, U3()), n !== null)\n      for (r = e.onRecoverableError, t = 0; t < n.length; t++)\n        l = n[t], r(l.value, { componentStack: l.stack, digest: l.digest });\n    if (Or)\n      throw Or = false, e = ci, ci = null, e;\n    return (Fr & 1) !== 0 && e.tag !== 0 && Bn(), i = e.pendingLanes, (i & 1) !== 0 ? e === fi ? yt++ : (yt = 0, fi = e) : yt = 0, on(), null;\n  }\n  function Bn() {\n    if (Ye !== null) {\n      var e = Vo(Fr), n = he3.transition, t = P;\n      try {\n        if (he3.transition = null, P = 16 > e ? 16 : e, Ye === null)\n          var r = false;\n        else {\n          if (e = Ye, Ye = null, Fr = 0, (_ & 6) !== 0)\n            throw Error(v(331));\n          var l = _;\n          for (_ |= 4, w = e.current; w !== null; ) {\n            var i = w, u = i.child;\n            if ((w.flags & 16) !== 0) {\n              var o = i.deletions;\n              if (o !== null) {\n                for (var s = 0; s < o.length; s++) {\n                  var d = o[s];\n                  for (w = d; w !== null; ) {\n                    var m = w;\n                    switch (m.tag) {\n                      case 0:\n                      case 11:\n                      case 15:\n                        ht(8, m, i);\n                    }\n                    var h = m.child;\n                    if (h !== null)\n                      h.return = m, w = h;\n                    else\n                      for (; w !== null; ) {\n                        m = w;\n                        var p = m.sibling, g = m.return;\n                        if (Js(m), m === d) {\n                          w = null;\n                          break;\n                        }\n                        if (p !== null) {\n                          p.return = g, w = p;\n                          break;\n                        }\n                        w = g;\n                      }\n                  }\n                }\n                var S2 = i.alternate;\n                if (S2 !== null) {\n                  var k2 = S2.child;\n                  if (k2 !== null) {\n                    S2.child = null;\n                    do {\n                      var j = k2.sibling;\n                      k2.sibling = null, k2 = j;\n                    } while (k2 !== null);\n                  }\n                }\n                w = i;\n              }\n            }\n            if ((i.subtreeFlags & 2064) !== 0 && u !== null)\n              u.return = i, w = u;\n            else\n              e:\n                for (; w !== null; ) {\n                  if (i = w, (i.flags & 2048) !== 0)\n                    switch (i.tag) {\n                      case 0:\n                      case 11:\n                      case 15:\n                        ht(9, i, i.return);\n                    }\n                  var c3 = i.sibling;\n                  if (c3 !== null) {\n                    c3.return = i.return, w = c3;\n                    break e;\n                  }\n                  w = i.return;\n                }\n          }\n          var a = e.current;\n          for (w = a; w !== null; ) {\n            u = w;\n            var f = u.child;\n            if ((u.subtreeFlags & 2064) !== 0 && f !== null)\n              f.return = u, w = f;\n            else\n              e:\n                for (u = a; w !== null; ) {\n                  if (o = w, (o.flags & 2048) !== 0)\n                    try {\n                      switch (o.tag) {\n                        case 0:\n                        case 11:\n                        case 15:\n                          Kr(9, o);\n                      }\n                    } catch (E) {\n                      I(o, o.return, E);\n                    }\n                  if (o === u) {\n                    w = null;\n                    break e;\n                  }\n                  var y = o.sibling;\n                  if (y !== null) {\n                    y.return = o.return, w = y;\n                    break e;\n                  }\n                  w = o.return;\n                }\n          }\n          if (_ = l, on(), Pe3 && typeof Pe3.onPostCommitFiberRoot == \"function\")\n            try {\n              Pe3.onPostCommitFiberRoot(Ur, e);\n            } catch {\n            }\n          r = true;\n        }\n        return r;\n      } finally {\n        P = t, he3.transition = n;\n      }\n    }\n    return false;\n  }\n  function co(e, n, t) {\n    n = Yn(t, n), n = As(e, n, 1), e = qe2(e, n, 1), n = b(), e !== null && (Ft(e, 1, n), ie(e, n));\n  }\n  function I(e, n, t) {\n    if (e.tag === 3)\n      co(e, e, t);\n    else\n      for (; n !== null; ) {\n        if (n.tag === 3) {\n          co(n, e, t);\n          break;\n        } else if (n.tag === 1) {\n          var r = n.stateNode;\n          if (typeof n.type.getDerivedStateFromError == \"function\" || typeof r.componentDidCatch == \"function\" && (be3 === null || !be3.has(r))) {\n            e = Yn(t, e), e = Bs(n, e, 1), n = qe2(n, e, 1), e = b(), n !== null && (Ft(n, 1, e), ie(n, e));\n            break;\n          }\n        }\n        n = n.return;\n      }\n  }\n  function wf(e, n, t) {\n    var r = e.pingCache;\n    r !== null && r.delete(n), n = b(), e.pingedLanes |= e.suspendedLanes & t, Q2 === e && (K & t) === t && (B3 === 4 || B3 === 3 && (K & 130023424) === K && 500 > U3() - Gi ? pn(e, 0) : Xi |= t), ie(e, n);\n  }\n  function oa(e, n) {\n    n === 0 && ((e.mode & 1) === 0 ? n = 1 : (n = Wt, Wt <<= 1, (Wt & 130023424) === 0 && (Wt = 4194304)));\n    var t = b();\n    e = je2(e, n), e !== null && (Ft(e, n, t), ie(e, t));\n  }\n  function Sf(e) {\n    var n = e.memoizedState, t = 0;\n    n !== null && (t = n.retryLane), oa(e, t);\n  }\n  function kf(e, n) {\n    var t = 0;\n    switch (e.tag) {\n      case 13:\n        var r = e.stateNode, l = e.memoizedState;\n        l !== null && (t = l.retryLane);\n        break;\n      case 19:\n        r = e.stateNode;\n        break;\n      default:\n        throw Error(v(314));\n    }\n    r !== null && r.delete(n), oa(e, t);\n  }\n  var sa;\n  sa = function(e, n, t) {\n    if (e !== null)\n      if (e.memoizedProps !== n.pendingProps || re.current)\n        te2 = true;\n      else {\n        if ((e.lanes & t) === 0 && (n.flags & 128) === 0)\n          return te2 = false, sf(e, n, t);\n        te2 = (e.flags & 131072) !== 0;\n      }\n    else\n      te2 = false, D2 && (n.flags & 1048576) !== 0 && fs(n, _r, n.index);\n    switch (n.lanes = 0, n.tag) {\n      case 2:\n        var r = n.type;\n        cr(e, n), e = n.pendingProps;\n        var l = Wn(n, J2.current);\n        An(n, t), l = Hi(null, n, r, e, l, t);\n        var i = Wi();\n        return n.flags |= 1, typeof l == \"object\" && l !== null && typeof l.render == \"function\" && l.$$typeof === void 0 ? (n.tag = 1, n.memoizedState = null, n.updateQueue = null, le2(r) ? (i = true, xr(n)) : i = false, n.memoizedState = l.state !== null && l.state !== void 0 ? l.state : null, ji(n), l.updater = Qr, n.stateNode = l, l._reactInternals = n, bl(n, r, e, t), n = ti(null, n, r, true, i, t)) : (n.tag = 0, D2 && i && Ti(n), q2(null, n, l, t), n = n.child), n;\n      case 16:\n        r = n.elementType;\n        e: {\n          switch (cr(e, n), e = n.pendingProps, l = r._init, r = l(r._payload), n.type = r, l = n.tag = Cf(r), e = we3(r, e), l) {\n            case 0:\n              n = ni(null, n, r, e, t);\n              break e;\n            case 1:\n              n = eo(null, n, r, e, t);\n              break e;\n            case 11:\n              n = qu(null, n, r, e, t);\n              break e;\n            case 14:\n              n = bu(null, n, r, we3(r.type, e), t);\n              break e;\n          }\n          throw Error(v(306, r, \"\"));\n        }\n        return n;\n      case 0:\n        return r = n.type, l = n.pendingProps, l = n.elementType === r ? l : we3(r, l), ni(e, n, r, l, t);\n      case 1:\n        return r = n.type, l = n.pendingProps, l = n.elementType === r ? l : we3(r, l), eo(e, n, r, l, t);\n      case 3:\n        e: {\n          if ($s(n), e === null)\n            throw Error(v(387));\n          r = n.pendingProps, i = n.memoizedState, l = i.element, hs(e, n), Lr(n, r, null, t);\n          var u = n.memoizedState;\n          if (r = u.element, i.isDehydrated)\n            if (i = { element: r, isDehydrated: false, cache: u.cache, pendingSuspenseBoundaries: u.pendingSuspenseBoundaries, transitions: u.transitions }, n.updateQueue.baseState = i, n.memoizedState = i, n.flags & 256) {\n              l = Yn(Error(v(423)), n), n = no(e, n, r, t, l);\n              break e;\n            } else if (r !== l) {\n              l = Yn(Error(v(424)), n), n = no(e, n, r, t, l);\n              break e;\n            } else\n              for (oe2 = Je(n.stateNode.containerInfo.firstChild), se2 = n, D2 = true, ke3 = null, t = ws(n, null, r, t), n.child = t; t; )\n                t.flags = t.flags & -3 | 4096, t = t.sibling;\n          else {\n            if (Qn(), r === l) {\n              n = Ue2(e, n, t);\n              break e;\n            }\n            q2(e, n, r, t);\n          }\n          n = n.child;\n        }\n        return n;\n      case 5:\n        return Ss(n), e === null && Zl(n), r = n.type, l = n.pendingProps, i = e !== null ? e.memoizedProps : null, u = l.children, $l(r, l) ? u = null : i !== null && $l(r, i) && (n.flags |= 32), Qs(e, n), q2(e, n, u, t), n.child;\n      case 6:\n        return e === null && Zl(n), null;\n      case 13:\n        return Ks(e, n, t);\n      case 4:\n        return Ui(n, n.stateNode.containerInfo), r = n.pendingProps, e === null ? n.child = $n(n, null, r, t) : q2(e, n, r, t), n.child;\n      case 11:\n        return r = n.type, l = n.pendingProps, l = n.elementType === r ? l : we3(r, l), qu(e, n, r, l, t);\n      case 7:\n        return q2(e, n, n.pendingProps, t), n.child;\n      case 8:\n        return q2(e, n, n.pendingProps.children, t), n.child;\n      case 12:\n        return q2(e, n, n.pendingProps.children, t), n.child;\n      case 10:\n        e: {\n          if (r = n.type._context, l = n.pendingProps, i = n.memoizedProps, u = l.value, L2(zr, r._currentValue), r._currentValue = u, i !== null)\n            if (xe3(i.value, u)) {\n              if (i.children === l.children && !re.current) {\n                n = Ue2(e, n, t);\n                break e;\n              }\n            } else\n              for (i = n.child, i !== null && (i.return = n); i !== null; ) {\n                var o = i.dependencies;\n                if (o !== null) {\n                  u = i.child;\n                  for (var s = o.firstContext; s !== null; ) {\n                    if (s.context === r) {\n                      if (i.tag === 1) {\n                        s = Oe2(-1, t & -t), s.tag = 2;\n                        var d = i.updateQueue;\n                        if (d !== null) {\n                          d = d.shared;\n                          var m = d.pending;\n                          m === null ? s.next = s : (s.next = m.next, m.next = s), d.pending = s;\n                        }\n                      }\n                      i.lanes |= t, s = i.alternate, s !== null && (s.lanes |= t), Jl(i.return, t, n), o.lanes |= t;\n                      break;\n                    }\n                    s = s.next;\n                  }\n                } else if (i.tag === 10)\n                  u = i.type === n.type ? null : i.child;\n                else if (i.tag === 18) {\n                  if (u = i.return, u === null)\n                    throw Error(v(341));\n                  u.lanes |= t, o = u.alternate, o !== null && (o.lanes |= t), Jl(u, t, n), u = i.sibling;\n                } else\n                  u = i.child;\n                if (u !== null)\n                  u.return = i;\n                else\n                  for (u = i; u !== null; ) {\n                    if (u === n) {\n                      u = null;\n                      break;\n                    }\n                    if (i = u.sibling, i !== null) {\n                      i.return = u.return, u = i;\n                      break;\n                    }\n                    u = u.return;\n                  }\n                i = u;\n              }\n          q2(e, n, l.children, t), n = n.child;\n        }\n        return n;\n      case 9:\n        return l = n.type, r = n.pendingProps.children, An(n, t), l = ve3(l), r = r(l), n.flags |= 1, q2(e, n, r, t), n.child;\n      case 14:\n        return r = n.type, l = we3(r, n.pendingProps), l = we3(r.type, l), bu(e, n, r, l, t);\n      case 15:\n        return Hs(e, n, n.type, n.pendingProps, t);\n      case 17:\n        return r = n.type, l = n.pendingProps, l = n.elementType === r ? l : we3(r, l), cr(e, n), n.tag = 1, le2(r) ? (e = true, xr(n)) : e = false, An(n, t), ys(n, r, l), bl(n, r, l, t), ti(null, n, r, true, e, t);\n      case 19:\n        return Ys(e, n, t);\n      case 22:\n        return Ws(e, n, t);\n    }\n    throw Error(v(156, n.tag));\n  };\n  function aa(e, n) {\n    return Fo(e, n);\n  }\n  function Ef(e, n, t, r) {\n    this.tag = e, this.key = t, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = n, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;\n  }\n  function me3(e, n, t, r) {\n    return new Ef(e, n, t, r);\n  }\n  function bi(e) {\n    return e = e.prototype, !(!e || !e.isReactComponent);\n  }\n  function Cf(e) {\n    if (typeof e == \"function\")\n      return bi(e) ? 1 : 0;\n    if (e != null) {\n      if (e = e.$$typeof, e === gi)\n        return 11;\n      if (e === wi)\n        return 14;\n    }\n    return 2;\n  }\n  function nn(e, n) {\n    var t = e.alternate;\n    return t === null ? (t = me3(e.tag, n, e.key, e.mode), t.elementType = e.elementType, t.type = e.type, t.stateNode = e.stateNode, t.alternate = e, e.alternate = t) : (t.pendingProps = n, t.type = e.type, t.flags = 0, t.subtreeFlags = 0, t.deletions = null), t.flags = e.flags & 14680064, t.childLanes = e.childLanes, t.lanes = e.lanes, t.child = e.child, t.memoizedProps = e.memoizedProps, t.memoizedState = e.memoizedState, t.updateQueue = e.updateQueue, n = e.dependencies, t.dependencies = n === null ? null : { lanes: n.lanes, firstContext: n.firstContext }, t.sibling = e.sibling, t.index = e.index, t.ref = e.ref, t;\n  }\n  function pr(e, n, t, r, l, i) {\n    var u = 2;\n    if (r = e, typeof e == \"function\")\n      bi(e) && (u = 1);\n    else if (typeof e == \"string\")\n      u = 5;\n    else\n      e:\n        switch (e) {\n          case Nn:\n            return mn(t.children, l, i, n);\n          case yi:\n            u = 8, l |= 8;\n            break;\n          case Cl:\n            return e = me3(12, t, n, l | 2), e.elementType = Cl, e.lanes = i, e;\n          case xl:\n            return e = me3(13, t, n, l), e.elementType = xl, e.lanes = i, e;\n          case Nl:\n            return e = me3(19, t, n, l), e.elementType = Nl, e.lanes = i, e;\n          case go:\n            return Xr(t, l, i, n);\n          default:\n            if (typeof e == \"object\" && e !== null)\n              switch (e.$$typeof) {\n                case vo:\n                  u = 10;\n                  break e;\n                case yo:\n                  u = 9;\n                  break e;\n                case gi:\n                  u = 11;\n                  break e;\n                case wi:\n                  u = 14;\n                  break e;\n                case He2:\n                  u = 16, r = null;\n                  break e;\n              }\n            throw Error(v(130, e == null ? e : typeof e, \"\"));\n        }\n    return n = me3(u, t, n, l), n.elementType = e, n.type = r, n.lanes = i, n;\n  }\n  function mn(e, n, t, r) {\n    return e = me3(7, e, r, n), e.lanes = t, e;\n  }\n  function Xr(e, n, t, r) {\n    return e = me3(22, e, r, n), e.elementType = go, e.lanes = t, e.stateNode = { isHidden: false }, e;\n  }\n  function Sl(e, n, t) {\n    return e = me3(6, e, null, n), e.lanes = t, e;\n  }\n  function kl(e, n, t) {\n    return n = me3(4, e.children !== null ? e.children : [], e.key, n), n.lanes = t, n.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, n;\n  }\n  function xf(e, n, t, r, l) {\n    this.tag = n, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = ll(0), this.expirationTimes = ll(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ll(0), this.identifierPrefix = r, this.onRecoverableError = l, this.mutableSourceEagerHydrationData = null;\n  }\n  function eu(e, n, t, r, l, i, u, o, s) {\n    return e = new xf(e, n, t, o, s), n === 1 ? (n = 1, i === true && (n |= 8)) : n = 0, i = me3(3, null, null, n), e.current = i, i.stateNode = e, i.memoizedState = { element: r, isDehydrated: t, cache: null, transitions: null, pendingSuspenseBoundaries: null }, ji(i), e;\n  }\n  function Nf(e, n, t) {\n    var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;\n    return { $$typeof: xn, key: r == null ? null : \"\" + r, children: e, containerInfo: n, implementation: t };\n  }\n  function ca(e) {\n    if (!e)\n      return rn;\n    e = e._reactInternals;\n    e: {\n      if (kn(e) !== e || e.tag !== 1)\n        throw Error(v(170));\n      var n = e;\n      do {\n        switch (n.tag) {\n          case 3:\n            n = n.stateNode.context;\n            break e;\n          case 1:\n            if (le2(n.type)) {\n              n = n.stateNode.__reactInternalMemoizedMergedChildContext;\n              break e;\n            }\n        }\n        n = n.return;\n      } while (n !== null);\n      throw Error(v(171));\n    }\n    if (e.tag === 1) {\n      var t = e.type;\n      if (le2(t))\n        return as(e, t, n);\n    }\n    return n;\n  }\n  function fa(e, n, t, r, l, i, u, o, s) {\n    return e = eu(t, r, true, e, l, i, u, o, s), e.context = ca(null), t = e.current, r = b(), l = en2(t), i = Oe2(r, l), i.callback = n ?? null, qe2(t, i, l), e.current.lanes = l, Ft(e, l, r), ie(e, r), e;\n  }\n  function Gr(e, n, t, r) {\n    var l = n.current, i = b(), u = en2(l);\n    return t = ca(t), n.context === null ? n.context = t : n.pendingContext = t, n = Oe2(i, u), n.payload = { element: e }, r = r === void 0 ? null : r, r !== null && (n.callback = r), e = qe2(l, n, u), e !== null && (Ce3(e, l, u, i), or(e, l, u)), u;\n  }\n  function jr(e) {\n    if (e = e.current, !e.child)\n      return null;\n    switch (e.child.tag) {\n      case 5:\n        return e.child.stateNode;\n      default:\n        return e.child.stateNode;\n    }\n  }\n  function fo(e, n) {\n    if (e = e.memoizedState, e !== null && e.dehydrated !== null) {\n      var t = e.retryLane;\n      e.retryLane = t !== 0 && t < n ? t : n;\n    }\n  }\n  function nu(e, n) {\n    fo(e, n), (e = e.alternate) && fo(e, n);\n  }\n  function _f() {\n    return null;\n  }\n  var da = typeof reportError == \"function\" ? reportError : function(e) {\n    console.error(e);\n  };\n  function tu(e) {\n    this._internalRoot = e;\n  }\n  Zr.prototype.render = tu.prototype.render = function(e) {\n    var n = this._internalRoot;\n    if (n === null)\n      throw Error(v(409));\n    Gr(e, n, null, null);\n  };\n  Zr.prototype.unmount = tu.prototype.unmount = function() {\n    var e = this._internalRoot;\n    if (e !== null) {\n      this._internalRoot = null;\n      var n = e.containerInfo;\n      wn(function() {\n        Gr(null, e, null, null);\n      }), n[Ie3] = null;\n    }\n  };\n  function Zr(e) {\n    this._internalRoot = e;\n  }\n  Zr.prototype.unstable_scheduleHydration = function(e) {\n    if (e) {\n      var n = Ho();\n      e = { blockedOn: null, target: e, priority: n };\n      for (var t = 0; t < Qe.length && n !== 0 && n < Qe[t].priority; t++)\n        ;\n      Qe.splice(t, 0, e), t === 0 && Qo(e);\n    }\n  };\n  function ru2(e) {\n    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11);\n  }\n  function Jr(e) {\n    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== \" react-mount-point-unstable \"));\n  }\n  function po() {\n  }\n  function zf(e, n, t, r, l) {\n    if (l) {\n      if (typeof r == \"function\") {\n        var i = r;\n        r = function() {\n          var d = jr(u);\n          i.call(d);\n        };\n      }\n      var u = fa(n, r, e, 0, null, false, false, \"\", po);\n      return e._reactRootContainer = u, e[Ie3] = u.current, _t(e.nodeType === 8 ? e.parentNode : e), wn(), u;\n    }\n    for (; l = e.lastChild; )\n      e.removeChild(l);\n    if (typeof r == \"function\") {\n      var o = r;\n      r = function() {\n        var d = jr(s);\n        o.call(d);\n      };\n    }\n    var s = eu(e, 0, false, null, null, false, false, \"\", po);\n    return e._reactRootContainer = s, e[Ie3] = s.current, _t(e.nodeType === 8 ? e.parentNode : e), wn(function() {\n      Gr(n, s, t, r);\n    }), s;\n  }\n  function qr(e, n, t, r, l) {\n    var i = t._reactRootContainer;\n    if (i) {\n      var u = i;\n      if (typeof l == \"function\") {\n        var o = l;\n        l = function() {\n          var s = jr(u);\n          o.call(s);\n        };\n      }\n      Gr(n, u, e, l);\n    } else\n      u = zf(t, n, e, l, r);\n    return jr(u);\n  }\n  Ao = function(e) {\n    switch (e.tag) {\n      case 3:\n        var n = e.stateNode;\n        if (n.current.memoizedState.isDehydrated) {\n          var t = ot(n.pendingLanes);\n          t !== 0 && (Ei(n, t | 1), ie(n, U3()), (_ & 6) === 0 && (Xn = U3() + 500, on()));\n        }\n        break;\n      case 13:\n        wn(function() {\n          var r = je2(e, 1);\n          if (r !== null) {\n            var l = b();\n            Ce3(r, e, 1, l);\n          }\n        }), nu(e, 1);\n    }\n  };\n  Ci = function(e) {\n    if (e.tag === 13) {\n      var n = je2(e, 134217728);\n      if (n !== null) {\n        var t = b();\n        Ce3(n, e, 134217728, t);\n      }\n      nu(e, 134217728);\n    }\n  };\n  Bo = function(e) {\n    if (e.tag === 13) {\n      var n = en2(e), t = je2(e, n);\n      if (t !== null) {\n        var r = b();\n        Ce3(t, e, n, r);\n      }\n      nu(e, n);\n    }\n  };\n  Ho = function() {\n    return P;\n  };\n  Wo = function(e, n) {\n    var t = P;\n    try {\n      return P = e, n();\n    } finally {\n      P = t;\n    }\n  };\n  Fl = function(e, n, t) {\n    switch (n) {\n      case \"input\":\n        if (Pl(e, t), n = t.name, t.type === \"radio\" && n != null) {\n          for (t = e; t.parentNode; )\n            t = t.parentNode;\n          for (t = t.querySelectorAll(\"input[name=\" + JSON.stringify(\"\" + n) + '][type=\"radio\"]'), n = 0; n < t.length; n++) {\n            var r = t[n];\n            if (r !== e && r.form === e.form) {\n              var l = Hr(r);\n              if (!l)\n                throw Error(v(90));\n              So(r), Pl(r, l);\n            }\n          }\n        }\n        break;\n      case \"textarea\":\n        Eo(e, t);\n        break;\n      case \"select\":\n        n = t.value, n != null && In(e, !!t.multiple, n, false);\n    }\n  };\n  Lo = Zi;\n  To = wn;\n  var Pf = { usingClientEntryPoint: false, Events: [jt, Ln, Hr, zo, Po, Zi] }, rt = { findFiberByHostInstance: cn2, bundleType: 0, version: \"18.2.0\", rendererPackageName: \"react-dom\" }, Lf = { bundleType: rt.bundleType, version: rt.version, rendererPackageName: rt.rendererPackageName, rendererConfig: rt.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Ve2.ReactCurrentDispatcher, findHostInstanceByFiber: function(e) {\n    return e = Mo(e), e === null ? null : e.stateNode;\n  }, findFiberByHostInstance: rt.findFiberByHostInstance || _f, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: \"18.2.0-next-9e3b772b8-20220608\" };\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < \"u\" && (lt = __REACT_DEVTOOLS_GLOBAL_HOOK__, !lt.isDisabled && lt.supportsFiber))\n    try {\n      Ur = lt.inject(Lf), Pe3 = lt;\n    } catch {\n    }\n  var lt;\n  fe2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Pf;\n  fe2.createPortal = function(e, n) {\n    var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;\n    if (!ru2(n))\n      throw Error(v(200));\n    return Nf(e, n, null, t);\n  };\n  fe2.createRoot = function(e, n) {\n    if (!ru2(e))\n      throw Error(v(299));\n    var t = false, r = \"\", l = da;\n    return n != null && (n.unstable_strictMode === true && (t = true), n.identifierPrefix !== void 0 && (r = n.identifierPrefix), n.onRecoverableError !== void 0 && (l = n.onRecoverableError)), n = eu(e, 1, false, null, null, t, false, r, l), e[Ie3] = n.current, _t(e.nodeType === 8 ? e.parentNode : e), new tu(n);\n  };\n  fe2.findDOMNode = function(e) {\n    if (e == null)\n      return null;\n    if (e.nodeType === 1)\n      return e;\n    var n = e._reactInternals;\n    if (n === void 0)\n      throw typeof e.render == \"function\" ? Error(v(188)) : (e = Object.keys(e).join(\",\"), Error(v(268, e)));\n    return e = Mo(n), e = e === null ? null : e.stateNode, e;\n  };\n  fe2.flushSync = function(e) {\n    return wn(e);\n  };\n  fe2.hydrate = function(e, n, t) {\n    if (!Jr(n))\n      throw Error(v(200));\n    return qr(null, e, n, true, t);\n  };\n  fe2.hydrateRoot = function(e, n, t) {\n    if (!ru2(e))\n      throw Error(v(405));\n    var r = t != null && t.hydratedSources || null, l = false, i = \"\", u = da;\n    if (t != null && (t.unstable_strictMode === true && (l = true), t.identifierPrefix !== void 0 && (i = t.identifierPrefix), t.onRecoverableError !== void 0 && (u = t.onRecoverableError)), n = fa(n, null, e, 1, t ?? null, l, false, i, u), e[Ie3] = n.current, _t(e), r)\n      for (e = 0; e < r.length; e++)\n        t = r[e], l = t._getVersion, l = l(t._source), n.mutableSourceEagerHydrationData == null ? n.mutableSourceEagerHydrationData = [t, l] : n.mutableSourceEagerHydrationData.push(t, l);\n    return new Zr(n);\n  };\n  fe2.render = function(e, n, t) {\n    if (!Jr(n))\n      throw Error(v(200));\n    return qr(null, e, n, false, t);\n  };\n  fe2.unmountComponentAtNode = function(e) {\n    if (!Jr(e))\n      throw Error(v(40));\n    return e._reactRootContainer ? (wn(function() {\n      qr(null, null, e, false, function() {\n        e._reactRootContainer = null, e[Ie3] = null;\n      });\n    }), true) : false;\n  };\n  fe2.unstable_batchedUpdates = Zi;\n  fe2.unstable_renderSubtreeIntoContainer = function(e, n, t, r) {\n    if (!Jr(t))\n      throw Error(v(200));\n    if (e == null || e._reactInternals === void 0)\n      throw Error(v(38));\n    return qr(e, n, t, false, r);\n  };\n  fe2.version = \"18.2.0-next-9e3b772b8-20220608\";\n});\nvar va = br((Mf, ha) => {\n  \"use strict\";\n  function ma() {\n    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > \"u\" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != \"function\"))\n      try {\n        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(ma);\n      } catch (e) {\n        console.error(e);\n      }\n  }\n  ma(), ha.exports = pa();\n});\nvar ga = br((lu) => {\n  \"use strict\";\n  var ya = va();\n  lu.createRoot = ya.createRoot, lu.hydrateRoot = ya.hydrateRoot;\n  var Of;\n});\nvar Sa = Pa(ga());\nvar { createRoot: If, hydrateRoot: jf } = Sa;\nvar { default: wa, ...Tf } = Sa;\n\n// https://deno.land/x/murmur_hash_3@1.0.0/mod.ts\nvar C1 = 3432918353;\nvar C2 = 461845907;\nvar R1 = 15;\nvar R2 = 13;\nvar M2 = 5;\nvar N2 = 3864292196;\nvar textEncoder = new TextEncoder();\nvar rotateLeft = (m, n) => {\n  return m << n | m >>> 32 - n;\n};\nvar murmurHash3 = (key, seed = 0) => {\n  const bytes = textEncoder.encode(key);\n  let hash = seed >>> 0;\n  const remainingBytes = bytes.length % 4;\n  const fourByteChunks = bytes.length - remainingBytes;\n  let i = 0;\n  for (; i < fourByteChunks; i += 4) {\n    let k3 = (bytes[i] & 255) + ((bytes[i + 1] & 255) << 8) + ((bytes[i + 2] & 255) << 16) + ((bytes[i + 3] & 255) << 24);\n    k3 = Math.imul(k3, C1);\n    k3 = rotateLeft(k3, R1);\n    k3 = Math.imul(k3, C2);\n    hash ^= k3;\n    hash = rotateLeft(hash, R2);\n    hash = Math.imul(hash, M2) + N2;\n  }\n  let k2 = 0;\n  switch (remainingBytes) {\n    case 3:\n      k2 |= (bytes[i + 2] & 255) << 16;\n    case 2:\n      k2 |= (bytes[i + 1] & 255) << 8;\n    case 1:\n      k2 |= bytes[i] & 255;\n      k2 = Math.imul(k2, C1);\n      k2 = rotateLeft(k2, R1);\n      k2 = Math.imul(k2, C2);\n      hash ^= k2;\n  }\n  hash ^= bytes.length;\n  hash ^= hash >>> 16;\n  hash = Math.imul(hash, 2246822507);\n  hash ^= hash >>> 13;\n  hash = Math.imul(hash, 3266489909);\n  hash ^= hash >>> 16;\n  return hash >>> 0;\n};\n\n// cssInJs/mod.ts\nvar definyCssInJsId = \"definy-css-in-js\";\nvar stylePropertyNameCamelCaseToKebabCaseMap = /* @__PURE__ */ new Map([\n  [\"textAlign\", \"text-align\"],\n  [\"fontSize\", \"font-size\"],\n  [\"lineHeight\", \"line-height\"],\n  [\"backgroundColor\", \"background-color\"],\n  [\"borderRadius\", \"border-radius\"],\n  [\"boxSizing\", \"box-sizing\"],\n  [\"alignContent\", \"align-content\"],\n  [\"overflowY\", \"overflow-y\"],\n  [\"overflowWrap\", \"overflow-wrap\"],\n  [\"gridTemplateColumns\", \"grid-template-columns\"],\n  [\"gridTemplateRows\", \"grid-template-rows\"],\n  [\"whiteSpace\", \"white-space\"],\n  [\"borderStyle\", \"border-style\"],\n  [\"borderColor\", \"border-color\"],\n  [\"fontFamily\", \"font-family\"],\n  [\"fontWeight\", \"font-weight\"],\n  [\"gridColumn\", \"grid-column\"],\n  [\"gridRow\", \"grid-row\"],\n  [\"justifySelf\", \"justify-self\"],\n  [\"alignSelf\", \"align-self\"],\n  [\"minHeight\", \"min-height\"],\n  [\"alignItems\", \"align-items\"],\n  [\"paddingLeft\", \"padding-left\"],\n  [\"textDecoration\", \"text-decoration\"],\n  [\"flexGrow\", \"flex-grow\"],\n  [\"backdropFilter\", \"backdrop-filter\"],\n  [\"zIndex\", \"z-index\"]\n]);\nvar insertedStyle = /* @__PURE__ */ new Map();\nvar hashToClassName = (hash) => \"d_\" + hash;\nvar toStyleAndHash = (style2, state) => {\n  const stateStyle = {\n    hover: state?.hover ?? {},\n    disabled: state?.disabled ?? {},\n    focus: state?.focus ?? {}\n  };\n  const hash = hashStyle(style2, stateStyle);\n  return {\n    style: style2,\n    stateStyle,\n    hash\n  };\n};\nvar c = (styleAndHash) => {\n  const className = hashToClassName(styleAndHash.hash);\n  if (insertedStyle.has(styleAndHash.hash)) {\n    return className;\n  }\n  insertedStyle.set(styleAndHash.hash, {\n    style: styleAndHash.style,\n    state: styleAndHash.stateStyle\n  });\n  if (globalThis.document === void 0) {\n    return className;\n  }\n  const cssString = styleAndStateStyleToCssString(\n    className,\n    styleAndHash.style,\n    styleAndHash.stateStyle\n  );\n  console.log(cssString);\n  const styleElement = document.getElementById(definyCssInJsId);\n  if (styleElement instanceof HTMLStyleElement) {\n    styleElement.append(cssString);\n    return className;\n  }\n  const createdStyleElement = document.createElement(\"style\");\n  createdStyleElement.id = definyCssInJsId;\n  document.head.appendChild(createdStyleElement);\n  createdStyleElement.textContent = cssString;\n  return className;\n};\nvar hashStyle = (style2, state) => {\n  return murmurHash3(styleAndStateStyleToCssString(\"\", style2, state)).toString(\n    16\n  );\n};\nvar styleAndStateStyleToCssString = (className, style2, stateStyle) => {\n  return styleToCssString(\".\" + className, style2) + styleToCssString(\".\" + className + \":hover\", stateStyle.hover) + styleToCssString(\".\" + className + \":disabled\", stateStyle.disabled);\n};\nvar styleToCssString = (selector, style2) => {\n  const declarations = Object.entries(style2);\n  if (declarations.length === 0) {\n    return \"\";\n  }\n  return selector + \" {\\n\" + declarations.map(([key, value]) => {\n    if (value === void 0) {\n      return \"\";\n    }\n    return (stylePropertyNameCamelCaseToKebabCaseMap.get(key) ?? key) + \":\" + (typeof value === \"number\" && value !== 0 ? value + \"px\" : value) + \";\";\n  }).join(\"\\n\") + \"\\n}\";\n};\n\n// editor/Button.tsx\nvar style = toStyleAndHash(\n  {\n    cursor: \"pointer\",\n    border: \"none\",\n    padding: 8,\n    textAlign: \"left\",\n    fontSize: 16,\n    backgroundColor: \"#333\",\n    color: \"#ddd\",\n    borderRadius: 16\n  },\n  {\n    hover: {\n      backgroundColor: \"#444\",\n      color: \"#dfdfdf\"\n    },\n    disabled: {\n      cursor: \"not-allowed\",\n      backgroundColor: \"#000\",\n      borderRadius: 0\n    }\n  }\n);\nvar Button = (props) => /* @__PURE__ */ We.createElement(\"button\", {\n  className: c(style),\n  onClick: props.onClick,\n  disabled: props.onClick === void 0\n}, props.children);\n\n// definyRpc/core/coreType.ts\nvar String2 = {\n  type: () => Type.from({\n    namespace: Namespace.coreType,\n    name: \"String\",\n    parameters: []\n  })\n};\nvar Bool = {\n  type: () => Type.from({ namespace: Namespace.coreType, name: \"Bool\", parameters: [] })\n};\nvar StructuredJsonValue = {\n  type: () => Type.from({\n    namespace: Namespace.coreType,\n    name: \"StructuredJsonValue\",\n    parameters: []\n  }),\n  string: (p) => ({\n    type: \"string\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.StructuredJsonValue\"\n  }),\n  array: (p) => ({\n    type: \"array\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.StructuredJsonValue\"\n  }),\n  boolean: (p) => ({\n    type: \"boolean\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.StructuredJsonValue\"\n  }),\n  null: { type: \"null\", [Symbol.toStringTag]: \"*coreType.StructuredJsonValue\" },\n  number: (p) => ({\n    type: \"number\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.StructuredJsonValue\"\n  }),\n  object: (p) => ({\n    type: \"object\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.StructuredJsonValue\"\n  })\n};\nvar List = {\n  type: (element) => Type.from({\n    namespace: Namespace.coreType,\n    name: \"List\",\n    parameters: [element]\n  })\n};\nvar Maybe = {\n  type: (element) => Type.from({\n    namespace: Namespace.coreType,\n    name: \"Maybe\",\n    parameters: [element]\n  }),\n  just: (p) => ({\n    type: \"just\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.Maybe\"\n  }),\n  nothing: () => ({\n    type: \"nothing\",\n    [Symbol.toStringTag]: \"*coreType.Maybe\"\n  })\n};\nvar Result = {\n  type: (ok, error) => Type.from({\n    namespace: Namespace.coreType,\n    name: \"Result\",\n    parameters: [ok, error]\n  }),\n  ok: (p) => ({\n    type: \"ok\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.Result\"\n  }),\n  error: (p) => ({\n    type: \"error\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.Result\"\n  })\n};\nvar Namespace = {\n  type: () => Type.from({\n    namespace: Namespace.coreType,\n    name: \"Namespace\",\n    parameters: []\n  }),\n  local: (p) => ({\n    type: \"local\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.Namespace\"\n  }),\n  coreType: { type: \"coreType\", [Symbol.toStringTag]: \"*coreType.Namespace\" },\n  typedJson: { type: \"typedJson\", [Symbol.toStringTag]: \"*coreType.Namespace\" },\n  request: { type: \"request\", [Symbol.toStringTag]: \"*coreType.Namespace\" },\n  meta: { type: \"meta\", [Symbol.toStringTag]: \"*coreType.Namespace\" }\n};\nvar DefinyRpcTypeInfo = {\n  type: () => Type.from({\n    namespace: Namespace.coreType,\n    name: \"DefinyRpcTypeInfo\",\n    parameters: []\n  }),\n  from: (obj) => ({\n    namespace: obj.namespace,\n    name: obj.name,\n    description: obj.description,\n    parameter: obj.parameter,\n    attribute: obj.attribute,\n    body: obj.body,\n    [Symbol.toStringTag]: \"*coreType.DefinyRpcTypeInfo\"\n  })\n};\nvar TypeParameterInfo = {\n  type: () => Type.from({\n    namespace: Namespace.coreType,\n    name: \"TypeParameterInfo\",\n    parameters: []\n  }),\n  from: (obj) => ({\n    name: obj.name,\n    description: obj.description,\n    [Symbol.toStringTag]: \"*coreType.TypeParameterInfo\"\n  })\n};\nvar TypeAttribute = {\n  type: () => Type.from({\n    namespace: Namespace.coreType,\n    name: \"TypeAttribute\",\n    parameters: []\n  }),\n  asType: { type: \"asType\", [Symbol.toStringTag]: \"*coreType.TypeAttribute\" }\n};\nvar TypeBody = {\n  type: () => Type.from({\n    namespace: Namespace.coreType,\n    name: \"TypeBody\",\n    parameters: []\n  }),\n  string: { type: \"string\", [Symbol.toStringTag]: \"*coreType.TypeBody\" },\n  number: { type: \"number\", [Symbol.toStringTag]: \"*coreType.TypeBody\" },\n  boolean: { type: \"boolean\", [Symbol.toStringTag]: \"*coreType.TypeBody\" },\n  unit: { type: \"unit\", [Symbol.toStringTag]: \"*coreType.TypeBody\" },\n  list: { type: \"list\", [Symbol.toStringTag]: \"*coreType.TypeBody\" },\n  set: { type: \"set\", [Symbol.toStringTag]: \"*coreType.TypeBody\" },\n  map: { type: \"map\", [Symbol.toStringTag]: \"*coreType.TypeBody\" },\n  url: { type: \"url\", [Symbol.toStringTag]: \"*coreType.TypeBody\" },\n  product: (p) => ({\n    type: \"product\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.TypeBody\"\n  }),\n  sum: (p) => ({\n    type: \"sum\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.TypeBody\"\n  })\n};\nvar Field = {\n  type: () => Type.from({ namespace: Namespace.coreType, name: \"Field\", parameters: [] }),\n  from: (obj) => ({\n    name: obj.name,\n    description: obj.description,\n    type: obj.type,\n    [Symbol.toStringTag]: \"*coreType.Field\"\n  })\n};\nvar Pattern = {\n  type: () => Type.from({\n    namespace: Namespace.coreType,\n    name: \"Pattern\",\n    parameters: []\n  }),\n  from: (obj) => ({\n    name: obj.name,\n    description: obj.description,\n    parameter: obj.parameter,\n    [Symbol.toStringTag]: \"*coreType.Pattern\"\n  })\n};\nvar Type = {\n  type: () => Type.from({ namespace: Namespace.coreType, name: \"Type\", parameters: [] }),\n  from: (obj) => ({\n    namespace: obj.namespace,\n    name: obj.name,\n    parameters: obj.parameters,\n    [Symbol.toStringTag]: \"*coreType.Type\",\n    __typeVariable: {}\n  })\n};\nvar FunctionNamespace = {\n  type: () => Type.from({\n    namespace: Namespace.coreType,\n    name: \"FunctionNamespace\",\n    parameters: []\n  }),\n  meta: { type: \"meta\", [Symbol.toStringTag]: \"*coreType.FunctionNamespace\" },\n  local: (p) => ({\n    type: \"local\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.FunctionNamespace\"\n  })\n};\n\n// definyRpc/codeGen/namespace.ts\nvar namespaceToString = (namespace) => {\n  switch (namespace.type) {\n    case \"typedJson\":\n      return \"*typedJson\";\n    case \"request\":\n      return \"*request\";\n    case \"coreType\":\n      return \"*coreType\";\n    case \"meta\":\n      return \"*meta\";\n    case \"local\":\n      return namespace.value.join(\".\");\n  }\n};\nvar namespaceEqual = (a, b) => {\n  return namespaceToString(a) === namespaceToString(b);\n};\nvar functionNamespaceToString = (functionNamespace2) => {\n  if (functionNamespace2.type === \"meta\") {\n    return \"*meta\";\n  }\n  return functionNamespace2.value.join(\".\");\n};\n\n// definyRpc/clientEditor/DetailView.tsx\nvar containerStyle = toStyleAndHash({\n  overflowWrap: \"anywhere\"\n});\nvar box = toStyleAndHash({\n  padding: 8\n});\nvar DetailView = (props) => {\n  if (props.selectedFuncName === void 0) {\n    return /* @__PURE__ */ We.createElement(\"div\", null, /* @__PURE__ */ We.createElement(\"h2\", null, \"\\u672A\\u9078\\u629E\"));\n  }\n  const selectedFuncDetail = props.functionList.find(\n    (func) => functionNamespaceToString(func.namespace) + \".\" + func.name === props.selectedFuncName\n  );\n  if (selectedFuncDetail === void 0) {\n    return /* @__PURE__ */ We.createElement(\"div\", null, /* @__PURE__ */ We.createElement(\"h2\", null, \"\\u4E0D\\u660E\\u306A\\u95A2\\u6570\"));\n  }\n  return /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(containerStyle)\n  }, /* @__PURE__ */ We.createElement(\"div\", null, functionNamespaceToString(selectedFuncDetail.namespace)), /* @__PURE__ */ We.createElement(\"h2\", null, selectedFuncDetail.name), /* @__PURE__ */ We.createElement(\"div\", null, selectedFuncDetail.description), /* @__PURE__ */ We.createElement(\"div\", null, \"\\u5165\\u529B input:\", /* @__PURE__ */ We.createElement(TypeView, {\n    type: selectedFuncDetail.input,\n    typeList: props.typeList\n  })), /* @__PURE__ */ We.createElement(\"div\", null, \"\\u51FA\\u529B output:\", /* @__PURE__ */ We.createElement(TypeView, {\n    type: selectedFuncDetail.output,\n    typeList: props.typeList\n  })));\n};\nvar TypeView = (props) => {\n  const [isOpen, setIsOpen] = We.useState(false);\n  const typeInfo = props.typeList.find(\n    (t) => namespaceEqual(t.namespace, props.type.namespace) && t.name === props.type.name\n  );\n  return /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(box)\n  }, /* @__PURE__ */ We.createElement(\"div\", null, namespaceToString(props.type.namespace) + \".\" + props.type.name), isOpen ? /* @__PURE__ */ We.createElement(\"div\", null, /* @__PURE__ */ We.createElement(\"button\", {\n    onClick: () => {\n      setIsOpen(false);\n    }\n  }, \"\\u25BC\"), /* @__PURE__ */ We.createElement(\"div\", null, typeInfo ? /* @__PURE__ */ We.createElement(TypeInfoView, {\n    typeInfo,\n    typeList: props.typeList\n  }) : /* @__PURE__ */ We.createElement(We.Fragment, null))) : /* @__PURE__ */ We.createElement(\"div\", null, /* @__PURE__ */ We.createElement(\"button\", {\n    onClick: () => {\n      setIsOpen(true);\n    }\n  }, \"\\u25B6\")), /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(box)\n  }, props.type.parameters.map((parameter, index2) => /* @__PURE__ */ We.createElement(TypeView, {\n    key: index2,\n    type: parameter,\n    typeList: props.typeList\n  }))));\n};\nvar TypeInfoView = (props) => {\n  return /* @__PURE__ */ We.createElement(\"div\", null, /* @__PURE__ */ We.createElement(\"div\", null, props.typeInfo.description), /* @__PURE__ */ We.createElement(TypeBodyView, {\n    typeBody: props.typeInfo.body,\n    typeList: props.typeList\n  }));\n};\nvar TypeBodyView = (props) => {\n  switch (props.typeBody.type) {\n    case \"string\":\n      return /* @__PURE__ */ We.createElement(\"div\", null, \"string\");\n    case \"number\":\n      return /* @__PURE__ */ We.createElement(\"div\", null, \"number\");\n    case \"boolean\":\n      return /* @__PURE__ */ We.createElement(\"div\", null, \"boolean\");\n    case \"unit\":\n      return /* @__PURE__ */ We.createElement(\"div\", null, \"unit\");\n    case \"list\":\n      return /* @__PURE__ */ We.createElement(\"div\", null, \"list\");\n    case \"set\":\n      return /* @__PURE__ */ We.createElement(\"div\", null, \"set\");\n    case \"map\":\n      return /* @__PURE__ */ We.createElement(\"div\", null, \"map\");\n    case \"url\":\n      return /* @__PURE__ */ We.createElement(\"div\", null, \"url\");\n    case \"product\": {\n      return /* @__PURE__ */ We.createElement(\"div\", null, /* @__PURE__ */ We.createElement(\"div\", null, \"product\"), /* @__PURE__ */ We.createElement(\"div\", null, props.typeBody.value.map((field2) => /* @__PURE__ */ We.createElement(\"div\", null, /* @__PURE__ */ We.createElement(\"div\", null, field2.name), /* @__PURE__ */ We.createElement(\"div\", null, field2.description), /* @__PURE__ */ We.createElement(TypeView, {\n        type: field2.type,\n        typeList: props.typeList\n      })))));\n    }\n    case \"sum\": {\n      return /* @__PURE__ */ We.createElement(\"div\", null, /* @__PURE__ */ We.createElement(\"div\", null, \"product\"), /* @__PURE__ */ We.createElement(\"div\", null, props.typeBody.value.map((pattern2) => /* @__PURE__ */ We.createElement(\"div\", null, /* @__PURE__ */ We.createElement(\"div\", null, pattern2.name), /* @__PURE__ */ We.createElement(\"div\", null, pattern2.description), pattern2.parameter.type === \"just\" && /* @__PURE__ */ We.createElement(TypeView, {\n        type: pattern2.parameter.value,\n        typeList: props.typeList\n      })))));\n    }\n  }\n};\n\n// typedJson.ts\nvar jsonParse = (value) => {\n  try {\n    return JSON.parse(value);\n  } catch (e) {\n    console.error(\"json \\u306E\\u30D1\\u30FC\\u30B9\\u30A8\\u30E9\\u30FC\", e);\n    return void 0;\n  }\n};\nvar structuredJsonParse = (value) => {\n  const rawJson = jsonParse(value);\n  if (rawJson === void 0) {\n    return void 0;\n  }\n  return rawJsonToStructuredJsonValue(rawJson);\n};\nvar rawJsonToStructuredJsonValue = (rawJson) => {\n  if (rawJson === null) {\n    return StructuredJsonValue.null;\n  }\n  if (typeof rawJson === \"boolean\") {\n    return StructuredJsonValue.boolean(rawJson);\n  }\n  if (typeof rawJson === \"string\") {\n    return StructuredJsonValue.string(rawJson);\n  }\n  if (typeof rawJson === \"number\") {\n    return StructuredJsonValue.number(rawJson);\n  }\n  if (rawJson instanceof Array) {\n    return StructuredJsonValue.array(rawJson.map(rawJsonToStructuredJsonValue));\n  }\n  return StructuredJsonValue.object(\n    new Map(\n      Object.entries(rawJson).map(([k2, v]) => [\n        k2,\n        rawJsonToStructuredJsonValue(v)\n      ])\n    )\n  );\n};\nvar jsonStringify = (jsonValue, indent = false) => {\n  if (indent) {\n    return JSON.stringify(jsonValue, void 0, 2);\n  }\n  return JSON.stringify(jsonValue);\n};\nvar structuredJsonStringify = (structuredJsonValue2, indent = false) => {\n  return jsonStringify(\n    structuredJsonValueToRawJson(structuredJsonValue2),\n    indent\n  );\n};\nvar structuredJsonValueToRawJson = (structuredJsonValue2) => {\n  switch (structuredJsonValue2.type) {\n    case \"null\":\n      return null;\n    case \"string\":\n      return structuredJsonValue2.value;\n    case \"number\":\n      return structuredJsonValue2.value;\n    case \"boolean\":\n      return structuredJsonValue2.value;\n    case \"array\":\n      return structuredJsonValue2.value.map(structuredJsonValueToRawJson);\n    case \"object\":\n      return Object.fromEntries(\n        [...structuredJsonValue2.value.entries()].map(\n          ([k2, v]) => [k2, structuredJsonValueToRawJson(v)]\n        )\n      );\n  }\n};\n\n// definyRpc/clientEditor/Result.tsx\nvar requestingStyle = toStyleAndHash({\n  backgroundColor: \"gray\",\n  height: 32\n});\nvar resultStyle = toStyleAndHash({\n  whiteSpace: \"pre-wrap\",\n  borderStyle: \"solid\",\n  borderColor: \"#ccc\",\n  padding: 8,\n  overflowWrap: \"anywhere\"\n});\nvar Result2 = (props) => {\n  const [responseToClipboardLoading, setResponseToClipboardLoading] = We.useState(false);\n  if (props.requesting) {\n    return /* @__PURE__ */ We.createElement(\"div\", {\n      className: c(requestingStyle)\n    });\n  }\n  const data3 = props.data;\n  return /* @__PURE__ */ We.createElement(\"div\", null, typeof data3 === \"string\" && /* @__PURE__ */ We.createElement(Button, {\n    onClick: responseToClipboardLoading ? void 0 : () => {\n      setResponseToClipboardLoading(true);\n      navigator.clipboard.writeText(data3).then(() => {\n        setResponseToClipboardLoading(false);\n      });\n    }\n  }, \"\\u30AF\\u30EA\\u30C3\\u30D7\\u30DC\\u30FC\\u30C9\\u306B\\u30B3\\u30D4\\u30FC\"), /* @__PURE__ */ We.createElement(\"div\", null, /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(resultStyle)\n  }, typeof data3 === \"string\" ? data3 : jsonStringify(data3))));\n};\n\n// definyRpc/clientEditor/Select.tsx\nvar readonlyStyle = toStyleAndHash({\n  display: \"grid\",\n  borderStyle: \"solid\",\n  borderColor: \"white\",\n  borderRadius: 8,\n  fontFamily: \"monospace\",\n  fontSize: 18,\n  padding: \"4px 8px\"\n});\nvar containerStyle2 = toStyleAndHash({\n  display: \"grid\",\n  borderStyle: \"solid\",\n  borderColor: \"white\",\n  borderRadius: 8\n});\nvar inputStyle = toStyleAndHash({\n  fontFamily: \"monospace\",\n  fontSize: 18,\n  padding: \"0 8px\",\n  backgroundColor: \"#000\",\n  color: \"white\"\n});\nvar suggestionContainerStyle = toStyleAndHash({\n  display: \"grid\",\n  gap: 1\n});\nvar suggestionItemStyle = toStyleAndHash({\n  fontFamily: \"monospace\",\n  fontSize: 18,\n  textAlign: \"left\",\n  cursor: \"pointer\"\n});\nvar Select = (props) => {\n  const [isFocus, setIsFocus] = We.useState(false);\n  const onBlur = We.useCallback(\n    (value) => {\n      props.onSelect(value);\n      setIsFocus(false);\n    },\n    [props.onSelect]\n  );\n  if (isFocus) {\n    return /* @__PURE__ */ We.createElement(SelectActive, {\n      values: props.values,\n      value: props.value,\n      onSelect: props.onSelect,\n      onSelectAndExit: onBlur\n    });\n  }\n  return /* @__PURE__ */ We.createElement(\"div\", {\n    onFocus: () => {\n      setIsFocus(true);\n    },\n    tabIndex: -1,\n    className: c(readonlyStyle)\n  }, /* @__PURE__ */ We.createElement(\"div\", null, props.value ?? \"???\"));\n};\nvar SelectActive = (props) => {\n  const [inputText, setInputText] = We.useState(props.value ?? \"\");\n  const inputElementRef = We.useRef(null);\n  const [initValue] = We.useState(props.value);\n  const [suggestionList, setSuggestionList] = We.useState(\n    createSuggestionSorted({ values: props.values ?? [], inputText })\n  );\n  We.useEffect(() => {\n    inputElementRef.current?.setSelectionRange(0, inputText.length);\n  }, [inputElementRef.current]);\n  const onInput = We.useCallback(\n    (e) => {\n      const newInputText = e.target.value;\n      setInputText(newInputText);\n      if (props.values === void 0) {\n        return;\n      }\n      const newSuggestionList = createSuggestionSorted({\n        values: props.values,\n        inputText: newInputText\n      });\n      setSuggestionList(newSuggestionList);\n      props.onSelect(newSuggestionList[0]?.value);\n    },\n    [props.onSelect]\n  );\n  return /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(containerStyle2)\n  }, /* @__PURE__ */ We.createElement(\"input\", {\n    autoFocus: true,\n    ref: inputElementRef,\n    type: \"text\",\n    className: c(inputStyle),\n    value: inputText,\n    onChange: onInput,\n    onKeyDown: (e) => {\n      if (e.key === \"ArrowDown\") {\n        if (props.values === void 0) {\n          return;\n        }\n        const index2 = suggestionList.findIndex(\n          (s) => s.value === props.value\n        );\n        const newValue = suggestionList[(index2 + 1) % suggestionList.length]?.value;\n        if (newValue !== void 0) {\n          props.onSelect(newValue);\n          setInputText(newValue);\n        }\n      }\n      if (e.key === \"ArrowUp\") {\n        if (props.values === void 0) {\n          return;\n        }\n        const index2 = suggestionList.findIndex(\n          (s) => s.value === props.value\n        );\n        const newValue = suggestionList[(index2 - 1 + suggestionList.length) % suggestionList.length]?.value;\n        if (newValue !== void 0) {\n          props.onSelect(newValue);\n          setInputText(newValue);\n        }\n      }\n      if (e.key === \"Enter\") {\n        props.onSelectAndExit(props.value);\n      }\n      if (e.key === \"Escape\") {\n        props.onSelectAndExit(initValue);\n      }\n    }\n  }), /* @__PURE__ */ We.createElement(Suggestion, {\n    value: props.value,\n    suggestionList: props.values === void 0 ? void 0 : suggestionList,\n    inputText,\n    onSelect: props.onSelectAndExit\n  }));\n};\nvar Suggestion = (props) => {\n  if (props.suggestionList === void 0) {\n    return /* @__PURE__ */ We.createElement(\"div\", null, \"loading...\");\n  }\n  if (props.suggestionList.length === 0) {\n    return /* @__PURE__ */ We.createElement(\"div\", null, \"\\u5019\\u88DC\\u306A\\u3057\");\n  }\n  return /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(suggestionContainerStyle)\n  }, props.suggestionList.map((v) => /* @__PURE__ */ We.createElement(\"button\", {\n    key: v.value,\n    className: c(\n      toStyleAndHash({\n        backgroundColor: v.value === props.value ? \"#511\" : \"transparent\",\n        fontFamily: \"monospace\",\n        fontSize: 18,\n        textAlign: \"left\",\n        cursor: \"pointer\",\n        ...v.value === props.value ? {} : {\n          \":hover\": {\n            backgroundColor: \"#333\"\n          }\n        }\n      })\n    ),\n    onClick: () => {\n      props.onSelect(v.value);\n    }\n  }, v.text.map((s, index2) => /* @__PURE__ */ We.createElement(\"span\", {\n    key: index2,\n    className: c(\n      toStyleAndHash({\n        color: s.emphasis ? \"#faa\" : \"white\",\n        fontWeight: s.emphasis ? \"bold\" : \"normal\"\n      })\n    )\n  }, s.text)))));\n};\nvar createSuggestionSorted = (parameter) => {\n  const result2 = [...createSuggestionWithPoint(parameter)];\n  result2.sort((a, b) => b.point - a.point);\n  return result2;\n};\nvar createSuggestionWithPoint = (parameter) => {\n  const normalizedSearchText = parameter.inputText.trim().toLocaleLowerCase();\n  return parameter.values.map((value) => {\n    const name2 = functionNamespaceToString(value.namespace) + \".\" + value.name;\n    const includeIndex = name2.toLocaleLowerCase().indexOf(normalizedSearchText);\n    if (includeIndex === -1) {\n      return {\n        value: name2,\n        text: [{ text: name2, emphasis: false }],\n        point: 0\n      };\n    }\n    return {\n      value: name2,\n      text: [\n        { text: name2.slice(0, includeIndex), emphasis: false },\n        {\n          text: name2.slice(\n            includeIndex,\n            includeIndex + normalizedSearchText.length\n          ),\n          emphasis: true\n        },\n        {\n          text: name2.slice(includeIndex + normalizedSearchText.length),\n          emphasis: false\n        }\n      ],\n      point: name2.length - normalizedSearchText.length + name2.length - includeIndex\n    };\n  });\n};\n\n// definyRpc/core/collectType.ts\nvar createTypeKey = (namespace, typeName) => {\n  return namespaceToString(namespace) + \".\" + typeName;\n};\nvar collectedDefinyRpcTypeMapGet = (map4, namespace, typeName) => {\n  const typeInfo = map4.get(createTypeKey(namespace, typeName));\n  if (typeInfo === void 0) {\n    throw new Error(\n      \"type (\" + createTypeKey(namespace, typeName) + \") not found. in [\" + [...map4.keys()].join(\", \") + \"]\"\n    );\n  }\n  return typeInfo;\n};\n\n// definyRpc/core/fromStructuredJson.ts\nvar changeType = (type2) => type2;\nvar fromStructuredJsonValue = (type2, typeMap, jsonValue) => {\n  const typeInfo = collectedDefinyRpcTypeMapGet(\n    typeMap,\n    type2.namespace,\n    type2.name\n  );\n  switch (typeInfo.body.type) {\n    case \"string\": {\n      if (jsonValue.type !== \"string\") {\n        throw new Error(\n          `expected json string in String type (${createTypeKey(type2.namespace, type2.name)})`\n        );\n      }\n      return jsonValue.value;\n    }\n    case \"number\": {\n      if (jsonValue.type !== \"number\") {\n        throw new Error(\n          `expected json number in Number type (${createTypeKey(type2.namespace, type2.name)})`\n        );\n      }\n      return jsonValue.value;\n    }\n    case \"boolean\": {\n      if (jsonValue.type !== \"boolean\") {\n        throw new Error(\n          `expected json boolean in Bool type (${createTypeKey(type2.namespace, type2.name)})`\n        );\n      }\n      return jsonValue.value;\n    }\n    case \"unit\": {\n      return void 0;\n    }\n    case \"list\": {\n      const [elementType] = type2.parameters;\n      if (elementType === void 0) {\n        throw new Error(\n          `expected type parameter in List type (${createTypeKey(type2.namespace, type2.name)})`\n        );\n      }\n      if (jsonValue.type !== \"array\") {\n        throw new Error(\n          `expected json array in List type (${createTypeKey(type2.namespace, type2.name)})`\n        );\n      }\n      return jsonValue.value.map(\n        (element) => fromStructuredJsonValueConsiderTypeParameter(\n          type2.parameters,\n          typeInfo.parameter,\n          elementType,\n          typeMap,\n          element\n        )\n      );\n    }\n    case \"set\": {\n      const [elementType] = type2.parameters;\n      if (elementType === void 0) {\n        throw new Error(\n          `expected type parameter in Set type (${createTypeKey(type2.namespace, type2.name)})`\n        );\n      }\n      if (jsonValue.type !== \"array\") {\n        throw new Error(\n          `expected json array in List type (${createTypeKey(type2.namespace, type2.name)})`\n        );\n      }\n      return new Set(\n        jsonValue.value.map(\n          (element) => fromStructuredJsonValueConsiderTypeParameter(\n            type2.parameters,\n            typeInfo.parameter,\n            elementType,\n            typeMap,\n            element\n          )\n        )\n      );\n    }\n    case \"map\":\n      return toMap(\n        changeType(type2),\n        typeInfo,\n        typeMap,\n        jsonValue\n      );\n    case \"url\": {\n      if (jsonValue.type !== \"string\") {\n        throw new Error(\n          `expected json string in URL (${createTypeKey(type2.namespace, type2.name)})`\n        );\n      }\n      return new URL(jsonValue.value);\n    }\n    case \"product\":\n      return toProduct(\n        changeType(type2),\n        typeInfo,\n        typeMap,\n        jsonValue,\n        typeInfo.body.value\n      );\n    case \"sum\":\n      return toSum(\n        changeType(type2),\n        typeInfo,\n        typeMap,\n        jsonValue,\n        typeInfo.body.value\n      );\n  }\n};\nvar toMap = (type2, typeInfo, typeMap, jsonValue) => {\n  const [keyType, valueType] = type2.parameters;\n  if (keyType === void 0 || valueType === void 0) {\n    throw new Error(\n      `expected 2 type parameter in Map type (${createTypeKey(type2.namespace, type2.name)})`\n    );\n  }\n  if (jsonValue.type !== \"object\") {\n    throw new Error(\n      `expected json object in Map type (${createTypeKey(type2.namespace, type2.name)})`\n    );\n  }\n  return new Map(\n    [...jsonValue.value].map(\n      ([key, valueJson]) => {\n        const keyTypeInfo = collectedDefinyRpcTypeMapGet(\n          typeMap,\n          keyType.namespace,\n          keyType.name\n        );\n        if (keyTypeInfo.body.type === \"string\") {\n          return [\n            key,\n            fromStructuredJsonValueConsiderTypeParameter(\n              type2.parameters,\n              typeInfo.parameter,\n              changeType(valueType),\n              typeMap,\n              valueJson\n            )\n          ];\n        }\n        const keyJson = structuredJsonParse(key);\n        if (keyJson === void 0) {\n          throw new Error(\n            `Map \\u578B\\u306E\\u3068\\u304D\\u306B key \\u304C string \\u4EE5\\u5916\\u3067\\u306E\\u5834\\u5408\\u306F json \\u3068\\u3057\\u3066\\u89E3\\u91C8\\u3067\\u304D\\u308B\\u6587\\u5B57\\u5217\\u3067\\u3042\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059 (${createTypeKey(type2.namespace, type2.name)})`\n          );\n        }\n        return [\n          fromStructuredJsonValueConsiderTypeParameter(\n            type2.parameters,\n            typeInfo.parameter,\n            changeType(keyType),\n            typeMap,\n            keyJson\n          ),\n          fromStructuredJsonValueConsiderTypeParameter(\n            type2.parameters,\n            typeInfo.parameter,\n            changeType(valueType),\n            typeMap,\n            valueJson\n          )\n        ];\n      }\n    )\n  );\n};\nvar toProduct = (type2, typeInfo, typeMap, jsonValue, fields) => {\n  if (jsonValue.type !== \"object\") {\n    throw new Error(\n      `expected json object in product (${createTypeKey(type2.namespace, type2.name)})`\n    );\n  }\n  return Object.fromEntries([\n    ...fields.map((field2) => {\n      const fieldValueJson = jsonValue.value.get(field2.name);\n      if (fieldValueJson === void 0) {\n        throw new Error(\n          `${createTypeKey(type2.namespace, type2.name)} need ${field2.name} field (${createTypeKey(type2.namespace, type2.name)})`\n        );\n      }\n      return [\n        field2.name,\n        fromStructuredJsonValueConsiderTypeParameter(\n          type2.parameters,\n          typeInfo.parameter,\n          changeType(field2.type),\n          typeMap,\n          fieldValueJson\n        )\n      ];\n    }),\n    [\n      Symbol.toStringTag,\n      createTypeKey(type2.namespace, type2.name)\n    ]\n  ]);\n};\nvar toSum = (type2, typeInfo, typeMap, jsonValue, patternList) => {\n  if (jsonValue.type === \"string\") {\n    for (const pattern2 of patternList) {\n      if (pattern2.name === jsonValue.value) {\n        if (pattern2.parameter.type === \"just\") {\n          throw new Error(\n            `expected json object in sum pattern with parameter (${createTypeKey(type2.namespace, type2.name)})`\n          );\n        }\n        return {\n          type: pattern2.name,\n          [Symbol.toStringTag]: createTypeKey(\n            type2.namespace,\n            type2.name\n          )\n        };\n      }\n    }\n    throw new Error(\n      `unknown pattern name expected [${patternList.map((p) => p.name).join(\",\")}] but got ${jsonValue.value} (${createTypeKey(type2.namespace, type2.name)})`\n    );\n  }\n  if (jsonValue.type === \"object\") {\n    const typeFieldJson = jsonValue.value.get(\"type\");\n    if (typeFieldJson?.type !== \"string\") {\n      throw new Error(\n        `expected json string in sum pattern key (${createTypeKey(type2.namespace, type2.name)})`\n      );\n    }\n    for (const pattern2 of patternList) {\n      if (pattern2.name === typeFieldJson.value) {\n        if (pattern2.parameter.type === \"just\") {\n          const valueJson = jsonValue.value.get(\"value\");\n          if (valueJson === void 0) {\n            throw new Error(\n              `expected value field in sum pattern with parameter (${createTypeKey(type2.namespace, type2.name)})`\n            );\n          }\n          return {\n            type: pattern2.name,\n            value: fromStructuredJsonValueConsiderTypeParameter(\n              type2.parameters,\n              typeInfo.parameter,\n              pattern2.parameter.value,\n              typeMap,\n              valueJson\n            ),\n            [Symbol.toStringTag]: createTypeKey(\n              type2.namespace,\n              type2.name\n            )\n          };\n        }\n        return {\n          type: pattern2.name,\n          [Symbol.toStringTag]: createTypeKey(\n            type2.namespace,\n            type2.name\n          )\n        };\n      }\n    }\n    throw new Error(\n      `unknown pattern name expected [${patternList.map((p) => p.name).join(\",\")}] but got ${jsonValue.value} (${createTypeKey(type2.namespace, type2.name)})`\n    );\n  }\n  throw new Error(\n    `expected json object or string in sum (${createTypeKey(type2.namespace, type2.name)})`\n  );\n};\nvar fromStructuredJsonValueConsiderTypeParameter = (typeParameters, typeParameterInfoList, type2, typeMap, jsonValue) => {\n  if (typeParameters.length !== typeParameterInfoList.length) {\n    throw new Error(\n      \"\\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u306E\\u6570\\u304C\\u5408\\u308F\\u306A\\u3044! expected:\" + typeParameterInfoList.length + \" but got:\" + typeParameters.length\n    );\n  }\n  for (const [index2, typeParameter] of typeParameterInfoList.entries()) {\n    if (typeParameter.name === type2.name) {\n      const matchedTypeParameter = typeParameters[index2];\n      if (matchedTypeParameter === void 0) {\n        throw new Error(\"\\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u306E\\u6570\\u304C\\u5408\\u308F\\u306A\\u3044?\");\n      }\n      return fromStructuredJsonValue(\n        changeType(matchedTypeParameter),\n        typeMap,\n        jsonValue\n      );\n    }\n  }\n  return fromStructuredJsonValue(\n    type2,\n    typeMap,\n    jsonValue\n  );\n};\n\n// definyRpc/core/toStructuredJson.ts\nvar toStructuredJsonValue = (type2, typeMap, value) => {\n  const typeInfo = collectedDefinyRpcTypeMapGet(\n    typeMap,\n    type2.namespace,\n    type2.name\n  );\n  switch (typeInfo.body.type) {\n    case \"string\":\n      if (typeof value !== \"string\") {\n        throw new Error(\"expected string in toStructuredJsonValue\");\n      }\n      return StructuredJsonValue.string(value);\n    case \"number\":\n      if (typeof value !== \"number\") {\n        throw new Error(\"expected number in toStructuredJsonValue\");\n      }\n      return StructuredJsonValue.number(value);\n    case \"boolean\":\n      if (typeof value !== \"boolean\") {\n        throw new Error(\"expected boolean in toStructuredJsonValue\");\n      }\n      return StructuredJsonValue.boolean(value);\n    case \"unit\":\n      return StructuredJsonValue.null;\n    case \"list\": {\n      if (!(value instanceof Array)) {\n        throw new Error(\"expected Array in toStructuredJsonValue\");\n      }\n      const [elementType] = type2.parameters;\n      if (elementType === void 0) {\n        throw new Error(\n          `expected type parameter in List type (${createTypeKey(type2.namespace, type2.name)})`\n        );\n      }\n      return StructuredJsonValue.array(\n        value.map(\n          (element) => toStructuredJsonValueConsiderTypeParameter(\n            type2.parameters,\n            typeInfo.parameter,\n            elementType,\n            typeMap,\n            element\n          )\n        )\n      );\n    }\n    case \"set\": {\n      if (!(value instanceof Set)) {\n        throw new Error(\"expected Set in toStructuredJsonValue\");\n      }\n      const [elementType] = type2.parameters;\n      if (elementType === void 0) {\n        throw new Error(\n          `expected type parameter in Set type (${createTypeKey(type2.namespace, type2.name)})`\n        );\n      }\n      return StructuredJsonValue.array(\n        [...value].map(\n          (element) => toStructuredJsonValueConsiderTypeParameter(\n            type2.parameters,\n            typeInfo.parameter,\n            elementType,\n            typeMap,\n            element\n          )\n        )\n      );\n    }\n    case \"map\": {\n      if (!(value instanceof Map)) {\n        throw new Error(\"expected Map in toStructuredJsonValue\");\n      }\n      const [keyType, valueType] = type2.parameters;\n      if (keyType === void 0 || valueType === void 0) {\n        throw new Error(\n          `expected 2 type parameter in Map type (${createTypeKey(type2.namespace, type2.name)})`\n        );\n      }\n      const keyTypeInfo = collectedDefinyRpcTypeMapGet(\n        typeMap,\n        keyType.namespace,\n        keyType.name\n      );\n      if (keyTypeInfo.body.type === \"string\") {\n        return StructuredJsonValue.object(\n          new Map(\n            [...value].map(([key, value2]) => [\n              key,\n              toStructuredJsonValueConsiderTypeParameter(\n                type2.parameters,\n                typeInfo.parameter,\n                valueType,\n                typeMap,\n                value2\n              )\n            ])\n          )\n        );\n      }\n      return StructuredJsonValue.object(\n        new Map(\n          [...value].map(([key, value2]) => [\n            structuredJsonStringify(\n              toStructuredJsonValueConsiderTypeParameter(\n                type2.parameters,\n                typeInfo.parameter,\n                keyType,\n                typeMap,\n                key\n              )\n            ),\n            toStructuredJsonValueConsiderTypeParameter(\n              type2.parameters,\n              typeInfo.parameter,\n              valueType,\n              typeMap,\n              value2\n            )\n          ])\n        )\n      );\n    }\n    case \"url\": {\n      if (!(value instanceof URL)) {\n        throw new Error(\"expected Map in toStructuredJsonValue\");\n      }\n      return StructuredJsonValue.string(value.toString());\n    }\n    case \"product\": {\n      return StructuredJsonValue.object(\n        new Map(\n          typeInfo.body.value.map((field2) => [\n            field2.name,\n            toStructuredJsonValueConsiderTypeParameter(\n              type2.parameters,\n              typeInfo.parameter,\n              field2.type,\n              typeMap,\n              value[field2.name]\n            )\n          ])\n        )\n      );\n    }\n    case \"sum\": {\n      const valueObj = value;\n      if (typeInfo.body.value.every(\n        (pattern2) => pattern2.parameter.type === \"nothing\"\n      )) {\n        return StructuredJsonValue.string(valueObj.type);\n      }\n      for (const pattern2 of typeInfo.body.value) {\n        if (pattern2.name === valueObj.type) {\n          if (pattern2.parameter.type === \"just\") {\n            return StructuredJsonValue.object(\n              /* @__PURE__ */ new Map([\n                [\"type\", StructuredJsonValue.string(pattern2.name)],\n                [\n                  \"value\",\n                  toStructuredJsonValueConsiderTypeParameter(\n                    type2.parameters,\n                    typeInfo.parameter,\n                    pattern2.parameter.value,\n                    typeMap,\n                    valueObj.value\n                  )\n                ]\n              ])\n            );\n          }\n          return StructuredJsonValue.object(\n            /* @__PURE__ */ new Map([\n              [\"type\", StructuredJsonValue.string(pattern2.name)]\n            ])\n          );\n        }\n      }\n      throw new Error(\n        `unknown pattern name expected [${typeInfo.body.value.map((p) => p.name).join(\",\")}] but got ${valueObj.type} (${createTypeKey(type2.namespace, type2.name)})`\n      );\n    }\n  }\n};\nvar toStructuredJsonValueConsiderTypeParameter = (typeParameters, typeParameterInfoList, type2, typeMap, value) => {\n  if (typeParameters.length !== typeParameterInfoList.length) {\n    throw new Error(\n      \"\\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u306E\\u6570\\u304C\\u5408\\u308F\\u306A\\u3044! expected:\" + typeParameterInfoList.length + \" but got:\" + typeParameters.length\n    );\n  }\n  for (const [index2, typeParameter] of typeParameterInfoList.entries()) {\n    if (typeParameter.name === type2.name) {\n      const matchedTypeParameter = typeParameters[index2];\n      if (matchedTypeParameter === void 0) {\n        throw new Error(\"\\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u306E\\u6570\\u304C\\u5408\\u308F\\u306A\\u3044?\");\n      }\n      return toStructuredJsonValue(\n        matchedTypeParameter,\n        typeMap,\n        value\n      );\n    }\n  }\n  return toStructuredJsonValue(\n    type2,\n    typeMap,\n    value\n  );\n};\n\n// definyRpc/core/request.ts\nvar requestQuery = async (parameter) => {\n  const url = new URL(parameter.url.toString());\n  url.pathname = requestPath(url.pathname, parameter.namespace, parameter.name);\n  const inputAsStructuredJson = toStructuredJsonValue(\n    parameter.inputType,\n    parameter.typeMap,\n    parameter.input\n  );\n  try {\n    if (parameter.accountToken === void 0) {\n      const search = structuredJsonValueToUrlSearch(\n        inputAsStructuredJson\n      );\n      if (search !== void 0) {\n        for (const [key, value] of search) {\n          url.searchParams.set(key, value);\n        }\n        const response2 = await fetch(url);\n        const jsonValue2 = await response2.json();\n        return Result.ok(fromStructuredJsonValue(\n          parameter.outputType,\n          parameter.typeMap,\n          rawJsonToStructuredJsonValue(jsonValue2)\n        ));\n      }\n    }\n    const response = await fetch(url, {\n      method: \"POST\",\n      body: structuredJsonStringify(\n        parameter.accountToken === void 0 ? StructuredJsonValue.object(\n          /* @__PURE__ */ new Map([[\"input\", inputAsStructuredJson]])\n        ) : StructuredJsonValue.object(\n          /* @__PURE__ */ new Map([[\n            \"accountToken\",\n            StructuredJsonValue.string(parameter.accountToken)\n          ], [\n            \"input\",\n            inputAsStructuredJson\n          ]])\n        )\n      )\n    });\n    const jsonValue = await response.json();\n    return Result.ok(fromStructuredJsonValue(\n      parameter.outputType,\n      parameter.typeMap,\n      rawJsonToStructuredJsonValue(jsonValue)\n    ));\n  } catch (e) {\n    return Result.error(e.toString());\n  }\n};\nvar structuredJsonValueToUrlSearch = (structuredJsonValue2) => {\n  const search = structuredJsonValueToUrlSearchNoLimit(structuredJsonValue2);\n  if (2e3 < search.toString().length) {\n    return void 0;\n  }\n  return search;\n};\nvar structuredJsonValueToUrlSearchNoLimit = (structuredJsonValue2) => {\n  switch (structuredJsonValue2.type) {\n    case \"string\":\n      return new URLSearchParams({ q: structuredJsonValue2.value });\n    case \"number\":\n      return new URLSearchParams({ q: structuredJsonValue2.value.toString() });\n    case \"boolean\":\n      return new URLSearchParams({ q: structuredJsonValue2.value.toString() });\n    case \"null\":\n      return new URLSearchParams({});\n    case \"array\":\n      return new URLSearchParams({\n        q: structuredJsonStringify(structuredJsonValue2)\n      });\n    case \"object\": {\n      const search = new URLSearchParams(\n        [...structuredJsonValue2.value].map(([key, value]) => [key, structuredJsonStringify(value)])\n      );\n      search.sort();\n      return search;\n    }\n  }\n};\nvar requestPath = (pathname, namespace, name2) => {\n  return pathname + (pathname.endsWith(\"/\") ? \"\" : \"/\") + (namespace.type === \"meta\" ? \"meta/\" : \"api/\" + namespace.value.join(\"/\") + \"/\") + name2;\n};\n\n// definyRpc/core/coreTypeInfo.ts\nvar string = DefinyRpcTypeInfo.from({\n  namespace: Namespace.coreType,\n  name: \"String\",\n  description: \"\\u6587\\u5B57\\u5217\",\n  parameter: [],\n  attribute: Maybe.nothing(),\n  body: TypeBody.string\n});\nvar bool = DefinyRpcTypeInfo.from({\n  namespace: Namespace.coreType,\n  name: \"Bool\",\n  description: \"Bool. boolean. \\u771F\\u507D\\u5024. True \\u304B False\",\n  parameter: [],\n  attribute: Maybe.nothing(),\n  body: TypeBody.boolean\n});\nvar number = DefinyRpcTypeInfo.from({\n  namespace: Namespace.coreType,\n  name: \"Number\",\n  description: \"64bit \\u6D6E\\u52D5\\u5C0F\\u6570\\u70B9\\u6570\",\n  parameter: [],\n  attribute: Maybe.nothing(),\n  body: TypeBody.number\n});\nvar unit = DefinyRpcTypeInfo.from({\n  namespace: Namespace.coreType,\n  name: \"Unit\",\n  description: \"\\u5024\\u304C1\\u3064\\u3060\\u3051\",\n  parameter: [],\n  attribute: Maybe.nothing(),\n  body: TypeBody.unit\n});\nvar structuredJsonValue = DefinyRpcTypeInfo.from({\n  namespace: Namespace.coreType,\n  name: \"StructuredJsonValue\",\n  description: \"\\u69CB\\u9020\\u5316\\u3055\\u308C\\u305FJSON\",\n  parameter: [],\n  attribute: Maybe.nothing(),\n  body: TypeBody.sum([\n    Pattern.from({\n      name: \"string\",\n      description: \"string\",\n      parameter: Maybe.just(String2.type())\n    }),\n    Pattern.from({\n      name: \"array\",\n      description: \"array\",\n      parameter: Maybe.just(\n        List.type(StructuredJsonValue.type())\n      )\n    }),\n    Pattern.from({\n      name: \"boolean\",\n      description: \"boolean\",\n      parameter: Maybe.just(Bool.type())\n    }),\n    Pattern.from({\n      name: \"null\",\n      description: \"null\",\n      parameter: Maybe.nothing()\n    }),\n    Pattern.from({\n      name: \"number\",\n      description: \"number\",\n      parameter: Maybe.just(\n        Type.from({\n          namespace: Namespace.coreType,\n          name: number.name,\n          parameters: []\n        })\n      )\n    }),\n    Pattern.from({\n      name: \"object\",\n      description: \"object\",\n      parameter: Maybe.just(Type.from({\n        namespace: Namespace.coreType,\n        name: \"Map\",\n        parameters: [\n          Type.from({\n            name: \"String\",\n            namespace: Namespace.coreType,\n            parameters: []\n          }),\n          Type.from({\n            name: \"StructuredJsonValue\",\n            namespace: Namespace.coreType,\n            parameters: []\n          })\n        ]\n      }))\n    })\n  ])\n});\nvar list = DefinyRpcTypeInfo.from({\n  namespace: Namespace.coreType,\n  name: \"List\",\n  description: \"\\u30EA\\u30B9\\u30C8\",\n  parameter: [TypeParameterInfo.from({\n    name: \"element\",\n    description: \"\\u8981\\u7D20\\u306E\\u578B\"\n  })],\n  attribute: Maybe.nothing(),\n  body: TypeBody.list\n});\nvar map = DefinyRpcTypeInfo.from({\n  namespace: Namespace.coreType,\n  name: \"Map\",\n  description: \"\\u8F9E\\u66F8\\u578B. Map, Dictionary\",\n  parameter: [\n    TypeParameterInfo.from({\n      name: \"key\",\n      description: \"\\u30AD\\u30FC\\u306E\\u578B\"\n    }),\n    TypeParameterInfo.from({\n      name: \"value\",\n      description: \"\\u5024\\u306E\\u578B\"\n    })\n  ],\n  attribute: Maybe.nothing(),\n  body: TypeBody.map\n});\nvar set = DefinyRpcTypeInfo.from({\n  namespace: Namespace.coreType,\n  name: \"Set\",\n  description: \"Set. \\u96C6\\u5408\",\n  parameter: [TypeParameterInfo.from({\n    name: \"element\",\n    description: \"\\u96C6\\u5408\\u306B\\u542B\\u307E\\u308C\\u308B\\u8981\\u7D20\\u306E\\u578B\"\n  })],\n  attribute: Maybe.nothing(),\n  body: TypeBody.set\n});\nvar maybe = DefinyRpcTypeInfo.from({\n  namespace: Namespace.coreType,\n  name: \"Maybe\",\n  description: \"\",\n  parameter: [\n    TypeParameterInfo.from({ name: \"element\", description: \"just\\u306E\\u3068\\u304D\\u306B\\u5165\\u308B\\u5024\\u306E\\u578B\" })\n  ],\n  attribute: Maybe.nothing(),\n  body: TypeBody.sum([\n    Pattern.from({\n      name: \"just\",\n      description: \"\",\n      parameter: Maybe.just(Type.from({\n        namespace: Namespace.coreType,\n        name: \"element\",\n        parameters: []\n      }))\n    }),\n    Pattern.from({\n      name: \"nothing\",\n      description: \"\",\n      parameter: Maybe.nothing()\n    })\n  ])\n});\nvar result = DefinyRpcTypeInfo.from({\n  namespace: Namespace.coreType,\n  name: \"Result\",\n  description: \"\",\n  parameter: [\n    TypeParameterInfo.from({ name: \"ok\", description: \"ok\\u306E\\u3068\\u304D\\u306B\\u5165\\u308B\\u5024\" }),\n    TypeParameterInfo.from({ name: \"error\", description: \"error\\u306E\\u3068\\u304D\\u306B\\u5165\\u308B\\u5024\\u306E\\u578B\" })\n  ],\n  attribute: Maybe.nothing(),\n  body: TypeBody.sum([\n    Pattern.from({\n      name: \"ok\",\n      description: \"\",\n      parameter: Maybe.just(\n        Type.from({\n          namespace: Namespace.coreType,\n          name: \"ok\",\n          parameters: []\n        })\n      )\n    }),\n    Pattern.from({\n      name: \"error\",\n      description: \"\",\n      parameter: Maybe.just(Type.from({\n        namespace: Namespace.coreType,\n        name: \"error\",\n        parameters: []\n      }))\n    })\n  ])\n});\nvar nameSpace = DefinyRpcTypeInfo.from({\n  namespace: Namespace.coreType,\n  name: \"Namespace\",\n  description: \"\\u540D\\u524D\\u7A7A\\u9593. \\u30E6\\u30FC\\u30B6\\u30FC\\u304C\\u751F\\u6210\\u3059\\u308B\\u3082\\u306E\\u304C\\u3053\\u3063\\u3061\\u304C\\u7528\\u610F\\u3059\\u308B\\u3082\\u306E\\u304B\",\n  parameter: [],\n  attribute: Maybe.nothing(),\n  body: TypeBody.sum([\n    Pattern.from({\n      name: \"local\",\n      description: \"\\u30E6\\u30FC\\u30B6\\u30FC\\u304C\\u4F5C\\u3063\\u305FAPI\\u304C\\u3042\\u308B\\u3068\\u3053\\u308D\",\n      parameter: Maybe.just(\n        Type.from({\n          namespace: Namespace.coreType,\n          name: \"List\",\n          parameters: [Type.from({\n            namespace: Namespace.coreType,\n            name: \"String\",\n            parameters: []\n          })]\n        })\n      )\n    }),\n    Pattern.from({\n      name: \"coreType\",\n      description: \"definyRpc \\u5171\\u901A\\u3067\\u4F7F\\u308F\\u308C\\u308B\\u578B\",\n      parameter: Maybe.nothing()\n    }),\n    Pattern.from({\n      name: \"typedJson\",\n      description: \"\\u578B\\u5B89\\u5168\\u306AJSON\\u306E\\u30B3\\u30FC\\u30C7\\u30C3\\u30AF\",\n      parameter: Maybe.nothing()\n    }),\n    Pattern.from({\n      name: \"request\",\n      description: \"HTTP\\u7D4C\\u8DEF\\u3067API\\u547C\\u3076\\u3068\\u304D\\u306B\\u4F7F\\u3046\\u30B3\\u30FC\\u30C9\",\n      parameter: Maybe.nothing()\n    }),\n    Pattern.from({\n      name: \"meta\",\n      description: \"\\u5404\\u30B5\\u30FC\\u30D0\\u30FC\\u306B\\u30A2\\u30AF\\u30BB\\u30B9\\u3057\\u578B\\u60C5\\u5831\\u3092\\u53D6\\u5F97\\u3059\\u308B\",\n      parameter: Maybe.nothing()\n    })\n  ])\n});\nvar definyRpcTypeInfo = DefinyRpcTypeInfo.from({\n  name: \"DefinyRpcTypeInfo\",\n  namespace: Namespace.coreType,\n  description: \"definy RPC \\u578B\\u306E\\u69CB\\u9020\",\n  parameter: [],\n  attribute: Maybe.nothing(),\n  body: TypeBody.product([\n    Field.from({\n      name: \"namespace\",\n      description: \"\\u578B\\u304C\\u6240\\u5C5E\\u3059\\u308B\\u540D\\u524D\\u7A7A\\u9593\",\n      type: Type.from({\n        namespace: Namespace.coreType,\n        name: \"Namespace\",\n        parameters: []\n      })\n    }),\n    Field.from({\n      name: \"name\",\n      description: \"\\u578B\\u306E\\u540D\\u524D\",\n      type: Type.from({\n        namespace: Namespace.coreType,\n        name: \"String\",\n        parameters: []\n      })\n    }),\n    Field.from({\n      name: \"description\",\n      description: \"\\u8AAC\\u660E\\u6587. \\u30B3\\u30E1\\u30F3\\u30C8\\u306A\\u3069\\u306B\\u51FA\\u529B\\u3055\\u308C\\u308B\",\n      type: Type.from({\n        namespace: Namespace.coreType,\n        name: \"String\",\n        parameters: []\n      })\n    }),\n    Field.from({\n      name: \"parameter\",\n      description: \"\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u30FC\",\n      type: List.type(Type.from({\n        namespace: Namespace.coreType,\n        name: \"TypeParameterInfo\",\n        parameters: []\n      }))\n    }),\n    Field.from({\n      name: \"attribute\",\n      description: \"\\u7279\\u6B8A\\u306A\\u6271\\u3044\\u3092\\u3059\\u308B\",\n      type: Maybe.type(Type.from({\n        namespace: Namespace.coreType,\n        name: \"TypeAttribute\",\n        parameters: []\n      }))\n    }),\n    Field.from({\n      name: \"body\",\n      description: \"\\u578B\\u306E\\u69CB\\u9020\\u3092\\u8868\\u73FE\\u3059\\u308B\",\n      type: Type.from({\n        namespace: Namespace.coreType,\n        name: \"TypeBody\",\n        parameters: []\n      })\n    })\n  ])\n});\nvar typeParameterInfo = DefinyRpcTypeInfo.from({\n  name: \"TypeParameterInfo\",\n  description: \"\\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u540D\\u3068\\u8AAC\\u660E\\u6587\",\n  namespace: Namespace.coreType,\n  parameter: [],\n  attribute: Maybe.nothing(),\n  body: TypeBody.product([\n    Field.from({\n      name: \"name\",\n      description: \"\\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u30FC\\u540D\",\n      type: String2.type()\n    }),\n    Field.from({\n      name: \"description\",\n      description: \"\\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u30FC\\u8AAC\\u660E\",\n      type: String2.type()\n    })\n  ])\n});\nvar typeAttribute = DefinyRpcTypeInfo.from({\n  name: \"TypeAttribute\",\n  description: \"\\u578B\\u3092\\u3069\\u306E\\u3088\\u3046\\u306A\\u7279\\u6B8A\\u306A\\u6271\\u3044\\u3092\\u3059\\u308B\\u304B\\u3069\\u3046\\u304B\",\n  namespace: Namespace.coreType,\n  parameter: [],\n  attribute: Maybe.nothing(),\n  body: TypeBody.sum([\n    Pattern.from({\n      name: \"asType\",\n      description: \"\\u578B\\u306E\\u30C7\\u30FC\\u30BF. \\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u3092\\u4ED8\\u4E0E\\u3059\\u308B\",\n      parameter: Maybe.nothing()\n    })\n  ])\n});\nvar typeBody = DefinyRpcTypeInfo.from({\n  namespace: Namespace.coreType,\n  name: \"TypeBody\",\n  description: \"\\u578B\\u306E\\u69CB\\u9020\\u3092\\u8868\\u73FE\\u3059\\u308B\",\n  parameter: [],\n  attribute: Maybe.nothing(),\n  body: TypeBody.sum([\n    Pattern.from({\n      name: \"string\",\n      description: \"string\",\n      parameter: Maybe.nothing()\n    }),\n    Pattern.from({\n      name: \"number\",\n      description: \"number\",\n      parameter: Maybe.nothing()\n    }),\n    Pattern.from({\n      name: \"boolean\",\n      description: \"boolean\",\n      parameter: Maybe.nothing()\n    }),\n    Pattern.from({\n      name: \"unit\",\n      description: \"unit\",\n      parameter: Maybe.nothing()\n    }),\n    Pattern.from({\n      name: \"list\",\n      description: \"list\",\n      parameter: Maybe.nothing()\n    }),\n    Pattern.from({\n      name: \"set\",\n      description: \"set\",\n      parameter: Maybe.nothing()\n    }),\n    Pattern.from({\n      name: \"map\",\n      description: \"map\",\n      parameter: Maybe.nothing()\n    }),\n    Pattern.from({\n      name: \"url\",\n      description: \"url\",\n      parameter: Maybe.nothing()\n    }),\n    Pattern.from({\n      name: \"product\",\n      description: \"product\",\n      parameter: Maybe.just(Type.from({\n        namespace: Namespace.coreType,\n        name: \"List\",\n        parameters: [\n          Type.from({\n            namespace: Namespace.coreType,\n            name: \"Field\",\n            parameters: []\n          })\n        ]\n      }))\n    }),\n    Pattern.from({\n      name: \"sum\",\n      description: \"sum\",\n      parameter: Maybe.just(Type.from({\n        namespace: Namespace.coreType,\n        name: \"List\",\n        parameters: [Type.from({\n          namespace: Namespace.coreType,\n          name: \"Pattern\",\n          parameters: []\n        })]\n      }))\n    })\n  ])\n});\nvar field = DefinyRpcTypeInfo.from({\n  namespace: Namespace.coreType,\n  name: \"Field\",\n  description: \"product \\u76F4\\u7A4D\\u578B\\u3067\\u4F7F\\u3046\",\n  parameter: [],\n  attribute: Maybe.nothing(),\n  body: TypeBody.product([\n    Field.from({\n      name: \"name\",\n      description: \"\\u30D5\\u30A3\\u30FC\\u30EB\\u30C9\\u540D\",\n      type: Type.from({\n        namespace: Namespace.coreType,\n        name: \"String\",\n        parameters: []\n      })\n    }),\n    Field.from({\n      name: \"description\",\n      description: \"\\u30D5\\u30A3\\u30FC\\u30EB\\u30C9\\u306E\\u8AAC\\u660E\",\n      type: Type.from({\n        namespace: Namespace.coreType,\n        name: \"String\",\n        parameters: []\n      })\n    }),\n    Field.from({\n      name: \"type\",\n      description: \"\\u578B\",\n      type: Type.from({\n        namespace: Namespace.coreType,\n        name: \"Type\",\n        parameters: []\n      })\n    })\n  ])\n});\nvar pattern = DefinyRpcTypeInfo.from({\n  namespace: Namespace.coreType,\n  name: \"Pattern\",\n  description: \"\\u76F4\\u548C\\u578B\\u306E\\u8868\\u73FE\",\n  parameter: [],\n  attribute: Maybe.nothing(),\n  body: TypeBody.product([\n    Field.from({\n      name: \"name\",\n      description: \"\\u30D1\\u30BF\\u30FC\\u30F3\\u540D\",\n      type: Type.from({\n        namespace: Namespace.coreType,\n        name: \"String\",\n        parameters: []\n      })\n    }),\n    Field.from({\n      name: \"description\",\n      description: \"\\u8AAC\\u660E\",\n      type: Type.from({\n        namespace: Namespace.coreType,\n        name: \"String\",\n        parameters: []\n      })\n    }),\n    Field.from({\n      name: \"parameter\",\n      description: \"\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u30FC\",\n      type: Maybe.type(Type.type())\n    })\n  ])\n});\nvar type = DefinyRpcTypeInfo.from({\n  namespace: Namespace.coreType,\n  name: \"Type\",\n  description: \"\\u578B\",\n  parameter: [],\n  attribute: Maybe.just(TypeAttribute.asType),\n  body: TypeBody.product([\n    Field.from({\n      name: \"namespace\",\n      description: \"\\u540D\\u524D\\u7A7A\\u9593\",\n      type: Type.from({\n        namespace: Namespace.coreType,\n        name: \"Namespace\",\n        parameters: []\n      })\n    }),\n    Field.from({\n      name: \"name\",\n      description: \"\\u578B\\u306E\\u540D\\u524D\",\n      type: Type.from({\n        namespace: Namespace.coreType,\n        name: \"String\",\n        parameters: []\n      })\n    }),\n    Field.from({\n      name: \"parameters\",\n      description: \"\\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\",\n      type: Type.from({\n        namespace: Namespace.coreType,\n        name: \"List\",\n        parameters: [\n          Type.from({\n            namespace: Namespace.coreType,\n            name: \"Type\",\n            parameters: []\n          })\n        ]\n      })\n    })\n  ])\n});\nvar functionNamespace = DefinyRpcTypeInfo.from({\n  namespace: Namespace.coreType,\n  description: \"\\u51FA\\u529B\\u3055\\u308C\\u308BAPI\\u95A2\\u6570\\u306E\\u30E2\\u30B8\\u30E5\\u30FC\\u30EB\\u540D\",\n  parameter: [],\n  attribute: Maybe.nothing(),\n  name: \"FunctionNamespace\",\n  body: TypeBody.sum([\n    Pattern.from({\n      name: \"meta\",\n      description: \"API\\u304C\\u3069\\u3093\\u306A\\u69CB\\u9020\\u3067\\u8868\\u73FE\\u3055\\u308C\\u3066\\u3044\\u308B\\u304B\\u3092\\u53D6\\u5F97\\u3059\\u308B\\u305F\\u3081\\u306EAPI\",\n      parameter: Maybe.nothing()\n    }),\n    Pattern.from({\n      name: \"local\",\n      description: \"definy RPC \\u3092\\u5229\\u7528\\u3059\\u308B\\u30E6\\u30FC\\u30B6\\u30FC\\u304C\\u5B9A\\u7FA9\\u3057\\u305F\\u30E2\\u30B8\\u30E5\\u30FC\\u30EB\",\n      parameter: Maybe.just(List.type(String2.type()))\n    })\n  ])\n});\nvar functionDetail = DefinyRpcTypeInfo.from({\n  name: \"FunctionDetail\",\n  description: \"\\u95A2\\u6570\\u306E\\u30C7\\u30FC\\u30BF functionByName\\u306E\\u7D50\\u679C\",\n  parameter: [],\n  attribute: Maybe.nothing(),\n  namespace: Namespace.coreType,\n  body: TypeBody.product([\n    Field.from({\n      name: \"namespace\",\n      description: \"\\u540D\\u524D\\u7A7A\\u9593\",\n      type: Type.from({\n        namespace: Namespace.coreType,\n        name: \"FunctionNamespace\",\n        parameters: []\n      })\n    }),\n    Field.from({\n      name: \"name\",\n      description: \"api\\u540D\",\n      type: String2.type()\n    }),\n    Field.from({\n      name: \"description\",\n      description: \"\\u8AAC\\u660E\\u6587\",\n      type: String2.type()\n    }),\n    Field.from({\n      name: \"input\",\n      description: \"\\u5165\\u529B\\u306E\\u578B\",\n      type: Type.type()\n    }),\n    Field.from({\n      name: \"output\",\n      description: \"\\u51FA\\u529B\\u306E\\u578B\",\n      type: Type.type()\n    }),\n    Field.from({\n      name: \"needAuthentication\",\n      description: \"\\u8A8D\\u8A3C\\u304C\\u5FC5\\u8981\\u304B\\u3069\\u3046\\u304B (\\u30AD\\u30E3\\u30C3\\u30B7\\u30E5\\u3057\\u306A\\u304F\\u306A\\u308B)\",\n      type: Bool.type()\n    }),\n    Field.from({\n      name: \"isMutation\",\n      description: \"\\u5358\\u306A\\u308B\\u30C7\\u30FC\\u30BF\\u306E\\u53D6\\u5F97\\u3067\\u306F\\u306A\\u304F, \\u5909\\u66F4\\u3059\\u308B\\u3088\\u3046\\u306A\\u3082\\u306E\\u304B\",\n      type: Bool.type()\n    })\n  ])\n});\nvar coreTypeInfoList = [\n  string,\n  unit,\n  bool,\n  number,\n  structuredJsonValue,\n  list,\n  map,\n  set,\n  maybe,\n  result,\n  nameSpace,\n  definyRpcTypeInfo,\n  typeParameterInfo,\n  typeAttribute,\n  typeBody,\n  field,\n  pattern,\n  type,\n  functionNamespace,\n  functionDetail\n];\n\n// definyRpc/clientEditor/Editor.tsx\nvar containerStyle3 = toStyleAndHash({\n  padding: 16,\n  display: \"grid\",\n  gridTemplateColumns: \"1fr 1fr\"\n});\nvar contentStyle = toStyleAndHash({\n  display: \"grid\",\n  alignContent: \"start\"\n});\nvar Editor = (props) => {\n  const [selectedFunc, setSelectedFunc] = We.useState(\n    void 0\n  );\n  const [runResponse, setRunResponse] = We.useState(void 0);\n  const [isRequesting, setIsRequesting] = We.useState(false);\n  We.useEffect(() => {\n    if (selectedFunc === void 0) {\n      const first2 = props.functionAndTypeList?.funcList?.[0];\n      if (first2 === void 0) {\n        setSelectedFunc(void 0);\n      } else {\n        setSelectedFunc(\n          functionNamespaceToString(first2.namespace) + \".\" + first2.name\n        );\n      }\n    }\n  }, [selectedFunc, props.functionAndTypeList]);\n  const selectedFuncDetail = props.functionAndTypeList?.funcList?.find(\n    (func) => functionNamespaceToString(func.namespace) + \".\" + func.name === selectedFunc\n  );\n  return /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(containerStyle3)\n  }, /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(contentStyle)\n  }, /* @__PURE__ */ We.createElement(Select, {\n    values: props.functionAndTypeList?.funcList,\n    value: selectedFunc,\n    onSelect: (e) => {\n      setSelectedFunc(e);\n    }\n  }), /* @__PURE__ */ We.createElement(Button, {\n    onClick: selectedFuncDetail?.input.name === \"Unit\" && selectedFuncDetail?.input.namespace.type === \"coreType\" && !isRequesting ? () => {\n      setIsRequesting(true);\n      requestQuery({\n        url: new URL(props.serverOrigin),\n        inputType: selectedFuncDetail.input,\n        outputType: selectedFuncDetail.output,\n        typeMap: new Map(\n          coreTypeInfoList.map((info) => [\n            namespaceToString(info.namespace) + \".\" + info.name,\n            info\n          ])\n        ),\n        name: selectedFuncDetail.name,\n        namespace: selectedFuncDetail.namespace,\n        input: StructuredJsonValue.null\n      }).then((json) => {\n        console.log(\"response\", json);\n        setRunResponse(json);\n        setIsRequesting(false);\n      });\n    } : void 0\n  }, \"Run\"), /* @__PURE__ */ We.createElement(Result2, {\n    data: runResponse,\n    requesting: isRequesting\n  })), props.functionAndTypeList === void 0 ? /* @__PURE__ */ We.createElement(\"div\", null, \"loading...\") : /* @__PURE__ */ We.createElement(DetailView, {\n    functionList: props.functionAndTypeList.funcList,\n    selectedFuncName: selectedFunc,\n    typeList: props.functionAndTypeList.typeList\n  }));\n};\n\n// editor/EnterIcon.tsx\nvar EnterIcon = (props) => {\n  return /* @__PURE__ */ We.createElement(\"svg\", {\n    viewBox: \"0 0 38 32\",\n    className: c(\n      toStyleAndHash({ stroke: props.stroke, height: props.height })\n    )\n  }, /* @__PURE__ */ We.createElement(\"polygon\", {\n    points: \"4,4 34,4 34,28 12,28 12,16 4,16\",\n    fill: \"none\"\n  }), /* @__PURE__ */ We.createElement(\"path\", {\n    d: \"M30,8 V20 H16 L18,18 M16,20 L18,22\",\n    fill: \"none\"\n  }));\n};\n\n// editor/useEditorKeyInput.ts\nvar useEditorKeyInput = ({\n  disabled,\n  onDown,\n  onUp,\n  onEnter\n}) => {\n  We.useEffect(() => {\n    console.log(\"reset!\");\n    const handleKeyEvent = (e) => {\n      if (disabled) {\n        return;\n      }\n      console.log(e.code);\n      if (e.code === \"Enter\") {\n        onEnter();\n        e.preventDefault();\n        return;\n      }\n      if (e.code === \"ArrowUp\" || e.code === \"KeyW\") {\n        onUp();\n        e.preventDefault();\n        return;\n      }\n      if (e.code === \"ArrowDown\" || e.code === \"KeyS\") {\n        onDown();\n        e.preventDefault();\n      }\n    };\n    document.addEventListener(\"keydown\", handleKeyEvent);\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyEvent);\n    };\n  }, [disabled, onEnter, onUp, onDown]);\n};\n\n// util.ts\nvar createRandomId = () => {\n  const binary = crypto.getRandomValues(new Uint8Array(32));\n  let result2 = \"\";\n  for (const item of binary) {\n    result2 += item.toString(16).padStart(2, \"0\");\n  }\n  return result2;\n};\n\n// editor/useNotification.tsx\nvar containerStyle4 = toStyleAndHash({\n  display: \"grid\",\n  gap: 8\n});\nvar messageStyle = toStyleAndHash({\n  flexGrow: \"1\"\n});\nvar useNotification = () => {\n  const [messageList, setMessageList] = We.useState(\n    []\n  );\n  const addMessage = We.useCallback((newMessage) => {\n    setMessageList((oldMessageList) => [\n      ...oldMessageList,\n      { ...newMessage, id: createRandomId() }\n    ]);\n  }, []);\n  return {\n    addMessage,\n    element: /* @__PURE__ */ We.createElement(\"div\", {\n      className: c(containerStyle4)\n    }, [...messageList].slice(messageList.length - 4, messageList.length).map((message) => /* @__PURE__ */ We.createElement(\"div\", {\n      key: message.id,\n      className: c(\n        toStyleAndHash({\n          backgroundColor: message.type === \"success\" ? \"skyblue\" : \"red\",\n          padding: 8,\n          color: \"#111\",\n          display: \"flex\"\n        })\n      )\n    }, /* @__PURE__ */ We.createElement(\"div\", {\n      className: c(messageStyle)\n    }, message.text), /* @__PURE__ */ We.createElement(\"button\", {\n      onClick: () => {\n        setMessageList(\n          (old) => old.filter((m) => m.id !== message.id)\n        );\n      }\n    }, \"x\"))))\n  };\n};\n\n// editor/Editor.tsx\nvar isFieldAvailable = (field2) => {\n  switch (field2.body.type) {\n    case \"button\":\n      return field2.body.value !== void 0;\n    case \"text\":\n    case \"product\": {\n      return !field2.body.readonly;\n    }\n  }\n};\nvar containerStyle5 = toStyleAndHash({\n  display: \"grid\",\n  height: \"100%\",\n  overflowY: \"scroll\"\n});\nvar editorMainStyle = toStyleAndHash({\n  gridColumn: \"1 / 2\",\n  gridRow: \"1 / 2\"\n});\nvar notificationStyle = toStyleAndHash({\n  gridColumn: \"1 / 2\",\n  gridRow: \"1 / 2\",\n  justifySelf: \"end\",\n  alignSelf: \"end\"\n});\nvar Editor2 = (props) => {\n  const [selectedFieldId, setSelectedFieldId] = We.useState(props.fields[0]?.id);\n  const [isEditing, setIsEditing] = We.useState(false);\n  const onStartEdit = We.useCallback(() => {\n    console.log(\"onStartEdit\", selectedFieldId);\n    const selectedField = props.fields.find(\n      (field2) => field2.id === selectedFieldId\n    );\n    if (selectedField === void 0) {\n      return;\n    }\n    switch (selectedField.body.type) {\n      case \"button\":\n        selectedField.body.value?.();\n        return;\n      case \"text\":\n      case \"product\": {\n        if (!selectedField.body.readonly) {\n          setIsEditing(true);\n        }\n      }\n    }\n  }, [props.fields, selectedFieldId]);\n  useEditorKeyInput({\n    disabled: isEditing,\n    onEnter: onStartEdit,\n    onUp: () => {\n      console.log(\"onUp\");\n      if (selectedFieldId === void 0) {\n        const nextFieldId2 = props.fields[props.fields.length - 1]?.id;\n        if (nextFieldId2 !== void 0) {\n          setSelectedFieldId(nextFieldId2);\n        }\n        return;\n      }\n      const index2 = props.fields.findIndex((f) => f.id === selectedFieldId);\n      const nextFieldId = props.fields[index2 - 1]?.id;\n      if (nextFieldId !== void 0) {\n        setSelectedFieldId(nextFieldId);\n      }\n    },\n    onDown: () => {\n      console.log(\"onDown\");\n      if (selectedFieldId === void 0) {\n        const nextFieldId2 = props.fields[0]?.id;\n        if (nextFieldId2 !== void 0) {\n          setSelectedFieldId(nextFieldId2);\n        }\n        return;\n      }\n      const index2 = props.fields.findIndex((f) => f.id === selectedFieldId);\n      const nextFieldId = props.fields[index2 + 1]?.id;\n      if (nextFieldId !== void 0) {\n        setSelectedFieldId(nextFieldId);\n      }\n    }\n  });\n  const { element: notificationElement, addMessage } = useNotification();\n  return /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(containerStyle5)\n  }, /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(editorMainStyle)\n  }, [...props.fields].map((field2) => /* @__PURE__ */ We.createElement(Field2, {\n    key: field2.id,\n    name: field2.name,\n    value: field2.body,\n    selected: selectedFieldId === field2.id,\n    isEditing,\n    errorMessage: field2.errorMessage,\n    onSelected: () => {\n      console.log(\"onSelected\", field2.name);\n      setSelectedFieldId(field2.id);\n      setIsEditing(false);\n    },\n    onUnSelected: () => {\n      console.log(\"onUnSelected\", field2.name);\n      setSelectedFieldId(void 0);\n    },\n    onStartEdit: field2.body.type === \"button\" || field2.body.readonly ? void 0 : onStartEdit,\n    onChange: (newText) => {\n      props.onChange(field2.id, newText);\n      setIsEditing(false);\n    },\n    onCopy: (text) => {\n      addMessage({\n        text: \"\\u300C\" + text + \"\\u300D\\u3092\\u30B3\\u30D4\\u30FC\\u3057\\u305F\",\n        type: \"success\"\n      });\n    },\n    onPaste: (text) => {\n      addMessage({\n        text: \"\\u300C\" + text + \"\\u300D\\u3092\\u8CBC\\u308A\\u4ED8\\u3051\\u305F\",\n        type: \"success\"\n      });\n    }\n  }))), /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(notificationStyle)\n  }, notificationElement));\n};\nvar Field2 = (props) => {\n  switch (props.value.type) {\n    case \"text\":\n      return /* @__PURE__ */ We.createElement(TextField, {\n        name: props.name,\n        value: props.value.value,\n        selected: props.selected,\n        errorMessage: props.errorMessage,\n        isEditing: props.isEditing,\n        isTitle: props.value.isTitle,\n        onChange: props.onChange,\n        onCopy: props.onCopy,\n        onPaste: props.onPaste,\n        onSelected: props.onSelected,\n        onStartEdit: props.onStartEdit,\n        onUnSelected: props.onUnSelected\n      });\n    case \"button\":\n      return /* @__PURE__ */ We.createElement(ButtonField, {\n        name: props.name,\n        value: props.value.value,\n        selected: props.selected,\n        errorMessage: props.errorMessage,\n        onChange: props.onChange,\n        onCopy: props.onCopy,\n        onPaste: props.onPaste,\n        onSelected: props.onSelected,\n        onUnSelected: props.onUnSelected\n      });\n    case \"product\":\n      return /* @__PURE__ */ We.createElement(ProductField, {\n        name: props.name,\n        value: props.value.value,\n        selected: props.selected,\n        errorMessage: props.errorMessage,\n        onChange: props.onChange,\n        onCopy: props.onCopy,\n        onPaste: props.onPaste,\n        onSelected: props.onSelected,\n        onStartEdit: props.onStartEdit,\n        onUnSelected: props.onUnSelected\n      });\n  }\n};\nvar textFieldEnterIconContainer = toStyleAndHash({\n  backgroundColor: \"#444\",\n  padding: \"0 8px\",\n  display: \"flex\",\n  alignItems: \"center\",\n  gap: 2\n});\nvar textFieldContainerOut = toStyleAndHash({\n  paddingLeft: 8\n});\nvar textFieldContainerIn = toStyleAndHash({\n  display: \"flex\",\n  gap: 4\n});\nvar errorMessageStyle = toStyleAndHash({\n  backgroundColor: \"#d37171\",\n  color: \"#000\",\n  padding: \"0 4px\"\n});\nvar TextField = (props) => {\n  const ref = We.useRef(null);\n  We.useEffect(() => {\n    if (props.selected) {\n      ref.current?.focus();\n    }\n  }, [props.selected, ref.current]);\n  return /* @__PURE__ */ We.createElement(\"div\", {\n    ref,\n    className: c(\n      toStyleAndHash(\n        {\n          borderStyle: \"solid\",\n          borderColor: props.selected ? \"orange\" : \"transparent\",\n          borderRadius: 8,\n          minHeight: 64,\n          display: \"grid\"\n        },\n        {\n          focus: {\n            borderColor: \"skyblue\"\n          }\n        }\n      )\n    ),\n    onFocus: () => {\n      props.onSelected();\n    },\n    onPaste: (e) => {\n      const textInClipboard = e.clipboardData.getData(\"text\");\n      console.log(\"div\\u5185 paste\", e, textInClipboard);\n      props.onChange(textInClipboard);\n      props.onPaste(textInClipboard);\n    },\n    onCopy: (e) => {\n      e.preventDefault();\n      e.clipboardData.setData(\"text\", props.value);\n      console.log(\"div \\u5185 \\u3067copy. \\u4E2D\\u8EAB:\", props.value);\n      props.onCopy(props.value);\n    },\n    tabIndex: -1\n  }, /* @__PURE__ */ We.createElement(\"div\", null, props.name), /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(textFieldContainerOut)\n  }, /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(textFieldContainerIn)\n  }, props.selected && props.isEditing ? false : /* @__PURE__ */ We.createElement(TextFieldValue, {\n    isError: props.errorMessage !== void 0,\n    value: props.value,\n    isTitle: props.isTitle,\n    onStartEdit: props.onStartEdit\n  }), props.onStartEdit !== void 0 && props.selected && !props.isEditing && /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(textFieldEnterIconContainer)\n  }, /* @__PURE__ */ We.createElement(EnterIcon, {\n    stroke: \"white\",\n    height: 24\n  }), \"\\u7DE8\\u96C6\"), props.errorMessage !== void 0 && /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(errorMessageStyle)\n  }, props.errorMessage)), props.selected && props.isEditing && /* @__PURE__ */ We.createElement(StyledInput, {\n    value: props.value,\n    onSubmit: props.onChange,\n    onCopy: props.onCopy,\n    onPaste: props.onPaste\n  })));\n};\nvar buttonFieldIconContainerStyle = toStyleAndHash({\n  display: \"flex\",\n  alignItems: \"center\",\n  gap: 8\n});\nvar ButtonField = (props) => {\n  const ref = We.useRef(null);\n  We.useEffect(() => {\n    if (props.selected) {\n      ref.current?.focus();\n    }\n  }, [props.selected, ref.current]);\n  return /* @__PURE__ */ We.createElement(\"div\", {\n    ref,\n    className: c(\n      toStyleAndHash(\n        {\n          borderStyle: \"solid\",\n          borderColor: props.selected ? \"orange\" : \"transparent\",\n          borderRadius: 8,\n          minHeight: 64,\n          display: \"grid\"\n        },\n        {\n          focus: {\n            borderColor: \"skyblue\"\n          }\n        }\n      )\n    ),\n    onFocus: () => {\n      props.onSelected();\n    },\n    tabIndex: -1\n  }, /* @__PURE__ */ We.createElement(\"div\", null, /* @__PURE__ */ We.createElement(Button, {\n    onClick: props.value\n  }, /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(buttonFieldIconContainerStyle)\n  }, props.selected && /* @__PURE__ */ We.createElement(EnterIcon, {\n    stroke: \"white\",\n    height: 24\n  }), /* @__PURE__ */ We.createElement(\"div\", null, props.name)))));\n};\nvar productFieldStyle = toStyleAndHash({\n  paddingLeft: 8\n});\nvar productFieldErrorMessageContainerStyle = toStyleAndHash({\n  display: \"flex\",\n  gap: 4\n});\nvar productFieldErrorMessageStyle = toStyleAndHash({\n  backgroundColor: \"#d37171\",\n  color: \"#000\",\n  padding: \"0 4px\"\n});\nvar ProductField = (props) => {\n  const ref = We.useRef(null);\n  We.useEffect(() => {\n    if (props.selected) {\n      ref.current?.focus();\n    }\n  }, [props.selected, ref.current]);\n  return /* @__PURE__ */ We.createElement(\"div\", {\n    ref,\n    className: c(\n      toStyleAndHash(\n        {\n          borderStyle: \"solid\",\n          borderColor: props.selected ? \"orange\" : \"transparent\",\n          borderRadius: 8,\n          minHeight: 64,\n          display: \"grid\"\n        },\n        {\n          focus: {\n            borderColor: \"skyblue\"\n          }\n        }\n      )\n    ),\n    onFocus: () => {\n      props.onSelected();\n    },\n    onPaste: (e) => {\n      const textInClipboard = e.clipboardData.getData(\"text\");\n      console.log(\"div\\u5185 paste\", e, textInClipboard);\n      props.onChange(textInClipboard);\n      props.onPaste(textInClipboard);\n    },\n    onCopy: (e) => {\n      e.preventDefault();\n      const serialized = props.value.map(serializeField);\n      e.clipboardData.setData(\"text\", jsonStringify(serialized, true));\n      console.log(\"div \\u5185 \\u3067copy. \\u4E2D\\u8EAB:\", props.value);\n      props.onCopy(jsonStringify(serialized, true));\n    },\n    tabIndex: -1\n  }, /* @__PURE__ */ We.createElement(\"div\", null, props.name), /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(productFieldStyle)\n  }, props.value.map((field2) => /* @__PURE__ */ We.createElement(Field2, {\n    key: field2.id,\n    name: field2.name,\n    value: field2.body,\n    selected: false,\n    isEditing: false,\n    errorMessage: field2.errorMessage,\n    onSelected: () => {\n      console.log(\"onSelected\", field2.name);\n    },\n    onUnSelected: () => {\n    },\n    onStartEdit: isFieldAvailable(field2) ? () => {\n    } : void 0,\n    onChange: (newText) => {\n      props.onChange(newText);\n    },\n    onCopy: () => {\n    },\n    onPaste: () => {\n    }\n  }))), /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(productFieldStyle)\n  }, /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(productFieldErrorMessageContainerStyle)\n  }, props.errorMessage !== void 0 && /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(productFieldErrorMessageStyle)\n  }, props.errorMessage))));\n};\nvar serializeField = (field2) => {\n  return {\n    id: field2.id,\n    name: field2.name,\n    body: serializeBody(field2.body)\n  };\n};\nvar serializeBody = (body) => {\n  switch (body.type) {\n    case \"text\":\n      return {\n        type: \"text\",\n        value: body.value\n      };\n    case \"button\":\n      return null;\n    case \"product\":\n      return { type: \"text\", value: body.value.map(serializeField) };\n  }\n};\nvar TextFieldValue = (props) => {\n  if (props.isTitle) {\n    return /* @__PURE__ */ We.createElement(\"h2\", {\n      className: c(\n        toStyleAndHash({\n          whiteSpace: \"pre-wrap\",\n          textDecoration: props.isError ? \"underline wavy red\" : \"none\",\n          margin: 0,\n          fontSize: 32\n        })\n      ),\n      onClick: props.onStartEdit\n    }, props.value);\n  }\n  return /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(\n      toStyleAndHash({\n        whiteSpace: \"pre-wrap\",\n        textDecoration: props.isError ? \"underline wavy red\" : \"none\"\n      })\n    ),\n    onClick: props.onStartEdit\n  }, props.value);\n};\nvar inputStyle2 = toStyleAndHash(\n  {\n    padding: 8,\n    fontSize: 16,\n    backgroundColor: \"#222\",\n    border: \"none\",\n    color: \"#eee\",\n    borderRadius: 8,\n    width: \"100%\"\n  },\n  {\n    hover: {\n      backgroundColor: \"#333\"\n    }\n  }\n);\nvar StyledInput = (props) => {\n  const [editingText, setEditingText] = We.useState(props.value);\n  return /* @__PURE__ */ We.createElement(\"form\", {\n    onSubmit: (e) => {\n      e.preventDefault();\n      props.onSubmit(editingText);\n    }\n  }, /* @__PURE__ */ We.createElement(\"input\", {\n    type: \"text\",\n    value: editingText,\n    className: c(inputStyle2),\n    autoFocus: true,\n    onFocus: (e) => {\n      e.stopPropagation();\n    },\n    onChange: (e) => {\n      setEditingText(e.target.value);\n    },\n    onPaste: (e) => {\n      props.onPaste(e.clipboardData.getData(\"text\"));\n      e.stopPropagation();\n    },\n    onCopy: (e) => {\n      const start = e.currentTarget.selectionStart;\n      const end = e.currentTarget.selectionEnd;\n      if (start === null || end === null) {\n        return;\n      }\n      console.log(start, end);\n      props.onCopy(e.currentTarget.value.slice(start, end));\n      e.stopPropagation();\n    }\n  }));\n};\n\n// definyRpc/clientEditor/ServerOrigin.tsx\nvar serverOriginFieldId = \"server-origin\";\nvar containerStyle6 = toStyleAndHash({\n  padding: 16\n});\nvar ServerOrigin = (props) => {\n  const [originText, setOriginText] = We.useState(\n    props.initServerOrigin\n  );\n  const origin = getSafeOrigin(originText);\n  return /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(containerStyle6)\n  }, /* @__PURE__ */ We.createElement(Editor2, {\n    fields: [\n      {\n        id: serverOriginFieldId,\n        name: \"server origin\",\n        body: {\n          type: \"text\",\n          value: originText,\n          readonly: false,\n          isTitle: false\n        },\n        errorMessage: origin === void 0 ? \"\\u4E0D\\u6B63\\u306A\\u30AA\\u30EA\\u30B8\\u30F3\\u3067\\u3059. \\u4F8B: http://localhost:3000\" : void 0\n      },\n      {\n        id: \"server-name\",\n        errorMessage: void 0,\n        name: \"server name\",\n        body: {\n          type: \"text\",\n          value: props.serverName === void 0 ? \"...\" : props.serverName,\n          readonly: true,\n          isTitle: true\n        }\n      }\n    ],\n    onChange: (fieldId, value) => {\n      setOriginText(value);\n      if (origin !== void 0) {\n        props.onChangeServerOrigin(origin);\n      }\n    }\n  }));\n};\nvar getSafeOrigin = (text) => {\n  try {\n    return new URL(text).origin;\n  } catch {\n    return void 0;\n  }\n};\n\n// https://cdn.skypack.dev/-/vis-data@v7.1.4-T8FsVAGUTMBckCNl16HT/dist=es2019,mode=imports/optimized/vis-data.js\nvar global$1 = typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {};\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global$1 !== \"undefined\" ? global$1 : typeof self !== \"undefined\" ? self : {};\nvar defineProperty$e = { exports: {} };\nvar check = function(it2) {\n  return it2 && it2.Math == Math && it2;\n};\nvar global$M = check(typeof globalThis == \"object\" && globalThis) || check(typeof window == \"object\" && window) || check(typeof self == \"object\" && self) || check(typeof commonjsGlobal == \"object\" && commonjsGlobal) || function() {\n  return this;\n}() || Function(\"return this\")();\nvar fails$r = function(exec22) {\n  try {\n    return !!exec22();\n  } catch (error) {\n    return true;\n  }\n};\nvar fails$q = fails$r;\nvar functionBindNative = !fails$q(function() {\n  var test22 = function() {\n  }.bind();\n  return typeof test22 != \"function\" || test22.hasOwnProperty(\"prototype\");\n});\nvar NATIVE_BIND$4 = functionBindNative;\nvar FunctionPrototype$3 = Function.prototype;\nvar apply$6 = FunctionPrototype$3.apply;\nvar call$c = FunctionPrototype$3.call;\nvar functionApply = typeof Reflect == \"object\" && Reflect.apply || (NATIVE_BIND$4 ? call$c.bind(apply$6) : function() {\n  return call$c.apply(apply$6, arguments);\n});\nvar NATIVE_BIND$3 = functionBindNative;\nvar FunctionPrototype$2 = Function.prototype;\nvar bind$d = FunctionPrototype$2.bind;\nvar call$b = FunctionPrototype$2.call;\nvar uncurryThis$t = NATIVE_BIND$3 && bind$d.bind(call$b, call$b);\nvar functionUncurryThis = NATIVE_BIND$3 ? function(fn) {\n  return fn && uncurryThis$t(fn);\n} : function(fn) {\n  return fn && function() {\n    return call$b.apply(fn, arguments);\n  };\n};\nvar isCallable$h = function(argument) {\n  return typeof argument == \"function\";\n};\nvar objectGetOwnPropertyDescriptor = {};\nvar fails$p = fails$r;\nvar descriptors = !fails$p(function() {\n  return Object.defineProperty({}, 1, {\n    get: function() {\n      return 7;\n    }\n  })[1] != 7;\n});\nvar NATIVE_BIND$2 = functionBindNative;\nvar call$a = Function.prototype.call;\nvar functionCall = NATIVE_BIND$2 ? call$a.bind(call$a) : function() {\n  return call$a.apply(call$a, arguments);\n};\nvar objectPropertyIsEnumerable = {};\nvar $propertyIsEnumerable$2 = {}.propertyIsEnumerable;\nvar getOwnPropertyDescriptor$5 = Object.getOwnPropertyDescriptor;\nvar NASHORN_BUG = getOwnPropertyDescriptor$5 && !$propertyIsEnumerable$2.call({\n  1: 2\n}, 1);\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {\n  var descriptor = getOwnPropertyDescriptor$5(this, V2);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable$2;\nvar createPropertyDescriptor$5 = function(bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value\n  };\n};\nvar uncurryThis$s = functionUncurryThis;\nvar toString$9 = uncurryThis$s({}.toString);\nvar stringSlice$1 = uncurryThis$s(\"\".slice);\nvar classofRaw$1 = function(it2) {\n  return stringSlice$1(toString$9(it2), 8, -1);\n};\nvar global$L = global$M;\nvar uncurryThis$r = functionUncurryThis;\nvar fails$o = fails$r;\nvar classof$f = classofRaw$1;\nvar Object$9 = global$L.Object;\nvar split = uncurryThis$r(\"\".split);\nvar indexedObject = fails$o(function() {\n  return !Object$9(\"z\").propertyIsEnumerable(0);\n}) ? function(it2) {\n  return classof$f(it2) == \"String\" ? split(it2, \"\") : Object$9(it2);\n} : Object$9;\nvar global$K = global$M;\nvar TypeError$j = global$K.TypeError;\nvar requireObjectCoercible$5 = function(it2) {\n  if (it2 == void 0)\n    throw TypeError$j(\"Can't call method on \" + it2);\n  return it2;\n};\nvar IndexedObject$3 = indexedObject;\nvar requireObjectCoercible$4 = requireObjectCoercible$5;\nvar toIndexedObject$b = function(it2) {\n  return IndexedObject$3(requireObjectCoercible$4(it2));\n};\nvar isCallable$g = isCallable$h;\nvar isObject$f = function(it2) {\n  return typeof it2 == \"object\" ? it2 !== null : isCallable$g(it2);\n};\nvar path$q = {};\nvar path$p = path$q;\nvar global$J = global$M;\nvar isCallable$f = isCallable$h;\nvar aFunction = function(variable) {\n  return isCallable$f(variable) ? variable : void 0;\n};\nvar getBuiltIn$9 = function(namespace, method22) {\n  return arguments.length < 2 ? aFunction(path$p[namespace]) || aFunction(global$J[namespace]) : path$p[namespace] && path$p[namespace][method22] || global$J[namespace] && global$J[namespace][method22];\n};\nvar uncurryThis$q = functionUncurryThis;\nvar objectIsPrototypeOf = uncurryThis$q({}.isPrototypeOf);\nvar getBuiltIn$8 = getBuiltIn$9;\nvar engineUserAgent = getBuiltIn$8(\"navigator\", \"userAgent\") || \"\";\nvar global$I = global$M;\nvar userAgent$3 = engineUserAgent;\nvar process = global$I.process;\nvar Deno = global$I.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match;\nvar version;\nif (v8) {\n  match = v8.split(\".\");\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\nif (!version && userAgent$3) {\n  match = userAgent$3.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent$3.match(/Chrome\\/(\\d+)/);\n    if (match)\n      version = +match[1];\n  }\n}\nvar engineV8Version = version;\nvar V8_VERSION$2 = engineV8Version;\nvar fails$n = fails$r;\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$n(function() {\n  var symbol22 = Symbol();\n  return !String(symbol22) || !(Object(symbol22) instanceof Symbol) || !Symbol.sham && V8_VERSION$2 && V8_VERSION$2 < 41;\n});\nvar NATIVE_SYMBOL$2 = nativeSymbol;\nvar useSymbolAsUid = NATIVE_SYMBOL$2 && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\nvar global$H = global$M;\nvar getBuiltIn$7 = getBuiltIn$9;\nvar isCallable$e = isCallable$h;\nvar isPrototypeOf$i = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\nvar Object$8 = global$H.Object;\nvar isSymbol$3 = USE_SYMBOL_AS_UID$1 ? function(it2) {\n  return typeof it2 == \"symbol\";\n} : function(it2) {\n  var $Symbol22 = getBuiltIn$7(\"Symbol\");\n  return isCallable$e($Symbol22) && isPrototypeOf$i($Symbol22.prototype, Object$8(it2));\n};\nvar global$G = global$M;\nvar String$4 = global$G.String;\nvar tryToString$4 = function(argument) {\n  try {\n    return String$4(argument);\n  } catch (error) {\n    return \"Object\";\n  }\n};\nvar global$F = global$M;\nvar isCallable$d = isCallable$h;\nvar tryToString$3 = tryToString$4;\nvar TypeError$i = global$F.TypeError;\nvar aCallable$7 = function(argument) {\n  if (isCallable$d(argument))\n    return argument;\n  throw TypeError$i(tryToString$3(argument) + \" is not a function\");\n};\nvar aCallable$6 = aCallable$7;\nvar getMethod$3 = function(V2, P) {\n  var func = V2[P];\n  return func == null ? void 0 : aCallable$6(func);\n};\nvar global$E = global$M;\nvar call$9 = functionCall;\nvar isCallable$c = isCallable$h;\nvar isObject$e = isObject$f;\nvar TypeError$h = global$E.TypeError;\nvar ordinaryToPrimitive$1 = function(input, pref) {\n  var fn, val;\n  if (pref === \"string\" && isCallable$c(fn = input.toString) && !isObject$e(val = call$9(fn, input)))\n    return val;\n  if (isCallable$c(fn = input.valueOf) && !isObject$e(val = call$9(fn, input)))\n    return val;\n  if (pref !== \"string\" && isCallable$c(fn = input.toString) && !isObject$e(val = call$9(fn, input)))\n    return val;\n  throw TypeError$h(\"Can't convert object to primitive value\");\n};\nvar shared$4 = { exports: {} };\nvar global$D = global$M;\nvar defineProperty$d = Object.defineProperty;\nvar setGlobal$1 = function(key, value) {\n  try {\n    defineProperty$d(global$D, key, {\n      value,\n      configurable: true,\n      writable: true\n    });\n  } catch (error) {\n    global$D[key] = value;\n  }\n  return value;\n};\nvar global$C = global$M;\nvar setGlobal = setGlobal$1;\nvar SHARED = \"__core-js_shared__\";\nvar store$3 = global$C[SHARED] || setGlobal(SHARED, {});\nvar sharedStore = store$3;\nvar store$2 = sharedStore;\n(shared$4.exports = function(key, value) {\n  return store$2[key] || (store$2[key] = value !== void 0 ? value : {});\n})(\"versions\", []).push({\n  version: \"3.21.1\",\n  mode: \"pure\",\n  copyright: \"\\xA9 2014-2022 Denis Pushkarev (zloirock.ru)\",\n  license: \"https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE\",\n  source: \"https://github.com/zloirock/core-js\"\n});\nvar global$B = global$M;\nvar requireObjectCoercible$3 = requireObjectCoercible$5;\nvar Object$7 = global$B.Object;\nvar toObject$e = function(argument) {\n  return Object$7(requireObjectCoercible$3(argument));\n};\nvar uncurryThis$p = functionUncurryThis;\nvar toObject$d = toObject$e;\nvar hasOwnProperty = uncurryThis$p({}.hasOwnProperty);\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it2, key) {\n  return hasOwnProperty(toObject$d(it2), key);\n};\nvar uncurryThis$o = functionUncurryThis;\nvar id$1 = 0;\nvar postfix = Math.random();\nvar toString$8 = uncurryThis$o(1 .toString);\nvar uid$4 = function(key) {\n  return \"Symbol(\" + (key === void 0 ? \"\" : key) + \")_\" + toString$8(++id$1 + postfix, 36);\n};\nvar global$A = global$M;\nvar shared$3 = shared$4.exports;\nvar hasOwn$f = hasOwnProperty_1;\nvar uid$3 = uid$4;\nvar NATIVE_SYMBOL$1 = nativeSymbol;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\nvar WellKnownSymbolsStore$1 = shared$3(\"wks\");\nvar Symbol$2 = global$A.Symbol;\nvar symbolFor = Symbol$2 && Symbol$2[\"for\"];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$2 : Symbol$2 && Symbol$2.withoutSetter || uid$3;\nvar wellKnownSymbol$j = function(name2) {\n  if (!hasOwn$f(WellKnownSymbolsStore$1, name2) || !(NATIVE_SYMBOL$1 || typeof WellKnownSymbolsStore$1[name2] == \"string\")) {\n    var description = \"Symbol.\" + name2;\n    if (NATIVE_SYMBOL$1 && hasOwn$f(Symbol$2, name2)) {\n      WellKnownSymbolsStore$1[name2] = Symbol$2[name2];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore$1[name2] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore$1[name2] = createWellKnownSymbol(description);\n    }\n  }\n  return WellKnownSymbolsStore$1[name2];\n};\nvar global$z = global$M;\nvar call$8 = functionCall;\nvar isObject$d = isObject$f;\nvar isSymbol$2 = isSymbol$3;\nvar getMethod$2 = getMethod$3;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$i = wellKnownSymbol$j;\nvar TypeError$g = global$z.TypeError;\nvar TO_PRIMITIVE$1 = wellKnownSymbol$i(\"toPrimitive\");\nvar toPrimitive$1 = function(input, pref) {\n  if (!isObject$d(input) || isSymbol$2(input))\n    return input;\n  var exoticToPrim = getMethod$2(input, TO_PRIMITIVE$1);\n  var result2;\n  if (exoticToPrim) {\n    if (pref === void 0)\n      pref = \"default\";\n    result2 = call$8(exoticToPrim, input, pref);\n    if (!isObject$d(result2) || isSymbol$2(result2))\n      return result2;\n    throw TypeError$g(\"Can't convert object to primitive value\");\n  }\n  if (pref === void 0)\n    pref = \"number\";\n  return ordinaryToPrimitive(input, pref);\n};\nvar toPrimitive = toPrimitive$1;\nvar isSymbol$1 = isSymbol$3;\nvar toPropertyKey$4 = function(argument) {\n  var key = toPrimitive(argument, \"string\");\n  return isSymbol$1(key) ? key : key + \"\";\n};\nvar global$y = global$M;\nvar isObject$c = isObject$f;\nvar document$1 = global$y.document;\nvar EXISTS$1 = isObject$c(document$1) && isObject$c(document$1.createElement);\nvar documentCreateElement$1 = function(it2) {\n  return EXISTS$1 ? document$1.createElement(it2) : {};\n};\nvar DESCRIPTORS$h = descriptors;\nvar fails$m = fails$r;\nvar createElement = documentCreateElement$1;\nvar ie8DomDefine = !DESCRIPTORS$h && !fails$m(function() {\n  return Object.defineProperty(createElement(\"div\"), \"a\", {\n    get: function() {\n      return 7;\n    }\n  }).a != 7;\n});\nvar DESCRIPTORS$g = descriptors;\nvar call$7 = functionCall;\nvar propertyIsEnumerableModule$2 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$4 = createPropertyDescriptor$5;\nvar toIndexedObject$a = toIndexedObject$b;\nvar toPropertyKey$3 = toPropertyKey$4;\nvar hasOwn$e = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\nvar $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$g ? $getOwnPropertyDescriptor$2 : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$a(O);\n  P = toPropertyKey$3(P);\n  if (IE8_DOM_DEFINE$1)\n    try {\n      return $getOwnPropertyDescriptor$2(O, P);\n    } catch (error) {\n    }\n  if (hasOwn$e(O, P))\n    return createPropertyDescriptor$4(!call$7(propertyIsEnumerableModule$2.f, O, P), O[P]);\n};\nvar fails$l = fails$r;\nvar isCallable$b = isCallable$h;\nvar replacement = /#|\\.prototype\\./;\nvar isForced$1 = function(feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true : value == NATIVE ? false : isCallable$b(detection) ? fails$l(detection) : !!detection;\n};\nvar normalize = isForced$1.normalize = function(string3) {\n  return String(string3).replace(replacement, \".\").toLowerCase();\n};\nvar data = isForced$1.data = {};\nvar NATIVE = isForced$1.NATIVE = \"N\";\nvar POLYFILL = isForced$1.POLYFILL = \"P\";\nvar isForced_1 = isForced$1;\nvar uncurryThis$n = functionUncurryThis;\nvar aCallable$5 = aCallable$7;\nvar NATIVE_BIND$1 = functionBindNative;\nvar bind$c = uncurryThis$n(uncurryThis$n.bind);\nvar functionBindContext = function(fn, that) {\n  aCallable$5(fn);\n  return that === void 0 ? fn : NATIVE_BIND$1 ? bind$c(fn, that) : function() {\n    return fn.apply(that, arguments);\n  };\n};\nvar objectDefineProperty = {};\nvar DESCRIPTORS$f = descriptors;\nvar fails$k = fails$r;\nvar v8PrototypeDefineBug = DESCRIPTORS$f && fails$k(function() {\n  return Object.defineProperty(function() {\n  }, \"prototype\", {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\nvar global$x = global$M;\nvar isObject$b = isObject$f;\nvar String$3 = global$x.String;\nvar TypeError$f = global$x.TypeError;\nvar anObject$b = function(argument) {\n  if (isObject$b(argument))\n    return argument;\n  throw TypeError$f(String$3(argument) + \" is not an object\");\n};\nvar global$w = global$M;\nvar DESCRIPTORS$e = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$a = anObject$b;\nvar toPropertyKey$2 = toPropertyKey$4;\nvar TypeError$e = global$w.TypeError;\nvar $defineProperty$1 = Object.defineProperty;\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = \"enumerable\";\nvar CONFIGURABLE$1 = \"configurable\";\nvar WRITABLE = \"writable\";\nobjectDefineProperty.f = DESCRIPTORS$e ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n  anObject$a(O);\n  P = toPropertyKey$2(P);\n  anObject$a(Attributes);\n  if (typeof O === \"function\" && P === \"prototype\" && \"value\" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor$1(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  }\n  return $defineProperty$1(O, P, Attributes);\n} : $defineProperty$1 : function defineProperty2(O, P, Attributes) {\n  anObject$a(O);\n  P = toPropertyKey$2(P);\n  anObject$a(Attributes);\n  if (IE8_DOM_DEFINE)\n    try {\n      return $defineProperty$1(O, P, Attributes);\n    } catch (error) {\n    }\n  if (\"get\" in Attributes || \"set\" in Attributes)\n    throw TypeError$e(\"Accessors not supported\");\n  if (\"value\" in Attributes)\n    O[P] = Attributes.value;\n  return O;\n};\nvar DESCRIPTORS$d = descriptors;\nvar definePropertyModule$4 = objectDefineProperty;\nvar createPropertyDescriptor$3 = createPropertyDescriptor$5;\nvar createNonEnumerableProperty$6 = DESCRIPTORS$d ? function(object2, key, value) {\n  return definePropertyModule$4.f(object2, key, createPropertyDescriptor$3(1, value));\n} : function(object2, key, value) {\n  object2[key] = value;\n  return object2;\n};\nvar global$v = global$M;\nvar apply$5 = functionApply;\nvar uncurryThis$m = functionUncurryThis;\nvar isCallable$a = isCallable$h;\nvar getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor.f;\nvar isForced = isForced_1;\nvar path$o = path$q;\nvar bind$b = functionBindContext;\nvar createNonEnumerableProperty$5 = createNonEnumerableProperty$6;\nvar hasOwn$d = hasOwnProperty_1;\nvar wrapConstructor = function(NativeConstructor) {\n  var Wrapper = function(a, b, c3) {\n    if (this instanceof Wrapper) {\n      switch (arguments.length) {\n        case 0:\n          return new NativeConstructor();\n        case 1:\n          return new NativeConstructor(a);\n        case 2:\n          return new NativeConstructor(a, b);\n      }\n      return new NativeConstructor(a, b, c3);\n    }\n    return apply$5(NativeConstructor, this, arguments);\n  };\n  Wrapper.prototype = NativeConstructor.prototype;\n  return Wrapper;\n};\nvar _export = function(options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var PROTO = options.proto;\n  var nativeSource = GLOBAL ? global$v : STATIC ? global$v[TARGET] : (global$v[TARGET] || {}).prototype;\n  var target = GLOBAL ? path$o : path$o[TARGET] || createNonEnumerableProperty$5(path$o, TARGET, {})[TARGET];\n  var targetPrototype = target.prototype;\n  var FORCED22, USE_NATIVE, VIRTUAL_PROTOTYPE;\n  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;\n  for (key in source) {\n    FORCED22 = isForced(GLOBAL ? key : TARGET + (STATIC ? \".\" : \"#\") + key, options.forced);\n    USE_NATIVE = !FORCED22 && nativeSource && hasOwn$d(nativeSource, key);\n    targetProperty = target[key];\n    if (USE_NATIVE)\n      if (options.noTargetGet) {\n        descriptor = getOwnPropertyDescriptor$4(nativeSource, key);\n        nativeProperty = descriptor && descriptor.value;\n      } else\n        nativeProperty = nativeSource[key];\n    sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];\n    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty)\n      continue;\n    if (options.bind && USE_NATIVE)\n      resultProperty = bind$b(sourceProperty, global$v);\n    else if (options.wrap && USE_NATIVE)\n      resultProperty = wrapConstructor(sourceProperty);\n    else if (PROTO && isCallable$a(sourceProperty))\n      resultProperty = uncurryThis$m(sourceProperty);\n    else\n      resultProperty = sourceProperty;\n    if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {\n      createNonEnumerableProperty$5(resultProperty, \"sham\", true);\n    }\n    createNonEnumerableProperty$5(target, key, resultProperty);\n    if (PROTO) {\n      VIRTUAL_PROTOTYPE = TARGET + \"Prototype\";\n      if (!hasOwn$d(path$o, VIRTUAL_PROTOTYPE)) {\n        createNonEnumerableProperty$5(path$o, VIRTUAL_PROTOTYPE, {});\n      }\n      createNonEnumerableProperty$5(path$o[VIRTUAL_PROTOTYPE], key, sourceProperty);\n      if (options.real && targetPrototype && !targetPrototype[key]) {\n        createNonEnumerableProperty$5(targetPrototype, key, sourceProperty);\n      }\n    }\n  }\n};\nvar $$C = _export;\nvar DESCRIPTORS$c = descriptors;\nvar defineProperty$c = objectDefineProperty.f;\n$$C({\n  target: \"Object\",\n  stat: true,\n  forced: Object.defineProperty !== defineProperty$c,\n  sham: !DESCRIPTORS$c\n}, {\n  defineProperty: defineProperty$c\n});\nvar path$n = path$q;\nvar Object$6 = path$n.Object;\nvar defineProperty$b = defineProperty$e.exports = function defineProperty3(it2, key, desc) {\n  return Object$6.defineProperty(it2, key, desc);\n};\nif (Object$6.defineProperty.sham)\n  defineProperty$b.sham = true;\nvar parent$V = defineProperty$e.exports;\nvar defineProperty$a = parent$V;\nvar parent$U = defineProperty$a;\nvar defineProperty$9 = parent$U;\nvar parent$T = defineProperty$9;\nvar defineProperty$8 = parent$T;\nvar defineProperty$7 = defineProperty$8;\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor)\n      descriptor.writable = true;\n    defineProperty$7(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps)\n    _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps)\n    _defineProperties(Constructor, staticProps);\n  defineProperty$7(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    defineProperty$7(obj, key, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar uncurryThis$l = functionUncurryThis;\nvar arraySlice$5 = uncurryThis$l([].slice);\nvar global$u = global$M;\nvar uncurryThis$k = functionUncurryThis;\nvar aCallable$4 = aCallable$7;\nvar isObject$a = isObject$f;\nvar hasOwn$c = hasOwnProperty_1;\nvar arraySlice$4 = arraySlice$5;\nvar NATIVE_BIND = functionBindNative;\nvar Function$2 = global$u.Function;\nvar concat$6 = uncurryThis$k([].concat);\nvar join = uncurryThis$k([].join);\nvar factories = {};\nvar construct$4 = function(C3, argsLength, args) {\n  if (!hasOwn$c(factories, argsLength)) {\n    for (var list2 = [], i = 0; i < argsLength; i++)\n      list2[i] = \"a[\" + i + \"]\";\n    factories[argsLength] = Function$2(\"C,a\", \"return new C(\" + join(list2, \",\") + \")\");\n  }\n  return factories[argsLength](C3, args);\n};\nvar functionBind = NATIVE_BIND ? Function$2.bind : function bind(that) {\n  var F2 = aCallable$4(this);\n  var Prototype = F2.prototype;\n  var partArgs = arraySlice$4(arguments, 1);\n  var boundFunction = function bound() {\n    var args = concat$6(partArgs, arraySlice$4(arguments));\n    return this instanceof boundFunction ? construct$4(F2, args.length, args) : F2.apply(that, args);\n  };\n  if (isObject$a(Prototype))\n    boundFunction.prototype = Prototype;\n  return boundFunction;\n};\nvar $$B = _export;\nvar bind$a = functionBind;\n$$B({\n  target: \"Function\",\n  proto: true,\n  forced: Function.bind !== bind$a\n}, {\n  bind: bind$a\n});\nvar path$m = path$q;\nvar entryVirtual$k = function(CONSTRUCTOR) {\n  return path$m[CONSTRUCTOR + \"Prototype\"];\n};\nvar entryVirtual$j = entryVirtual$k;\nvar bind$9 = entryVirtual$j(\"Function\").bind;\nvar isPrototypeOf$h = objectIsPrototypeOf;\nvar method$e = bind$9;\nvar FunctionPrototype$1 = Function.prototype;\nvar bind$8 = function(it2) {\n  var own = it2.bind;\n  return it2 === FunctionPrototype$1 || isPrototypeOf$h(FunctionPrototype$1, it2) && own === FunctionPrototype$1.bind ? method$e : own;\n};\nvar parent$S = bind$8;\nvar bind$7 = parent$S;\nvar bind$6 = bind$7;\nvar ceil = Math.ceil;\nvar floor$1 = Math.floor;\nvar toIntegerOrInfinity$4 = function(argument) {\n  var number3 = +argument;\n  return number3 !== number3 || number3 === 0 ? 0 : (number3 > 0 ? floor$1 : ceil)(number3);\n};\nvar toIntegerOrInfinity$3 = toIntegerOrInfinity$4;\nvar min$2 = Math.min;\nvar toLength$1 = function(argument) {\n  return argument > 0 ? min$2(toIntegerOrInfinity$3(argument), 9007199254740991) : 0;\n};\nvar toLength = toLength$1;\nvar lengthOfArrayLike$d = function(obj) {\n  return toLength(obj.length);\n};\nvar global$t = global$M;\nvar aCallable$3 = aCallable$7;\nvar toObject$c = toObject$e;\nvar IndexedObject$2 = indexedObject;\nvar lengthOfArrayLike$c = lengthOfArrayLike$d;\nvar TypeError$d = global$t.TypeError;\nvar createMethod$5 = function(IS_RIGHT) {\n  return function(that, callbackfn, argumentsLength, memo) {\n    aCallable$3(callbackfn);\n    var O = toObject$c(that);\n    var self2 = IndexedObject$2(O);\n    var length2 = lengthOfArrayLike$c(O);\n    var index2 = IS_RIGHT ? length2 - 1 : 0;\n    var i = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2)\n      while (true) {\n        if (index2 in self2) {\n          memo = self2[index2];\n          index2 += i;\n          break;\n        }\n        index2 += i;\n        if (IS_RIGHT ? index2 < 0 : length2 <= index2) {\n          throw TypeError$d(\"Reduce of empty array with no initial value\");\n        }\n      }\n    for (; IS_RIGHT ? index2 >= 0 : length2 > index2; index2 += i)\n      if (index2 in self2) {\n        memo = callbackfn(memo, self2[index2], index2, O);\n      }\n    return memo;\n  };\n};\nvar arrayReduce = {\n  left: createMethod$5(false),\n  right: createMethod$5(true)\n};\nvar fails$j = fails$r;\nvar arrayMethodIsStrict$5 = function(METHOD_NAME, argument) {\n  var method22 = [][METHOD_NAME];\n  return !!method22 && fails$j(function() {\n    method22.call(null, argument || function() {\n      return 1;\n    }, 1);\n  });\n};\nvar classof$e = classofRaw$1;\nvar global$s = global$M;\nvar engineIsNode = classof$e(global$s.process) == \"process\";\nvar $$A = _export;\nvar $reduce = arrayReduce.left;\nvar arrayMethodIsStrict$4 = arrayMethodIsStrict$5;\nvar CHROME_VERSION = engineV8Version;\nvar IS_NODE = engineIsNode;\nvar STRICT_METHOD$4 = arrayMethodIsStrict$4(\"reduce\");\nvar CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;\n$$A({\n  target: \"Array\",\n  proto: true,\n  forced: !STRICT_METHOD$4 || CHROME_BUG\n}, {\n  reduce: function reduce(callbackfn) {\n    var length2 = arguments.length;\n    return $reduce(this, callbackfn, length2, length2 > 1 ? arguments[1] : void 0);\n  }\n});\nvar entryVirtual$i = entryVirtual$k;\nvar reduce$3 = entryVirtual$i(\"Array\").reduce;\nvar isPrototypeOf$g = objectIsPrototypeOf;\nvar method$d = reduce$3;\nvar ArrayPrototype$e = Array.prototype;\nvar reduce$2 = function(it2) {\n  var own = it2.reduce;\n  return it2 === ArrayPrototype$e || isPrototypeOf$g(ArrayPrototype$e, it2) && own === ArrayPrototype$e.reduce ? method$d : own;\n};\nvar parent$R = reduce$2;\nvar reduce$1 = parent$R;\nvar reduce2 = reduce$1;\nvar classof$d = classofRaw$1;\nvar isArray$d = Array.isArray || function isArray(argument) {\n  return classof$d(argument) == \"Array\";\n};\nvar wellKnownSymbol$h = wellKnownSymbol$j;\nvar TO_STRING_TAG$3 = wellKnownSymbol$h(\"toStringTag\");\nvar test$2 = {};\ntest$2[TO_STRING_TAG$3] = \"z\";\nvar toStringTagSupport = String(test$2) === \"[object z]\";\nvar global$r = global$M;\nvar TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;\nvar isCallable$9 = isCallable$h;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol$g = wellKnownSymbol$j;\nvar TO_STRING_TAG$2 = wellKnownSymbol$g(\"toStringTag\");\nvar Object$5 = global$r.Object;\nvar CORRECT_ARGUMENTS = classofRaw(function() {\n  return arguments;\n}()) == \"Arguments\";\nvar tryGet = function(it2, key) {\n  try {\n    return it2[key];\n  } catch (error) {\n  }\n};\nvar classof$c = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function(it2) {\n  var O, tag, result2;\n  return it2 === void 0 ? \"Undefined\" : it2 === null ? \"Null\" : typeof (tag = tryGet(O = Object$5(it2), TO_STRING_TAG$2)) == \"string\" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result2 = classofRaw(O)) == \"Object\" && isCallable$9(O.callee) ? \"Arguments\" : result2;\n};\nvar uncurryThis$j = functionUncurryThis;\nvar isCallable$8 = isCallable$h;\nvar store$1 = sharedStore;\nvar functionToString = uncurryThis$j(Function.toString);\nif (!isCallable$8(store$1.inspectSource)) {\n  store$1.inspectSource = function(it2) {\n    return functionToString(it2);\n  };\n}\nvar inspectSource$2 = store$1.inspectSource;\nvar uncurryThis$i = functionUncurryThis;\nvar fails$i = fails$r;\nvar isCallable$7 = isCallable$h;\nvar classof$b = classof$c;\nvar getBuiltIn$6 = getBuiltIn$9;\nvar inspectSource$1 = inspectSource$2;\nvar noop = function() {\n};\nvar empty = [];\nvar construct$3 = getBuiltIn$6(\"Reflect\", \"construct\");\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec$2 = uncurryThis$i(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable$7(argument))\n    return false;\n  try {\n    construct$3(noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\nvar isConstructorLegacy = function isConstructor2(argument) {\n  if (!isCallable$7(argument))\n    return false;\n  switch (classof$b(argument)) {\n    case \"AsyncFunction\":\n    case \"GeneratorFunction\":\n    case \"AsyncGeneratorFunction\":\n      return false;\n  }\n  try {\n    return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource$1(argument));\n  } catch (error) {\n    return true;\n  }\n};\nisConstructorLegacy.sham = true;\nvar isConstructor$4 = !construct$3 || fails$i(function() {\n  var called;\n  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {\n    called = true;\n  }) || called;\n}) ? isConstructorLegacy : isConstructorModern;\nvar global$q = global$M;\nvar isArray$c = isArray$d;\nvar isConstructor$3 = isConstructor$4;\nvar isObject$9 = isObject$f;\nvar wellKnownSymbol$f = wellKnownSymbol$j;\nvar SPECIES$3 = wellKnownSymbol$f(\"species\");\nvar Array$5 = global$q.Array;\nvar arraySpeciesConstructor$1 = function(originalArray) {\n  var C3;\n  if (isArray$c(originalArray)) {\n    C3 = originalArray.constructor;\n    if (isConstructor$3(C3) && (C3 === Array$5 || isArray$c(C3.prototype)))\n      C3 = void 0;\n    else if (isObject$9(C3)) {\n      C3 = C3[SPECIES$3];\n      if (C3 === null)\n        C3 = void 0;\n    }\n  }\n  return C3 === void 0 ? Array$5 : C3;\n};\nvar arraySpeciesConstructor = arraySpeciesConstructor$1;\nvar arraySpeciesCreate$4 = function(originalArray, length2) {\n  return new (arraySpeciesConstructor(originalArray))(length2 === 0 ? 0 : length2);\n};\nvar bind$5 = functionBindContext;\nvar uncurryThis$h = functionUncurryThis;\nvar IndexedObject$1 = indexedObject;\nvar toObject$b = toObject$e;\nvar lengthOfArrayLike$b = lengthOfArrayLike$d;\nvar arraySpeciesCreate$3 = arraySpeciesCreate$4;\nvar push$5 = uncurryThis$h([].push);\nvar createMethod$4 = function(TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var IS_FILTER_REJECT = TYPE == 7;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function($this, callbackfn, that, specificCreate) {\n    var O = toObject$b($this);\n    var self2 = IndexedObject$1(O);\n    var boundFunction = bind$5(callbackfn, that);\n    var length2 = lengthOfArrayLike$b(self2);\n    var index2 = 0;\n    var create52 = specificCreate || arraySpeciesCreate$3;\n    var target = IS_MAP ? create52($this, length2) : IS_FILTER || IS_FILTER_REJECT ? create52($this, 0) : void 0;\n    var value, result2;\n    for (; length2 > index2; index2++)\n      if (NO_HOLES || index2 in self2) {\n        value = self2[index2];\n        result2 = boundFunction(value, index2, O);\n        if (TYPE) {\n          if (IS_MAP)\n            target[index2] = result2;\n          else if (result2)\n            switch (TYPE) {\n              case 3:\n                return true;\n              case 5:\n                return value;\n              case 6:\n                return index2;\n              case 2:\n                push$5(target, value);\n            }\n          else\n            switch (TYPE) {\n              case 4:\n                return false;\n              case 7:\n                push$5(target, value);\n            }\n        }\n      }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\nvar arrayIteration = {\n  forEach: createMethod$4(0),\n  map: createMethod$4(1),\n  filter: createMethod$4(2),\n  some: createMethod$4(3),\n  every: createMethod$4(4),\n  find: createMethod$4(5),\n  findIndex: createMethod$4(6),\n  filterReject: createMethod$4(7)\n};\nvar fails$h = fails$r;\nvar wellKnownSymbol$e = wellKnownSymbol$j;\nvar V8_VERSION$1 = engineV8Version;\nvar SPECIES$2 = wellKnownSymbol$e(\"species\");\nvar arrayMethodHasSpeciesSupport$5 = function(METHOD_NAME) {\n  return V8_VERSION$1 >= 51 || !fails$h(function() {\n    var array2 = [];\n    var constructor = array2.constructor = {};\n    constructor[SPECIES$2] = function() {\n      return {\n        foo: 1\n      };\n    };\n    return array2[METHOD_NAME](Boolean).foo !== 1;\n  });\n};\nvar $$z = _export;\nvar $filter = arrayIteration.filter;\nvar arrayMethodHasSpeciesSupport$4 = arrayMethodHasSpeciesSupport$5;\nvar HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport$4(\"filter\");\n$$z({\n  target: \"Array\",\n  proto: true,\n  forced: !HAS_SPECIES_SUPPORT$3\n}, {\n  filter: function filter(callbackfn) {\n    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);\n  }\n});\nvar entryVirtual$h = entryVirtual$k;\nvar filter$3 = entryVirtual$h(\"Array\").filter;\nvar isPrototypeOf$f = objectIsPrototypeOf;\nvar method$c = filter$3;\nvar ArrayPrototype$d = Array.prototype;\nvar filter$2 = function(it2) {\n  var own = it2.filter;\n  return it2 === ArrayPrototype$d || isPrototypeOf$f(ArrayPrototype$d, it2) && own === ArrayPrototype$d.filter ? method$c : own;\n};\nvar parent$Q = filter$2;\nvar filter$1 = parent$Q;\nvar filter2 = filter$1;\nvar $$y = _export;\nvar $map = arrayIteration.map;\nvar arrayMethodHasSpeciesSupport$3 = arrayMethodHasSpeciesSupport$5;\nvar HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport$3(\"map\");\n$$y({\n  target: \"Array\",\n  proto: true,\n  forced: !HAS_SPECIES_SUPPORT$2\n}, {\n  map: function map2(callbackfn) {\n    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);\n  }\n});\nvar entryVirtual$g = entryVirtual$k;\nvar map$6 = entryVirtual$g(\"Array\").map;\nvar isPrototypeOf$e = objectIsPrototypeOf;\nvar method$b = map$6;\nvar ArrayPrototype$c = Array.prototype;\nvar map$5 = function(it2) {\n  var own = it2.map;\n  return it2 === ArrayPrototype$c || isPrototypeOf$e(ArrayPrototype$c, it2) && own === ArrayPrototype$c.map ? method$b : own;\n};\nvar parent$P = map$5;\nvar map$4 = parent$P;\nvar map$3 = map$4;\nvar global$p = global$M;\nvar isArray$b = isArray$d;\nvar lengthOfArrayLike$a = lengthOfArrayLike$d;\nvar bind$4 = functionBindContext;\nvar TypeError$c = global$p.TypeError;\nvar flattenIntoArray$1 = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {\n  var targetIndex = start;\n  var sourceIndex = 0;\n  var mapFn = mapper ? bind$4(mapper, thisArg) : false;\n  var element, elementLen;\n  while (sourceIndex < sourceLen) {\n    if (sourceIndex in source) {\n      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];\n      if (depth > 0 && isArray$b(element)) {\n        elementLen = lengthOfArrayLike$a(element);\n        targetIndex = flattenIntoArray$1(target, original, element, elementLen, targetIndex, depth - 1) - 1;\n      } else {\n        if (targetIndex >= 9007199254740991)\n          throw TypeError$c(\"Exceed the acceptable array length\");\n        target[targetIndex] = element;\n      }\n      targetIndex++;\n    }\n    sourceIndex++;\n  }\n  return targetIndex;\n};\nvar flattenIntoArray_1 = flattenIntoArray$1;\nvar $$x = _export;\nvar flattenIntoArray = flattenIntoArray_1;\nvar aCallable$2 = aCallable$7;\nvar toObject$a = toObject$e;\nvar lengthOfArrayLike$9 = lengthOfArrayLike$d;\nvar arraySpeciesCreate$2 = arraySpeciesCreate$4;\n$$x({\n  target: \"Array\",\n  proto: true\n}, {\n  flatMap: function flatMap(callbackfn) {\n    var O = toObject$a(this);\n    var sourceLen = lengthOfArrayLike$9(O);\n    var A2;\n    aCallable$2(callbackfn);\n    A2 = arraySpeciesCreate$2(O, 0);\n    A2.length = flattenIntoArray(A2, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);\n    return A2;\n  }\n});\nvar entryVirtual$f = entryVirtual$k;\nvar flatMap$3 = entryVirtual$f(\"Array\").flatMap;\nvar ArrayPrototype$b = Array.prototype;\nvar global$o = global$M;\nvar classof$a = classof$c;\nvar String$2 = global$o.String;\nvar toString$7 = function(argument) {\n  if (classof$a(argument) === \"Symbol\")\n    throw TypeError(\"Cannot convert a Symbol value to a string\");\n  return String$2(argument);\n};\nvar uncurryThis$g = functionUncurryThis;\nvar toIntegerOrInfinity$2 = toIntegerOrInfinity$4;\nvar toString$6 = toString$7;\nvar requireObjectCoercible$2 = requireObjectCoercible$5;\nvar charAt$2 = uncurryThis$g(\"\".charAt);\nvar charCodeAt$1 = uncurryThis$g(\"\".charCodeAt);\nvar stringSlice = uncurryThis$g(\"\".slice);\nvar createMethod$3 = function(CONVERT_TO_STRING) {\n  return function($this, pos) {\n    var S2 = toString$6(requireObjectCoercible$2($this));\n    var position = toIntegerOrInfinity$2(pos);\n    var size = S2.length;\n    var first2, second;\n    if (position < 0 || position >= size)\n      return CONVERT_TO_STRING ? \"\" : void 0;\n    first2 = charCodeAt$1(S2, position);\n    return first2 < 55296 || first2 > 56319 || position + 1 === size || (second = charCodeAt$1(S2, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt$2(S2, position) : first2 : CONVERT_TO_STRING ? stringSlice(S2, position, position + 2) : (first2 - 55296 << 10) + (second - 56320) + 65536;\n  };\n};\nvar stringMultibyte = {\n  codeAt: createMethod$3(false),\n  charAt: createMethod$3(true)\n};\nvar global$n = global$M;\nvar isCallable$6 = isCallable$h;\nvar inspectSource = inspectSource$2;\nvar WeakMap$1 = global$n.WeakMap;\nvar nativeWeakMap = isCallable$6(WeakMap$1) && /native code/.test(inspectSource(WeakMap$1));\nvar shared$2 = shared$4.exports;\nvar uid$2 = uid$4;\nvar keys$7 = shared$2(\"keys\");\nvar sharedKey$4 = function(key) {\n  return keys$7[key] || (keys$7[key] = uid$2(key));\n};\nvar hiddenKeys$6 = {};\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$m = global$M;\nvar uncurryThis$f = functionUncurryThis;\nvar isObject$8 = isObject$f;\nvar createNonEnumerableProperty$4 = createNonEnumerableProperty$6;\nvar hasOwn$b = hasOwnProperty_1;\nvar shared$1 = sharedStore;\nvar sharedKey$3 = sharedKey$4;\nvar hiddenKeys$5 = hiddenKeys$6;\nvar OBJECT_ALREADY_INITIALIZED = \"Object already initialized\";\nvar TypeError$b = global$m.TypeError;\nvar WeakMap2 = global$m.WeakMap;\nvar set$3;\nvar get;\nvar has;\nvar enforce = function(it2) {\n  return has(it2) ? get(it2) : set$3(it2, {});\n};\nvar getterFor = function(TYPE) {\n  return function(it2) {\n    var state;\n    if (!isObject$8(it2) || (state = get(it2)).type !== TYPE) {\n      throw TypeError$b(\"Incompatible receiver, \" + TYPE + \" required\");\n    }\n    return state;\n  };\n};\nif (NATIVE_WEAK_MAP || shared$1.state) {\n  store = shared$1.state || (shared$1.state = new WeakMap2());\n  wmget = uncurryThis$f(store.get);\n  wmhas = uncurryThis$f(store.has);\n  wmset = uncurryThis$f(store.set);\n  set$3 = function(it2, metadata) {\n    if (wmhas(store, it2))\n      throw new TypeError$b(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it2;\n    wmset(store, it2, metadata);\n    return metadata;\n  };\n  get = function(it2) {\n    return wmget(store, it2) || {};\n  };\n  has = function(it2) {\n    return wmhas(store, it2);\n  };\n} else {\n  STATE = sharedKey$3(\"state\");\n  hiddenKeys$5[STATE] = true;\n  set$3 = function(it2, metadata) {\n    if (hasOwn$b(it2, STATE))\n      throw new TypeError$b(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it2;\n    createNonEnumerableProperty$4(it2, STATE, metadata);\n    return metadata;\n  };\n  get = function(it2) {\n    return hasOwn$b(it2, STATE) ? it2[STATE] : {};\n  };\n  has = function(it2) {\n    return hasOwn$b(it2, STATE);\n  };\n}\nvar store;\nvar wmget;\nvar wmhas;\nvar wmset;\nvar STATE;\nvar internalState = {\n  set: set$3,\n  get,\n  has,\n  enforce,\n  getterFor\n};\nvar DESCRIPTORS$b = descriptors;\nvar hasOwn$a = hasOwnProperty_1;\nvar FunctionPrototype = Function.prototype;\nvar getDescriptor = DESCRIPTORS$b && Object.getOwnPropertyDescriptor;\nvar EXISTS = hasOwn$a(FunctionPrototype, \"name\");\nvar PROPER = EXISTS && function something() {\n}.name === \"something\";\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$b || DESCRIPTORS$b && getDescriptor(FunctionPrototype, \"name\").configurable);\nvar functionName = {\n  EXISTS,\n  PROPER,\n  CONFIGURABLE\n};\nvar objectDefineProperties = {};\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$4;\nvar max$3 = Math.max;\nvar min$1 = Math.min;\nvar toAbsoluteIndex$5 = function(index2, length2) {\n  var integer = toIntegerOrInfinity$1(index2);\n  return integer < 0 ? max$3(integer + length2, 0) : min$1(integer, length2);\n};\nvar toIndexedObject$9 = toIndexedObject$b;\nvar toAbsoluteIndex$4 = toAbsoluteIndex$5;\nvar lengthOfArrayLike$8 = lengthOfArrayLike$d;\nvar createMethod$2 = function(IS_INCLUDES) {\n  return function($this, el, fromIndex) {\n    var O = toIndexedObject$9($this);\n    var length2 = lengthOfArrayLike$8(O);\n    var index2 = toAbsoluteIndex$4(fromIndex, length2);\n    var value;\n    if (IS_INCLUDES && el != el)\n      while (length2 > index2) {\n        value = O[index2++];\n        if (value != value)\n          return true;\n      }\n    else\n      for (; length2 > index2; index2++) {\n        if ((IS_INCLUDES || index2 in O) && O[index2] === el)\n          return IS_INCLUDES || index2 || 0;\n      }\n    return !IS_INCLUDES && -1;\n  };\n};\nvar arrayIncludes = {\n  includes: createMethod$2(true),\n  indexOf: createMethod$2(false)\n};\nvar uncurryThis$e = functionUncurryThis;\nvar hasOwn$9 = hasOwnProperty_1;\nvar toIndexedObject$8 = toIndexedObject$b;\nvar indexOf = arrayIncludes.indexOf;\nvar hiddenKeys$4 = hiddenKeys$6;\nvar push$4 = uncurryThis$e([].push);\nvar objectKeysInternal = function(object2, names) {\n  var O = toIndexedObject$8(object2);\n  var i = 0;\n  var result2 = [];\n  var key;\n  for (key in O)\n    !hasOwn$9(hiddenKeys$4, key) && hasOwn$9(O, key) && push$4(result2, key);\n  while (names.length > i)\n    if (hasOwn$9(O, key = names[i++])) {\n      ~indexOf(result2, key) || push$4(result2, key);\n    }\n  return result2;\n};\nvar enumBugKeys$3 = [\"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"toLocaleString\", \"toString\", \"valueOf\"];\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\nvar objectKeys$4 = Object.keys || function keys(O) {\n  return internalObjectKeys$1(O, enumBugKeys$2);\n};\nvar DESCRIPTORS$a = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$3 = objectDefineProperty;\nvar anObject$9 = anObject$b;\nvar toIndexedObject$7 = toIndexedObject$b;\nvar objectKeys$3 = objectKeys$4;\nobjectDefineProperties.f = DESCRIPTORS$a && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject$9(O);\n  var props = toIndexedObject$7(Properties);\n  var keys42 = objectKeys$3(Properties);\n  var length2 = keys42.length;\n  var index2 = 0;\n  var key;\n  while (length2 > index2)\n    definePropertyModule$3.f(O, key = keys42[index2++], props[key]);\n  return O;\n};\nvar getBuiltIn$5 = getBuiltIn$9;\nvar html$1 = getBuiltIn$5(\"document\", \"documentElement\");\nvar anObject$8 = anObject$b;\nvar definePropertiesModule$1 = objectDefineProperties;\nvar enumBugKeys$1 = enumBugKeys$3;\nvar hiddenKeys$3 = hiddenKeys$6;\nvar html = html$1;\nvar documentCreateElement = documentCreateElement$1;\nvar sharedKey$2 = sharedKey$4;\nvar GT = \">\";\nvar LT = \"<\";\nvar PROTOTYPE$1 = \"prototype\";\nvar SCRIPT = \"script\";\nvar IE_PROTO$1 = sharedKey$2(\"IE_PROTO\");\nvar EmptyConstructor = function() {\n};\nvar scriptTag = function(content) {\n  return LT + SCRIPT + GT + content + LT + \"/\" + SCRIPT + GT;\n};\nvar NullProtoObjectViaActiveX = function(activeXDocument22) {\n  activeXDocument22.write(scriptTag(\"\"));\n  activeXDocument22.close();\n  var temp = activeXDocument22.parentWindow.Object;\n  activeXDocument22 = null;\n  return temp;\n};\nvar NullProtoObjectViaIFrame = function() {\n  var iframe = documentCreateElement(\"iframe\");\n  var JS = \"java\" + SCRIPT + \":\";\n  var iframeDocument;\n  iframe.style.display = \"none\";\n  html.appendChild(iframe);\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag(\"document.F=Object\"));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\nvar activeXDocument;\nvar NullProtoObject = function() {\n  try {\n    activeXDocument = new ActiveXObject(\"htmlfile\");\n  } catch (error) {\n  }\n  NullProtoObject = typeof document != \"undefined\" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);\n  var length2 = enumBugKeys$1.length;\n  while (length2--)\n    delete NullProtoObject[PROTOTYPE$1][enumBugKeys$1[length2]];\n  return NullProtoObject();\n};\nhiddenKeys$3[IE_PROTO$1] = true;\nvar objectCreate = Object.create || function create(O, Properties) {\n  var result2;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE$1] = anObject$8(O);\n    result2 = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE$1] = null;\n    result2[IE_PROTO$1] = O;\n  } else\n    result2 = NullProtoObject();\n  return Properties === void 0 ? result2 : definePropertiesModule$1.f(result2, Properties);\n};\nvar fails$g = fails$r;\nvar correctPrototypeGetter = !fails$g(function() {\n  function F2() {\n  }\n  F2.prototype.constructor = null;\n  return Object.getPrototypeOf(new F2()) !== F2.prototype;\n});\nvar global$l = global$M;\nvar hasOwn$8 = hasOwnProperty_1;\nvar isCallable$5 = isCallable$h;\nvar toObject$9 = toObject$e;\nvar sharedKey$1 = sharedKey$4;\nvar CORRECT_PROTOTYPE_GETTER$1 = correctPrototypeGetter;\nvar IE_PROTO = sharedKey$1(\"IE_PROTO\");\nvar Object$4 = global$l.Object;\nvar ObjectPrototype$2 = Object$4.prototype;\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER$1 ? Object$4.getPrototypeOf : function(O) {\n  var object2 = toObject$9(O);\n  if (hasOwn$8(object2, IE_PROTO))\n    return object2[IE_PROTO];\n  var constructor = object2.constructor;\n  if (isCallable$5(constructor) && object2 instanceof constructor) {\n    return constructor.prototype;\n  }\n  return object2 instanceof Object$4 ? ObjectPrototype$2 : null;\n};\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$6;\nvar redefine$4 = function(target, key, value, options) {\n  if (options && options.enumerable)\n    target[key] = value;\n  else\n    createNonEnumerableProperty$3(target, key, value);\n};\nvar fails$f = fails$r;\nvar isCallable$4 = isCallable$h;\nvar create$a = objectCreate;\nvar getPrototypeOf$6 = objectGetPrototypeOf;\nvar redefine$3 = redefine$4;\nvar wellKnownSymbol$d = wellKnownSymbol$j;\nvar ITERATOR$5 = wellKnownSymbol$d(\"iterator\");\nvar BUGGY_SAFARI_ITERATORS$1 = false;\nvar IteratorPrototype$1;\nvar PrototypeOfArrayIteratorPrototype;\nvar arrayIterator;\nif ([].keys) {\n  arrayIterator = [].keys();\n  if (!(\"next\" in arrayIterator))\n    BUGGY_SAFARI_ITERATORS$1 = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf$6(getPrototypeOf$6(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype)\n      IteratorPrototype$1 = PrototypeOfArrayIteratorPrototype;\n  }\n}\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$1 == void 0 || fails$f(function() {\n  var test22 = {};\n  return IteratorPrototype$1[ITERATOR$5].call(test22) !== test22;\n});\nif (NEW_ITERATOR_PROTOTYPE)\n  IteratorPrototype$1 = {};\nelse\n  IteratorPrototype$1 = create$a(IteratorPrototype$1);\nif (!isCallable$4(IteratorPrototype$1[ITERATOR$5])) {\n  redefine$3(IteratorPrototype$1, ITERATOR$5, function() {\n    return this;\n  });\n}\nvar iteratorsCore = {\n  IteratorPrototype: IteratorPrototype$1,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\nvar TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;\nvar classof$9 = classof$c;\nvar objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString() {\n  return \"[object \" + classof$9(this) + \"]\";\n};\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar defineProperty$6 = objectDefineProperty.f;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$6;\nvar hasOwn$7 = hasOwnProperty_1;\nvar toString$5 = objectToString;\nvar wellKnownSymbol$c = wellKnownSymbol$j;\nvar TO_STRING_TAG$1 = wellKnownSymbol$c(\"toStringTag\");\nvar setToStringTag$5 = function(it2, TAG, STATIC, SET_METHOD) {\n  if (it2) {\n    var target = STATIC ? it2 : it2.prototype;\n    if (!hasOwn$7(target, TO_STRING_TAG$1)) {\n      defineProperty$6(target, TO_STRING_TAG$1, {\n        configurable: true,\n        value: TAG\n      });\n    }\n    if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {\n      createNonEnumerableProperty$2(target, \"toString\", toString$5);\n    }\n  }\n};\nvar iterators = {};\nvar IteratorPrototype = iteratorsCore.IteratorPrototype;\nvar create$9 = objectCreate;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$5;\nvar setToStringTag$4 = setToStringTag$5;\nvar Iterators$5 = iterators;\nvar returnThis$1 = function() {\n  return this;\n};\nvar createIteratorConstructor$1 = function(IteratorConstructor, NAME, next23, ENUMERABLE_NEXT) {\n  var TO_STRING_TAG22 = NAME + \" Iterator\";\n  IteratorConstructor.prototype = create$9(IteratorPrototype, {\n    next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next23)\n  });\n  setToStringTag$4(IteratorConstructor, TO_STRING_TAG22, false, true);\n  Iterators$5[TO_STRING_TAG22] = returnThis$1;\n  return IteratorConstructor;\n};\nvar global$k = global$M;\nvar isCallable$3 = isCallable$h;\nvar String$1 = global$k.String;\nvar TypeError$a = global$k.TypeError;\nvar aPossiblePrototype$1 = function(argument) {\n  if (typeof argument == \"object\" || isCallable$3(argument))\n    return argument;\n  throw TypeError$a(\"Can't set \" + String$1(argument) + \" as a prototype\");\n};\nvar uncurryThis$d = functionUncurryThis;\nvar anObject$7 = anObject$b;\nvar aPossiblePrototype = aPossiblePrototype$1;\nvar objectSetPrototypeOf = Object.setPrototypeOf || (\"__proto__\" in {} ? function() {\n  var CORRECT_SETTER = false;\n  var test22 = {};\n  var setter;\n  try {\n    setter = uncurryThis$d(Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\").set);\n    setter(test22, []);\n    CORRECT_SETTER = test22 instanceof Array;\n  } catch (error) {\n  }\n  return function setPrototypeOf22(O, proto) {\n    anObject$7(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER)\n      setter(O, proto);\n    else\n      O.__proto__ = proto;\n    return O;\n  };\n}() : void 0);\nvar $$w = _export;\nvar call$6 = functionCall;\nvar FunctionName = functionName;\nvar createIteratorConstructor = createIteratorConstructor$1;\nvar getPrototypeOf$5 = objectGetPrototypeOf;\nvar setToStringTag$3 = setToStringTag$5;\nvar redefine$2 = redefine$4;\nvar wellKnownSymbol$b = wellKnownSymbol$j;\nvar Iterators$4 = iterators;\nvar IteratorsCore = iteratorsCore;\nvar PROPER_FUNCTION_NAME$1 = FunctionName.PROPER;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$4 = wellKnownSymbol$b(\"iterator\");\nvar KEYS = \"keys\";\nvar VALUES = \"values\";\nvar ENTRIES = \"entries\";\nvar returnThis = function() {\n  return this;\n};\nvar defineIterator$3 = function(Iterable, NAME, IteratorConstructor, next23, DEFAULT, IS_SET, FORCED22) {\n  createIteratorConstructor(IteratorConstructor, NAME, next23);\n  var getIterationMethod = function(KIND) {\n    if (KIND === DEFAULT && defaultIterator)\n      return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)\n      return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS:\n        return function keys42() {\n          return new IteratorConstructor(this, KIND);\n        };\n      case VALUES:\n        return function values32() {\n          return new IteratorConstructor(this, KIND);\n        };\n      case ENTRIES:\n        return function entries2() {\n          return new IteratorConstructor(this, KIND);\n        };\n    }\n    return function() {\n      return new IteratorConstructor(this);\n    };\n  };\n  var TO_STRING_TAG22 = NAME + \" Iterator\";\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR$4] || IterablePrototype[\"@@iterator\"] || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == \"Array\" ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf$5(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      setToStringTag$3(CurrentIteratorPrototype, TO_STRING_TAG22, true, true);\n      Iterators$4[TO_STRING_TAG22] = returnThis;\n    }\n  }\n  if (PROPER_FUNCTION_NAME$1 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values32() {\n        return call$6(nativeIterator, this);\n      };\n    }\n  }\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED22)\n      for (KEY in methods) {\n        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n          redefine$2(IterablePrototype, KEY, methods[KEY]);\n        }\n      }\n    else\n      $$w({\n        target: NAME,\n        proto: true,\n        forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME\n      }, methods);\n  }\n  if (FORCED22 && IterablePrototype[ITERATOR$4] !== defaultIterator) {\n    redefine$2(IterablePrototype, ITERATOR$4, defaultIterator, {\n      name: DEFAULT\n    });\n  }\n  Iterators$4[NAME] = defaultIterator;\n  return methods;\n};\nvar charAt$1 = stringMultibyte.charAt;\nvar toString$4 = toString$7;\nvar InternalStateModule$4 = internalState;\nvar defineIterator$2 = defineIterator$3;\nvar STRING_ITERATOR = \"String Iterator\";\nvar setInternalState$4 = InternalStateModule$4.set;\nvar getInternalState$2 = InternalStateModule$4.getterFor(STRING_ITERATOR);\ndefineIterator$2(String, \"String\", function(iterated) {\n  setInternalState$4(this, {\n    type: STRING_ITERATOR,\n    string: toString$4(iterated),\n    index: 0\n  });\n}, function next() {\n  var state = getInternalState$2(this);\n  var string3 = state.string;\n  var index2 = state.index;\n  var point;\n  if (index2 >= string3.length)\n    return {\n      value: void 0,\n      done: true\n    };\n  point = charAt$1(string3, index2);\n  state.index += point.length;\n  return {\n    value: point,\n    done: false\n  };\n});\nvar call$5 = functionCall;\nvar anObject$6 = anObject$b;\nvar getMethod$1 = getMethod$3;\nvar iteratorClose$2 = function(iterator22, kind, value) {\n  var innerResult, innerError;\n  anObject$6(iterator22);\n  try {\n    innerResult = getMethod$1(iterator22, \"return\");\n    if (!innerResult) {\n      if (kind === \"throw\")\n        throw value;\n      return value;\n    }\n    innerResult = call$5(innerResult, iterator22);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === \"throw\")\n    throw value;\n  if (innerError)\n    throw innerResult;\n  anObject$6(innerResult);\n  return value;\n};\nvar anObject$5 = anObject$b;\nvar iteratorClose$1 = iteratorClose$2;\nvar callWithSafeIterationClosing$1 = function(iterator22, fn, value, ENTRIES22) {\n  try {\n    return ENTRIES22 ? fn(anObject$5(value)[0], value[1]) : fn(value);\n  } catch (error) {\n    iteratorClose$1(iterator22, \"throw\", error);\n  }\n};\nvar wellKnownSymbol$a = wellKnownSymbol$j;\nvar Iterators$3 = iterators;\nvar ITERATOR$3 = wellKnownSymbol$a(\"iterator\");\nvar ArrayPrototype$a = Array.prototype;\nvar isArrayIteratorMethod$2 = function(it2) {\n  return it2 !== void 0 && (Iterators$3.Array === it2 || ArrayPrototype$a[ITERATOR$3] === it2);\n};\nvar toPropertyKey$1 = toPropertyKey$4;\nvar definePropertyModule$2 = objectDefineProperty;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$5;\nvar createProperty$6 = function(object2, key, value) {\n  var propertyKey = toPropertyKey$1(key);\n  if (propertyKey in object2)\n    definePropertyModule$2.f(object2, propertyKey, createPropertyDescriptor$1(0, value));\n  else\n    object2[propertyKey] = value;\n};\nvar classof$8 = classof$c;\nvar getMethod = getMethod$3;\nvar Iterators$2 = iterators;\nvar wellKnownSymbol$9 = wellKnownSymbol$j;\nvar ITERATOR$2 = wellKnownSymbol$9(\"iterator\");\nvar getIteratorMethod$8 = function(it2) {\n  if (it2 != void 0)\n    return getMethod(it2, ITERATOR$2) || getMethod(it2, \"@@iterator\") || Iterators$2[classof$8(it2)];\n};\nvar global$j = global$M;\nvar call$4 = functionCall;\nvar aCallable$1 = aCallable$7;\nvar anObject$4 = anObject$b;\nvar tryToString$2 = tryToString$4;\nvar getIteratorMethod$7 = getIteratorMethod$8;\nvar TypeError$9 = global$j.TypeError;\nvar getIterator$7 = function(argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$7(argument) : usingIterator;\n  if (aCallable$1(iteratorMethod))\n    return anObject$4(call$4(iteratorMethod, argument));\n  throw TypeError$9(tryToString$2(argument) + \" is not iterable\");\n};\nvar global$i = global$M;\nvar bind$3 = functionBindContext;\nvar call$3 = functionCall;\nvar toObject$8 = toObject$e;\nvar callWithSafeIterationClosing = callWithSafeIterationClosing$1;\nvar isArrayIteratorMethod$1 = isArrayIteratorMethod$2;\nvar isConstructor$2 = isConstructor$4;\nvar lengthOfArrayLike$7 = lengthOfArrayLike$d;\nvar createProperty$5 = createProperty$6;\nvar getIterator$6 = getIterator$7;\nvar getIteratorMethod$6 = getIteratorMethod$8;\nvar Array$4 = global$i.Array;\nvar arrayFrom = function from(arrayLike) {\n  var O = toObject$8(arrayLike);\n  var IS_CONSTRUCTOR = isConstructor$2(this);\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;\n  var mapping = mapfn !== void 0;\n  if (mapping)\n    mapfn = bind$3(mapfn, argumentsLength > 2 ? arguments[2] : void 0);\n  var iteratorMethod = getIteratorMethod$6(O);\n  var index2 = 0;\n  var length2, result2, step, iterator22, next23, value;\n  if (iteratorMethod && !(this == Array$4 && isArrayIteratorMethod$1(iteratorMethod))) {\n    iterator22 = getIterator$6(O, iteratorMethod);\n    next23 = iterator22.next;\n    result2 = IS_CONSTRUCTOR ? new this() : [];\n    for (; !(step = call$3(next23, iterator22)).done; index2++) {\n      value = mapping ? callWithSafeIterationClosing(iterator22, mapfn, [step.value, index2], true) : step.value;\n      createProperty$5(result2, index2, value);\n    }\n  } else {\n    length2 = lengthOfArrayLike$7(O);\n    result2 = IS_CONSTRUCTOR ? new this(length2) : Array$4(length2);\n    for (; length2 > index2; index2++) {\n      value = mapping ? mapfn(O[index2], index2) : O[index2];\n      createProperty$5(result2, index2, value);\n    }\n  }\n  result2.length = index2;\n  return result2;\n};\nvar wellKnownSymbol$8 = wellKnownSymbol$j;\nvar ITERATOR$1 = wellKnownSymbol$8(\"iterator\");\nvar SAFE_CLOSING = false;\ntry {\n  called = 0;\n  iteratorWithReturn = {\n    next: function() {\n      return {\n        done: !!called++\n      };\n    },\n    return: function() {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR$1] = function() {\n    return this;\n  };\n  Array.from(iteratorWithReturn, function() {\n    throw 2;\n  });\n} catch (error) {\n}\nvar called;\nvar iteratorWithReturn;\nvar checkCorrectnessOfIteration$1 = function(exec22, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING)\n    return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object2 = {};\n    object2[ITERATOR$1] = function() {\n      return {\n        next: function() {\n          return {\n            done: ITERATION_SUPPORT = true\n          };\n        }\n      };\n    };\n    exec22(object2);\n  } catch (error) {\n  }\n  return ITERATION_SUPPORT;\n};\nvar $$v = _export;\nvar from$6 = arrayFrom;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;\nvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {\n  Array.from(iterable);\n});\n$$v({\n  target: \"Array\",\n  stat: true,\n  forced: INCORRECT_ITERATION\n}, {\n  from: from$6\n});\nvar path$l = path$q;\nvar from$5 = path$l.Array.from;\nvar parent$N = from$5;\nvar from$4 = parent$N;\nvar from$3 = from$4;\nvar toIndexedObject$6 = toIndexedObject$b;\nvar Iterators$1 = iterators;\nvar InternalStateModule$3 = internalState;\nvar defineIterator$1 = defineIterator$3;\nvar ARRAY_ITERATOR = \"Array Iterator\";\nvar setInternalState$3 = InternalStateModule$3.set;\nvar getInternalState$1 = InternalStateModule$3.getterFor(ARRAY_ITERATOR);\ndefineIterator$1(Array, \"Array\", function(iterated, kind) {\n  setInternalState$3(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject$6(iterated),\n    index: 0,\n    kind\n  });\n}, function() {\n  var state = getInternalState$1(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index2 = state.index++;\n  if (!target || index2 >= target.length) {\n    state.target = void 0;\n    return {\n      value: void 0,\n      done: true\n    };\n  }\n  if (kind == \"keys\")\n    return {\n      value: index2,\n      done: false\n    };\n  if (kind == \"values\")\n    return {\n      value: target[index2],\n      done: false\n    };\n  return {\n    value: [index2, target[index2]],\n    done: false\n  };\n}, \"values\");\nIterators$1.Arguments = Iterators$1.Array;\nvar getIteratorMethod$5 = getIteratorMethod$8;\nvar getIteratorMethod_1 = getIteratorMethod$5;\nvar domIterables = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\nvar DOMIterables$4 = domIterables;\nvar global$h = global$M;\nvar classof$7 = classof$c;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$6;\nvar Iterators = iterators;\nvar wellKnownSymbol$7 = wellKnownSymbol$j;\nvar TO_STRING_TAG = wellKnownSymbol$7(\"toStringTag\");\nfor (COLLECTION_NAME in DOMIterables$4) {\n  Collection = global$h[COLLECTION_NAME];\n  CollectionPrototype = Collection && Collection.prototype;\n  if (CollectionPrototype && classof$7(CollectionPrototype) !== TO_STRING_TAG) {\n    createNonEnumerableProperty$1(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\n  }\n  Iterators[COLLECTION_NAME] = Iterators.Array;\n}\nvar Collection;\nvar CollectionPrototype;\nvar COLLECTION_NAME;\nvar parent$M = getIteratorMethod_1;\nvar getIteratorMethod$4 = parent$M;\nvar parent$L = getIteratorMethod$4;\nvar getIteratorMethod$3 = parent$L;\nvar parent$K = getIteratorMethod$3;\nvar getIteratorMethod$2 = parent$K;\nvar getIteratorMethod$1 = getIteratorMethod$2;\nvar objectGetOwnPropertyNames = {};\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys = enumBugKeys$3;\nvar hiddenKeys$2 = enumBugKeys.concat(\"length\", \"prototype\");\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys$2);\n};\nvar objectGetOwnPropertyNamesExternal = {};\nvar global$g = global$M;\nvar toAbsoluteIndex$3 = toAbsoluteIndex$5;\nvar lengthOfArrayLike$6 = lengthOfArrayLike$d;\nvar createProperty$4 = createProperty$6;\nvar Array$3 = global$g.Array;\nvar max$2 = Math.max;\nvar arraySliceSimple = function(O, start, end) {\n  var length2 = lengthOfArrayLike$6(O);\n  var k2 = toAbsoluteIndex$3(start, length2);\n  var fin = toAbsoluteIndex$3(end === void 0 ? length2 : end, length2);\n  var result2 = Array$3(max$2(fin - k2, 0));\n  for (var n = 0; k2 < fin; k2++, n++)\n    createProperty$4(result2, n, O[k2]);\n  result2.length = n;\n  return result2;\n};\nvar classof$6 = classofRaw$1;\nvar toIndexedObject$5 = toIndexedObject$b;\nvar $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;\nvar arraySlice$3 = arraySliceSimple;\nvar windowNames = typeof window == \"object\" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];\nvar getWindowNames = function(it2) {\n  try {\n    return $getOwnPropertyNames$1(it2);\n  } catch (error) {\n    return arraySlice$3(windowNames);\n  }\n};\nobjectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames2(it2) {\n  return windowNames && classof$6(it2) == \"Window\" ? getWindowNames(it2) : $getOwnPropertyNames$1(toIndexedObject$5(it2));\n};\nvar objectGetOwnPropertySymbols = {};\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\nvar wellKnownSymbolWrapped = {};\nvar wellKnownSymbol$6 = wellKnownSymbol$j;\nwellKnownSymbolWrapped.f = wellKnownSymbol$6;\nvar path$k = path$q;\nvar hasOwn$6 = hasOwnProperty_1;\nvar wrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;\nvar defineProperty$5 = objectDefineProperty.f;\nvar defineWellKnownSymbol$l = function(NAME) {\n  var Symbol2 = path$k.Symbol || (path$k.Symbol = {});\n  if (!hasOwn$6(Symbol2, NAME))\n    defineProperty$5(Symbol2, NAME, {\n      value: wrappedWellKnownSymbolModule$1.f(NAME)\n    });\n};\nvar $$u = _export;\nvar global$f = global$M;\nvar getBuiltIn$4 = getBuiltIn$9;\nvar apply$4 = functionApply;\nvar call$2 = functionCall;\nvar uncurryThis$c = functionUncurryThis;\nvar DESCRIPTORS$9 = descriptors;\nvar NATIVE_SYMBOL = nativeSymbol;\nvar fails$e = fails$r;\nvar hasOwn$5 = hasOwnProperty_1;\nvar isArray$a = isArray$d;\nvar isCallable$2 = isCallable$h;\nvar isObject$7 = isObject$f;\nvar isPrototypeOf$c = objectIsPrototypeOf;\nvar isSymbol = isSymbol$3;\nvar anObject$3 = anObject$b;\nvar toObject$7 = toObject$e;\nvar toIndexedObject$4 = toIndexedObject$b;\nvar toPropertyKey = toPropertyKey$4;\nvar $toString = toString$7;\nvar createPropertyDescriptor = createPropertyDescriptor$5;\nvar nativeObjectCreate = objectCreate;\nvar objectKeys$2 = objectKeys$4;\nvar getOwnPropertyNamesModule$2 = objectGetOwnPropertyNames;\nvar getOwnPropertyNamesExternal = objectGetOwnPropertyNamesExternal;\nvar getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols;\nvar getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$1 = objectDefineProperty;\nvar definePropertiesModule = objectDefineProperties;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar arraySlice$2 = arraySlice$5;\nvar redefine$1 = redefine$4;\nvar shared = shared$4.exports;\nvar sharedKey = sharedKey$4;\nvar hiddenKeys$1 = hiddenKeys$6;\nvar uid$1 = uid$4;\nvar wellKnownSymbol$5 = wellKnownSymbol$j;\nvar wrappedWellKnownSymbolModule = wellKnownSymbolWrapped;\nvar defineWellKnownSymbol$k = defineWellKnownSymbol$l;\nvar setToStringTag$2 = setToStringTag$5;\nvar InternalStateModule$2 = internalState;\nvar $forEach$1 = arrayIteration.forEach;\nvar HIDDEN = sharedKey(\"hidden\");\nvar SYMBOL = \"Symbol\";\nvar PROTOTYPE = \"prototype\";\nvar TO_PRIMITIVE = wellKnownSymbol$5(\"toPrimitive\");\nvar setInternalState$2 = InternalStateModule$2.set;\nvar getInternalState = InternalStateModule$2.getterFor(SYMBOL);\nvar ObjectPrototype$1 = Object[PROTOTYPE];\nvar $Symbol = global$f.Symbol;\nvar SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];\nvar TypeError$8 = global$f.TypeError;\nvar QObject = global$f.QObject;\nvar $stringify$1 = getBuiltIn$4(\"JSON\", \"stringify\");\nvar nativeGetOwnPropertyDescriptor$1 = getOwnPropertyDescriptorModule$1.f;\nvar nativeDefineProperty = definePropertyModule$1.f;\nvar nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;\nvar nativePropertyIsEnumerable = propertyIsEnumerableModule$1.f;\nvar push$3 = uncurryThis$c([].push);\nvar AllSymbols = shared(\"symbols\");\nvar ObjectPrototypeSymbols = shared(\"op-symbols\");\nvar StringToSymbolRegistry = shared(\"string-to-symbol-registry\");\nvar SymbolToStringRegistry = shared(\"symbol-to-string-registry\");\nvar WellKnownSymbolsStore = shared(\"wks\");\nvar USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\nvar setSymbolDescriptor = DESCRIPTORS$9 && fails$e(function() {\n  return nativeObjectCreate(nativeDefineProperty({}, \"a\", {\n    get: function() {\n      return nativeDefineProperty(this, \"a\", {\n        value: 7\n      }).a;\n    }\n  })).a != 7;\n}) ? function(O, P, Attributes) {\n  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype$1, P);\n  if (ObjectPrototypeDescriptor)\n    delete ObjectPrototype$1[P];\n  nativeDefineProperty(O, P, Attributes);\n  if (ObjectPrototypeDescriptor && O !== ObjectPrototype$1) {\n    nativeDefineProperty(ObjectPrototype$1, P, ObjectPrototypeDescriptor);\n  }\n} : nativeDefineProperty;\nvar wrap$1 = function(tag, description) {\n  var symbol22 = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);\n  setInternalState$2(symbol22, {\n    type: SYMBOL,\n    tag,\n    description\n  });\n  if (!DESCRIPTORS$9)\n    symbol22.description = description;\n  return symbol22;\n};\nvar $defineProperty = function defineProperty4(O, P, Attributes) {\n  if (O === ObjectPrototype$1)\n    $defineProperty(ObjectPrototypeSymbols, P, Attributes);\n  anObject$3(O);\n  var key = toPropertyKey(P);\n  anObject$3(Attributes);\n  if (hasOwn$5(AllSymbols, key)) {\n    if (!Attributes.enumerable) {\n      if (!hasOwn$5(O, HIDDEN))\n        nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));\n      O[HIDDEN][key] = true;\n    } else {\n      if (hasOwn$5(O, HIDDEN) && O[HIDDEN][key])\n        O[HIDDEN][key] = false;\n      Attributes = nativeObjectCreate(Attributes, {\n        enumerable: createPropertyDescriptor(0, false)\n      });\n    }\n    return setSymbolDescriptor(O, key, Attributes);\n  }\n  return nativeDefineProperty(O, key, Attributes);\n};\nvar $defineProperties = function defineProperties2(O, Properties) {\n  anObject$3(O);\n  var properties = toIndexedObject$4(Properties);\n  var keys42 = objectKeys$2(properties).concat($getOwnPropertySymbols(properties));\n  $forEach$1(keys42, function(key) {\n    if (!DESCRIPTORS$9 || call$2($propertyIsEnumerable$1, properties, key))\n      $defineProperty(O, key, properties[key]);\n  });\n  return O;\n};\nvar $create = function create2(O, Properties) {\n  return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);\n};\nvar $propertyIsEnumerable$1 = function propertyIsEnumerable2(V2) {\n  var P = toPropertyKey(V2);\n  var enumerable = call$2(nativePropertyIsEnumerable, this, P);\n  if (this === ObjectPrototype$1 && hasOwn$5(AllSymbols, P) && !hasOwn$5(ObjectPrototypeSymbols, P))\n    return false;\n  return enumerable || !hasOwn$5(this, P) || !hasOwn$5(AllSymbols, P) || hasOwn$5(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor2(O, P) {\n  var it2 = toIndexedObject$4(O);\n  var key = toPropertyKey(P);\n  if (it2 === ObjectPrototype$1 && hasOwn$5(AllSymbols, key) && !hasOwn$5(ObjectPrototypeSymbols, key))\n    return;\n  var descriptor = nativeGetOwnPropertyDescriptor$1(it2, key);\n  if (descriptor && hasOwn$5(AllSymbols, key) && !(hasOwn$5(it2, HIDDEN) && it2[HIDDEN][key])) {\n    descriptor.enumerable = true;\n  }\n  return descriptor;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames3(O) {\n  var names = nativeGetOwnPropertyNames(toIndexedObject$4(O));\n  var result2 = [];\n  $forEach$1(names, function(key) {\n    if (!hasOwn$5(AllSymbols, key) && !hasOwn$5(hiddenKeys$1, key))\n      push$3(result2, key);\n  });\n  return result2;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(O) {\n  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$1;\n  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject$4(O));\n  var result2 = [];\n  $forEach$1(names, function(key) {\n    if (hasOwn$5(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn$5(ObjectPrototype$1, key))) {\n      push$3(result2, AllSymbols[key]);\n    }\n  });\n  return result2;\n};\nif (!NATIVE_SYMBOL) {\n  $Symbol = function Symbol2() {\n    if (isPrototypeOf$c(SymbolPrototype, this))\n      throw TypeError$8(\"Symbol is not a constructor\");\n    var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);\n    var tag = uid$1(description);\n    var setter = function(value) {\n      if (this === ObjectPrototype$1)\n        call$2(setter, ObjectPrototypeSymbols, value);\n      if (hasOwn$5(this, HIDDEN) && hasOwn$5(this[HIDDEN], tag))\n        this[HIDDEN][tag] = false;\n      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));\n    };\n    if (DESCRIPTORS$9 && USE_SETTER)\n      setSymbolDescriptor(ObjectPrototype$1, tag, {\n        configurable: true,\n        set: setter\n      });\n    return wrap$1(tag, description);\n  };\n  SymbolPrototype = $Symbol[PROTOTYPE];\n  redefine$1(SymbolPrototype, \"toString\", function toString32() {\n    return getInternalState(this).tag;\n  });\n  redefine$1($Symbol, \"withoutSetter\", function(description) {\n    return wrap$1(uid$1(description), description);\n  });\n  propertyIsEnumerableModule$1.f = $propertyIsEnumerable$1;\n  definePropertyModule$1.f = $defineProperty;\n  definePropertiesModule.f = $defineProperties;\n  getOwnPropertyDescriptorModule$1.f = $getOwnPropertyDescriptor;\n  getOwnPropertyNamesModule$2.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;\n  getOwnPropertySymbolsModule$2.f = $getOwnPropertySymbols;\n  wrappedWellKnownSymbolModule.f = function(name2) {\n    return wrap$1(wellKnownSymbol$5(name2), name2);\n  };\n  if (DESCRIPTORS$9) {\n    nativeDefineProperty(SymbolPrototype, \"description\", {\n      configurable: true,\n      get: function description() {\n        return getInternalState(this).description;\n      }\n    });\n  }\n}\n$$u({\n  global: true,\n  wrap: true,\n  forced: !NATIVE_SYMBOL,\n  sham: !NATIVE_SYMBOL\n}, {\n  Symbol: $Symbol\n});\n$forEach$1(objectKeys$2(WellKnownSymbolsStore), function(name2) {\n  defineWellKnownSymbol$k(name2);\n});\n$$u({\n  target: SYMBOL,\n  stat: true,\n  forced: !NATIVE_SYMBOL\n}, {\n  for: function(key) {\n    var string3 = $toString(key);\n    if (hasOwn$5(StringToSymbolRegistry, string3))\n      return StringToSymbolRegistry[string3];\n    var symbol22 = $Symbol(string3);\n    StringToSymbolRegistry[string3] = symbol22;\n    SymbolToStringRegistry[symbol22] = string3;\n    return symbol22;\n  },\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym))\n      throw TypeError$8(sym + \" is not a symbol\");\n    if (hasOwn$5(SymbolToStringRegistry, sym))\n      return SymbolToStringRegistry[sym];\n  },\n  useSetter: function() {\n    USE_SETTER = true;\n  },\n  useSimple: function() {\n    USE_SETTER = false;\n  }\n});\n$$u({\n  target: \"Object\",\n  stat: true,\n  forced: !NATIVE_SYMBOL,\n  sham: !DESCRIPTORS$9\n}, {\n  create: $create,\n  defineProperty: $defineProperty,\n  defineProperties: $defineProperties,\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor\n});\n$$u({\n  target: \"Object\",\n  stat: true,\n  forced: !NATIVE_SYMBOL\n}, {\n  getOwnPropertyNames: $getOwnPropertyNames,\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n$$u({\n  target: \"Object\",\n  stat: true,\n  forced: fails$e(function() {\n    getOwnPropertySymbolsModule$2.f(1);\n  })\n}, {\n  getOwnPropertySymbols: function getOwnPropertySymbols2(it2) {\n    return getOwnPropertySymbolsModule$2.f(toObject$7(it2));\n  }\n});\nif ($stringify$1) {\n  FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails$e(function() {\n    var symbol22 = $Symbol();\n    return $stringify$1([symbol22]) != \"[null]\" || $stringify$1({\n      a: symbol22\n    }) != \"{}\" || $stringify$1(Object(symbol22)) != \"{}\";\n  });\n  $$u({\n    target: \"JSON\",\n    stat: true,\n    forced: FORCED_JSON_STRINGIFY\n  }, {\n    stringify: function stringify32(it2, replacer, space) {\n      var args = arraySlice$2(arguments);\n      var $replacer = replacer;\n      if (!isObject$7(replacer) && it2 === void 0 || isSymbol(it2))\n        return;\n      if (!isArray$a(replacer))\n        replacer = function(key, value) {\n          if (isCallable$2($replacer))\n            value = call$2($replacer, this, key, value);\n          if (!isSymbol(value))\n            return value;\n        };\n      args[1] = replacer;\n      return apply$4($stringify$1, null, args);\n    }\n  });\n}\nvar FORCED_JSON_STRINGIFY;\nif (!SymbolPrototype[TO_PRIMITIVE]) {\n  valueOf = SymbolPrototype.valueOf;\n  redefine$1(SymbolPrototype, TO_PRIMITIVE, function(hint) {\n    return call$2(valueOf, this);\n  });\n}\nvar valueOf;\nsetToStringTag$2($Symbol, SYMBOL);\nhiddenKeys$1[HIDDEN] = true;\nvar path$j = path$q;\nvar getOwnPropertySymbols$2 = path$j.Object.getOwnPropertySymbols;\nvar parent$J = getOwnPropertySymbols$2;\nvar getOwnPropertySymbols$1 = parent$J;\nvar getOwnPropertySymbols3 = getOwnPropertySymbols$1;\nvar getOwnPropertyDescriptor$3 = { exports: {} };\nvar $$t = _export;\nvar fails$d = fails$r;\nvar toIndexedObject$3 = toIndexedObject$b;\nvar nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar DESCRIPTORS$8 = descriptors;\nvar FAILS_ON_PRIMITIVES$3 = fails$d(function() {\n  nativeGetOwnPropertyDescriptor(1);\n});\nvar FORCED$5 = !DESCRIPTORS$8 || FAILS_ON_PRIMITIVES$3;\n$$t({\n  target: \"Object\",\n  stat: true,\n  forced: FORCED$5,\n  sham: !DESCRIPTORS$8\n}, {\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor3(it2, key) {\n    return nativeGetOwnPropertyDescriptor(toIndexedObject$3(it2), key);\n  }\n});\nvar path$i = path$q;\nvar Object$3 = path$i.Object;\nvar getOwnPropertyDescriptor$2 = getOwnPropertyDescriptor$3.exports = function getOwnPropertyDescriptor4(it2, key) {\n  return Object$3.getOwnPropertyDescriptor(it2, key);\n};\nif (Object$3.getOwnPropertyDescriptor.sham)\n  getOwnPropertyDescriptor$2.sham = true;\nvar parent$I = getOwnPropertyDescriptor$3.exports;\nvar getOwnPropertyDescriptor$1 = parent$I;\nvar getOwnPropertyDescriptor5 = getOwnPropertyDescriptor$1;\nvar getBuiltIn$3 = getBuiltIn$9;\nvar uncurryThis$b = functionUncurryThis;\nvar getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar anObject$2 = anObject$b;\nvar concat$5 = uncurryThis$b([].concat);\nvar ownKeys$6 = getBuiltIn$3(\"Reflect\", \"ownKeys\") || function ownKeys(it2) {\n  var keys42 = getOwnPropertyNamesModule$1.f(anObject$2(it2));\n  var getOwnPropertySymbols42 = getOwnPropertySymbolsModule$1.f;\n  return getOwnPropertySymbols42 ? concat$5(keys42, getOwnPropertySymbols42(it2)) : keys42;\n};\nvar $$s = _export;\nvar DESCRIPTORS$7 = descriptors;\nvar ownKeys$5 = ownKeys$6;\nvar toIndexedObject$2 = toIndexedObject$b;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar createProperty$3 = createProperty$6;\n$$s({\n  target: \"Object\",\n  stat: true,\n  sham: !DESCRIPTORS$7\n}, {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object2) {\n    var O = toIndexedObject$2(object2);\n    var getOwnPropertyDescriptor62 = getOwnPropertyDescriptorModule.f;\n    var keys42 = ownKeys$5(O);\n    var result2 = {};\n    var index2 = 0;\n    var key, descriptor;\n    while (keys42.length > index2) {\n      descriptor = getOwnPropertyDescriptor62(O, key = keys42[index2++]);\n      if (descriptor !== void 0)\n        createProperty$3(result2, key, descriptor);\n    }\n    return result2;\n  }\n});\nvar path$h = path$q;\nvar getOwnPropertyDescriptors$2 = path$h.Object.getOwnPropertyDescriptors;\nvar parent$H = getOwnPropertyDescriptors$2;\nvar getOwnPropertyDescriptors$1 = parent$H;\nvar getOwnPropertyDescriptors2 = getOwnPropertyDescriptors$1;\nvar defineProperties$4 = { exports: {} };\nvar $$r = _export;\nvar DESCRIPTORS$6 = descriptors;\nvar defineProperties$3 = objectDefineProperties.f;\n$$r({\n  target: \"Object\",\n  stat: true,\n  forced: Object.defineProperties !== defineProperties$3,\n  sham: !DESCRIPTORS$6\n}, {\n  defineProperties: defineProperties$3\n});\nvar path$g = path$q;\nvar Object$2 = path$g.Object;\nvar defineProperties$2 = defineProperties$4.exports = function defineProperties3(T, D2) {\n  return Object$2.defineProperties(T, D2);\n};\nif (Object$2.defineProperties.sham)\n  defineProperties$2.sham = true;\nvar parent$G = defineProperties$4.exports;\nvar defineProperties$1 = parent$G;\nvar defineProperties4 = defineProperties$1;\nvar defineProperty$4 = defineProperty$a;\nvar $$q = _export;\nvar isArray$9 = isArray$d;\n$$q({\n  target: \"Array\",\n  stat: true\n}, {\n  isArray: isArray$9\n});\nvar path$f = path$q;\nvar isArray$8 = path$f.Array.isArray;\nvar parent$F = isArray$8;\nvar isArray$7 = parent$F;\nvar parent$E = isArray$7;\nvar isArray$6 = parent$E;\nvar parent$D = isArray$6;\nvar isArray$5 = parent$D;\nvar isArray$4 = isArray$5;\nfunction _arrayWithHoles(arr) {\n  if (isArray$4(arr))\n    return arr;\n}\nvar $$p = _export;\nvar global$e = global$M;\nvar fails$c = fails$r;\nvar isArray$3 = isArray$d;\nvar isObject$6 = isObject$f;\nvar toObject$6 = toObject$e;\nvar lengthOfArrayLike$5 = lengthOfArrayLike$d;\nvar createProperty$2 = createProperty$6;\nvar arraySpeciesCreate$1 = arraySpeciesCreate$4;\nvar arrayMethodHasSpeciesSupport$2 = arrayMethodHasSpeciesSupport$5;\nvar wellKnownSymbol$4 = wellKnownSymbol$j;\nvar V8_VERSION = engineV8Version;\nvar IS_CONCAT_SPREADABLE = wellKnownSymbol$4(\"isConcatSpreadable\");\nvar MAX_SAFE_INTEGER$1 = 9007199254740991;\nvar MAXIMUM_ALLOWED_INDEX_EXCEEDED = \"Maximum allowed index exceeded\";\nvar TypeError$7 = global$e.TypeError;\nvar IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails$c(function() {\n  var array2 = [];\n  array2[IS_CONCAT_SPREADABLE] = false;\n  return array2.concat()[0] !== array2;\n});\nvar SPECIES_SUPPORT = arrayMethodHasSpeciesSupport$2(\"concat\");\nvar isConcatSpreadable = function(O) {\n  if (!isObject$6(O))\n    return false;\n  var spreadable = O[IS_CONCAT_SPREADABLE];\n  return spreadable !== void 0 ? !!spreadable : isArray$3(O);\n};\nvar FORCED$4 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;\n$$p({\n  target: \"Array\",\n  proto: true,\n  forced: FORCED$4\n}, {\n  concat: function concat(arg) {\n    var O = toObject$6(this);\n    var A2 = arraySpeciesCreate$1(O, 0);\n    var n = 0;\n    var i, k2, length2, len, E;\n    for (i = -1, length2 = arguments.length; i < length2; i++) {\n      E = i === -1 ? O : arguments[i];\n      if (isConcatSpreadable(E)) {\n        len = lengthOfArrayLike$5(E);\n        if (n + len > MAX_SAFE_INTEGER$1)\n          throw TypeError$7(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n        for (k2 = 0; k2 < len; k2++, n++)\n          if (k2 in E)\n            createProperty$2(A2, n, E[k2]);\n      } else {\n        if (n >= MAX_SAFE_INTEGER$1)\n          throw TypeError$7(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n        createProperty$2(A2, n++, E);\n      }\n    }\n    A2.length = n;\n    return A2;\n  }\n});\nvar defineWellKnownSymbol$j = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$j(\"asyncIterator\");\nvar defineWellKnownSymbol$i = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$i(\"hasInstance\");\nvar defineWellKnownSymbol$h = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$h(\"isConcatSpreadable\");\nvar defineWellKnownSymbol$g = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$g(\"iterator\");\nvar defineWellKnownSymbol$f = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$f(\"match\");\nvar defineWellKnownSymbol$e = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$e(\"matchAll\");\nvar defineWellKnownSymbol$d = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$d(\"replace\");\nvar defineWellKnownSymbol$c = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$c(\"search\");\nvar defineWellKnownSymbol$b = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$b(\"species\");\nvar defineWellKnownSymbol$a = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$a(\"split\");\nvar defineWellKnownSymbol$9 = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$9(\"toPrimitive\");\nvar defineWellKnownSymbol$8 = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$8(\"toStringTag\");\nvar defineWellKnownSymbol$7 = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$7(\"unscopables\");\nvar global$d = global$M;\nvar setToStringTag$1 = setToStringTag$5;\nsetToStringTag$1(global$d.JSON, \"JSON\", true);\nvar path$e = path$q;\nvar symbol$5 = path$e.Symbol;\nvar parent$C = symbol$5;\nvar symbol$4 = parent$C;\nvar parent$B = symbol$4;\nvar symbol$3 = parent$B;\nvar defineWellKnownSymbol$6 = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$6(\"asyncDispose\");\nvar defineWellKnownSymbol$5 = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$5(\"dispose\");\nvar defineWellKnownSymbol$4 = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$4(\"matcher\");\nvar defineWellKnownSymbol$3 = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$3(\"metadata\");\nvar defineWellKnownSymbol$2 = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$2(\"observable\");\nvar defineWellKnownSymbol$1 = defineWellKnownSymbol$l;\ndefineWellKnownSymbol$1(\"patternMatch\");\nvar defineWellKnownSymbol = defineWellKnownSymbol$l;\ndefineWellKnownSymbol(\"replaceAll\");\nvar parent$A = symbol$3;\nvar symbol$2 = parent$A;\nvar symbol$1 = symbol$2;\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof symbol$1 !== \"undefined\" && getIteratorMethod$1(arr) || arr[\"@@iterator\"];\n  if (_i == null)\n    return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e3;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i)\n        break;\n    }\n  } catch (err) {\n    _d = true;\n    _e3 = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null)\n        _i[\"return\"]();\n    } finally {\n      if (_d)\n        throw _e3;\n    }\n  }\n  return _arr;\n}\nvar $$o = _export;\nvar global$c = global$M;\nvar isArray$2 = isArray$d;\nvar isConstructor$1 = isConstructor$4;\nvar isObject$5 = isObject$f;\nvar toAbsoluteIndex$2 = toAbsoluteIndex$5;\nvar lengthOfArrayLike$4 = lengthOfArrayLike$d;\nvar toIndexedObject$1 = toIndexedObject$b;\nvar createProperty$1 = createProperty$6;\nvar wellKnownSymbol$3 = wellKnownSymbol$j;\nvar arrayMethodHasSpeciesSupport$1 = arrayMethodHasSpeciesSupport$5;\nvar un$Slice = arraySlice$5;\nvar HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport$1(\"slice\");\nvar SPECIES$1 = wellKnownSymbol$3(\"species\");\nvar Array$2 = global$c.Array;\nvar max$1 = Math.max;\n$$o({\n  target: \"Array\",\n  proto: true,\n  forced: !HAS_SPECIES_SUPPORT$1\n}, {\n  slice: function slice(start, end) {\n    var O = toIndexedObject$1(this);\n    var length2 = lengthOfArrayLike$4(O);\n    var k2 = toAbsoluteIndex$2(start, length2);\n    var fin = toAbsoluteIndex$2(end === void 0 ? length2 : end, length2);\n    var Constructor, result2, n;\n    if (isArray$2(O)) {\n      Constructor = O.constructor;\n      if (isConstructor$1(Constructor) && (Constructor === Array$2 || isArray$2(Constructor.prototype))) {\n        Constructor = void 0;\n      } else if (isObject$5(Constructor)) {\n        Constructor = Constructor[SPECIES$1];\n        if (Constructor === null)\n          Constructor = void 0;\n      }\n      if (Constructor === Array$2 || Constructor === void 0) {\n        return un$Slice(O, k2, fin);\n      }\n    }\n    result2 = new (Constructor === void 0 ? Array$2 : Constructor)(max$1(fin - k2, 0));\n    for (n = 0; k2 < fin; k2++, n++)\n      if (k2 in O)\n        createProperty$1(result2, n, O[k2]);\n    result2.length = n;\n    return result2;\n  }\n});\nvar entryVirtual$e = entryVirtual$k;\nvar slice$6 = entryVirtual$e(\"Array\").slice;\nvar isPrototypeOf$b = objectIsPrototypeOf;\nvar method$9 = slice$6;\nvar ArrayPrototype$9 = Array.prototype;\nvar slice$5 = function(it2) {\n  var own = it2.slice;\n  return it2 === ArrayPrototype$9 || isPrototypeOf$b(ArrayPrototype$9, it2) && own === ArrayPrototype$9.slice ? method$9 : own;\n};\nvar parent$z = slice$5;\nvar slice$4 = parent$z;\nvar parent$y = slice$4;\nvar slice$3 = parent$y;\nvar parent$x = slice$3;\nvar slice$2 = parent$x;\nvar slice$1 = slice$2;\nvar parent$w = from$4;\nvar from$2 = parent$w;\nvar parent$v = from$2;\nvar from$1 = parent$v;\nvar from2 = from$1;\nfunction _arrayLikeToArray$4(arr, len) {\n  if (len == null || len > arr.length)\n    len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _unsupportedIterableToArray$4(o, minLen) {\n  var _context;\n  if (!o)\n    return;\n  if (typeof o === \"string\")\n    return _arrayLikeToArray$4(o, minLen);\n  var n = slice$1(_context = Object.prototype.toString.call(o)).call(_context, 8, -1);\n  if (n === \"Object\" && o.constructor)\n    n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\")\n    return from2(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray$4(o, minLen);\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$4(arr, i) || _nonIterableRest();\n}\nvar WrappedWellKnownSymbolModule = wellKnownSymbolWrapped;\nvar iterator$5 = WrappedWellKnownSymbolModule.f(\"iterator\");\nvar parent$u = iterator$5;\nvar iterator$4 = parent$u;\nvar parent$t = iterator$4;\nvar iterator$3 = parent$t;\nvar parent$s = iterator$3;\nvar iterator$2 = parent$s;\nvar iterator$1 = iterator$2;\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n  return _typeof = typeof symbol$1 == \"function\" && typeof iterator$1 == \"symbol\" ? function(obj2) {\n    return typeof obj2;\n  } : function(obj2) {\n    return obj2 && typeof symbol$1 == \"function\" && obj2.constructor === symbol$1 && obj2 !== symbol$1.prototype ? \"symbol\" : typeof obj2;\n  }, _typeof(obj);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (isArray$4(arr))\n    return _arrayLikeToArray$4(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof symbol$1 !== \"undefined\" && getIteratorMethod$1(iter) != null || iter[\"@@iterator\"] != null)\n    return from2(iter);\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$4(arr) || _nonIterableSpread();\n}\nvar symbol = symbol$4;\nvar entryVirtual$d = entryVirtual$k;\nvar concat$4 = entryVirtual$d(\"Array\").concat;\nvar isPrototypeOf$a = objectIsPrototypeOf;\nvar method$8 = concat$4;\nvar ArrayPrototype$8 = Array.prototype;\nvar concat$3 = function(it2) {\n  var own = it2.concat;\n  return it2 === ArrayPrototype$8 || isPrototypeOf$a(ArrayPrototype$8, it2) && own === ArrayPrototype$8.concat ? method$8 : own;\n};\nvar parent$r = concat$3;\nvar concat$2 = parent$r;\nvar concat$1 = concat$2;\nvar slice2 = slice$4;\nvar $$n = _export;\nvar ownKeys$4 = ownKeys$6;\n$$n({\n  target: \"Reflect\",\n  stat: true\n}, {\n  ownKeys: ownKeys$4\n});\nvar path$d = path$q;\nvar ownKeys$3 = path$d.Reflect.ownKeys;\nvar parent$q = ownKeys$3;\nvar ownKeys$2 = parent$q;\nvar ownKeys$1 = ownKeys$2;\nvar isArray$1 = isArray$7;\nvar $$m = _export;\nvar toObject$5 = toObject$e;\nvar nativeKeys = objectKeys$4;\nvar fails$b = fails$r;\nvar FAILS_ON_PRIMITIVES$2 = fails$b(function() {\n  nativeKeys(1);\n});\n$$m({\n  target: \"Object\",\n  stat: true,\n  forced: FAILS_ON_PRIMITIVES$2\n}, {\n  keys: function keys2(it2) {\n    return nativeKeys(toObject$5(it2));\n  }\n});\nvar path$c = path$q;\nvar keys$6 = path$c.Object.keys;\nvar parent$p = keys$6;\nvar keys$5 = parent$p;\nvar keys$4 = keys$5;\nvar $$l = _export;\nvar global$b = global$M;\nvar uncurryThis$a = functionUncurryThis;\nvar Date$1 = global$b.Date;\nvar getTime = uncurryThis$a(Date$1.prototype.getTime);\n$$l({\n  target: \"Date\",\n  stat: true\n}, {\n  now: function now() {\n    return getTime(new Date$1());\n  }\n});\nvar path$b = path$q;\npath$b.Date.now;\nvar $forEach = arrayIteration.forEach;\nvar arrayMethodIsStrict$3 = arrayMethodIsStrict$5;\nvar STRICT_METHOD$3 = arrayMethodIsStrict$3(\"forEach\");\nvar arrayForEach = !STRICT_METHOD$3 ? function forEach(callbackfn) {\n  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);\n} : [].forEach;\nvar $$k = _export;\nvar forEach$5 = arrayForEach;\n$$k({\n  target: \"Array\",\n  proto: true,\n  forced: [].forEach != forEach$5\n}, {\n  forEach: forEach$5\n});\nvar entryVirtual$c = entryVirtual$k;\nvar forEach$4 = entryVirtual$c(\"Array\").forEach;\nvar parent$o = forEach$4;\nvar forEach$3 = parent$o;\nvar classof$5 = classof$c;\nvar hasOwn$4 = hasOwnProperty_1;\nvar isPrototypeOf$9 = objectIsPrototypeOf;\nvar method$7 = forEach$3;\nvar ArrayPrototype$7 = Array.prototype;\nvar DOMIterables$3 = {\n  DOMTokenList: true,\n  NodeList: true\n};\nvar forEach$2 = function(it2) {\n  var own = it2.forEach;\n  return it2 === ArrayPrototype$7 || isPrototypeOf$9(ArrayPrototype$7, it2) && own === ArrayPrototype$7.forEach || hasOwn$4(DOMIterables$3, classof$5(it2)) ? method$7 : own;\n};\nvar forEach$1 = forEach$2;\nvar $$j = _export;\nvar uncurryThis$9 = functionUncurryThis;\nvar isArray2 = isArray$d;\nvar un$Reverse = uncurryThis$9([].reverse);\nvar test$1 = [1, 2];\n$$j({\n  target: \"Array\",\n  proto: true,\n  forced: String(test$1) === String(test$1.reverse())\n}, {\n  reverse: function reverse() {\n    if (isArray2(this))\n      this.length = this.length;\n    return un$Reverse(this);\n  }\n});\nvar entryVirtual$b = entryVirtual$k;\nvar reverse$3 = entryVirtual$b(\"Array\").reverse;\nvar isPrototypeOf$8 = objectIsPrototypeOf;\nvar method$6 = reverse$3;\nvar ArrayPrototype$6 = Array.prototype;\nvar reverse$2 = function(it2) {\n  var own = it2.reverse;\n  return it2 === ArrayPrototype$6 || isPrototypeOf$8(ArrayPrototype$6, it2) && own === ArrayPrototype$6.reverse ? method$6 : own;\n};\nvar parent$n = reverse$2;\nvar reverse$1 = parent$n;\nvar reverse2 = reverse$1;\nvar $$i = _export;\nvar global$a = global$M;\nvar toAbsoluteIndex$1 = toAbsoluteIndex$5;\nvar toIntegerOrInfinity = toIntegerOrInfinity$4;\nvar lengthOfArrayLike$3 = lengthOfArrayLike$d;\nvar toObject$4 = toObject$e;\nvar arraySpeciesCreate = arraySpeciesCreate$4;\nvar createProperty = createProperty$6;\nvar arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$5;\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport(\"splice\");\nvar TypeError$6 = global$a.TypeError;\nvar max = Math.max;\nvar min = Math.min;\nvar MAX_SAFE_INTEGER = 9007199254740991;\nvar MAXIMUM_ALLOWED_LENGTH_EXCEEDED = \"Maximum allowed length exceeded\";\n$$i({\n  target: \"Array\",\n  proto: true,\n  forced: !HAS_SPECIES_SUPPORT\n}, {\n  splice: function splice(start, deleteCount) {\n    var O = toObject$4(this);\n    var len = lengthOfArrayLike$3(O);\n    var actualStart = toAbsoluteIndex$1(start, len);\n    var argumentsLength = arguments.length;\n    var insertCount, actualDeleteCount, A2, k2, from32, to;\n    if (argumentsLength === 0) {\n      insertCount = actualDeleteCount = 0;\n    } else if (argumentsLength === 1) {\n      insertCount = 0;\n      actualDeleteCount = len - actualStart;\n    } else {\n      insertCount = argumentsLength - 2;\n      actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);\n    }\n    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {\n      throw TypeError$6(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);\n    }\n    A2 = arraySpeciesCreate(O, actualDeleteCount);\n    for (k2 = 0; k2 < actualDeleteCount; k2++) {\n      from32 = actualStart + k2;\n      if (from32 in O)\n        createProperty(A2, k2, O[from32]);\n    }\n    A2.length = actualDeleteCount;\n    if (insertCount < actualDeleteCount) {\n      for (k2 = actualStart; k2 < len - actualDeleteCount; k2++) {\n        from32 = k2 + actualDeleteCount;\n        to = k2 + insertCount;\n        if (from32 in O)\n          O[to] = O[from32];\n        else\n          delete O[to];\n      }\n      for (k2 = len; k2 > len - actualDeleteCount + insertCount; k2--)\n        delete O[k2 - 1];\n    } else if (insertCount > actualDeleteCount) {\n      for (k2 = len - actualDeleteCount; k2 > actualStart; k2--) {\n        from32 = k2 + actualDeleteCount - 1;\n        to = k2 + insertCount - 1;\n        if (from32 in O)\n          O[to] = O[from32];\n        else\n          delete O[to];\n      }\n    }\n    for (k2 = 0; k2 < insertCount; k2++) {\n      O[k2 + actualStart] = arguments[k2 + 2];\n    }\n    O.length = len - actualDeleteCount + insertCount;\n    return A2;\n  }\n});\nvar entryVirtual$a = entryVirtual$k;\nvar splice$3 = entryVirtual$a(\"Array\").splice;\nvar isPrototypeOf$7 = objectIsPrototypeOf;\nvar method$5 = splice$3;\nvar ArrayPrototype$5 = Array.prototype;\nvar splice$2 = function(it2) {\n  var own = it2.splice;\n  return it2 === ArrayPrototype$5 || isPrototypeOf$7(ArrayPrototype$5, it2) && own === ArrayPrototype$5.splice ? method$5 : own;\n};\nvar parent$m = splice$2;\nvar splice$1 = parent$m;\nvar splice2 = splice$1;\nvar DESCRIPTORS$5 = descriptors;\nvar uncurryThis$8 = functionUncurryThis;\nvar call$1 = functionCall;\nvar fails$a = fails$r;\nvar objectKeys$1 = objectKeys$4;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar toObject$3 = toObject$e;\nvar IndexedObject = indexedObject;\nvar $assign = Object.assign;\nvar defineProperty$3 = Object.defineProperty;\nvar concat2 = uncurryThis$8([].concat);\nvar objectAssign = !$assign || fails$a(function() {\n  if (DESCRIPTORS$5 && $assign({\n    b: 1\n  }, $assign(defineProperty$3({}, \"a\", {\n    enumerable: true,\n    get: function() {\n      defineProperty$3(this, \"b\", {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), {\n    b: 2\n  })).b !== 1)\n    return true;\n  var A2 = {};\n  var B3 = {};\n  var symbol22 = Symbol();\n  var alphabet = \"abcdefghijklmnopqrst\";\n  A2[symbol22] = 7;\n  alphabet.split(\"\").forEach(function(chr) {\n    B3[chr] = chr;\n  });\n  return $assign({}, A2)[symbol22] != 7 || objectKeys$1($assign({}, B3)).join(\"\") != alphabet;\n}) ? function assign(target, source) {\n  var T = toObject$3(target);\n  var argumentsLength = arguments.length;\n  var index2 = 1;\n  var getOwnPropertySymbols42 = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable42 = propertyIsEnumerableModule.f;\n  while (argumentsLength > index2) {\n    var S2 = IndexedObject(arguments[index2++]);\n    var keys42 = getOwnPropertySymbols42 ? concat2(objectKeys$1(S2), getOwnPropertySymbols42(S2)) : objectKeys$1(S2);\n    var length2 = keys42.length;\n    var j = 0;\n    var key;\n    while (length2 > j) {\n      key = keys42[j++];\n      if (!DESCRIPTORS$5 || call$1(propertyIsEnumerable42, S2, key))\n        T[key] = S2[key];\n    }\n  }\n  return T;\n} : $assign;\nvar $$h = _export;\nvar assign$5 = objectAssign;\n$$h({\n  target: \"Object\",\n  stat: true,\n  forced: Object.assign !== assign$5\n}, {\n  assign: assign$5\n});\nvar path$a = path$q;\nvar assign$4 = path$a.Object.assign;\nvar parent$l = assign$4;\nvar assign$3 = parent$l;\nvar assign$2 = assign$3;\nvar $$g = _export;\nvar $includes = arrayIncludes.includes;\n$$g({\n  target: \"Array\",\n  proto: true\n}, {\n  includes: function includes(el) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);\n  }\n});\nvar entryVirtual$9 = entryVirtual$k;\nentryVirtual$9(\"Array\").includes;\nvar isObject$4 = isObject$f;\nvar classof$4 = classofRaw$1;\nvar wellKnownSymbol$2 = wellKnownSymbol$j;\nvar MATCH$1 = wellKnownSymbol$2(\"match\");\nvar isRegexp = function(it2) {\n  var isRegExp22;\n  return isObject$4(it2) && ((isRegExp22 = it2[MATCH$1]) !== void 0 ? !!isRegExp22 : classof$4(it2) == \"RegExp\");\n};\nvar global$9 = global$M;\nvar isRegExp = isRegexp;\nvar TypeError$5 = global$9.TypeError;\nvar notARegexp = function(it2) {\n  if (isRegExp(it2)) {\n    throw TypeError$5(\"The method doesn't accept regular expressions\");\n  }\n  return it2;\n};\nvar wellKnownSymbol$1 = wellKnownSymbol$j;\nvar MATCH = wellKnownSymbol$1(\"match\");\nvar correctIsRegexpLogic = function(METHOD_NAME) {\n  var regexp = /./;\n  try {\n    \"/./\"[METHOD_NAME](regexp);\n  } catch (error1) {\n    try {\n      regexp[MATCH] = false;\n      return \"/./\"[METHOD_NAME](regexp);\n    } catch (error2) {\n    }\n  }\n  return false;\n};\nvar $$f = _export;\nvar uncurryThis$7 = functionUncurryThis;\nvar notARegExp = notARegexp;\nvar requireObjectCoercible$1 = requireObjectCoercible$5;\nvar toString$3 = toString$7;\nvar correctIsRegExpLogic = correctIsRegexpLogic;\nvar stringIndexOf = uncurryThis$7(\"\".indexOf);\n$$f({\n  target: \"String\",\n  proto: true,\n  forced: !correctIsRegExpLogic(\"includes\")\n}, {\n  includes: function includes2(searchString) {\n    return !!~stringIndexOf(toString$3(requireObjectCoercible$1(this)), toString$3(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : void 0);\n  }\n});\nvar entryVirtual$8 = entryVirtual$k;\nentryVirtual$8(\"String\").includes;\nvar $$e = _export;\nvar fails$9 = fails$r;\nvar toObject$2 = toObject$e;\nvar nativeGetPrototypeOf = objectGetPrototypeOf;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\nvar FAILS_ON_PRIMITIVES$1 = fails$9(function() {\n  nativeGetPrototypeOf(1);\n});\n$$e({\n  target: \"Object\",\n  stat: true,\n  forced: FAILS_ON_PRIMITIVES$1,\n  sham: !CORRECT_PROTOTYPE_GETTER\n}, {\n  getPrototypeOf: function getPrototypeOf(it2) {\n    return nativeGetPrototypeOf(toObject$2(it2));\n  }\n});\nvar path$9 = path$q;\nvar getPrototypeOf$4 = path$9.Object.getPrototypeOf;\nvar parent$k = getPrototypeOf$4;\nvar getPrototypeOf$3 = parent$k;\nvar DESCRIPTORS$4 = descriptors;\nvar uncurryThis$6 = functionUncurryThis;\nvar objectKeys = objectKeys$4;\nvar toIndexedObject = toIndexedObject$b;\nvar $propertyIsEnumerable = objectPropertyIsEnumerable.f;\nvar propertyIsEnumerable3 = uncurryThis$6($propertyIsEnumerable);\nvar push$2 = uncurryThis$6([].push);\nvar createMethod$1 = function(TO_ENTRIES) {\n  return function(it2) {\n    var O = toIndexedObject(it2);\n    var keys42 = objectKeys(O);\n    var length2 = keys42.length;\n    var i = 0;\n    var result2 = [];\n    var key;\n    while (length2 > i) {\n      key = keys42[i++];\n      if (!DESCRIPTORS$4 || propertyIsEnumerable3(O, key)) {\n        push$2(result2, TO_ENTRIES ? [key, O[key]] : O[key]);\n      }\n    }\n    return result2;\n  };\n};\nvar objectToArray = {\n  entries: createMethod$1(true),\n  values: createMethod$1(false)\n};\nvar $$d = _export;\nvar $values = objectToArray.values;\n$$d({\n  target: \"Object\",\n  stat: true\n}, {\n  values: function values(O) {\n    return $values(O);\n  }\n});\nvar path$8 = path$q;\npath$8.Object.values;\nvar whitespaces$3 = \"\t\\n\\v\\f\\r \\xA0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF\";\nvar uncurryThis$5 = functionUncurryThis;\nvar requireObjectCoercible = requireObjectCoercible$5;\nvar toString$2 = toString$7;\nvar whitespaces$2 = whitespaces$3;\nvar replace$1 = uncurryThis$5(\"\".replace);\nvar whitespace = \"[\" + whitespaces$2 + \"]\";\nvar ltrim = RegExp(\"^\" + whitespace + whitespace + \"*\");\nvar rtrim = RegExp(whitespace + whitespace + \"*$\");\nvar createMethod = function(TYPE) {\n  return function($this) {\n    var string3 = toString$2(requireObjectCoercible($this));\n    if (TYPE & 1)\n      string3 = replace$1(string3, ltrim, \"\");\n    if (TYPE & 2)\n      string3 = replace$1(string3, rtrim, \"\");\n    return string3;\n  };\n};\nvar stringTrim = {\n  start: createMethod(1),\n  end: createMethod(2),\n  trim: createMethod(3)\n};\nvar global$8 = global$M;\nvar fails$8 = fails$r;\nvar uncurryThis$4 = functionUncurryThis;\nvar toString$1 = toString$7;\nvar trim = stringTrim.trim;\nvar whitespaces$1 = whitespaces$3;\nvar $parseInt$1 = global$8.parseInt;\nvar Symbol$1 = global$8.Symbol;\nvar ITERATOR = Symbol$1 && Symbol$1.iterator;\nvar hex = /^[+-]?0x/i;\nvar exec$1 = uncurryThis$4(hex.exec);\nvar FORCED$3 = $parseInt$1(whitespaces$1 + \"08\") !== 8 || $parseInt$1(whitespaces$1 + \"0x16\") !== 22 || ITERATOR && !fails$8(function() {\n  $parseInt$1(Object(ITERATOR));\n});\nvar numberParseInt = FORCED$3 ? function parseInt2(string3, radix) {\n  var S2 = trim(toString$1(string3));\n  return $parseInt$1(S2, radix >>> 0 || (exec$1(hex, S2) ? 16 : 10));\n} : $parseInt$1;\nvar $$c = _export;\nvar $parseInt = numberParseInt;\n$$c({\n  global: true,\n  forced: parseInt != $parseInt\n}, {\n  parseInt: $parseInt\n});\nvar $$b = _export;\nvar uncurryThis$3 = functionUncurryThis;\nvar $IndexOf = arrayIncludes.indexOf;\nvar arrayMethodIsStrict$2 = arrayMethodIsStrict$5;\nvar un$IndexOf = uncurryThis$3([].indexOf);\nvar NEGATIVE_ZERO = !!un$IndexOf && 1 / un$IndexOf([1], 1, -0) < 0;\nvar STRICT_METHOD$2 = arrayMethodIsStrict$2(\"indexOf\");\n$$b({\n  target: \"Array\",\n  proto: true,\n  forced: NEGATIVE_ZERO || !STRICT_METHOD$2\n}, {\n  indexOf: function indexOf2(searchElement) {\n    var fromIndex = arguments.length > 1 ? arguments[1] : void 0;\n    return NEGATIVE_ZERO ? un$IndexOf(this, searchElement, fromIndex) || 0 : $IndexOf(this, searchElement, fromIndex);\n  }\n});\nvar entryVirtual$7 = entryVirtual$k;\nentryVirtual$7(\"Array\").indexOf;\nvar PROPER_FUNCTION_NAME = functionName.PROPER;\nvar fails$7 = fails$r;\nvar whitespaces = whitespaces$3;\nvar non = \"\\u200B\\x85\\u180E\";\nvar stringTrimForced = function(METHOD_NAME) {\n  return fails$7(function() {\n    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;\n  });\n};\nvar $$a = _export;\nvar $trim = stringTrim.trim;\nvar forcedStringTrimMethod = stringTrimForced;\n$$a({\n  target: \"String\",\n  proto: true,\n  forced: forcedStringTrimMethod(\"trim\")\n}, {\n  trim: function trim2() {\n    return $trim(this);\n  }\n});\nvar entryVirtual$6 = entryVirtual$k;\nentryVirtual$6(\"String\").trim;\nvar $$9 = _export;\nvar DESCRIPTORS$3 = descriptors;\nvar create$8 = objectCreate;\n$$9({\n  target: \"Object\",\n  stat: true,\n  sham: !DESCRIPTORS$3\n}, {\n  create: create$8\n});\nvar path$6 = path$q;\nvar Object$1 = path$6.Object;\nvar create$7 = function create3(P, D2) {\n  return Object$1.create(P, D2);\n};\nvar parent$j = create$7;\nvar create$6 = parent$j;\nvar create$5 = create$6;\nvar $$8 = _export;\nvar global$7 = global$M;\nvar getBuiltIn$2 = getBuiltIn$9;\nvar apply$3 = functionApply;\nvar uncurryThis$2 = functionUncurryThis;\nvar fails$6 = fails$r;\nvar Array$1 = global$7.Array;\nvar $stringify = getBuiltIn$2(\"JSON\", \"stringify\");\nvar exec = uncurryThis$2(/./.exec);\nvar charAt = uncurryThis$2(\"\".charAt);\nvar charCodeAt = uncurryThis$2(\"\".charCodeAt);\nvar replace = uncurryThis$2(\"\".replace);\nvar numberToString = uncurryThis$2(1 .toString);\nvar tester = /[\\uD800-\\uDFFF]/g;\nvar low = /^[\\uD800-\\uDBFF]$/;\nvar hi = /^[\\uDC00-\\uDFFF]$/;\nvar fix = function(match22, offset, string3) {\n  var prev = charAt(string3, offset - 1);\n  var next23 = charAt(string3, offset + 1);\n  if (exec(low, match22) && !exec(hi, next23) || exec(hi, match22) && !exec(low, prev)) {\n    return \"\\\\u\" + numberToString(charCodeAt(match22, 0), 16);\n  }\n  return match22;\n};\nvar FORCED$2 = fails$6(function() {\n  return $stringify(\"\\uDF06\\uD834\") !== '\"\\\\udf06\\\\ud834\"' || $stringify(\"\\uDEAD\") !== '\"\\\\udead\"';\n});\nif ($stringify) {\n  $$8({\n    target: \"JSON\",\n    stat: true,\n    forced: FORCED$2\n  }, {\n    stringify: function stringify32(it2, replacer, space) {\n      for (var i = 0, l = arguments.length, args = Array$1(l); i < l; i++)\n        args[i] = arguments[i];\n      var result2 = apply$3($stringify, null, args);\n      return typeof result2 == \"string\" ? replace(result2, tester, fix) : result2;\n    }\n  });\n}\nvar path$5 = path$q;\nvar apply$2 = functionApply;\nif (!path$5.JSON)\n  path$5.JSON = {\n    stringify: JSON.stringify\n  };\nvar stringify$3 = function stringify(it2, replacer, space) {\n  return apply$2(path$5.JSON.stringify, null, arguments);\n};\nvar parent$i = stringify$3;\nvar stringify$2 = parent$i;\nvar stringify$1 = stringify$2;\nvar global$6 = global$M;\nvar TypeError$4 = global$6.TypeError;\nvar validateArgumentsLength$1 = function(passed, required) {\n  if (passed < required)\n    throw TypeError$4(\"Not enough arguments\");\n  return passed;\n};\nvar $$7 = _export;\nvar global$5 = global$M;\nvar apply$1 = functionApply;\nvar isCallable$1 = isCallable$h;\nvar userAgent$2 = engineUserAgent;\nvar arraySlice$1 = arraySlice$5;\nvar validateArgumentsLength = validateArgumentsLength$1;\nvar MSIE = /MSIE .\\./.test(userAgent$2);\nvar Function$1 = global$5.Function;\nvar wrap = function(scheduler) {\n  return function(handler, timeout) {\n    var boundArgs = validateArgumentsLength(arguments.length, 1) > 2;\n    var fn = isCallable$1(handler) ? handler : Function$1(handler);\n    var args = boundArgs ? arraySlice$1(arguments, 2) : void 0;\n    return scheduler(boundArgs ? function() {\n      apply$1(fn, this, args);\n    } : fn, timeout);\n  };\n};\n$$7({\n  global: true,\n  bind: true,\n  forced: MSIE\n}, {\n  setTimeout: wrap(global$5.setTimeout),\n  setInterval: wrap(global$5.setInterval)\n});\nvar path$4 = path$q;\nvar setTimeout$2 = path$4.setTimeout;\nvar setTimeout$1 = setTimeout$2;\nvar toObject$1 = toObject$e;\nvar toAbsoluteIndex = toAbsoluteIndex$5;\nvar lengthOfArrayLike$2 = lengthOfArrayLike$d;\nvar arrayFill = function fill(value) {\n  var O = toObject$1(this);\n  var length2 = lengthOfArrayLike$2(O);\n  var argumentsLength = arguments.length;\n  var index2 = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : void 0, length2);\n  var end = argumentsLength > 2 ? arguments[2] : void 0;\n  var endPos = end === void 0 ? length2 : toAbsoluteIndex(end, length2);\n  while (endPos > index2)\n    O[index2++] = value;\n  return O;\n};\nvar $$6 = _export;\nvar fill2 = arrayFill;\n$$6({\n  target: \"Array\",\n  proto: true\n}, {\n  fill: fill2\n});\nvar entryVirtual$5 = entryVirtual$k;\nentryVirtual$5(\"Array\").fill;\nvar componentEmitter = { exports: {} };\n(function(module) {\n  {\n    module.exports = Emitter22;\n  }\n  function Emitter22(obj) {\n    if (obj)\n      return mixin(obj);\n  }\n  function mixin(obj) {\n    for (var key in Emitter22.prototype) {\n      obj[key] = Emitter22.prototype[key];\n    }\n    return obj;\n  }\n  Emitter22.prototype.on = Emitter22.prototype.addEventListener = function(event, fn) {\n    this._callbacks = this._callbacks || {};\n    (this._callbacks[\"$\" + event] = this._callbacks[\"$\" + event] || []).push(fn);\n    return this;\n  };\n  Emitter22.prototype.once = function(event, fn) {\n    function on() {\n      this.off(event, on);\n      fn.apply(this, arguments);\n    }\n    on.fn = fn;\n    this.on(event, on);\n    return this;\n  };\n  Emitter22.prototype.off = Emitter22.prototype.removeListener = Emitter22.prototype.removeAllListeners = Emitter22.prototype.removeEventListener = function(event, fn) {\n    this._callbacks = this._callbacks || {};\n    if (arguments.length == 0) {\n      this._callbacks = {};\n      return this;\n    }\n    var callbacks = this._callbacks[\"$\" + event];\n    if (!callbacks)\n      return this;\n    if (arguments.length == 1) {\n      delete this._callbacks[\"$\" + event];\n      return this;\n    }\n    var cb;\n    for (var i = 0; i < callbacks.length; i++) {\n      cb = callbacks[i];\n      if (cb === fn || cb.fn === fn) {\n        callbacks.splice(i, 1);\n        break;\n      }\n    }\n    if (callbacks.length === 0) {\n      delete this._callbacks[\"$\" + event];\n    }\n    return this;\n  };\n  Emitter22.prototype.emit = function(event) {\n    this._callbacks = this._callbacks || {};\n    var args = new Array(arguments.length - 1), callbacks = this._callbacks[\"$\" + event];\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n    if (callbacks) {\n      callbacks = callbacks.slice(0);\n      for (var i = 0, len = callbacks.length; i < len; ++i) {\n        callbacks[i].apply(this, args);\n      }\n    }\n    return this;\n  };\n  Emitter22.prototype.listeners = function(event) {\n    this._callbacks = this._callbacks || {};\n    return this._callbacks[\"$\" + event] || [];\n  };\n  Emitter22.prototype.hasListeners = function(event) {\n    return !!this.listeners(event).length;\n  };\n})(componentEmitter);\nvar Emitter = componentEmitter.exports;\nfunction _extends() {\n  _extends = Object.assign || function(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\nfunction _assertThisInitialized$1(self2) {\n  if (self2 === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self2;\n}\nvar assign2;\nif (typeof Object.assign !== \"function\") {\n  assign2 = function assign32(target) {\n    if (target === void 0 || target === null) {\n      throw new TypeError(\"Cannot convert undefined or null to object\");\n    }\n    var output = Object(target);\n    for (var index2 = 1; index2 < arguments.length; index2++) {\n      var source = arguments[index2];\n      if (source !== void 0 && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n    return output;\n  };\n} else {\n  assign2 = Object.assign;\n}\nvar assign$1 = assign2;\nvar VENDOR_PREFIXES = [\"\", \"webkit\", \"Moz\", \"MS\", \"ms\", \"o\"];\nvar TEST_ELEMENT = typeof document === \"undefined\" ? {\n  style: {}\n} : document.createElement(\"div\");\nvar TYPE_FUNCTION = \"function\";\nvar round = Math.round;\nvar abs = Math.abs;\nvar now2 = Date.now;\nfunction prefixed(obj, property) {\n  var prefix;\n  var prop;\n  var camelProp = property[0].toUpperCase() + property.slice(1);\n  var i = 0;\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = prefix ? prefix + camelProp : property;\n    if (prop in obj) {\n      return prop;\n    }\n    i++;\n  }\n  return void 0;\n}\nvar win;\nif (typeof window === \"undefined\") {\n  win = {};\n} else {\n  win = window;\n}\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, \"touchAction\");\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== void 0;\nfunction getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n  var touchMap = {};\n  var cssSupports = win.CSS && win.CSS.supports;\n  [\"auto\", \"manipulation\", \"pan-y\", \"pan-x\", \"pan-x pan-y\", \"none\"].forEach(function(val) {\n    return touchMap[val] = cssSupports ? win.CSS.supports(\"touch-action\", val) : true;\n  });\n  return touchMap;\n}\nvar TOUCH_ACTION_COMPUTE = \"compute\";\nvar TOUCH_ACTION_AUTO = \"auto\";\nvar TOUCH_ACTION_MANIPULATION = \"manipulation\";\nvar TOUCH_ACTION_NONE = \"none\";\nvar TOUCH_ACTION_PAN_X = \"pan-x\";\nvar TOUCH_ACTION_PAN_Y = \"pan-y\";\nvar TOUCH_ACTION_MAP = getTouchActionProps();\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\nvar SUPPORT_TOUCH = \"ontouchstart\" in win;\nvar SUPPORT_POINTER_EVENTS = prefixed(win, \"PointerEvent\") !== void 0;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\nvar INPUT_TYPE_TOUCH = \"touch\";\nvar INPUT_TYPE_PEN = \"pen\";\nvar INPUT_TYPE_MOUSE = \"mouse\";\nvar INPUT_TYPE_KINECT = \"kinect\";\nvar COMPUTE_INTERVAL = 25;\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\nvar PROPS_XY = [\"x\", \"y\"];\nvar PROPS_CLIENT_XY = [\"clientX\", \"clientY\"];\nfunction each(obj, iterator22, context) {\n  var i;\n  if (!obj) {\n    return;\n  }\n  if (obj.forEach) {\n    obj.forEach(iterator22, context);\n  } else if (obj.length !== void 0) {\n    i = 0;\n    while (i < obj.length) {\n      iterator22.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator22.call(context, obj[i], i, obj);\n    }\n  }\n}\nfunction boolOrFn(val, args) {\n  if (typeof val === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || void 0 : void 0, args);\n  }\n  return val;\n}\nfunction inStr(str, find2) {\n  return str.indexOf(find2) > -1;\n}\nfunction cleanTouchActions(actions) {\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  }\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  }\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n  return TOUCH_ACTION_AUTO;\n}\nvar TouchAction = /* @__PURE__ */ function() {\n  function TouchAction22(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  var _proto = TouchAction22.prototype;\n  _proto.set = function set22(value) {\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n    }\n    this.actions = value.toLowerCase().trim();\n  };\n  _proto.update = function update() {\n    this.set(this.manager.options.touchAction);\n  };\n  _proto.compute = function compute() {\n    var actions = [];\n    each(this.manager.recognizers, function(recognizer) {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(\" \"));\n  };\n  _proto.preventDefaults = function preventDefaults(input) {\n    var srcEvent = input.srcEvent;\n    var direction = input.offsetDirection;\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n    var actions = this.actions;\n    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n    if (hasNone) {\n      var isTapPointer = input.pointers.length === 1;\n      var isTapMovement = input.distance < 2;\n      var isTapTouchTime = input.deltaTime < 250;\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n    if (hasPanX && hasPanY) {\n      return;\n    }\n    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n      return this.preventSrc(srcEvent);\n    }\n  };\n  _proto.preventSrc = function preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  };\n  return TouchAction22;\n}();\nfunction hasParent(node, parent22) {\n  while (node) {\n    if (node === parent22) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\nfunction getCenter(pointers) {\n  var pointersLength = pointers.length;\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n  var x = 0;\n  var y = 0;\n  var i = 0;\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\nfunction simpleCloneInputData(input) {\n  var pointers = [];\n  var i = 0;\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n  return {\n    timeStamp: now2(),\n    pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\nfunction getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.sqrt(x * x + y * y);\n}\nfunction getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\nfunction getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n  if (abs(x) >= abs(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\nfunction computeDeltaXY(session, input) {\n  var center = input.center;\n  var offset = session.offsetDelta || {};\n  var prevDelta = session.prevDelta || {};\n  var prevInput = session.prevInput || {};\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\nfunction getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\nfunction getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\nfunction getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\nfunction computeIntervalInputData(session, input) {\n  var last = session.lastInterval || input;\n  var deltaTime = input.timeStamp - last.timeStamp;\n  var velocity;\n  var velocityX;\n  var velocityY;\n  var direction;\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === void 0)) {\n    var deltaX = input.deltaX - last.deltaX;\n    var deltaY = input.deltaY - last.deltaY;\n    var v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n    session.lastInterval = input;\n  } else {\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\nfunction computeInputData(manager, input) {\n  var session = manager.session;\n  var pointers = input.pointers;\n  var pointersLength = pointers.length;\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  }\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n  var firstInput = session.firstInput, firstMultiple = session.firstMultiple;\n  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n  var center = input.center = getCenter(pointers);\n  input.timeStamp = now2();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n  computeIntervalInputData(session, input);\n  var target = manager.element;\n  var srcEvent = input.srcEvent;\n  var srcEventTarget;\n  if (srcEvent.composedPath) {\n    srcEventTarget = srcEvent.composedPath()[0];\n  } else if (srcEvent.path) {\n    srcEventTarget = srcEvent.path[0];\n  } else {\n    srcEventTarget = srcEvent.target;\n  }\n  if (hasParent(srcEventTarget, target)) {\n    target = srcEventTarget;\n  }\n  input.target = target;\n}\nfunction inputHandler(manager, eventType, input) {\n  var pointersLen = input.pointers.length;\n  var changedPointersLen = input.changedPointers.length;\n  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n  if (isFirst) {\n    manager.session = {};\n  }\n  input.eventType = eventType;\n  computeInputData(manager, input);\n  manager.emit(\"hammer.input\", input);\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\nfunction splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\nfunction addEventListeners(target, types, handler) {\n  each(splitStr(types), function(type2) {\n    target.addEventListener(type2, handler, false);\n  });\n}\nfunction removeEventListeners(target, types, handler) {\n  each(splitStr(types), function(type2) {\n    target.removeEventListener(type2, handler, false);\n  });\n}\nfunction getWindowForElement(element) {\n  var doc = element.ownerDocument || element;\n  return doc.defaultView || doc.parentWindow || window;\n}\nvar Input = /* @__PURE__ */ function() {\n  function Input22(manager, callback) {\n    var self2 = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n    this.domHandler = function(ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self2.handler(ev);\n      }\n    };\n    this.init();\n  }\n  var _proto = Input22.prototype;\n  _proto.handler = function handler() {\n  };\n  _proto.init = function init() {\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n  _proto.destroy = function destroy() {\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n  return Input22;\n}();\nfunction inArray(src, find2, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find2);\n  } else {\n    var i = 0;\n    while (i < src.length) {\n      if (findByKey && src[i][findByKey] == find2 || !findByKey && src[i] === find2) {\n        return i;\n      }\n      i++;\n    }\n    return -1;\n  }\n}\nvar POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n};\nvar IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT\n};\nvar POINTER_ELEMENT_EVENTS = \"pointerdown\";\nvar POINTER_WINDOW_EVENTS = \"pointermove pointerup pointercancel\";\nif (win.MSPointerEvent && !win.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = \"MSPointerDown\";\n  POINTER_WINDOW_EVENTS = \"MSPointerMove MSPointerUp MSPointerCancel\";\n}\nvar PointerEventInput = /* @__PURE__ */ function(_Input) {\n  _inheritsLoose(PointerEventInput22, _Input);\n  function PointerEventInput22() {\n    var _this;\n    var proto = PointerEventInput22.prototype;\n    proto.evEl = POINTER_ELEMENT_EVENTS;\n    proto.evWin = POINTER_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.store = _this.manager.session.pointerEvents = [];\n    return _this;\n  }\n  var _proto = PointerEventInput22.prototype;\n  _proto.handler = function handler(ev) {\n    var store = this.store;\n    var removePointer = false;\n    var eventTypeNormalized = ev.type.toLowerCase().replace(\"ms\", \"\");\n    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n    var isTouch = pointerType === INPUT_TYPE_TOUCH;\n    var storeIndex = inArray(store, ev.pointerId, \"pointerId\");\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    }\n    if (storeIndex < 0) {\n      return;\n    }\n    store[storeIndex] = ev;\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType,\n      srcEvent: ev\n    });\n    if (removePointer) {\n      store.splice(storeIndex, 1);\n    }\n  };\n  return PointerEventInput22;\n}(Input);\nfunction toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\nfunction uniqueArray(src, key, sort32) {\n  var results = [];\n  var values32 = [];\n  var i = 0;\n  while (i < src.length) {\n    var val = key ? src[i][key] : src[i];\n    if (inArray(values32, val) < 0) {\n      results.push(src[i]);\n    }\n    values32[i] = val;\n    i++;\n  }\n  if (sort32) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort(function(a, b) {\n        return a[key] > b[key];\n      });\n    }\n  }\n  return results;\n}\nvar TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar TOUCH_TARGET_EVENTS = \"touchstart touchmove touchend touchcancel\";\nvar TouchInput = /* @__PURE__ */ function(_Input) {\n  _inheritsLoose(TouchInput22, _Input);\n  function TouchInput22() {\n    var _this;\n    TouchInput22.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.targetIds = {};\n    return _this;\n  }\n  var _proto = TouchInput22.prototype;\n  _proto.handler = function handler(ev) {\n    var type2 = TOUCH_INPUT_MAP[ev.type];\n    var touches = getTouches.call(this, ev, type2);\n    if (!touches) {\n      return;\n    }\n    this.callback(this.manager, type2, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n  return TouchInput22;\n}(Input);\nfunction getTouches(ev, type2) {\n  var allTouches = toArray(ev.touches);\n  var targetIds = this.targetIds;\n  if (type2 & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n  var i;\n  var targetTouches;\n  var changedTouches = toArray(ev.changedTouches);\n  var changedTargetTouches = [];\n  var target = this.target;\n  targetTouches = allTouches.filter(function(touch) {\n    return hasParent(touch.target, target);\n  });\n  if (type2 === INPUT_START) {\n    i = 0;\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  }\n  i = 0;\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    }\n    if (type2 & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n    i++;\n  }\n  if (!changedTargetTouches.length) {\n    return;\n  }\n  return [\n    uniqueArray(targetTouches.concat(changedTargetTouches), \"identifier\", true),\n    changedTargetTouches\n  ];\n}\nvar MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\nvar MOUSE_ELEMENT_EVENTS = \"mousedown\";\nvar MOUSE_WINDOW_EVENTS = \"mousemove mouseup\";\nvar MouseInput = /* @__PURE__ */ function(_Input) {\n  _inheritsLoose(MouseInput22, _Input);\n  function MouseInput22() {\n    var _this;\n    var proto = MouseInput22.prototype;\n    proto.evEl = MOUSE_ELEMENT_EVENTS;\n    proto.evWin = MOUSE_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.pressed = false;\n    return _this;\n  }\n  var _proto = MouseInput22.prototype;\n  _proto.handler = function handler(ev) {\n    var eventType = MOUSE_INPUT_MAP[ev.type];\n    if (eventType & INPUT_START && ev.button === 0) {\n      this.pressed = true;\n    }\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\n      eventType = INPUT_END;\n    }\n    if (!this.pressed) {\n      return;\n    }\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE,\n      srcEvent: ev\n    });\n  };\n  return MouseInput22;\n}(Input);\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\nfunction setLastTouch(eventData) {\n  var _eventData$changedPoi = eventData.changedPointers, touch = _eventData$changedPoi[0];\n  if (touch.identifier === this.primaryTouch) {\n    var lastTouch = {\n      x: touch.clientX,\n      y: touch.clientY\n    };\n    var lts = this.lastTouches;\n    this.lastTouches.push(lastTouch);\n    var removeLastTouch = function removeLastTouch2() {\n      var i = lts.indexOf(lastTouch);\n      if (i > -1) {\n        lts.splice(i, 1);\n      }\n    };\n    setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n  }\n}\nfunction recordTouches(eventType, eventData) {\n  if (eventType & INPUT_START) {\n    this.primaryTouch = eventData.changedPointers[0].identifier;\n    setLastTouch.call(this, eventData);\n  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n    setLastTouch.call(this, eventData);\n  }\n}\nfunction isSyntheticEvent(eventData) {\n  var x = eventData.srcEvent.clientX;\n  var y = eventData.srcEvent.clientY;\n  for (var i = 0; i < this.lastTouches.length; i++) {\n    var t = this.lastTouches[i];\n    var dx = Math.abs(x - t.x);\n    var dy = Math.abs(y - t.y);\n    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n      return true;\n    }\n  }\n  return false;\n}\nvar TouchMouseInput = /* @__PURE__ */ function() {\n  var TouchMouseInput22 = /* @__PURE__ */ function(_Input) {\n    _inheritsLoose(TouchMouseInput3, _Input);\n    function TouchMouseInput3(_manager, callback) {\n      var _this;\n      _this = _Input.call(this, _manager, callback) || this;\n      _this.handler = function(manager, inputEvent, inputData) {\n        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;\n        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n          return;\n        }\n        if (isTouch) {\n          recordTouches.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputData)) {\n          return;\n        }\n        _this.callback(manager, inputEvent, inputData);\n      };\n      _this.touch = new TouchInput(_this.manager, _this.handler);\n      _this.mouse = new MouseInput(_this.manager, _this.handler);\n      _this.primaryTouch = null;\n      _this.lastTouches = [];\n      return _this;\n    }\n    var _proto = TouchMouseInput3.prototype;\n    _proto.destroy = function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    };\n    return TouchMouseInput3;\n  }(Input);\n  return TouchMouseInput22;\n}();\nfunction createInputInstance(manager) {\n  var Type7;\n  var inputClass = manager.options.inputClass;\n  if (inputClass) {\n    Type7 = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type7 = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type7 = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type7 = MouseInput;\n  } else {\n    Type7 = TouchMouseInput;\n  }\n  return new Type7(manager, inputHandler);\n}\nfunction invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n  return false;\n}\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\nvar _uniqueId = 1;\nfunction uniqueId() {\n  return _uniqueId++;\n}\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  var manager = recognizer.manager;\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n  return otherRecognizer;\n}\nfunction stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return \"cancel\";\n  } else if (state & STATE_ENDED) {\n    return \"end\";\n  } else if (state & STATE_CHANGED) {\n    return \"move\";\n  } else if (state & STATE_BEGAN) {\n    return \"start\";\n  }\n  return \"\";\n}\nvar Recognizer = /* @__PURE__ */ function() {\n  function Recognizer22(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.options = _extends({\n      enable: true\n    }, options);\n    this.id = uniqueId();\n    this.manager = null;\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  var _proto = Recognizer22.prototype;\n  _proto.set = function set22(options) {\n    assign$1(this.options, options);\n    this.manager && this.manager.touchAction.update();\n    return this;\n  };\n  _proto.recognizeWith = function recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, \"recognizeWith\", this)) {\n      return this;\n    }\n    var simultaneous = this.simultaneous;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n    return this;\n  };\n  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, \"dropRecognizeWith\", this)) {\n      return this;\n    }\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  };\n  _proto.requireFailure = function requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, \"requireFailure\", this)) {\n      return this;\n    }\n    var requireFail = this.requireFail;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n    return this;\n  };\n  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, \"dropRequireFailure\", this)) {\n      return this;\n    }\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    var index2 = inArray(this.requireFail, otherRecognizer);\n    if (index2 > -1) {\n      this.requireFail.splice(index2, 1);\n    }\n    return this;\n  };\n  _proto.hasRequireFailures = function hasRequireFailures() {\n    return this.requireFail.length > 0;\n  };\n  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  };\n  _proto.emit = function emit(input) {\n    var self2 = this;\n    var state = this.state;\n    function emit2(event) {\n      self2.manager.emit(event, input);\n    }\n    if (state < STATE_ENDED) {\n      emit2(self2.options.event + stateStr(state));\n    }\n    emit2(self2.options.event);\n    if (input.additionalEvent) {\n      emit2(input.additionalEvent);\n    }\n    if (state >= STATE_ENDED) {\n      emit2(self2.options.event + stateStr(state));\n    }\n  };\n  _proto.tryEmit = function tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    }\n    this.state = STATE_FAILED;\n  };\n  _proto.canEmit = function canEmit() {\n    var i = 0;\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  };\n  _proto.recognize = function recognize(inputData) {\n    var inputDataClone = assign$1({}, inputData);\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    }\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n    this.state = this.process(inputDataClone);\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  };\n  _proto.process = function process22(inputData) {\n  };\n  _proto.getTouchAction = function getTouchAction() {\n  };\n  _proto.reset = function reset() {\n  };\n  return Recognizer22;\n}();\nvar TapRecognizer = /* @__PURE__ */ function(_Recognizer) {\n  _inheritsLoose(TapRecognizer22, _Recognizer);\n  function TapRecognizer22(options) {\n    var _this;\n    if (options === void 0) {\n      options = {};\n    }\n    _this = _Recognizer.call(this, _extends({\n      event: \"tap\",\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      time: 250,\n      threshold: 9,\n      posThreshold: 10\n    }, options)) || this;\n    _this.pTime = false;\n    _this.pCenter = false;\n    _this._timer = null;\n    _this._input = null;\n    _this.count = 0;\n    return _this;\n  }\n  var _proto = TapRecognizer22.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  };\n  _proto.process = function process22(input) {\n    var _this2 = this;\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTouchTime = input.deltaTime < options.time;\n    this.reset();\n    if (input.eventType & INPUT_START && this.count === 0) {\n      return this.failTimeout();\n    }\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n      this._input = input;\n      var tapCount = this.count % options.taps;\n      if (tapCount === 0) {\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeout(function() {\n            _this2.state = STATE_RECOGNIZED;\n            _this2.tryEmit();\n          }, options.interval);\n          return STATE_BEGAN;\n        }\n      }\n    }\n    return STATE_FAILED;\n  };\n  _proto.failTimeout = function failTimeout() {\n    var _this3 = this;\n    this._timer = setTimeout(function() {\n      _this3.state = STATE_FAILED;\n    }, this.options.interval);\n    return STATE_FAILED;\n  };\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n  _proto.emit = function emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n  return TapRecognizer22;\n}(Recognizer);\nvar AttrRecognizer = /* @__PURE__ */ function(_Recognizer) {\n  _inheritsLoose(AttrRecognizer22, _Recognizer);\n  function AttrRecognizer22(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return _Recognizer.call(this, _extends({\n      pointers: 1\n    }, options)) || this;\n  }\n  var _proto = AttrRecognizer22.prototype;\n  _proto.attrTest = function attrTest(input) {\n    var optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  };\n  _proto.process = function process22(input) {\n    var state = this.state;\n    var eventType = input.eventType;\n    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    var isValid = this.attrTest(input);\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n      return state | STATE_CHANGED;\n    }\n    return STATE_FAILED;\n  };\n  return AttrRecognizer22;\n}(Recognizer);\nfunction directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return \"down\";\n  } else if (direction === DIRECTION_UP) {\n    return \"up\";\n  } else if (direction === DIRECTION_LEFT) {\n    return \"left\";\n  } else if (direction === DIRECTION_RIGHT) {\n    return \"right\";\n  }\n  return \"\";\n}\nvar PanRecognizer = /* @__PURE__ */ function(_AttrRecognizer) {\n  _inheritsLoose(PanRecognizer22, _AttrRecognizer);\n  function PanRecognizer22(options) {\n    var _this;\n    if (options === void 0) {\n      options = {};\n    }\n    _this = _AttrRecognizer.call(this, _extends({\n      event: \"pan\",\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    }, options)) || this;\n    _this.pX = null;\n    _this.pY = null;\n    return _this;\n  }\n  var _proto = PanRecognizer22.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    var direction = this.options.direction;\n    var actions = [];\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n    return actions;\n  };\n  _proto.directionTest = function directionTest(input) {\n    var options = this.options;\n    var hasMoved = true;\n    var distance = input.distance;\n    var direction = input.direction;\n    var x = input.deltaX;\n    var y = input.deltaY;\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  };\n  _proto.attrTest = function attrTest(input) {\n    return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n  };\n  _proto.emit = function emit(input) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n    var direction = directionStr(input.direction);\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n  return PanRecognizer22;\n}(AttrRecognizer);\nvar SwipeRecognizer = /* @__PURE__ */ function(_AttrRecognizer) {\n  _inheritsLoose(SwipeRecognizer22, _AttrRecognizer);\n  function SwipeRecognizer22(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return _AttrRecognizer.call(this, _extends({\n      event: \"swipe\",\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    }, options)) || this;\n  }\n  var _proto = SwipeRecognizer22.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  };\n  _proto.attrTest = function attrTest(input) {\n    var direction = this.options.direction;\n    var velocity;\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n  };\n  _proto.emit = function emit(input) {\n    var direction = directionStr(input.offsetDirection);\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n    this.manager.emit(this.options.event, input);\n  };\n  return SwipeRecognizer22;\n}(AttrRecognizer);\nvar PinchRecognizer = /* @__PURE__ */ function(_AttrRecognizer) {\n  _inheritsLoose(PinchRecognizer22, _AttrRecognizer);\n  function PinchRecognizer22(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return _AttrRecognizer.call(this, _extends({\n      event: \"pinch\",\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n  var _proto = PinchRecognizer22.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n  _proto.emit = function emit(input) {\n    if (input.scale !== 1) {\n      var inOut = input.scale < 1 ? \"in\" : \"out\";\n      input.additionalEvent = this.options.event + inOut;\n    }\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n  return PinchRecognizer22;\n}(AttrRecognizer);\nvar RotateRecognizer = /* @__PURE__ */ function(_AttrRecognizer) {\n  _inheritsLoose(RotateRecognizer22, _AttrRecognizer);\n  function RotateRecognizer22(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return _AttrRecognizer.call(this, _extends({\n      event: \"rotate\",\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n  var _proto = RotateRecognizer22.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n  return RotateRecognizer22;\n}(AttrRecognizer);\nvar PressRecognizer = /* @__PURE__ */ function(_Recognizer) {\n  _inheritsLoose(PressRecognizer22, _Recognizer);\n  function PressRecognizer22(options) {\n    var _this;\n    if (options === void 0) {\n      options = {};\n    }\n    _this = _Recognizer.call(this, _extends({\n      event: \"press\",\n      pointers: 1,\n      time: 251,\n      threshold: 9\n    }, options)) || this;\n    _this._timer = null;\n    _this._input = null;\n    return _this;\n  }\n  var _proto = PressRecognizer22.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  };\n  _proto.process = function process22(input) {\n    var _this2 = this;\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTime = input.deltaTime > options.time;\n    this._input = input;\n    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeout(function() {\n        _this2.state = STATE_RECOGNIZED;\n        _this2.tryEmit();\n      }, options.time);\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n    return STATE_FAILED;\n  };\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n  _proto.emit = function emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n    if (input && input.eventType & INPUT_END) {\n      this.manager.emit(this.options.event + \"up\", input);\n    } else {\n      this._input.timeStamp = now2();\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n  return PressRecognizer22;\n}(Recognizer);\nvar defaults = {\n  domEvents: false,\n  touchAction: TOUCH_ACTION_COMPUTE,\n  enable: true,\n  inputTarget: null,\n  inputClass: null,\n  cssProps: {\n    userSelect: \"none\",\n    touchSelect: \"none\",\n    touchCallout: \"none\",\n    contentZooming: \"none\",\n    userDrag: \"none\",\n    tapHighlightColor: \"rgba(0,0,0,0)\"\n  }\n};\nvar preset = [[RotateRecognizer, {\n  enable: false\n}], [PinchRecognizer, {\n  enable: false\n}, [\"rotate\"]], [SwipeRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}], [PanRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}, [\"swipe\"]], [TapRecognizer], [TapRecognizer, {\n  event: \"doubletap\",\n  taps: 2\n}, [\"tap\"]], [PressRecognizer]];\nvar STOP = 1;\nvar FORCED_STOP = 2;\nfunction toggleCssProps(manager, add) {\n  var element = manager.element;\n  if (!element.style) {\n    return;\n  }\n  var prop;\n  each(manager.options.cssProps, function(value, name2) {\n    prop = prefixed(element.style, name2);\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\n    }\n  });\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\nfunction triggerDomEvent(event, data22) {\n  var gestureEvent = document.createEvent(\"Event\");\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data22;\n  data22.target.dispatchEvent(gestureEvent);\n}\nvar Manager = /* @__PURE__ */ function() {\n  function Manager22(element, options) {\n    var _this = this;\n    this.options = assign$1({}, defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function(item) {\n      var recognizer = _this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  var _proto = Manager22.prototype;\n  _proto.set = function set22(options) {\n    assign$1(this.options, options);\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n    if (options.inputTarget) {\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n    return this;\n  };\n  _proto.stop = function stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  };\n  _proto.recognize = function recognize(inputData) {\n    var session = this.session;\n    if (session.stopped) {\n      return;\n    }\n    this.touchAction.preventDefaults(inputData);\n    var recognizer;\n    var recognizers = this.recognizers;\n    var curRecognizer = session.curRecognizer;\n    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n      session.curRecognizer = null;\n      curRecognizer = null;\n    }\n    var i = 0;\n    while (i < recognizers.length) {\n      recognizer = recognizers[i];\n      if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer === curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      }\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n        session.curRecognizer = recognizer;\n        curRecognizer = recognizer;\n      }\n      i++;\n    }\n  };\n  _proto.get = function get22(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n    var recognizers = this.recognizers;\n    for (var i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n    return null;\n  };\n  _proto.add = function add(recognizer) {\n    if (invokeArrayArg(recognizer, \"add\", this)) {\n      return this;\n    }\n    var existing = this.get(recognizer.options.event);\n    if (existing) {\n      this.remove(existing);\n    }\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n    this.touchAction.update();\n    return recognizer;\n  };\n  _proto.remove = function remove(recognizer) {\n    if (invokeArrayArg(recognizer, \"remove\", this)) {\n      return this;\n    }\n    var targetRecognizer = this.get(recognizer);\n    if (recognizer) {\n      var recognizers = this.recognizers;\n      var index2 = inArray(recognizers, targetRecognizer);\n      if (index2 !== -1) {\n        recognizers.splice(index2, 1);\n        this.touchAction.update();\n      }\n    }\n    return this;\n  };\n  _proto.on = function on(events, handler) {\n    if (events === void 0 || handler === void 0) {\n      return this;\n    }\n    var handlers = this.handlers;\n    each(splitStr(events), function(event) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  };\n  _proto.off = function off(events, handler) {\n    if (events === void 0) {\n      return this;\n    }\n    var handlers = this.handlers;\n    each(splitStr(events), function(event) {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  };\n  _proto.emit = function emit(event, data22) {\n    if (this.options.domEvents) {\n      triggerDomEvent(event, data22);\n    }\n    var handlers = this.handlers[event] && this.handlers[event].slice();\n    if (!handlers || !handlers.length) {\n      return;\n    }\n    data22.type = event;\n    data22.preventDefault = function() {\n      data22.srcEvent.preventDefault();\n    };\n    var i = 0;\n    while (i < handlers.length) {\n      handlers[i](data22);\n      i++;\n    }\n  };\n  _proto.destroy = function destroy() {\n    this.element && toggleCssProps(this, false);\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  };\n  return Manager22;\n}();\nvar SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar SINGLE_TOUCH_TARGET_EVENTS = \"touchstart\";\nvar SINGLE_TOUCH_WINDOW_EVENTS = \"touchstart touchmove touchend touchcancel\";\nvar SingleTouchInput = /* @__PURE__ */ function(_Input) {\n  _inheritsLoose(SingleTouchInput22, _Input);\n  function SingleTouchInput22() {\n    var _this;\n    var proto = SingleTouchInput22.prototype;\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.started = false;\n    return _this;\n  }\n  var _proto = SingleTouchInput22.prototype;\n  _proto.handler = function handler(ev) {\n    var type2 = SINGLE_TOUCH_INPUT_MAP[ev.type];\n    if (type2 === INPUT_START) {\n      this.started = true;\n    }\n    if (!this.started) {\n      return;\n    }\n    var touches = normalizeSingleTouches.call(this, ev, type2);\n    if (type2 & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n    this.callback(this.manager, type2, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n  return SingleTouchInput22;\n}(Input);\nfunction normalizeSingleTouches(ev, type2) {\n  var all = toArray(ev.touches);\n  var changed = toArray(ev.changedTouches);\n  if (type2 & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), \"identifier\", true);\n  }\n  return [all, changed];\n}\nfunction deprecate(method22, name2, message) {\n  var deprecationMessage = \"DEPRECATED METHOD: \" + name2 + \"\\n\" + message + \" AT \\n\";\n  return function() {\n    var e = new Error(\"get-stack-trace\");\n    var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, \"\").replace(/^\\s+at\\s+/gm, \"\").replace(/^Object.<anonymous>\\s*\\(/gm, \"{anonymous}()@\") : \"Unknown Stack Trace\";\n    var log = window.console && (window.console.warn || window.console.log);\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n    return method22.apply(this, arguments);\n  };\n}\nvar extend = deprecate(function(dest, src, merge22) {\n  var keys42 = Object.keys(src);\n  var i = 0;\n  while (i < keys42.length) {\n    if (!merge22 || merge22 && dest[keys42[i]] === void 0) {\n      dest[keys42[i]] = src[keys42[i]];\n    }\n    i++;\n  }\n  return dest;\n}, \"extend\", \"Use `assign`.\");\nvar merge$1 = deprecate(function(dest, src) {\n  return extend(dest, src, true);\n}, \"merge\", \"Use `assign`.\");\nfunction inherit(child, base, properties) {\n  var baseP = base.prototype;\n  var childP;\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n  if (properties) {\n    assign$1(childP, properties);\n  }\n}\nfunction bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\nvar Hammer = /* @__PURE__ */ function() {\n  var Hammer22 = function Hammer3(element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return new Manager(element, _extends({\n      recognizers: preset.concat()\n    }, options));\n  };\n  Hammer22.VERSION = \"2.0.17-rc\";\n  Hammer22.DIRECTION_ALL = DIRECTION_ALL;\n  Hammer22.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer22.DIRECTION_LEFT = DIRECTION_LEFT;\n  Hammer22.DIRECTION_RIGHT = DIRECTION_RIGHT;\n  Hammer22.DIRECTION_UP = DIRECTION_UP;\n  Hammer22.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n  Hammer22.DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n  Hammer22.DIRECTION_NONE = DIRECTION_NONE;\n  Hammer22.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer22.INPUT_START = INPUT_START;\n  Hammer22.INPUT_MOVE = INPUT_MOVE;\n  Hammer22.INPUT_END = INPUT_END;\n  Hammer22.INPUT_CANCEL = INPUT_CANCEL;\n  Hammer22.STATE_POSSIBLE = STATE_POSSIBLE;\n  Hammer22.STATE_BEGAN = STATE_BEGAN;\n  Hammer22.STATE_CHANGED = STATE_CHANGED;\n  Hammer22.STATE_ENDED = STATE_ENDED;\n  Hammer22.STATE_RECOGNIZED = STATE_RECOGNIZED;\n  Hammer22.STATE_CANCELLED = STATE_CANCELLED;\n  Hammer22.STATE_FAILED = STATE_FAILED;\n  Hammer22.Manager = Manager;\n  Hammer22.Input = Input;\n  Hammer22.TouchAction = TouchAction;\n  Hammer22.TouchInput = TouchInput;\n  Hammer22.MouseInput = MouseInput;\n  Hammer22.PointerEventInput = PointerEventInput;\n  Hammer22.TouchMouseInput = TouchMouseInput;\n  Hammer22.SingleTouchInput = SingleTouchInput;\n  Hammer22.Recognizer = Recognizer;\n  Hammer22.AttrRecognizer = AttrRecognizer;\n  Hammer22.Tap = TapRecognizer;\n  Hammer22.Pan = PanRecognizer;\n  Hammer22.Swipe = SwipeRecognizer;\n  Hammer22.Pinch = PinchRecognizer;\n  Hammer22.Rotate = RotateRecognizer;\n  Hammer22.Press = PressRecognizer;\n  Hammer22.on = addEventListeners;\n  Hammer22.off = removeEventListeners;\n  Hammer22.each = each;\n  Hammer22.merge = merge$1;\n  Hammer22.extend = extend;\n  Hammer22.bindFn = bindFn;\n  Hammer22.assign = assign$1;\n  Hammer22.inherit = inherit;\n  Hammer22.bindFn = bindFn;\n  Hammer22.prefixed = prefixed;\n  Hammer22.toArray = toArray;\n  Hammer22.inArray = inArray;\n  Hammer22.uniqueArray = uniqueArray;\n  Hammer22.splitStr = splitStr;\n  Hammer22.boolOrFn = boolOrFn;\n  Hammer22.hasParent = hasParent;\n  Hammer22.addEventListeners = addEventListeners;\n  Hammer22.removeEventListeners = removeEventListeners;\n  Hammer22.defaults = assign$1({}, defaults, {\n    preset\n  });\n  return Hammer22;\n}();\nvar RealHammer = Hammer;\nfunction _createForOfIteratorHelper$3(o, allowArrayLike) {\n  var it2 = typeof symbol !== \"undefined\" && getIteratorMethod$1(o) || o[\"@@iterator\"];\n  if (!it2) {\n    if (isArray$1(o) || (it2 = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it2)\n        o = it2;\n      var i = 0;\n      var F2 = function F22() {\n      };\n      return { s: F2, n: function n() {\n        if (i >= o.length)\n          return { done: true };\n        return { done: false, value: o[i++] };\n      }, e: function e(_e3) {\n        throw _e3;\n      }, f: F2 };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true, didErr = false, err;\n  return { s: function s() {\n    it2 = it2.call(o);\n  }, n: function n() {\n    var step = it2.next();\n    normalCompletion = step.done;\n    return step;\n  }, e: function e(_e22) {\n    didErr = true;\n    err = _e22;\n  }, f: function f() {\n    try {\n      if (!normalCompletion && it2.return != null)\n        it2.return();\n    } finally {\n      if (didErr)\n        throw err;\n    }\n  } };\n}\nfunction _unsupportedIterableToArray$3(o, minLen) {\n  var _context21;\n  if (!o)\n    return;\n  if (typeof o === \"string\")\n    return _arrayLikeToArray$3(o, minLen);\n  var n = slice2(_context21 = Object.prototype.toString.call(o)).call(_context21, 8, -1);\n  if (n === \"Object\" && o.constructor)\n    n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\")\n    return from$3(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray$3(o, minLen);\n}\nfunction _arrayLikeToArray$3(arr, len) {\n  if (len == null || len > arr.length)\n    len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar DELETE = symbol(\"DELETE\");\nfunction pureDeepObjectAssign(base) {\n  var _context;\n  for (var _len = arguments.length, updates = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    updates[_key - 1] = arguments[_key];\n  }\n  return deepObjectAssign.apply(void 0, concat$1(_context = [{}, base]).call(_context, updates));\n}\nfunction deepObjectAssign() {\n  var merged = deepObjectAssignNonentry.apply(void 0, arguments);\n  stripDelete(merged);\n  return merged;\n}\nfunction deepObjectAssignNonentry() {\n  for (var _len2 = arguments.length, values32 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    values32[_key2] = arguments[_key2];\n  }\n  if (values32.length < 2) {\n    return values32[0];\n  } else if (values32.length > 2) {\n    var _context2;\n    return deepObjectAssignNonentry.apply(void 0, concat$1(_context2 = [deepObjectAssign(values32[0], values32[1])]).call(_context2, _toConsumableArray(slice2(values32).call(values32, 2))));\n  }\n  var a = values32[0];\n  var b = values32[1];\n  var _iterator = _createForOfIteratorHelper$3(ownKeys$1(b)), _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done; ) {\n      var prop = _step.value;\n      if (!Object.prototype.propertyIsEnumerable.call(b, prop))\n        ;\n      else if (b[prop] === DELETE) {\n        delete a[prop];\n      } else if (a[prop] !== null && b[prop] !== null && _typeof(a[prop]) === \"object\" && _typeof(b[prop]) === \"object\" && !isArray$1(a[prop]) && !isArray$1(b[prop])) {\n        a[prop] = deepObjectAssignNonentry(a[prop], b[prop]);\n      } else {\n        a[prop] = clone(b[prop]);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return a;\n}\nfunction clone(a) {\n  if (isArray$1(a)) {\n    return map$3(a).call(a, function(value) {\n      return clone(value);\n    });\n  } else if (_typeof(a) === \"object\" && a !== null) {\n    return deepObjectAssignNonentry({}, a);\n  } else {\n    return a;\n  }\n}\nfunction stripDelete(a) {\n  for (var _i = 0, _Object$keys = keys$4(a); _i < _Object$keys.length; _i++) {\n    var prop = _Object$keys[_i];\n    if (a[prop] === DELETE) {\n      delete a[prop];\n    } else if (_typeof(a[prop]) === \"object\" && a[prop] !== null) {\n      stripDelete(a[prop]);\n    }\n  }\n}\nfunction hammerMock() {\n  var noop22 = function noop3() {\n  };\n  return {\n    on: noop22,\n    off: noop22,\n    destroy: noop22,\n    emit: noop22,\n    get: function get22() {\n      return {\n        set: noop22\n      };\n    }\n  };\n}\nvar Hammer$1 = typeof window !== \"undefined\" ? window.Hammer || RealHammer : function() {\n  return hammerMock();\n};\nfunction Activator$1(container) {\n  var _this = this, _context3;\n  this._cleanupQueue = [];\n  this.active = false;\n  this._dom = {\n    container,\n    overlay: document.createElement(\"div\")\n  };\n  this._dom.overlay.classList.add(\"vis-overlay\");\n  this._dom.container.appendChild(this._dom.overlay);\n  this._cleanupQueue.push(function() {\n    _this._dom.overlay.parentNode.removeChild(_this._dom.overlay);\n  });\n  var hammer = Hammer$1(this._dom.overlay);\n  hammer.on(\"tap\", bind$6(_context3 = this._onTapOverlay).call(_context3, this));\n  this._cleanupQueue.push(function() {\n    hammer.destroy();\n  });\n  var events = [\"tap\", \"doubletap\", \"press\", \"pinch\", \"pan\", \"panstart\", \"panmove\", \"panend\"];\n  forEach$1(events).call(events, function(event) {\n    hammer.on(event, function(event2) {\n      event2.srcEvent.stopPropagation();\n    });\n  });\n  if (document && document.body) {\n    this._onClick = function(event) {\n      if (!_hasParent(event.target, container)) {\n        _this.deactivate();\n      }\n    };\n    document.body.addEventListener(\"click\", this._onClick);\n    this._cleanupQueue.push(function() {\n      document.body.removeEventListener(\"click\", _this._onClick);\n    });\n  }\n  this._escListener = function(event) {\n    if (\"key\" in event ? event.key === \"Escape\" : event.keyCode === 27) {\n      _this.deactivate();\n    }\n  };\n}\nEmitter(Activator$1.prototype);\nActivator$1.current = null;\nActivator$1.prototype.destroy = function() {\n  var _context4, _context5;\n  this.deactivate();\n  var _iterator2 = _createForOfIteratorHelper$3(reverse2(_context4 = splice2(_context5 = this._cleanupQueue).call(_context5, 0)).call(_context4)), _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {\n      var callback = _step2.value;\n      callback();\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n};\nActivator$1.prototype.activate = function() {\n  if (Activator$1.current) {\n    Activator$1.current.deactivate();\n  }\n  Activator$1.current = this;\n  this.active = true;\n  this._dom.overlay.style.display = \"none\";\n  this._dom.container.classList.add(\"vis-active\");\n  this.emit(\"change\");\n  this.emit(\"activate\");\n  document.body.addEventListener(\"keydown\", this._escListener);\n};\nActivator$1.prototype.deactivate = function() {\n  this.active = false;\n  this._dom.overlay.style.display = \"block\";\n  this._dom.container.classList.remove(\"vis-active\");\n  document.body.removeEventListener(\"keydown\", this._escListener);\n  this.emit(\"change\");\n  this.emit(\"deactivate\");\n};\nActivator$1.prototype._onTapOverlay = function(event) {\n  this.activate();\n  event.srcEvent.stopPropagation();\n};\nfunction _hasParent(element, parent22) {\n  while (element) {\n    if (element === parent22) {\n      return true;\n    }\n    element = element.parentNode;\n  }\n  return false;\n}\nvar global$4 = global$M;\nvar isConstructor3 = isConstructor$4;\nvar tryToString$1 = tryToString$4;\nvar TypeError$3 = global$4.TypeError;\nvar aConstructor$1 = function(argument) {\n  if (isConstructor3(argument))\n    return argument;\n  throw TypeError$3(tryToString$1(argument) + \" is not a constructor\");\n};\nvar $$5 = _export;\nvar getBuiltIn$1 = getBuiltIn$9;\nvar apply = functionApply;\nvar bind$2 = functionBind;\nvar aConstructor = aConstructor$1;\nvar anObject$1 = anObject$b;\nvar isObject$3 = isObject$f;\nvar create$4 = objectCreate;\nvar fails$5 = fails$r;\nvar nativeConstruct = getBuiltIn$1(\"Reflect\", \"construct\");\nvar ObjectPrototype = Object.prototype;\nvar push$1 = [].push;\nvar NEW_TARGET_BUG = fails$5(function() {\n  function F2() {\n  }\n  return !(nativeConstruct(function() {\n  }, [], F2) instanceof F2);\n});\nvar ARGS_BUG = !fails$5(function() {\n  nativeConstruct(function() {\n  });\n});\nvar FORCED$1 = NEW_TARGET_BUG || ARGS_BUG;\n$$5({\n  target: \"Reflect\",\n  stat: true,\n  forced: FORCED$1,\n  sham: FORCED$1\n}, {\n  construct: function construct(Target, args) {\n    aConstructor(Target);\n    anObject$1(args);\n    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);\n    if (ARGS_BUG && !NEW_TARGET_BUG)\n      return nativeConstruct(Target, args, newTarget);\n    if (Target == newTarget) {\n      switch (args.length) {\n        case 0:\n          return new Target();\n        case 1:\n          return new Target(args[0]);\n        case 2:\n          return new Target(args[0], args[1]);\n        case 3:\n          return new Target(args[0], args[1], args[2]);\n        case 4:\n          return new Target(args[0], args[1], args[2], args[3]);\n      }\n      var $args = [null];\n      apply(push$1, $args, args);\n      return new (apply(bind$2, Target, $args))();\n    }\n    var proto = newTarget.prototype;\n    var instance = create$4(isObject$3(proto) ? proto : ObjectPrototype);\n    var result2 = apply(Target, instance, args);\n    return isObject$3(result2) ? result2 : instance;\n  }\n});\nvar path$3 = path$q;\nvar construct$2 = path$3.Reflect.construct;\nvar parent$h = construct$2;\nvar construct$1 = parent$h;\nvar construct2 = construct$1;\nfunction _assertThisInitialized(self2) {\n  if (self2 === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self2;\n}\nvar parent$g = create$6;\nvar create$3 = parent$g;\nvar parent$f = create$3;\nvar create$2 = parent$f;\nvar create$1 = create$2;\nvar $$4 = _export;\nvar setPrototypeOf$5 = objectSetPrototypeOf;\n$$4({\n  target: \"Object\",\n  stat: true\n}, {\n  setPrototypeOf: setPrototypeOf$5\n});\nvar path$2 = path$q;\nvar setPrototypeOf$4 = path$2.Object.setPrototypeOf;\nvar parent$e = setPrototypeOf$4;\nvar setPrototypeOf$3 = parent$e;\nvar parent$d = setPrototypeOf$3;\nvar setPrototypeOf$2 = parent$d;\nvar parent$c = setPrototypeOf$2;\nvar setPrototypeOf$1 = parent$c;\nvar setPrototypeOf = setPrototypeOf$1;\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = setPrototypeOf || function _setPrototypeOf22(o2, p2) {\n    o2.__proto__ = p2;\n    return o2;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = create$1(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  defineProperty$7(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass)\n    _setPrototypeOf(subClass, superClass);\n}\nfunction _possibleConstructorReturn(self2, call22) {\n  if (call22 && (_typeof(call22) === \"object\" || typeof call22 === \"function\")) {\n    return call22;\n  } else if (call22 !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self2);\n}\nvar parent$b = getPrototypeOf$3;\nvar getPrototypeOf$2 = parent$b;\nvar parent$a = getPrototypeOf$2;\nvar getPrototypeOf$1 = parent$a;\nvar getPrototypeOf2 = getPrototypeOf$1;\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = setPrototypeOf ? getPrototypeOf2 : function _getPrototypeOf22(o2) {\n    return o2.__proto__ || getPrototypeOf2(o2);\n  };\n  return _getPrototypeOf(o);\n}\nvar runtime = { exports: {} };\n(function(module) {\n  var runtime2 = function(exports) {\n    var Op = Object.prototype;\n    var hasOwn32 = Op.hasOwnProperty;\n    var undefined$1;\n    var $Symbol22 = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol22.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol22.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol22.toStringTag || \"@@toStringTag\";\n    function define(obj, key, value) {\n      Object.defineProperty(obj, key, {\n        value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n      return obj[key];\n    }\n    try {\n      define({}, \"\");\n    } catch (err) {\n      define = function(obj, key, value) {\n        return obj[key] = value;\n      };\n    }\n    function wrap22(innerFn, outerFn, self2, tryLocsList) {\n      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n      var generator = Object.create(protoGenerator.prototype);\n      var context = new Context(tryLocsList || []);\n      generator._invoke = makeInvokeMethod(innerFn, self2, context);\n      return generator;\n    }\n    exports.wrap = wrap22;\n    function tryCatch(fn, obj, arg) {\n      try {\n        return {\n          type: \"normal\",\n          arg: fn.call(obj, arg)\n        };\n      } catch (err) {\n        return {\n          type: \"throw\",\n          arg: err\n        };\n      }\n    }\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\";\n    var ContinueSentinel = {};\n    function Generator() {\n    }\n    function GeneratorFunction() {\n    }\n    function GeneratorFunctionPrototype() {\n    }\n    var IteratorPrototype22 = {};\n    define(IteratorPrototype22, iteratorSymbol, function() {\n      return this;\n    });\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values32([])));\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn32.call(NativeIteratorPrototype, iteratorSymbol)) {\n      IteratorPrototype22 = NativeIteratorPrototype;\n    }\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype22);\n    GeneratorFunction.prototype = GeneratorFunctionPrototype;\n    define(Gp, \"constructor\", GeneratorFunctionPrototype);\n    define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\");\n    function defineIteratorMethods(prototype) {\n      [\"next\", \"throw\", \"return\"].forEach(function(method22) {\n        define(prototype, method22, function(arg) {\n          return this._invoke(method22, arg);\n        });\n      });\n    }\n    exports.isGeneratorFunction = function(genFun) {\n      var ctor = typeof genFun === \"function\" && genFun.constructor;\n      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n    exports.mark = function(genFun) {\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n      } else {\n        genFun.__proto__ = GeneratorFunctionPrototype;\n        define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n      }\n      genFun.prototype = Object.create(Gp);\n      return genFun;\n    };\n    exports.awrap = function(arg) {\n      return {\n        __await: arg\n      };\n    };\n    function AsyncIterator(generator, PromiseImpl) {\n      function invoke(method22, arg, resolve, reject) {\n        var record = tryCatch(generator[method22], generator, arg);\n        if (record.type === \"throw\") {\n          reject(record.arg);\n        } else {\n          var result2 = record.arg;\n          var value = result2.value;\n          if (value && typeof value === \"object\" && hasOwn32.call(value, \"__await\")) {\n            return PromiseImpl.resolve(value.__await).then(function(value2) {\n              invoke(\"next\", value2, resolve, reject);\n            }, function(err) {\n              invoke(\"throw\", err, resolve, reject);\n            });\n          }\n          return PromiseImpl.resolve(value).then(function(unwrapped) {\n            result2.value = unwrapped;\n            resolve(result2);\n          }, function(error) {\n            return invoke(\"throw\", error, resolve, reject);\n          });\n        }\n      }\n      var previousPromise;\n      function enqueue(method22, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new PromiseImpl(function(resolve, reject) {\n            invoke(method22, arg, resolve, reject);\n          });\n        }\n        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      }\n      this._invoke = enqueue;\n    }\n    defineIteratorMethods(AsyncIterator.prototype);\n    define(AsyncIterator.prototype, asyncIteratorSymbol, function() {\n      return this;\n    });\n    exports.AsyncIterator = AsyncIterator;\n    exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {\n      if (PromiseImpl === void 0)\n        PromiseImpl = Promise;\n      var iter = new AsyncIterator(wrap22(innerFn, outerFn, self2, tryLocsList), PromiseImpl);\n      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result2) {\n        return result2.done ? result2.value : iter.next();\n      });\n    };\n    function makeInvokeMethod(innerFn, self2, context) {\n      var state = GenStateSuspendedStart;\n      return function invoke(method22, arg) {\n        if (state === GenStateExecuting) {\n          throw new Error(\"Generator is already running\");\n        }\n        if (state === GenStateCompleted) {\n          if (method22 === \"throw\") {\n            throw arg;\n          }\n          return doneResult();\n        }\n        context.method = method22;\n        context.arg = arg;\n        while (true) {\n          var delegate = context.delegate;\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel)\n                continue;\n              return delegateResult;\n            }\n          }\n          if (context.method === \"next\") {\n            context.sent = context._sent = context.arg;\n          } else if (context.method === \"throw\") {\n            if (state === GenStateSuspendedStart) {\n              state = GenStateCompleted;\n              throw context.arg;\n            }\n            context.dispatchException(context.arg);\n          } else if (context.method === \"return\") {\n            context.abrupt(\"return\", context.arg);\n          }\n          state = GenStateExecuting;\n          var record = tryCatch(innerFn, self2, context);\n          if (record.type === \"normal\") {\n            state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n            if (record.arg === ContinueSentinel) {\n              continue;\n            }\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          } else if (record.type === \"throw\") {\n            state = GenStateCompleted;\n            context.method = \"throw\";\n            context.arg = record.arg;\n          }\n        }\n      };\n    }\n    function maybeInvokeDelegate(delegate, context) {\n      var method22 = delegate.iterator[context.method];\n      if (method22 === undefined$1) {\n        context.delegate = null;\n        if (context.method === \"throw\") {\n          if (delegate.iterator[\"return\"]) {\n            context.method = \"return\";\n            context.arg = undefined$1;\n            maybeInvokeDelegate(delegate, context);\n            if (context.method === \"throw\") {\n              return ContinueSentinel;\n            }\n          }\n          context.method = \"throw\";\n          context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n        }\n        return ContinueSentinel;\n      }\n      var record = tryCatch(method22, delegate.iterator, context.arg);\n      if (record.type === \"throw\") {\n        context.method = \"throw\";\n        context.arg = record.arg;\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n      var info = record.arg;\n      if (!info) {\n        context.method = \"throw\";\n        context.arg = new TypeError(\"iterator result is not an object\");\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n      if (info.done) {\n        context[delegate.resultName] = info.value;\n        context.next = delegate.nextLoc;\n        if (context.method !== \"return\") {\n          context.method = \"next\";\n          context.arg = undefined$1;\n        }\n      } else {\n        return info;\n      }\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n    defineIteratorMethods(Gp);\n    define(Gp, toStringTagSymbol, \"Generator\");\n    define(Gp, iteratorSymbol, function() {\n      return this;\n    });\n    define(Gp, \"toString\", function() {\n      return \"[object Generator]\";\n    });\n    function pushTryEntry(locs) {\n      var entry = {\n        tryLoc: locs[0]\n      };\n      if (1 in locs) {\n        entry.catchLoc = locs[1];\n      }\n      if (2 in locs) {\n        entry.finallyLoc = locs[2];\n        entry.afterLoc = locs[3];\n      }\n      this.tryEntries.push(entry);\n    }\n    function resetTryEntry(entry) {\n      var record = entry.completion || {};\n      record.type = \"normal\";\n      delete record.arg;\n      entry.completion = record;\n    }\n    function Context(tryLocsList) {\n      this.tryEntries = [{\n        tryLoc: \"root\"\n      }];\n      tryLocsList.forEach(pushTryEntry, this);\n      this.reset(true);\n    }\n    exports.keys = function(object2) {\n      var keys42 = [];\n      for (var key in object2) {\n        keys42.push(key);\n      }\n      keys42.reverse();\n      return function next23() {\n        while (keys42.length) {\n          var key2 = keys42.pop();\n          if (key2 in object2) {\n            next23.value = key2;\n            next23.done = false;\n            return next23;\n          }\n        }\n        next23.done = true;\n        return next23;\n      };\n    };\n    function values32(iterable) {\n      if (iterable) {\n        var iteratorMethod = iterable[iteratorSymbol];\n        if (iteratorMethod) {\n          return iteratorMethod.call(iterable);\n        }\n        if (typeof iterable.next === \"function\") {\n          return iterable;\n        }\n        if (!isNaN(iterable.length)) {\n          var i = -1, next23 = function next3() {\n            while (++i < iterable.length) {\n              if (hasOwn32.call(iterable, i)) {\n                next3.value = iterable[i];\n                next3.done = false;\n                return next3;\n              }\n            }\n            next3.value = undefined$1;\n            next3.done = true;\n            return next3;\n          };\n          return next23.next = next23;\n        }\n      }\n      return {\n        next: doneResult\n      };\n    }\n    exports.values = values32;\n    function doneResult() {\n      return {\n        value: undefined$1,\n        done: true\n      };\n    }\n    Context.prototype = {\n      constructor: Context,\n      reset: function(skipTempReset) {\n        this.prev = 0;\n        this.next = 0;\n        this.sent = this._sent = undefined$1;\n        this.done = false;\n        this.delegate = null;\n        this.method = \"next\";\n        this.arg = undefined$1;\n        this.tryEntries.forEach(resetTryEntry);\n        if (!skipTempReset) {\n          for (var name2 in this) {\n            if (name2.charAt(0) === \"t\" && hasOwn32.call(this, name2) && !isNaN(+name2.slice(1))) {\n              this[name2] = undefined$1;\n            }\n          }\n        }\n      },\n      stop: function() {\n        this.done = true;\n        var rootEntry = this.tryEntries[0];\n        var rootRecord = rootEntry.completion;\n        if (rootRecord.type === \"throw\") {\n          throw rootRecord.arg;\n        }\n        return this.rval;\n      },\n      dispatchException: function(exception) {\n        if (this.done) {\n          throw exception;\n        }\n        var context = this;\n        function handle(loc, caught) {\n          record.type = \"throw\";\n          record.arg = exception;\n          context.next = loc;\n          if (caught) {\n            context.method = \"next\";\n            context.arg = undefined$1;\n          }\n          return !!caught;\n        }\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          var record = entry.completion;\n          if (entry.tryLoc === \"root\") {\n            return handle(\"end\");\n          }\n          if (entry.tryLoc <= this.prev) {\n            var hasCatch = hasOwn32.call(entry, \"catchLoc\");\n            var hasFinally = hasOwn32.call(entry, \"finallyLoc\");\n            if (hasCatch && hasFinally) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              } else if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else if (hasCatch) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              }\n            } else if (hasFinally) {\n              if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else {\n              throw new Error(\"try statement without catch or finally\");\n            }\n          }\n        }\n      },\n      abrupt: function(type2, arg) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.tryLoc <= this.prev && hasOwn32.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n            var finallyEntry = entry;\n            break;\n          }\n        }\n        if (finallyEntry && (type2 === \"break\" || type2 === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n          finallyEntry = null;\n        }\n        var record = finallyEntry ? finallyEntry.completion : {};\n        record.type = type2;\n        record.arg = arg;\n        if (finallyEntry) {\n          this.method = \"next\";\n          this.next = finallyEntry.finallyLoc;\n          return ContinueSentinel;\n        }\n        return this.complete(record);\n      },\n      complete: function(record, afterLoc) {\n        if (record.type === \"throw\") {\n          throw record.arg;\n        }\n        if (record.type === \"break\" || record.type === \"continue\") {\n          this.next = record.arg;\n        } else if (record.type === \"return\") {\n          this.rval = this.arg = record.arg;\n          this.method = \"return\";\n          this.next = \"end\";\n        } else if (record.type === \"normal\" && afterLoc) {\n          this.next = afterLoc;\n        }\n        return ContinueSentinel;\n      },\n      finish: function(finallyLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.finallyLoc === finallyLoc) {\n            this.complete(entry.completion, entry.afterLoc);\n            resetTryEntry(entry);\n            return ContinueSentinel;\n          }\n        }\n      },\n      catch: function(tryLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.tryLoc === tryLoc) {\n            var record = entry.completion;\n            if (record.type === \"throw\") {\n              var thrown = record.arg;\n              resetTryEntry(entry);\n            }\n            return thrown;\n          }\n        }\n        throw new Error(\"illegal catch attempt\");\n      },\n      delegateYield: function(iterable, resultName, nextLoc) {\n        this.delegate = {\n          iterator: values32(iterable),\n          resultName,\n          nextLoc\n        };\n        if (this.method === \"next\") {\n          this.arg = undefined$1;\n        }\n        return ContinueSentinel;\n      }\n    };\n    return exports;\n  }(module.exports);\n  try {\n    regeneratorRuntime = runtime2;\n  } catch (accidentalStrictMode) {\n    if (typeof globalThis === \"object\") {\n      globalThis.regeneratorRuntime = runtime2;\n    } else {\n      Function(\"r\", \"regeneratorRuntime = r\")(runtime2);\n    }\n  }\n})(runtime);\nvar regenerator = runtime.exports;\nvar internalMetadata = { exports: {} };\nvar fails$4 = fails$r;\nvar arrayBufferNonExtensible = fails$4(function() {\n  if (typeof ArrayBuffer == \"function\") {\n    var buffer = new ArrayBuffer(8);\n    if (Object.isExtensible(buffer))\n      Object.defineProperty(buffer, \"a\", {\n        value: 8\n      });\n  }\n});\nvar fails$3 = fails$r;\nvar isObject$2 = isObject$f;\nvar classof$3 = classofRaw$1;\nvar ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible;\nvar $isExtensible = Object.isExtensible;\nvar FAILS_ON_PRIMITIVES = fails$3(function() {\n  $isExtensible(1);\n});\nvar objectIsExtensible = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it2) {\n  if (!isObject$2(it2))\n    return false;\n  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$3(it2) == \"ArrayBuffer\")\n    return false;\n  return $isExtensible ? $isExtensible(it2) : true;\n} : $isExtensible;\nvar fails$2 = fails$r;\nvar freezing = !fails$2(function() {\n  return Object.isExtensible(Object.preventExtensions({}));\n});\nvar $$3 = _export;\nvar uncurryThis$1 = functionUncurryThis;\nvar hiddenKeys = hiddenKeys$6;\nvar isObject$1 = isObject$f;\nvar hasOwn$3 = hasOwnProperty_1;\nvar defineProperty$2 = objectDefineProperty.f;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;\nvar isExtensible2 = objectIsExtensible;\nvar uid = uid$4;\nvar FREEZING = freezing;\nvar REQUIRED = false;\nvar METADATA = uid(\"meta\");\nvar id = 0;\nvar setMetadata = function(it2) {\n  defineProperty$2(it2, METADATA, {\n    value: {\n      objectID: \"O\" + id++,\n      weakData: {}\n    }\n  });\n};\nvar fastKey$1 = function(it2, create52) {\n  if (!isObject$1(it2))\n    return typeof it2 == \"symbol\" ? it2 : (typeof it2 == \"string\" ? \"S\" : \"P\") + it2;\n  if (!hasOwn$3(it2, METADATA)) {\n    if (!isExtensible2(it2))\n      return \"F\";\n    if (!create52)\n      return \"E\";\n    setMetadata(it2);\n  }\n  return it2[METADATA].objectID;\n};\nvar getWeakData = function(it2, create52) {\n  if (!hasOwn$3(it2, METADATA)) {\n    if (!isExtensible2(it2))\n      return true;\n    if (!create52)\n      return false;\n    setMetadata(it2);\n  }\n  return it2[METADATA].weakData;\n};\nvar onFreeze = function(it2) {\n  if (FREEZING && REQUIRED && isExtensible2(it2) && !hasOwn$3(it2, METADATA))\n    setMetadata(it2);\n  return it2;\n};\nvar enable = function() {\n  meta.enable = function() {\n  };\n  REQUIRED = true;\n  var getOwnPropertyNames43 = getOwnPropertyNamesModule.f;\n  var splice32 = uncurryThis$1([].splice);\n  var test22 = {};\n  test22[METADATA] = 1;\n  if (getOwnPropertyNames43(test22).length) {\n    getOwnPropertyNamesModule.f = function(it2) {\n      var result2 = getOwnPropertyNames43(it2);\n      for (var i = 0, length2 = result2.length; i < length2; i++) {\n        if (result2[i] === METADATA) {\n          splice32(result2, i, 1);\n          break;\n        }\n      }\n      return result2;\n    };\n    $$3({\n      target: \"Object\",\n      stat: true,\n      forced: true\n    }, {\n      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f\n    });\n  }\n};\nvar meta = internalMetadata.exports = {\n  enable,\n  fastKey: fastKey$1,\n  getWeakData,\n  onFreeze\n};\nhiddenKeys[METADATA] = true;\nvar global$3 = global$M;\nvar bind$1 = functionBindContext;\nvar call = functionCall;\nvar anObject = anObject$b;\nvar tryToString = tryToString$4;\nvar isArrayIteratorMethod = isArrayIteratorMethod$2;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$d;\nvar isPrototypeOf$6 = objectIsPrototypeOf;\nvar getIterator$5 = getIterator$7;\nvar getIteratorMethod = getIteratorMethod$8;\nvar iteratorClose = iteratorClose$2;\nvar TypeError$2 = global$3.TypeError;\nvar Result3 = function(stopped, result2) {\n  this.stopped = stopped;\n  this.result = result2;\n};\nvar ResultPrototype = Result3.prototype;\nvar iterate$2 = function(iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = bind$1(unboundFunction, that);\n  var iterator22, iterFn, index2, length2, result2, next23, step;\n  var stop = function(condition) {\n    if (iterator22)\n      iteratorClose(iterator22, \"normal\", condition);\n    return new Result3(true, condition);\n  };\n  var callFn = function(value) {\n    if (AS_ENTRIES) {\n      anObject(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    }\n    return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n  if (IS_ITERATOR) {\n    iterator22 = iterable;\n  } else {\n    iterFn = getIteratorMethod(iterable);\n    if (!iterFn)\n      throw TypeError$2(tryToString(iterable) + \" is not iterable\");\n    if (isArrayIteratorMethod(iterFn)) {\n      for (index2 = 0, length2 = lengthOfArrayLike$1(iterable); length2 > index2; index2++) {\n        result2 = callFn(iterable[index2]);\n        if (result2 && isPrototypeOf$6(ResultPrototype, result2))\n          return result2;\n      }\n      return new Result3(false);\n    }\n    iterator22 = getIterator$5(iterable, iterFn);\n  }\n  next23 = iterator22.next;\n  while (!(step = call(next23, iterator22)).done) {\n    try {\n      result2 = callFn(step.value);\n    } catch (error) {\n      iteratorClose(iterator22, \"throw\", error);\n    }\n    if (typeof result2 == \"object\" && result2 && isPrototypeOf$6(ResultPrototype, result2))\n      return result2;\n  }\n  return new Result3(false);\n};\nvar global$2 = global$M;\nvar isPrototypeOf$5 = objectIsPrototypeOf;\nvar TypeError$1 = global$2.TypeError;\nvar anInstance$2 = function(it2, Prototype) {\n  if (isPrototypeOf$5(Prototype, it2))\n    return it2;\n  throw TypeError$1(\"Incorrect invocation\");\n};\nvar $$2 = _export;\nvar global$1$1 = global$M;\nvar InternalMetadataModule = internalMetadata.exports;\nvar fails$1 = fails$r;\nvar createNonEnumerableProperty = createNonEnumerableProperty$6;\nvar iterate$1 = iterate$2;\nvar anInstance$1 = anInstance$2;\nvar isCallable = isCallable$h;\nvar isObject = isObject$f;\nvar setToStringTag = setToStringTag$5;\nvar defineProperty$1 = objectDefineProperty.f;\nvar forEach2 = arrayIteration.forEach;\nvar DESCRIPTORS$2 = descriptors;\nvar InternalStateModule$1 = internalState;\nvar setInternalState$1 = InternalStateModule$1.set;\nvar internalStateGetterFor$1 = InternalStateModule$1.getterFor;\nvar collection$2 = function(CONSTRUCTOR_NAME, wrapper2, common) {\n  var IS_MAP = CONSTRUCTOR_NAME.indexOf(\"Map\") !== -1;\n  var IS_WEAK = CONSTRUCTOR_NAME.indexOf(\"Weak\") !== -1;\n  var ADDER = IS_MAP ? \"set\" : \"add\";\n  var NativeConstructor = global$1$1[CONSTRUCTOR_NAME];\n  var NativePrototype = NativeConstructor && NativeConstructor.prototype;\n  var exported = {};\n  var Constructor;\n  if (!DESCRIPTORS$2 || !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$1(function() {\n    new NativeConstructor().entries().next();\n  }))) {\n    Constructor = common.getConstructor(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER);\n    InternalMetadataModule.enable();\n  } else {\n    Constructor = wrapper2(function(target, iterable) {\n      setInternalState$1(anInstance$1(target, Prototype), {\n        type: CONSTRUCTOR_NAME,\n        collection: new NativeConstructor()\n      });\n      if (iterable != void 0)\n        iterate$1(iterable, target[ADDER], {\n          that: target,\n          AS_ENTRIES: IS_MAP\n        });\n    });\n    var Prototype = Constructor.prototype;\n    var getInternalState22 = internalStateGetterFor$1(CONSTRUCTOR_NAME);\n    forEach2([\"add\", \"clear\", \"delete\", \"forEach\", \"get\", \"has\", \"set\", \"keys\", \"values\", \"entries\"], function(KEY) {\n      var IS_ADDER = KEY == \"add\" || KEY == \"set\";\n      if (KEY in NativePrototype && !(IS_WEAK && KEY == \"clear\")) {\n        createNonEnumerableProperty(Prototype, KEY, function(a, b) {\n          var collection22 = getInternalState22(this).collection;\n          if (!IS_ADDER && IS_WEAK && !isObject(a))\n            return KEY == \"get\" ? void 0 : false;\n          var result2 = collection22[KEY](a === 0 ? 0 : a, b);\n          return IS_ADDER ? this : result2;\n        });\n      }\n    });\n    IS_WEAK || defineProperty$1(Prototype, \"size\", {\n      configurable: true,\n      get: function() {\n        return getInternalState22(this).collection.size;\n      }\n    });\n  }\n  setToStringTag(Constructor, CONSTRUCTOR_NAME, false, true);\n  exported[CONSTRUCTOR_NAME] = Constructor;\n  $$2({\n    global: true,\n    forced: true\n  }, exported);\n  if (!IS_WEAK)\n    common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);\n  return Constructor;\n};\nvar redefine = redefine$4;\nvar redefineAll$1 = function(target, src, options) {\n  for (var key in src) {\n    if (options && options.unsafe && target[key])\n      target[key] = src[key];\n    else\n      redefine(target, key, src[key], options);\n  }\n  return target;\n};\nvar getBuiltIn = getBuiltIn$9;\nvar definePropertyModule = objectDefineProperty;\nvar wellKnownSymbol = wellKnownSymbol$j;\nvar DESCRIPTORS$1 = descriptors;\nvar SPECIES = wellKnownSymbol(\"species\");\nvar setSpecies$1 = function(CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);\n  var defineProperty62 = definePropertyModule.f;\n  if (DESCRIPTORS$1 && Constructor && !Constructor[SPECIES]) {\n    defineProperty62(Constructor, SPECIES, {\n      configurable: true,\n      get: function() {\n        return this;\n      }\n    });\n  }\n};\nvar defineProperty5 = objectDefineProperty.f;\nvar create4 = objectCreate;\nvar redefineAll = redefineAll$1;\nvar bind2 = functionBindContext;\nvar anInstance = anInstance$2;\nvar iterate = iterate$2;\nvar defineIterator = defineIterator$3;\nvar setSpecies = setSpecies$1;\nvar DESCRIPTORS = descriptors;\nvar fastKey = internalMetadata.exports.fastKey;\nvar InternalStateModule = internalState;\nvar setInternalState = InternalStateModule.set;\nvar internalStateGetterFor = InternalStateModule.getterFor;\nvar collectionStrong$2 = {\n  getConstructor: function(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n    var Constructor = wrapper2(function(that, iterable) {\n      anInstance(that, Prototype);\n      setInternalState(that, {\n        type: CONSTRUCTOR_NAME,\n        index: create4(null),\n        first: void 0,\n        last: void 0,\n        size: 0\n      });\n      if (!DESCRIPTORS)\n        that.size = 0;\n      if (iterable != void 0)\n        iterate(iterable, that[ADDER], {\n          that,\n          AS_ENTRIES: IS_MAP\n        });\n    });\n    var Prototype = Constructor.prototype;\n    var getInternalState22 = internalStateGetterFor(CONSTRUCTOR_NAME);\n    var define = function(that, key, value) {\n      var state = getInternalState22(that);\n      var entry = getEntry(that, key);\n      var previous, index2;\n      if (entry) {\n        entry.value = value;\n      } else {\n        state.last = entry = {\n          index: index2 = fastKey(key, true),\n          key,\n          value,\n          previous: previous = state.last,\n          next: void 0,\n          removed: false\n        };\n        if (!state.first)\n          state.first = entry;\n        if (previous)\n          previous.next = entry;\n        if (DESCRIPTORS)\n          state.size++;\n        else\n          that.size++;\n        if (index2 !== \"F\")\n          state.index[index2] = entry;\n      }\n      return that;\n    };\n    var getEntry = function(that, key) {\n      var state = getInternalState22(that);\n      var index2 = fastKey(key);\n      var entry;\n      if (index2 !== \"F\")\n        return state.index[index2];\n      for (entry = state.first; entry; entry = entry.next) {\n        if (entry.key == key)\n          return entry;\n      }\n    };\n    redefineAll(Prototype, {\n      clear: function clear() {\n        var that = this;\n        var state = getInternalState22(that);\n        var data22 = state.index;\n        var entry = state.first;\n        while (entry) {\n          entry.removed = true;\n          if (entry.previous)\n            entry.previous = entry.previous.next = void 0;\n          delete data22[entry.index];\n          entry = entry.next;\n        }\n        state.first = state.last = void 0;\n        if (DESCRIPTORS)\n          state.size = 0;\n        else\n          that.size = 0;\n      },\n      delete: function(key) {\n        var that = this;\n        var state = getInternalState22(that);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next23 = entry.next;\n          var prev = entry.previous;\n          delete state.index[entry.index];\n          entry.removed = true;\n          if (prev)\n            prev.next = next23;\n          if (next23)\n            next23.previous = prev;\n          if (state.first == entry)\n            state.first = next23;\n          if (state.last == entry)\n            state.last = prev;\n          if (DESCRIPTORS)\n            state.size--;\n          else\n            that.size--;\n        }\n        return !!entry;\n      },\n      forEach: function forEach33(callbackfn) {\n        var state = getInternalState22(this);\n        var boundFunction = bind2(callbackfn, arguments.length > 1 ? arguments[1] : void 0);\n        var entry;\n        while (entry = entry ? entry.next : state.first) {\n          boundFunction(entry.value, entry.key, this);\n          while (entry && entry.removed)\n            entry = entry.previous;\n        }\n      },\n      has: function has22(key) {\n        return !!getEntry(this, key);\n      }\n    });\n    redefineAll(Prototype, IS_MAP ? {\n      get: function get22(key) {\n        var entry = getEntry(this, key);\n        return entry && entry.value;\n      },\n      set: function set22(key, value) {\n        return define(this, key === 0 ? 0 : key, value);\n      }\n    } : {\n      add: function add(value) {\n        return define(this, value = value === 0 ? 0 : value, value);\n      }\n    });\n    if (DESCRIPTORS)\n      defineProperty5(Prototype, \"size\", {\n        get: function() {\n          return getInternalState22(this).size;\n        }\n      });\n    return Constructor;\n  },\n  setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {\n    var ITERATOR_NAME = CONSTRUCTOR_NAME + \" Iterator\";\n    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);\n    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);\n    defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {\n      setInternalState(this, {\n        type: ITERATOR_NAME,\n        target: iterated,\n        state: getInternalCollectionState(iterated),\n        kind,\n        last: void 0\n      });\n    }, function() {\n      var state = getInternalIteratorState(this);\n      var kind = state.kind;\n      var entry = state.last;\n      while (entry && entry.removed)\n        entry = entry.previous;\n      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {\n        state.target = void 0;\n        return {\n          value: void 0,\n          done: true\n        };\n      }\n      if (kind == \"keys\")\n        return {\n          value: entry.key,\n          done: false\n        };\n      if (kind == \"values\")\n        return {\n          value: entry.value,\n          done: false\n        };\n      return {\n        value: [entry.key, entry.value],\n        done: false\n      };\n    }, IS_MAP ? \"entries\" : \"values\", !IS_MAP, true);\n    setSpecies(CONSTRUCTOR_NAME);\n  }\n};\nvar collection$1 = collection$2;\nvar collectionStrong$1 = collectionStrong$2;\ncollection$1(\"Map\", function(init) {\n  return function Map2() {\n    return init(this, arguments.length ? arguments[0] : void 0);\n  };\n}, collectionStrong$1);\nvar path$1 = path$q;\nvar map$2 = path$1.Map;\nvar parent$9 = map$2;\nvar map$1 = parent$9;\nvar map22 = map$1;\nvar $$1 = _export;\nvar $some = arrayIteration.some;\nvar arrayMethodIsStrict$1 = arrayMethodIsStrict$5;\nvar STRICT_METHOD$1 = arrayMethodIsStrict$1(\"some\");\n$$1({\n  target: \"Array\",\n  proto: true,\n  forced: !STRICT_METHOD$1\n}, {\n  some: function some(callbackfn) {\n    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);\n  }\n});\nvar entryVirtual$4 = entryVirtual$k;\nvar some$3 = entryVirtual$4(\"Array\").some;\nvar isPrototypeOf$4 = objectIsPrototypeOf;\nvar method$4 = some$3;\nvar ArrayPrototype$4 = Array.prototype;\nvar some$2 = function(it2) {\n  var own = it2.some;\n  return it2 === ArrayPrototype$4 || isPrototypeOf$4(ArrayPrototype$4, it2) && own === ArrayPrototype$4.some ? method$4 : own;\n};\nvar parent$8 = some$2;\nvar some$1 = parent$8;\nvar some2 = some$1;\nvar entryVirtual$3 = entryVirtual$k;\nvar keys$3 = entryVirtual$3(\"Array\").keys;\nvar parent$7 = keys$3;\nvar keys$2 = parent$7;\nvar classof$2 = classof$c;\nvar hasOwn$2 = hasOwnProperty_1;\nvar isPrototypeOf$3 = objectIsPrototypeOf;\nvar method$3 = keys$2;\nvar ArrayPrototype$3 = Array.prototype;\nvar DOMIterables$2 = {\n  DOMTokenList: true,\n  NodeList: true\n};\nvar keys$1 = function(it2) {\n  var own = it2.keys;\n  return it2 === ArrayPrototype$3 || isPrototypeOf$3(ArrayPrototype$3, it2) && own === ArrayPrototype$3.keys || hasOwn$2(DOMIterables$2, classof$2(it2)) ? method$3 : own;\n};\nvar keys3 = keys$1;\nvar arraySlice = arraySliceSimple;\nvar floor = Math.floor;\nvar mergeSort = function(array2, comparefn) {\n  var length2 = array2.length;\n  var middle = floor(length2 / 2);\n  return length2 < 8 ? insertionSort(array2, comparefn) : merge(array2, mergeSort(arraySlice(array2, 0, middle), comparefn), mergeSort(arraySlice(array2, middle), comparefn), comparefn);\n};\nvar insertionSort = function(array2, comparefn) {\n  var length2 = array2.length;\n  var i = 1;\n  var element, j;\n  while (i < length2) {\n    j = i;\n    element = array2[i];\n    while (j && comparefn(array2[j - 1], element) > 0) {\n      array2[j] = array2[--j];\n    }\n    if (j !== i++)\n      array2[j] = element;\n  }\n  return array2;\n};\nvar merge = function(array2, left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n  while (lindex < llength || rindex < rlength) {\n    array2[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];\n  }\n  return array2;\n};\nvar arraySort = mergeSort;\nvar userAgent$1 = engineUserAgent;\nvar firefox = userAgent$1.match(/firefox\\/(\\d+)/i);\nvar engineFfVersion = !!firefox && +firefox[1];\nvar UA = engineUserAgent;\nvar engineIsIeOrEdge = /MSIE|Trident/.test(UA);\nvar userAgent = engineUserAgent;\nvar webkit = userAgent.match(/AppleWebKit\\/(\\d+)\\./);\nvar engineWebkitVersion = !!webkit && +webkit[1];\nvar $2 = _export;\nvar uncurryThis = functionUncurryThis;\nvar aCallable = aCallable$7;\nvar toObject = toObject$e;\nvar lengthOfArrayLike = lengthOfArrayLike$d;\nvar toString2 = toString$7;\nvar fails = fails$r;\nvar internalSort = arraySort;\nvar arrayMethodIsStrict = arrayMethodIsStrict$5;\nvar FF = engineFfVersion;\nvar IE_OR_EDGE = engineIsIeOrEdge;\nvar V8 = engineV8Version;\nvar WEBKIT = engineWebkitVersion;\nvar test = [];\nvar un$Sort = uncurryThis(test.sort);\nvar push = uncurryThis(test.push);\nvar FAILS_ON_UNDEFINED = fails(function() {\n  test.sort(void 0);\n});\nvar FAILS_ON_NULL = fails(function() {\n  test.sort(null);\n});\nvar STRICT_METHOD = arrayMethodIsStrict(\"sort\");\nvar STABLE_SORT = !fails(function() {\n  if (V8)\n    return V8 < 70;\n  if (FF && FF > 3)\n    return;\n  if (IE_OR_EDGE)\n    return true;\n  if (WEBKIT)\n    return WEBKIT < 603;\n  var result2 = \"\";\n  var code, chr, value, index2;\n  for (code = 65; code < 76; code++) {\n    chr = String.fromCharCode(code);\n    switch (code) {\n      case 66:\n      case 69:\n      case 70:\n      case 72:\n        value = 3;\n        break;\n      case 68:\n      case 71:\n        value = 4;\n        break;\n      default:\n        value = 2;\n    }\n    for (index2 = 0; index2 < 47; index2++) {\n      test.push({\n        k: chr + index2,\n        v: value\n      });\n    }\n  }\n  test.sort(function(a, b) {\n    return b.v - a.v;\n  });\n  for (index2 = 0; index2 < test.length; index2++) {\n    chr = test[index2].k.charAt(0);\n    if (result2.charAt(result2.length - 1) !== chr)\n      result2 += chr;\n  }\n  return result2 !== \"DGBEFHACIJK\";\n});\nvar FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;\nvar getSortCompare = function(comparefn) {\n  return function(x, y) {\n    if (y === void 0)\n      return -1;\n    if (x === void 0)\n      return 1;\n    if (comparefn !== void 0)\n      return +comparefn(x, y) || 0;\n    return toString2(x) > toString2(y) ? 1 : -1;\n  };\n};\n$2({\n  target: \"Array\",\n  proto: true,\n  forced: FORCED\n}, {\n  sort: function sort(comparefn) {\n    if (comparefn !== void 0)\n      aCallable(comparefn);\n    var array2 = toObject(this);\n    if (STABLE_SORT)\n      return comparefn === void 0 ? un$Sort(array2) : un$Sort(array2, comparefn);\n    var items = [];\n    var arrayLength = lengthOfArrayLike(array2);\n    var itemsLength, index2;\n    for (index2 = 0; index2 < arrayLength; index2++) {\n      if (index2 in array2)\n        push(items, array2[index2]);\n    }\n    internalSort(items, getSortCompare(comparefn));\n    itemsLength = items.length;\n    index2 = 0;\n    while (index2 < itemsLength)\n      array2[index2] = items[index2++];\n    while (index2 < arrayLength)\n      delete array2[index2++];\n    return array2;\n  }\n});\nvar entryVirtual$2 = entryVirtual$k;\nvar sort$3 = entryVirtual$2(\"Array\").sort;\nvar isPrototypeOf$2 = objectIsPrototypeOf;\nvar method$2 = sort$3;\nvar ArrayPrototype$2 = Array.prototype;\nvar sort$2 = function(it2) {\n  var own = it2.sort;\n  return it2 === ArrayPrototype$2 || isPrototypeOf$2(ArrayPrototype$2, it2) && own === ArrayPrototype$2.sort ? method$2 : own;\n};\nvar parent$6 = sort$2;\nvar sort$1 = parent$6;\nvar sort2 = sort$1;\nvar entryVirtual$1 = entryVirtual$k;\nvar values$3 = entryVirtual$1(\"Array\").values;\nvar parent$5 = values$3;\nvar values$2 = parent$5;\nvar classof$1 = classof$c;\nvar hasOwn$1 = hasOwnProperty_1;\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar method$1 = values$2;\nvar ArrayPrototype$1 = Array.prototype;\nvar DOMIterables$1 = {\n  DOMTokenList: true,\n  NodeList: true\n};\nvar values$1 = function(it2) {\n  var own = it2.values;\n  return it2 === ArrayPrototype$1 || isPrototypeOf$1(ArrayPrototype$1, it2) && own === ArrayPrototype$1.values || hasOwn$1(DOMIterables$1, classof$1(it2)) ? method$1 : own;\n};\nvar values2 = values$1;\nvar iterator = iterator$4;\nvar entryVirtual = entryVirtual$k;\nvar entries$3 = entryVirtual(\"Array\").entries;\nvar parent$4 = entries$3;\nvar entries$2 = parent$4;\nvar classof = classof$c;\nvar hasOwn2 = hasOwnProperty_1;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar method = entries$2;\nvar ArrayPrototype = Array.prototype;\nvar DOMIterables = {\n  DOMTokenList: true,\n  NodeList: true\n};\nvar entries$1 = function(it2) {\n  var own = it2.entries;\n  return it2 === ArrayPrototype || isPrototypeOf(ArrayPrototype, it2) && own === ArrayPrototype.entries || hasOwn2(DOMIterables, classof(it2)) ? method : own;\n};\nvar entries = entries$1;\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  if (!getRandomValues) {\n    getRandomValues = typeof crypto !== \"undefined\" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== \"undefined\" && typeof msCrypto.getRandomValues === \"function\" && msCrypto.getRandomValues.bind(msCrypto);\n    if (!getRandomValues) {\n      throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n    }\n  }\n  return getRandomValues(rnds8);\n}\nvar REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nfunction validate(uuid) {\n  return typeof uuid === \"string\" && REGEX.test(uuid);\n}\nvar byteToHex = [];\nfor (i = 0; i < 256; ++i) {\n  byteToHex.push((i + 256).toString(16).substr(1));\n}\nvar i;\nfunction stringify2(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \"-\" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \"-\" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \"-\" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \"-\" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n  if (!validate(uuid)) {\n    throw TypeError(\"Stringified UUID is invalid\");\n  }\n  return uuid;\n}\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)();\n  rnds[6] = rnds[6] & 15 | 64;\n  rnds[8] = rnds[8] & 63 | 128;\n  if (buf) {\n    offset = offset || 0;\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return stringify2(rnds);\n}\nfunction isId(value) {\n  return typeof value === \"string\" || typeof value === \"number\";\n}\nvar Queue = /* @__PURE__ */ function() {\n  function Queue2(options) {\n    _classCallCheck(this, Queue2);\n    _defineProperty(this, \"delay\", void 0);\n    _defineProperty(this, \"max\", void 0);\n    _defineProperty(this, \"_queue\", []);\n    _defineProperty(this, \"_timeout\", null);\n    _defineProperty(this, \"_extended\", null);\n    this.delay = null;\n    this.max = Infinity;\n    this.setOptions(options);\n  }\n  _createClass(Queue2, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options && typeof options.delay !== \"undefined\") {\n        this.delay = options.delay;\n      }\n      if (options && typeof options.max !== \"undefined\") {\n        this.max = options.max;\n      }\n      this._flushIfNeeded();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.flush();\n      if (this._extended) {\n        var object2 = this._extended.object;\n        var methods = this._extended.methods;\n        for (var i = 0; i < methods.length; i++) {\n          var method22 = methods[i];\n          if (method22.original) {\n            object2[method22.name] = method22.original;\n          } else {\n            delete object2[method22.name];\n          }\n        }\n        this._extended = null;\n      }\n    }\n  }, {\n    key: \"replace\",\n    value: function replace22(object2, method22) {\n      var me3 = this;\n      var original = object2[method22];\n      if (!original) {\n        throw new Error(\"Method \" + method22 + \" undefined\");\n      }\n      object2[method22] = function() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        me3.queue({\n          args,\n          fn: original,\n          context: this\n        });\n      };\n    }\n  }, {\n    key: \"queue\",\n    value: function queue(entry) {\n      if (typeof entry === \"function\") {\n        this._queue.push({\n          fn: entry\n        });\n      } else {\n        this._queue.push(entry);\n      }\n      this._flushIfNeeded();\n    }\n  }, {\n    key: \"_flushIfNeeded\",\n    value: function _flushIfNeeded() {\n      var _this = this;\n      if (this._queue.length > this.max) {\n        this.flush();\n      }\n      if (this._timeout != null) {\n        clearTimeout(this._timeout);\n        this._timeout = null;\n      }\n      if (this.queue.length > 0 && typeof this.delay === \"number\") {\n        this._timeout = setTimeout$1(function() {\n          _this.flush();\n        }, this.delay);\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      var _context, _context2;\n      forEach$1(_context = splice2(_context2 = this._queue).call(_context2, 0)).call(_context, function(entry) {\n        entry.fn.apply(entry.context || entry.fn, entry.args || []);\n      });\n    }\n  }], [{\n    key: \"extend\",\n    value: function extend22(object2, options) {\n      var queue = new Queue2(options);\n      if (object2.flush !== void 0) {\n        throw new Error(\"Target object already has a property flush\");\n      }\n      object2.flush = function() {\n        queue.flush();\n      };\n      var methods = [{\n        name: \"flush\",\n        original: void 0\n      }];\n      if (options && options.replace) {\n        for (var i = 0; i < options.replace.length; i++) {\n          var name2 = options.replace[i];\n          methods.push({\n            name: name2,\n            original: object2[name2]\n          });\n          queue.replace(object2, name2);\n        }\n      }\n      queue._extended = {\n        object: object2,\n        methods\n      };\n      return queue;\n    }\n  }]);\n  return Queue2;\n}();\nvar DataSetPart = /* @__PURE__ */ function() {\n  function DataSetPart2() {\n    _classCallCheck(this, DataSetPart2);\n    _defineProperty(this, \"_subscribers\", {\n      \"*\": [],\n      add: [],\n      remove: [],\n      update: []\n    });\n    _defineProperty(this, \"subscribe\", DataSetPart2.prototype.on);\n    _defineProperty(this, \"unsubscribe\", DataSetPart2.prototype.off);\n  }\n  _createClass(DataSetPart2, [{\n    key: \"_trigger\",\n    value: function _trigger(event, payload, senderId) {\n      var _context, _context2;\n      if (event === \"*\") {\n        throw new Error(\"Cannot trigger event *\");\n      }\n      forEach$1(_context = concat$1(_context2 = []).call(_context2, _toConsumableArray(this._subscribers[event]), _toConsumableArray(this._subscribers[\"*\"]))).call(_context, function(subscriber) {\n        subscriber(event, payload, senderId != null ? senderId : null);\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      if (typeof callback === \"function\") {\n        this._subscribers[event].push(callback);\n      }\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, callback) {\n      var _context3;\n      this._subscribers[event] = filter2(_context3 = this._subscribers[event]).call(_context3, function(subscriber) {\n        return subscriber !== callback;\n      });\n    }\n  }]);\n  return DataSetPart2;\n}();\nvar collection = collection$2;\nvar collectionStrong = collectionStrong$2;\ncollection(\"Set\", function(init) {\n  return function Set2() {\n    return init(this, arguments.length ? arguments[0] : void 0);\n  };\n}, collectionStrong);\nvar path = path$q;\nvar set$2 = path.Set;\nvar parent$3 = set$2;\nvar set$1 = parent$3;\nvar set2 = set$1;\nvar getIterator$4 = getIterator$7;\nvar getIterator_1 = getIterator$4;\nvar parent$2 = getIterator_1;\nvar getIterator$3 = parent$2;\nvar parent$1 = getIterator$3;\nvar getIterator$2 = parent$1;\nvar parent = getIterator$2;\nvar getIterator$1 = parent;\nvar getIterator = getIterator$1;\nvar _Symbol$iterator;\nfunction _createForOfIteratorHelper$2(o, allowArrayLike) {\n  var it2 = typeof symbol !== \"undefined\" && getIteratorMethod$1(o) || o[\"@@iterator\"];\n  if (!it2) {\n    if (isArray$1(o) || (it2 = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it2)\n        o = it2;\n      var i = 0;\n      var F2 = function F22() {\n      };\n      return { s: F2, n: function n() {\n        if (i >= o.length)\n          return { done: true };\n        return { done: false, value: o[i++] };\n      }, e: function e(_e3) {\n        throw _e3;\n      }, f: F2 };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true, didErr = false, err;\n  return { s: function s() {\n    it2 = it2.call(o);\n  }, n: function n() {\n    var step = it2.next();\n    normalCompletion = step.done;\n    return step;\n  }, e: function e(_e22) {\n    didErr = true;\n    err = _e22;\n  }, f: function f() {\n    try {\n      if (!normalCompletion && it2.return != null)\n        it2.return();\n    } finally {\n      if (didErr)\n        throw err;\n    }\n  } };\n}\nfunction _unsupportedIterableToArray$2(o, minLen) {\n  var _context10;\n  if (!o)\n    return;\n  if (typeof o === \"string\")\n    return _arrayLikeToArray$2(o, minLen);\n  var n = slice2(_context10 = Object.prototype.toString.call(o)).call(_context10, 8, -1);\n  if (n === \"Object\" && o.constructor)\n    n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\")\n    return from$3(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray$2(o, minLen);\n}\nfunction _arrayLikeToArray$2(arr, len) {\n  if (len == null || len > arr.length)\n    len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\n_Symbol$iterator = iterator;\nvar DataStream = /* @__PURE__ */ function() {\n  function DataStream2(pairs) {\n    _classCallCheck(this, DataStream2);\n    _defineProperty(this, \"_pairs\", void 0);\n    this._pairs = pairs;\n  }\n  _createClass(DataStream2, [{\n    key: _Symbol$iterator,\n    value: /* @__PURE__ */ regenerator.mark(function value() {\n      var _iterator, _step, _step$value, id22, item;\n      return regenerator.wrap(function value$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iterator = _createForOfIteratorHelper$2(this._pairs);\n              _context.prev = 1;\n              _iterator.s();\n            case 3:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 9;\n                break;\n              }\n              _step$value = _slicedToArray(_step.value, 2), id22 = _step$value[0], item = _step$value[1];\n              _context.next = 7;\n              return [id22, item];\n            case 7:\n              _context.next = 3;\n              break;\n            case 9:\n              _context.next = 14;\n              break;\n            case 11:\n              _context.prev = 11;\n              _context.t0 = _context[\"catch\"](1);\n              _iterator.e(_context.t0);\n            case 14:\n              _context.prev = 14;\n              _iterator.f();\n              return _context.finish(14);\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, value, this, [[1, 11, 14, 17]]);\n    })\n  }, {\n    key: \"entries\",\n    value: /* @__PURE__ */ regenerator.mark(function entries2() {\n      var _iterator2, _step2, _step2$value, id22, item;\n      return regenerator.wrap(function entries$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _iterator2 = _createForOfIteratorHelper$2(this._pairs);\n              _context2.prev = 1;\n              _iterator2.s();\n            case 3:\n              if ((_step2 = _iterator2.n()).done) {\n                _context2.next = 9;\n                break;\n              }\n              _step2$value = _slicedToArray(_step2.value, 2), id22 = _step2$value[0], item = _step2$value[1];\n              _context2.next = 7;\n              return [id22, item];\n            case 7:\n              _context2.next = 3;\n              break;\n            case 9:\n              _context2.next = 14;\n              break;\n            case 11:\n              _context2.prev = 11;\n              _context2.t0 = _context2[\"catch\"](1);\n              _iterator2.e(_context2.t0);\n            case 14:\n              _context2.prev = 14;\n              _iterator2.f();\n              return _context2.finish(14);\n            case 17:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, entries2, this, [[1, 11, 14, 17]]);\n    })\n  }, {\n    key: \"keys\",\n    value: /* @__PURE__ */ regenerator.mark(function keys42() {\n      var _iterator3, _step3, _step3$value, id22;\n      return regenerator.wrap(function keys$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _iterator3 = _createForOfIteratorHelper$2(this._pairs);\n              _context3.prev = 1;\n              _iterator3.s();\n            case 3:\n              if ((_step3 = _iterator3.n()).done) {\n                _context3.next = 9;\n                break;\n              }\n              _step3$value = _slicedToArray(_step3.value, 1), id22 = _step3$value[0];\n              _context3.next = 7;\n              return id22;\n            case 7:\n              _context3.next = 3;\n              break;\n            case 9:\n              _context3.next = 14;\n              break;\n            case 11:\n              _context3.prev = 11;\n              _context3.t0 = _context3[\"catch\"](1);\n              _iterator3.e(_context3.t0);\n            case 14:\n              _context3.prev = 14;\n              _iterator3.f();\n              return _context3.finish(14);\n            case 17:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, keys42, this, [[1, 11, 14, 17]]);\n    })\n  }, {\n    key: \"values\",\n    value: /* @__PURE__ */ regenerator.mark(function values32() {\n      var _iterator4, _step4, _step4$value, item;\n      return regenerator.wrap(function values$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _iterator4 = _createForOfIteratorHelper$2(this._pairs);\n              _context4.prev = 1;\n              _iterator4.s();\n            case 3:\n              if ((_step4 = _iterator4.n()).done) {\n                _context4.next = 9;\n                break;\n              }\n              _step4$value = _slicedToArray(_step4.value, 2), item = _step4$value[1];\n              _context4.next = 7;\n              return item;\n            case 7:\n              _context4.next = 3;\n              break;\n            case 9:\n              _context4.next = 14;\n              break;\n            case 11:\n              _context4.prev = 11;\n              _context4.t0 = _context4[\"catch\"](1);\n              _iterator4.e(_context4.t0);\n            case 14:\n              _context4.prev = 14;\n              _iterator4.f();\n              return _context4.finish(14);\n            case 17:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, values32, this, [[1, 11, 14, 17]]);\n    })\n  }, {\n    key: \"toIdArray\",\n    value: function toIdArray() {\n      var _context5;\n      return map$3(_context5 = _toConsumableArray(this._pairs)).call(_context5, function(pair) {\n        return pair[0];\n      });\n    }\n  }, {\n    key: \"toItemArray\",\n    value: function toItemArray() {\n      var _context6;\n      return map$3(_context6 = _toConsumableArray(this._pairs)).call(_context6, function(pair) {\n        return pair[1];\n      });\n    }\n  }, {\n    key: \"toEntryArray\",\n    value: function toEntryArray() {\n      return _toConsumableArray(this._pairs);\n    }\n  }, {\n    key: \"toObjectMap\",\n    value: function toObjectMap() {\n      var map32 = create$5(null);\n      var _iterator5 = _createForOfIteratorHelper$2(this._pairs), _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {\n          var _step5$value = _slicedToArray(_step5.value, 2), id22 = _step5$value[0], item = _step5$value[1];\n          map32[id22] = item;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      return map32;\n    }\n  }, {\n    key: \"toMap\",\n    value: function toMap3() {\n      return new map22(this._pairs);\n    }\n  }, {\n    key: \"toIdSet\",\n    value: function toIdSet() {\n      return new set2(this.toIdArray());\n    }\n  }, {\n    key: \"toItemSet\",\n    value: function toItemSet() {\n      return new set2(this.toItemArray());\n    }\n  }, {\n    key: \"cache\",\n    value: function cache() {\n      return new DataStream2(_toConsumableArray(this._pairs));\n    }\n  }, {\n    key: \"distinct\",\n    value: function distinct(callback) {\n      var set$122 = new set2();\n      var _iterator6 = _createForOfIteratorHelper$2(this._pairs), _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {\n          var _step6$value = _slicedToArray(_step6.value, 2), id22 = _step6$value[0], item = _step6$value[1];\n          set$122.add(callback(item, id22));\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      return set$122;\n    }\n  }, {\n    key: \"filter\",\n    value: function filter32(callback) {\n      var pairs = this._pairs;\n      return new DataStream2(_defineProperty({}, iterator, /* @__PURE__ */ regenerator.mark(function _callee() {\n        var _iterator7, _step7, _step7$value, id22, item;\n        return regenerator.wrap(function _callee$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _iterator7 = _createForOfIteratorHelper$2(pairs);\n                _context7.prev = 1;\n                _iterator7.s();\n              case 3:\n                if ((_step7 = _iterator7.n()).done) {\n                  _context7.next = 10;\n                  break;\n                }\n                _step7$value = _slicedToArray(_step7.value, 2), id22 = _step7$value[0], item = _step7$value[1];\n                if (!callback(item, id22)) {\n                  _context7.next = 8;\n                  break;\n                }\n                _context7.next = 8;\n                return [id22, item];\n              case 8:\n                _context7.next = 3;\n                break;\n              case 10:\n                _context7.next = 15;\n                break;\n              case 12:\n                _context7.prev = 12;\n                _context7.t0 = _context7[\"catch\"](1);\n                _iterator7.e(_context7.t0);\n              case 15:\n                _context7.prev = 15;\n                _iterator7.f();\n                return _context7.finish(15);\n              case 18:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee, null, [[1, 12, 15, 18]]);\n      })));\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach33(callback) {\n      var _iterator8 = _createForOfIteratorHelper$2(this._pairs), _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {\n          var _step8$value = _slicedToArray(_step8.value, 2), id22 = _step8$value[0], item = _step8$value[1];\n          callback(item, id22);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  }, {\n    key: \"map\",\n    value: function map32(callback) {\n      var pairs = this._pairs;\n      return new DataStream2(_defineProperty({}, iterator, /* @__PURE__ */ regenerator.mark(function _callee2() {\n        var _iterator9, _step9, _step9$value, id22, item;\n        return regenerator.wrap(function _callee2$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _iterator9 = _createForOfIteratorHelper$2(pairs);\n                _context8.prev = 1;\n                _iterator9.s();\n              case 3:\n                if ((_step9 = _iterator9.n()).done) {\n                  _context8.next = 9;\n                  break;\n                }\n                _step9$value = _slicedToArray(_step9.value, 2), id22 = _step9$value[0], item = _step9$value[1];\n                _context8.next = 7;\n                return [id22, callback(item, id22)];\n              case 7:\n                _context8.next = 3;\n                break;\n              case 9:\n                _context8.next = 14;\n                break;\n              case 11:\n                _context8.prev = 11;\n                _context8.t0 = _context8[\"catch\"](1);\n                _iterator9.e(_context8.t0);\n              case 14:\n                _context8.prev = 14;\n                _iterator9.f();\n                return _context8.finish(14);\n              case 17:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee2, null, [[1, 11, 14, 17]]);\n      })));\n    }\n  }, {\n    key: \"max\",\n    value: function max22(callback) {\n      var iter = getIterator(this._pairs);\n      var curr = iter.next();\n      if (curr.done) {\n        return null;\n      }\n      var maxItem = curr.value[1];\n      var maxValue = callback(curr.value[1], curr.value[0]);\n      while (!(curr = iter.next()).done) {\n        var _curr$value = _slicedToArray(curr.value, 2), id22 = _curr$value[0], item = _curr$value[1];\n        var _value = callback(item, id22);\n        if (_value > maxValue) {\n          maxValue = _value;\n          maxItem = item;\n        }\n      }\n      return maxItem;\n    }\n  }, {\n    key: \"min\",\n    value: function min22(callback) {\n      var iter = getIterator(this._pairs);\n      var curr = iter.next();\n      if (curr.done) {\n        return null;\n      }\n      var minItem = curr.value[1];\n      var minValue = callback(curr.value[1], curr.value[0]);\n      while (!(curr = iter.next()).done) {\n        var _curr$value2 = _slicedToArray(curr.value, 2), id22 = _curr$value2[0], item = _curr$value2[1];\n        var _value2 = callback(item, id22);\n        if (_value2 < minValue) {\n          minValue = _value2;\n          minItem = item;\n        }\n      }\n      return minItem;\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce32(callback, accumulator) {\n      var _iterator10 = _createForOfIteratorHelper$2(this._pairs), _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {\n          var _step10$value = _slicedToArray(_step10.value, 2), id22 = _step10$value[0], item = _step10$value[1];\n          accumulator = callback(accumulator, item, id22);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n      return accumulator;\n    }\n  }, {\n    key: \"sort\",\n    value: function sort$122(callback) {\n      var _this = this;\n      return new DataStream2(_defineProperty({}, iterator, function() {\n        var _context9;\n        return getIterator(sort2(_context9 = _toConsumableArray(_this._pairs)).call(_context9, function(_ref, _ref2) {\n          var _ref3 = _slicedToArray(_ref, 2), idA = _ref3[0], itemA = _ref3[1];\n          var _ref4 = _slicedToArray(_ref2, 2), idB = _ref4[0], itemB = _ref4[1];\n          return callback(itemA, itemB, idA, idB);\n        }));\n      }));\n    }\n  }]);\n  return DataStream2;\n}();\nfunction ownKeys2(object2, enumerableOnly) {\n  var keys42 = keys$4(object2);\n  if (getOwnPropertySymbols3) {\n    var symbols = getOwnPropertySymbols3(object2);\n    enumerableOnly && (symbols = filter2(symbols).call(symbols, function(sym) {\n      return getOwnPropertyDescriptor5(object2, sym).enumerable;\n    })), keys42.push.apply(keys42, symbols);\n  }\n  return keys42;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var _context10, _context11;\n    var source = arguments[i] != null ? arguments[i] : {};\n    i % 2 ? forEach$1(_context10 = ownKeys2(Object(source), true)).call(_context10, function(key) {\n      _defineProperty(target, key, source[key]);\n    }) : getOwnPropertyDescriptors2 ? defineProperties4(target, getOwnPropertyDescriptors2(source)) : forEach$1(_context11 = ownKeys2(Object(source))).call(_context11, function(key) {\n      defineProperty$4(target, key, getOwnPropertyDescriptor5(source, key));\n    });\n  }\n  return target;\n}\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) {\n  var it2 = typeof symbol !== \"undefined\" && getIteratorMethod$1(o) || o[\"@@iterator\"];\n  if (!it2) {\n    if (isArray$1(o) || (it2 = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it2)\n        o = it2;\n      var i = 0;\n      var F2 = function F22() {\n      };\n      return { s: F2, n: function n() {\n        if (i >= o.length)\n          return { done: true };\n        return { done: false, value: o[i++] };\n      }, e: function e(_e3) {\n        throw _e3;\n      }, f: F2 };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true, didErr = false, err;\n  return { s: function s() {\n    it2 = it2.call(o);\n  }, n: function n() {\n    var step = it2.next();\n    normalCompletion = step.done;\n    return step;\n  }, e: function e(_e22) {\n    didErr = true;\n    err = _e22;\n  }, f: function f() {\n    try {\n      if (!normalCompletion && it2.return != null)\n        it2.return();\n    } finally {\n      if (didErr)\n        throw err;\n    }\n  } };\n}\nfunction _unsupportedIterableToArray$1(o, minLen) {\n  var _context9;\n  if (!o)\n    return;\n  if (typeof o === \"string\")\n    return _arrayLikeToArray$1(o, minLen);\n  var n = slice2(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1);\n  if (n === \"Object\" && o.constructor)\n    n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\")\n    return from$3(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray$1(o, minLen);\n}\nfunction _arrayLikeToArray$1(arr, len) {\n  if (len == null || len > arr.length)\n    len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _createSuper$1(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result2 = construct2(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$1() {\n  if (typeof Reflect === \"undefined\" || !construct2)\n    return false;\n  if (construct2.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct2(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction ensureFullItem(item, idProp) {\n  if (item[idProp] == null) {\n    item[idProp] = v4();\n  }\n  return item;\n}\nvar DataSet = /* @__PURE__ */ function(_DataSetPart) {\n  _inherits(DataSet2, _DataSetPart);\n  var _super = _createSuper$1(DataSet2);\n  function DataSet2(data22, options) {\n    var _this;\n    _classCallCheck(this, DataSet2);\n    _this = _super.call(this);\n    _defineProperty(_assertThisInitialized(_this), \"flush\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"length\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_options\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_data\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_idProp\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"_queue\", null);\n    if (data22 && !isArray$1(data22)) {\n      options = data22;\n      data22 = [];\n    }\n    _this._options = options || {};\n    _this._data = new map22();\n    _this.length = 0;\n    _this._idProp = _this._options.fieldId || \"id\";\n    if (data22 && data22.length) {\n      _this.add(data22);\n    }\n    _this.setOptions(options);\n    return _this;\n  }\n  _createClass(DataSet2, [{\n    key: \"idProp\",\n    get: function get22() {\n      return this._idProp;\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options && options.queue !== void 0) {\n        if (options.queue === false) {\n          if (this._queue) {\n            this._queue.destroy();\n            this._queue = null;\n          }\n        } else {\n          if (!this._queue) {\n            this._queue = Queue.extend(this, {\n              replace: [\"add\", \"update\", \"remove\"]\n            });\n          }\n          if (options.queue && _typeof(options.queue) === \"object\") {\n            this._queue.setOptions(options.queue);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"add\",\n    value: function add(data22, senderId) {\n      var _this2 = this;\n      var addedIds = [];\n      var id22;\n      if (isArray$1(data22)) {\n        var idsToAdd = map$3(data22).call(data22, function(d) {\n          return d[_this2._idProp];\n        });\n        if (some2(idsToAdd).call(idsToAdd, function(id3) {\n          return _this2._data.has(id3);\n        })) {\n          throw new Error(\"A duplicate id was found in the parameter array.\");\n        }\n        for (var i = 0, len = data22.length; i < len; i++) {\n          id22 = this._addItem(data22[i]);\n          addedIds.push(id22);\n        }\n      } else if (data22 && _typeof(data22) === \"object\") {\n        id22 = this._addItem(data22);\n        addedIds.push(id22);\n      } else {\n        throw new Error(\"Unknown dataType\");\n      }\n      if (addedIds.length) {\n        this._trigger(\"add\", {\n          items: addedIds\n        }, senderId);\n      }\n      return addedIds;\n    }\n  }, {\n    key: \"update\",\n    value: function update(data22, senderId) {\n      var _this3 = this;\n      var addedIds = [];\n      var updatedIds = [];\n      var oldData = [];\n      var updatedData = [];\n      var idProp = this._idProp;\n      var addOrUpdate = function addOrUpdate2(item) {\n        var origId = item[idProp];\n        if (origId != null && _this3._data.has(origId)) {\n          var fullItem = item;\n          var oldItem = assign$2({}, _this3._data.get(origId));\n          var id22 = _this3._updateItem(fullItem);\n          updatedIds.push(id22);\n          updatedData.push(fullItem);\n          oldData.push(oldItem);\n        } else {\n          var _id = _this3._addItem(item);\n          addedIds.push(_id);\n        }\n      };\n      if (isArray$1(data22)) {\n        for (var i = 0, len = data22.length; i < len; i++) {\n          if (data22[i] && _typeof(data22[i]) === \"object\") {\n            addOrUpdate(data22[i]);\n          } else {\n            console.warn(\"Ignoring input item, which is not an object at index \" + i);\n          }\n        }\n      } else if (data22 && _typeof(data22) === \"object\") {\n        addOrUpdate(data22);\n      } else {\n        throw new Error(\"Unknown dataType\");\n      }\n      if (addedIds.length) {\n        this._trigger(\"add\", {\n          items: addedIds\n        }, senderId);\n      }\n      if (updatedIds.length) {\n        var props = {\n          items: updatedIds,\n          oldData,\n          data: updatedData\n        };\n        this._trigger(\"update\", props, senderId);\n      }\n      return concat$1(addedIds).call(addedIds, updatedIds);\n    }\n  }, {\n    key: \"updateOnly\",\n    value: function updateOnly(data22, senderId) {\n      var _context, _this4 = this;\n      if (!isArray$1(data22)) {\n        data22 = [data22];\n      }\n      var updateEventData = map$3(_context = map$3(data22).call(data22, function(update) {\n        var oldData = _this4._data.get(update[_this4._idProp]);\n        if (oldData == null) {\n          throw new Error(\"Updating non-existent items is not allowed.\");\n        }\n        return {\n          oldData,\n          update\n        };\n      })).call(_context, function(_ref) {\n        var oldData = _ref.oldData, update = _ref.update;\n        var id22 = oldData[_this4._idProp];\n        var updatedData = pureDeepObjectAssign(oldData, update);\n        _this4._data.set(id22, updatedData);\n        return {\n          id: id22,\n          oldData,\n          updatedData\n        };\n      });\n      if (updateEventData.length) {\n        var props = {\n          items: map$3(updateEventData).call(updateEventData, function(value) {\n            return value.id;\n          }),\n          oldData: map$3(updateEventData).call(updateEventData, function(value) {\n            return value.oldData;\n          }),\n          data: map$3(updateEventData).call(updateEventData, function(value) {\n            return value.updatedData;\n          })\n        };\n        this._trigger(\"update\", props, senderId);\n        return props.items;\n      } else {\n        return [];\n      }\n    }\n  }, {\n    key: \"get\",\n    value: function get22(first2, second) {\n      var id22 = void 0;\n      var ids = void 0;\n      var options = void 0;\n      if (isId(first2)) {\n        id22 = first2;\n        options = second;\n      } else if (isArray$1(first2)) {\n        ids = first2;\n        options = second;\n      } else {\n        options = first2;\n      }\n      var returnType = options && options.returnType === \"Object\" ? \"Object\" : \"Array\";\n      var filter$122 = options && filter2(options);\n      var items = [];\n      var item = void 0;\n      var itemIds = void 0;\n      var itemId = void 0;\n      if (id22 != null) {\n        item = this._data.get(id22);\n        if (item && filter$122 && !filter$122(item)) {\n          item = void 0;\n        }\n      } else if (ids != null) {\n        for (var i = 0, len = ids.length; i < len; i++) {\n          item = this._data.get(ids[i]);\n          if (item != null && (!filter$122 || filter$122(item))) {\n            items.push(item);\n          }\n        }\n      } else {\n        var _context2;\n        itemIds = _toConsumableArray(keys3(_context2 = this._data).call(_context2));\n        for (var _i = 0, _len = itemIds.length; _i < _len; _i++) {\n          itemId = itemIds[_i];\n          item = this._data.get(itemId);\n          if (item != null && (!filter$122 || filter$122(item))) {\n            items.push(item);\n          }\n        }\n      }\n      if (options && options.order && id22 == void 0) {\n        this._sort(items, options.order);\n      }\n      if (options && options.fields) {\n        var fields = options.fields;\n        if (id22 != void 0 && item != null) {\n          item = this._filterFields(item, fields);\n        } else {\n          for (var _i2 = 0, _len2 = items.length; _i2 < _len2; _i2++) {\n            items[_i2] = this._filterFields(items[_i2], fields);\n          }\n        }\n      }\n      if (returnType == \"Object\") {\n        var result2 = {};\n        for (var _i3 = 0, _len3 = items.length; _i3 < _len3; _i3++) {\n          var resultant = items[_i3];\n          var _id2 = resultant[this._idProp];\n          result2[_id2] = resultant;\n        }\n        return result2;\n      } else {\n        if (id22 != null) {\n          var _item;\n          return (_item = item) !== null && _item !== void 0 ? _item : null;\n        } else {\n          return items;\n        }\n      }\n    }\n  }, {\n    key: \"getIds\",\n    value: function getIds(options) {\n      var data22 = this._data;\n      var filter$122 = options && filter2(options);\n      var order = options && options.order;\n      var itemIds = _toConsumableArray(keys3(data22).call(data22));\n      var ids = [];\n      if (filter$122) {\n        if (order) {\n          var items = [];\n          for (var i = 0, len = itemIds.length; i < len; i++) {\n            var id22 = itemIds[i];\n            var item = this._data.get(id22);\n            if (item != null && filter$122(item)) {\n              items.push(item);\n            }\n          }\n          this._sort(items, order);\n          for (var _i4 = 0, _len4 = items.length; _i4 < _len4; _i4++) {\n            ids.push(items[_i4][this._idProp]);\n          }\n        } else {\n          for (var _i5 = 0, _len5 = itemIds.length; _i5 < _len5; _i5++) {\n            var _id3 = itemIds[_i5];\n            var _item2 = this._data.get(_id3);\n            if (_item2 != null && filter$122(_item2)) {\n              ids.push(_item2[this._idProp]);\n            }\n          }\n        }\n      } else {\n        if (order) {\n          var _items = [];\n          for (var _i6 = 0, _len6 = itemIds.length; _i6 < _len6; _i6++) {\n            var _id4 = itemIds[_i6];\n            _items.push(data22.get(_id4));\n          }\n          this._sort(_items, order);\n          for (var _i7 = 0, _len7 = _items.length; _i7 < _len7; _i7++) {\n            ids.push(_items[_i7][this._idProp]);\n          }\n        } else {\n          for (var _i8 = 0, _len8 = itemIds.length; _i8 < _len8; _i8++) {\n            var _id5 = itemIds[_i8];\n            var _item3 = data22.get(_id5);\n            if (_item3 != null) {\n              ids.push(_item3[this._idProp]);\n            }\n          }\n        }\n      }\n      return ids;\n    }\n  }, {\n    key: \"getDataSet\",\n    value: function getDataSet() {\n      return this;\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach33(callback, options) {\n      var filter$122 = options && filter2(options);\n      var data22 = this._data;\n      var itemIds = _toConsumableArray(keys3(data22).call(data22));\n      if (options && options.order) {\n        var items = this.get(options);\n        for (var i = 0, len = items.length; i < len; i++) {\n          var item = items[i];\n          var id22 = item[this._idProp];\n          callback(item, id22);\n        }\n      } else {\n        for (var _i9 = 0, _len9 = itemIds.length; _i9 < _len9; _i9++) {\n          var _id6 = itemIds[_i9];\n          var _item4 = this._data.get(_id6);\n          if (_item4 != null && (!filter$122 || filter$122(_item4))) {\n            callback(_item4, _id6);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"map\",\n    value: function map32(callback, options) {\n      var filter$122 = options && filter2(options);\n      var mappedItems = [];\n      var data22 = this._data;\n      var itemIds = _toConsumableArray(keys3(data22).call(data22));\n      for (var i = 0, len = itemIds.length; i < len; i++) {\n        var id22 = itemIds[i];\n        var item = this._data.get(id22);\n        if (item != null && (!filter$122 || filter$122(item))) {\n          mappedItems.push(callback(item, id22));\n        }\n      }\n      if (options && options.order) {\n        this._sort(mappedItems, options.order);\n      }\n      return mappedItems;\n    }\n  }, {\n    key: \"_filterFields\",\n    value: function _filterFields(item, fields) {\n      var _context3;\n      if (!item) {\n        return item;\n      }\n      return reduce2(_context3 = isArray$1(fields) ? fields : keys$4(fields)).call(_context3, function(filteredItem, field2) {\n        filteredItem[field2] = item[field2];\n        return filteredItem;\n      }, {});\n    }\n  }, {\n    key: \"_sort\",\n    value: function _sort(items, order) {\n      if (typeof order === \"string\") {\n        var name2 = order;\n        sort2(items).call(items, function(a, b) {\n          var av = a[name2];\n          var bv = b[name2];\n          return av > bv ? 1 : av < bv ? -1 : 0;\n        });\n      } else if (typeof order === \"function\") {\n        sort2(items).call(items, order);\n      } else {\n        throw new TypeError(\"Order must be a function or a string\");\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(id22, senderId) {\n      var removedIds = [];\n      var removedItems = [];\n      var ids = isArray$1(id22) ? id22 : [id22];\n      for (var i = 0, len = ids.length; i < len; i++) {\n        var item = this._remove(ids[i]);\n        if (item) {\n          var itemId = item[this._idProp];\n          if (itemId != null) {\n            removedIds.push(itemId);\n            removedItems.push(item);\n          }\n        }\n      }\n      if (removedIds.length) {\n        this._trigger(\"remove\", {\n          items: removedIds,\n          oldData: removedItems\n        }, senderId);\n      }\n      return removedIds;\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove(id22) {\n      var ident;\n      if (isId(id22)) {\n        ident = id22;\n      } else if (id22 && _typeof(id22) === \"object\") {\n        ident = id22[this._idProp];\n      }\n      if (ident != null && this._data.has(ident)) {\n        var item = this._data.get(ident) || null;\n        this._data.delete(ident);\n        --this.length;\n        return item;\n      }\n      return null;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(senderId) {\n      var _context4;\n      var ids = _toConsumableArray(keys3(_context4 = this._data).call(_context4));\n      var items = [];\n      for (var i = 0, len = ids.length; i < len; i++) {\n        items.push(this._data.get(ids[i]));\n      }\n      this._data.clear();\n      this.length = 0;\n      this._trigger(\"remove\", {\n        items: ids,\n        oldData: items\n      }, senderId);\n      return ids;\n    }\n  }, {\n    key: \"max\",\n    value: function max22(field2) {\n      var _context5;\n      var max3 = null;\n      var maxField = null;\n      var _iterator = _createForOfIteratorHelper$1(values2(_context5 = this._data).call(_context5)), _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done; ) {\n          var item = _step.value;\n          var itemField = item[field2];\n          if (typeof itemField === \"number\" && (maxField == null || itemField > maxField)) {\n            max3 = item;\n            maxField = itemField;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return max3 || null;\n    }\n  }, {\n    key: \"min\",\n    value: function min22(field2) {\n      var _context6;\n      var min3 = null;\n      var minField = null;\n      var _iterator2 = _createForOfIteratorHelper$1(values2(_context6 = this._data).call(_context6)), _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {\n          var item = _step2.value;\n          var itemField = item[field2];\n          if (typeof itemField === \"number\" && (minField == null || itemField < minField)) {\n            min3 = item;\n            minField = itemField;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return min3 || null;\n    }\n  }, {\n    key: \"distinct\",\n    value: function distinct(prop) {\n      var data22 = this._data;\n      var itemIds = _toConsumableArray(keys3(data22).call(data22));\n      var values32 = [];\n      var count = 0;\n      for (var i = 0, len = itemIds.length; i < len; i++) {\n        var id22 = itemIds[i];\n        var item = data22.get(id22);\n        var value = item[prop];\n        var exists = false;\n        for (var j = 0; j < count; j++) {\n          if (values32[j] == value) {\n            exists = true;\n            break;\n          }\n        }\n        if (!exists && value !== void 0) {\n          values32[count] = value;\n          count++;\n        }\n      }\n      return values32;\n    }\n  }, {\n    key: \"_addItem\",\n    value: function _addItem(item) {\n      var fullItem = ensureFullItem(item, this._idProp);\n      var id22 = fullItem[this._idProp];\n      if (this._data.has(id22)) {\n        throw new Error(\"Cannot add item: item with id \" + id22 + \" already exists\");\n      }\n      this._data.set(id22, fullItem);\n      ++this.length;\n      return id22;\n    }\n  }, {\n    key: \"_updateItem\",\n    value: function _updateItem(update) {\n      var id22 = update[this._idProp];\n      if (id22 == null) {\n        throw new Error(\"Cannot update item: item has no id (item: \" + stringify$1(update) + \")\");\n      }\n      var item = this._data.get(id22);\n      if (!item) {\n        throw new Error(\"Cannot update item: no item with id \" + id22 + \" found\");\n      }\n      this._data.set(id22, _objectSpread(_objectSpread({}, item), update));\n      return id22;\n    }\n  }, {\n    key: \"stream\",\n    value: function stream(ids) {\n      if (ids) {\n        var data22 = this._data;\n        return new DataStream(_defineProperty({}, iterator, /* @__PURE__ */ regenerator.mark(function _callee() {\n          var _iterator3, _step3, id22, item;\n          return regenerator.wrap(function _callee$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  _iterator3 = _createForOfIteratorHelper$1(ids);\n                  _context7.prev = 1;\n                  _iterator3.s();\n                case 3:\n                  if ((_step3 = _iterator3.n()).done) {\n                    _context7.next = 11;\n                    break;\n                  }\n                  id22 = _step3.value;\n                  item = data22.get(id22);\n                  if (!(item != null)) {\n                    _context7.next = 9;\n                    break;\n                  }\n                  _context7.next = 9;\n                  return [id22, item];\n                case 9:\n                  _context7.next = 3;\n                  break;\n                case 11:\n                  _context7.next = 16;\n                  break;\n                case 13:\n                  _context7.prev = 13;\n                  _context7.t0 = _context7[\"catch\"](1);\n                  _iterator3.e(_context7.t0);\n                case 16:\n                  _context7.prev = 16;\n                  _iterator3.f();\n                  return _context7.finish(16);\n                case 19:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }, _callee, null, [[1, 13, 16, 19]]);\n        })));\n      } else {\n        var _context8;\n        return new DataStream(_defineProperty({}, iterator, bind$6(_context8 = entries(this._data)).call(_context8, this._data)));\n      }\n    }\n  }]);\n  return DataSet2;\n}(DataSetPart);\nfunction isDataSetLike(idProp, v) {\n  return _typeof(v) === \"object\" && v !== null && idProp === v.idProp && typeof v.add === \"function\" && typeof v.clear === \"function\" && typeof v.distinct === \"function\" && typeof forEach$1(v) === \"function\" && typeof v.get === \"function\" && typeof v.getDataSet === \"function\" && typeof v.getIds === \"function\" && typeof v.length === \"number\" && typeof map$3(v) === \"function\" && typeof v.max === \"function\" && typeof v.min === \"function\" && typeof v.off === \"function\" && typeof v.on === \"function\" && typeof v.remove === \"function\" && typeof v.setOptions === \"function\" && typeof v.stream === \"function\" && typeof v.update === \"function\" && typeof v.updateOnly === \"function\";\n}\nfunction isDataViewLike(idProp, v) {\n  return _typeof(v) === \"object\" && v !== null && idProp === v.idProp && typeof forEach$1(v) === \"function\" && typeof v.get === \"function\" && typeof v.getDataSet === \"function\" && typeof v.getIds === \"function\" && typeof v.length === \"number\" && typeof map$3(v) === \"function\" && typeof v.off === \"function\" && typeof v.on === \"function\" && typeof v.stream === \"function\" && isDataSetLike(idProp, v.getDataSet());\n}\n\n// https://cdn.skypack.dev/-/vis-network@v9.1.2-AcOXfM8LU7McxMAmi6cN/dist=es2019,mode=imports/optimized/vis-network.js\nvar global$12 = typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {};\nvar commonjsGlobal2 = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global$12 !== \"undefined\" ? global$12 : typeof self !== \"undefined\" ? self : {};\nvar check2 = function(it2) {\n  return it2 && it2.Math == Math && it2;\n};\nvar global$O = check2(typeof globalThis == \"object\" && globalThis) || check2(typeof window == \"object\" && window) || check2(typeof self == \"object\" && self) || check2(typeof commonjsGlobal2 == \"object\" && commonjsGlobal2) || function() {\n  return this;\n}() || Function(\"return this\")();\nvar fails$t = function(exec22) {\n  try {\n    return !!exec22();\n  } catch (error) {\n    return true;\n  }\n};\nvar fails$s = fails$t;\nvar functionBindNative2 = !fails$s(function() {\n  var test22 = function() {\n  }.bind();\n  return typeof test22 != \"function\" || test22.hasOwnProperty(\"prototype\");\n});\nvar NATIVE_BIND$42 = functionBindNative2;\nvar FunctionPrototype$32 = Function.prototype;\nvar apply$62 = FunctionPrototype$32.apply;\nvar call$d = FunctionPrototype$32.call;\nvar functionApply2 = typeof Reflect == \"object\" && Reflect.apply || (NATIVE_BIND$42 ? call$d.bind(apply$62) : function() {\n  return call$d.apply(apply$62, arguments);\n});\nvar NATIVE_BIND$32 = functionBindNative2;\nvar FunctionPrototype$22 = Function.prototype;\nvar bind$c2 = FunctionPrototype$22.bind;\nvar call$c2 = FunctionPrototype$22.call;\nvar uncurryThis$w = NATIVE_BIND$32 && bind$c2.bind(call$c2, call$c2);\nvar functionUncurryThis2 = NATIVE_BIND$32 ? function(fn) {\n  return fn && uncurryThis$w(fn);\n} : function(fn) {\n  return fn && function() {\n    return call$c2.apply(fn, arguments);\n  };\n};\nvar isCallable$h2 = function(argument) {\n  return typeof argument == \"function\";\n};\nvar objectGetOwnPropertyDescriptor2 = {};\nvar fails$r2 = fails$t;\nvar descriptors2 = !fails$r2(function() {\n  return Object.defineProperty({}, 1, {\n    get: function() {\n      return 7;\n    }\n  })[1] != 7;\n});\nvar NATIVE_BIND$22 = functionBindNative2;\nvar call$b2 = Function.prototype.call;\nvar functionCall2 = NATIVE_BIND$22 ? call$b2.bind(call$b2) : function() {\n  return call$b2.apply(call$b2, arguments);\n};\nvar objectPropertyIsEnumerable2 = {};\nvar $propertyIsEnumerable$22 = {}.propertyIsEnumerable;\nvar getOwnPropertyDescriptor$8 = Object.getOwnPropertyDescriptor;\nvar NASHORN_BUG2 = getOwnPropertyDescriptor$8 && !$propertyIsEnumerable$22.call({\n  1: 2\n}, 1);\nobjectPropertyIsEnumerable2.f = NASHORN_BUG2 ? function propertyIsEnumerable4(V2) {\n  var descriptor = getOwnPropertyDescriptor$8(this, V2);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable$22;\nvar createPropertyDescriptor$52 = function(bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value\n  };\n};\nvar uncurryThis$v = functionUncurryThis2;\nvar toString$a = uncurryThis$v({}.toString);\nvar stringSlice$12 = uncurryThis$v(\"\".slice);\nvar classofRaw$12 = function(it2) {\n  return stringSlice$12(toString$a(it2), 8, -1);\n};\nvar global$N = global$O;\nvar uncurryThis$u = functionUncurryThis2;\nvar fails$q2 = fails$t;\nvar classof$d2 = classofRaw$12;\nvar Object$a = global$N.Object;\nvar split2 = uncurryThis$u(\"\".split);\nvar indexedObject2 = fails$q2(function() {\n  return !Object$a(\"z\").propertyIsEnumerable(0);\n}) ? function(it2) {\n  return classof$d2(it2) == \"String\" ? split2(it2, \"\") : Object$a(it2);\n} : Object$a;\nvar global$M2 = global$O;\nvar TypeError$i2 = global$M2.TypeError;\nvar requireObjectCoercible$52 = function(it2) {\n  if (it2 == void 0)\n    throw TypeError$i2(\"Can't call method on \" + it2);\n  return it2;\n};\nvar IndexedObject$32 = indexedObject2;\nvar requireObjectCoercible$42 = requireObjectCoercible$52;\nvar toIndexedObject$b2 = function(it2) {\n  return IndexedObject$32(requireObjectCoercible$42(it2));\n};\nvar isCallable$g2 = isCallable$h2;\nvar isObject$j = function(it2) {\n  return typeof it2 == \"object\" ? it2 !== null : isCallable$g2(it2);\n};\nvar path$y = {};\nvar path$x = path$y;\nvar global$L2 = global$O;\nvar isCallable$f2 = isCallable$h2;\nvar aFunction2 = function(variable) {\n  return isCallable$f2(variable) ? variable : void 0;\n};\nvar getBuiltIn$92 = function(namespace, method22) {\n  return arguments.length < 2 ? aFunction2(path$x[namespace]) || aFunction2(global$L2[namespace]) : path$x[namespace] && path$x[namespace][method22] || global$L2[namespace] && global$L2[namespace][method22];\n};\nvar uncurryThis$t2 = functionUncurryThis2;\nvar objectIsPrototypeOf2 = uncurryThis$t2({}.isPrototypeOf);\nvar getBuiltIn$82 = getBuiltIn$92;\nvar engineUserAgent2 = getBuiltIn$82(\"navigator\", \"userAgent\") || \"\";\nvar global$K2 = global$O;\nvar userAgent$32 = engineUserAgent2;\nvar process2 = global$K2.process;\nvar Deno2 = global$K2.Deno;\nvar versions2 = process2 && process2.versions || Deno2 && Deno2.version;\nvar v82 = versions2 && versions2.v8;\nvar match2;\nvar version2;\nif (v82) {\n  match2 = v82.split(\".\");\n  version2 = match2[0] > 0 && match2[0] < 4 ? 1 : +(match2[0] + match2[1]);\n}\nif (!version2 && userAgent$32) {\n  match2 = userAgent$32.match(/Edge\\/(\\d+)/);\n  if (!match2 || match2[1] >= 74) {\n    match2 = userAgent$32.match(/Chrome\\/(\\d+)/);\n    if (match2)\n      version2 = +match2[1];\n  }\n}\nvar engineV8Version2 = version2;\nvar V8_VERSION$22 = engineV8Version2;\nvar fails$p2 = fails$t;\nvar nativeSymbol2 = !!Object.getOwnPropertySymbols && !fails$p2(function() {\n  var symbol22 = Symbol();\n  return !String(symbol22) || !(Object(symbol22) instanceof Symbol) || !Symbol.sham && V8_VERSION$22 && V8_VERSION$22 < 41;\n});\nvar NATIVE_SYMBOL$22 = nativeSymbol2;\nvar useSymbolAsUid2 = NATIVE_SYMBOL$22 && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\nvar global$J2 = global$O;\nvar getBuiltIn$72 = getBuiltIn$92;\nvar isCallable$e2 = isCallable$h2;\nvar isPrototypeOf$j = objectIsPrototypeOf2;\nvar USE_SYMBOL_AS_UID$12 = useSymbolAsUid2;\nvar Object$92 = global$J2.Object;\nvar isSymbol$32 = USE_SYMBOL_AS_UID$12 ? function(it2) {\n  return typeof it2 == \"symbol\";\n} : function(it2) {\n  var $Symbol22 = getBuiltIn$72(\"Symbol\");\n  return isCallable$e2($Symbol22) && isPrototypeOf$j($Symbol22.prototype, Object$92(it2));\n};\nvar global$I2 = global$O;\nvar String$42 = global$I2.String;\nvar tryToString$42 = function(argument) {\n  try {\n    return String$42(argument);\n  } catch (error) {\n    return \"Object\";\n  }\n};\nvar global$H2 = global$O;\nvar isCallable$d2 = isCallable$h2;\nvar tryToString$32 = tryToString$42;\nvar TypeError$h2 = global$H2.TypeError;\nvar aCallable$62 = function(argument) {\n  if (isCallable$d2(argument))\n    return argument;\n  throw TypeError$h2(tryToString$32(argument) + \" is not a function\");\n};\nvar aCallable$52 = aCallable$62;\nvar getMethod$32 = function(V2, P) {\n  var func = V2[P];\n  return func == null ? void 0 : aCallable$52(func);\n};\nvar global$G2 = global$O;\nvar call$a2 = functionCall2;\nvar isCallable$c2 = isCallable$h2;\nvar isObject$i = isObject$j;\nvar TypeError$g2 = global$G2.TypeError;\nvar ordinaryToPrimitive$12 = function(input, pref) {\n  var fn, val;\n  if (pref === \"string\" && isCallable$c2(fn = input.toString) && !isObject$i(val = call$a2(fn, input)))\n    return val;\n  if (isCallable$c2(fn = input.valueOf) && !isObject$i(val = call$a2(fn, input)))\n    return val;\n  if (pref !== \"string\" && isCallable$c2(fn = input.toString) && !isObject$i(val = call$a2(fn, input)))\n    return val;\n  throw TypeError$g2(\"Can't convert object to primitive value\");\n};\nvar shared$42 = { exports: {} };\nvar global$F2 = global$O;\nvar defineProperty$e2 = Object.defineProperty;\nvar setGlobal$12 = function(key, value) {\n  try {\n    defineProperty$e2(global$F2, key, {\n      value,\n      configurable: true,\n      writable: true\n    });\n  } catch (error) {\n    global$F2[key] = value;\n  }\n  return value;\n};\nvar global$E2 = global$O;\nvar setGlobal2 = setGlobal$12;\nvar SHARED2 = \"__core-js_shared__\";\nvar store$32 = global$E2[SHARED2] || setGlobal2(SHARED2, {});\nvar sharedStore2 = store$32;\nvar store$22 = sharedStore2;\n(shared$42.exports = function(key, value) {\n  return store$22[key] || (store$22[key] = value !== void 0 ? value : {});\n})(\"versions\", []).push({\n  version: \"3.21.1\",\n  mode: \"pure\",\n  copyright: \"\\xA9 2014-2022 Denis Pushkarev (zloirock.ru)\",\n  license: \"https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE\",\n  source: \"https://github.com/zloirock/core-js\"\n});\nvar global$D2 = global$O;\nvar requireObjectCoercible$32 = requireObjectCoercible$52;\nvar Object$82 = global$D2.Object;\nvar toObject$d2 = function(argument) {\n  return Object$82(requireObjectCoercible$32(argument));\n};\nvar uncurryThis$s2 = functionUncurryThis2;\nvar toObject$c2 = toObject$d2;\nvar hasOwnProperty2 = uncurryThis$s2({}.hasOwnProperty);\nvar hasOwnProperty_12 = Object.hasOwn || function hasOwn3(it2, key) {\n  return hasOwnProperty2(toObject$c2(it2), key);\n};\nvar uncurryThis$r2 = functionUncurryThis2;\nvar id$2 = 0;\nvar postfix2 = Math.random();\nvar toString$92 = uncurryThis$r2(1 .toString);\nvar uid$42 = function(key) {\n  return \"Symbol(\" + (key === void 0 ? \"\" : key) + \")_\" + toString$92(++id$2 + postfix2, 36);\n};\nvar global$C2 = global$O;\nvar shared$32 = shared$42.exports;\nvar hasOwn$f2 = hasOwnProperty_12;\nvar uid$32 = uid$42;\nvar NATIVE_SYMBOL$12 = nativeSymbol2;\nvar USE_SYMBOL_AS_UID2 = useSymbolAsUid2;\nvar WellKnownSymbolsStore$12 = shared$32(\"wks\");\nvar Symbol$3 = global$C2.Symbol;\nvar symbolFor2 = Symbol$3 && Symbol$3[\"for\"];\nvar createWellKnownSymbol2 = USE_SYMBOL_AS_UID2 ? Symbol$3 : Symbol$3 && Symbol$3.withoutSetter || uid$32;\nvar wellKnownSymbol$j2 = function(name2) {\n  if (!hasOwn$f2(WellKnownSymbolsStore$12, name2) || !(NATIVE_SYMBOL$12 || typeof WellKnownSymbolsStore$12[name2] == \"string\")) {\n    var description = \"Symbol.\" + name2;\n    if (NATIVE_SYMBOL$12 && hasOwn$f2(Symbol$3, name2)) {\n      WellKnownSymbolsStore$12[name2] = Symbol$3[name2];\n    } else if (USE_SYMBOL_AS_UID2 && symbolFor2) {\n      WellKnownSymbolsStore$12[name2] = symbolFor2(description);\n    } else {\n      WellKnownSymbolsStore$12[name2] = createWellKnownSymbol2(description);\n    }\n  }\n  return WellKnownSymbolsStore$12[name2];\n};\nvar global$B2 = global$O;\nvar call$92 = functionCall2;\nvar isObject$h = isObject$j;\nvar isSymbol$22 = isSymbol$32;\nvar getMethod$22 = getMethod$32;\nvar ordinaryToPrimitive2 = ordinaryToPrimitive$12;\nvar wellKnownSymbol$i2 = wellKnownSymbol$j2;\nvar TypeError$f2 = global$B2.TypeError;\nvar TO_PRIMITIVE$12 = wellKnownSymbol$i2(\"toPrimitive\");\nvar toPrimitive$12 = function(input, pref) {\n  if (!isObject$h(input) || isSymbol$22(input))\n    return input;\n  var exoticToPrim = getMethod$22(input, TO_PRIMITIVE$12);\n  var result2;\n  if (exoticToPrim) {\n    if (pref === void 0)\n      pref = \"default\";\n    result2 = call$92(exoticToPrim, input, pref);\n    if (!isObject$h(result2) || isSymbol$22(result2))\n      return result2;\n    throw TypeError$f2(\"Can't convert object to primitive value\");\n  }\n  if (pref === void 0)\n    pref = \"number\";\n  return ordinaryToPrimitive2(input, pref);\n};\nvar toPrimitive2 = toPrimitive$12;\nvar isSymbol$12 = isSymbol$32;\nvar toPropertyKey$42 = function(argument) {\n  var key = toPrimitive2(argument, \"string\");\n  return isSymbol$12(key) ? key : key + \"\";\n};\nvar global$A2 = global$O;\nvar isObject$g = isObject$j;\nvar document$12 = global$A2.document;\nvar EXISTS$12 = isObject$g(document$12) && isObject$g(document$12.createElement);\nvar documentCreateElement$12 = function(it2) {\n  return EXISTS$12 ? document$12.createElement(it2) : {};\n};\nvar DESCRIPTORS$h2 = descriptors2;\nvar fails$o2 = fails$t;\nvar createElement2 = documentCreateElement$12;\nvar ie8DomDefine2 = !DESCRIPTORS$h2 && !fails$o2(function() {\n  return Object.defineProperty(createElement2(\"div\"), \"a\", {\n    get: function() {\n      return 7;\n    }\n  }).a != 7;\n});\nvar DESCRIPTORS$g2 = descriptors2;\nvar call$82 = functionCall2;\nvar propertyIsEnumerableModule$22 = objectPropertyIsEnumerable2;\nvar createPropertyDescriptor$42 = createPropertyDescriptor$52;\nvar toIndexedObject$a2 = toIndexedObject$b2;\nvar toPropertyKey$32 = toPropertyKey$42;\nvar hasOwn$e2 = hasOwnProperty_12;\nvar IE8_DOM_DEFINE$12 = ie8DomDefine2;\nvar $getOwnPropertyDescriptor$22 = Object.getOwnPropertyDescriptor;\nobjectGetOwnPropertyDescriptor2.f = DESCRIPTORS$g2 ? $getOwnPropertyDescriptor$22 : function getOwnPropertyDescriptor6(O, P) {\n  O = toIndexedObject$a2(O);\n  P = toPropertyKey$32(P);\n  if (IE8_DOM_DEFINE$12)\n    try {\n      return $getOwnPropertyDescriptor$22(O, P);\n    } catch (error) {\n    }\n  if (hasOwn$e2(O, P))\n    return createPropertyDescriptor$42(!call$82(propertyIsEnumerableModule$22.f, O, P), O[P]);\n};\nvar fails$n2 = fails$t;\nvar isCallable$b2 = isCallable$h2;\nvar replacement2 = /#|\\.prototype\\./;\nvar isForced$12 = function(feature, detection) {\n  var value = data2[normalize2(feature)];\n  return value == POLYFILL2 ? true : value == NATIVE2 ? false : isCallable$b2(detection) ? fails$n2(detection) : !!detection;\n};\nvar normalize2 = isForced$12.normalize = function(string22) {\n  return String(string22).replace(replacement2, \".\").toLowerCase();\n};\nvar data2 = isForced$12.data = {};\nvar NATIVE2 = isForced$12.NATIVE = \"N\";\nvar POLYFILL2 = isForced$12.POLYFILL = \"P\";\nvar isForced_12 = isForced$12;\nvar uncurryThis$q2 = functionUncurryThis2;\nvar aCallable$42 = aCallable$62;\nvar NATIVE_BIND$12 = functionBindNative2;\nvar bind$b2 = uncurryThis$q2(uncurryThis$q2.bind);\nvar functionBindContext2 = function(fn, that) {\n  aCallable$42(fn);\n  return that === void 0 ? fn : NATIVE_BIND$12 ? bind$b2(fn, that) : function() {\n    return fn.apply(that, arguments);\n  };\n};\nvar objectDefineProperty2 = {};\nvar DESCRIPTORS$f2 = descriptors2;\nvar fails$m2 = fails$t;\nvar v8PrototypeDefineBug2 = DESCRIPTORS$f2 && fails$m2(function() {\n  return Object.defineProperty(function() {\n  }, \"prototype\", {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\nvar global$z2 = global$O;\nvar isObject$f2 = isObject$j;\nvar String$32 = global$z2.String;\nvar TypeError$e2 = global$z2.TypeError;\nvar anObject$d = function(argument) {\n  if (isObject$f2(argument))\n    return argument;\n  throw TypeError$e2(String$32(argument) + \" is not an object\");\n};\nvar global$y2 = global$O;\nvar DESCRIPTORS$e2 = descriptors2;\nvar IE8_DOM_DEFINE2 = ie8DomDefine2;\nvar V8_PROTOTYPE_DEFINE_BUG$12 = v8PrototypeDefineBug2;\nvar anObject$c = anObject$d;\nvar toPropertyKey$22 = toPropertyKey$42;\nvar TypeError$d2 = global$y2.TypeError;\nvar $defineProperty$12 = Object.defineProperty;\nvar $getOwnPropertyDescriptor$12 = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE2 = \"enumerable\";\nvar CONFIGURABLE$12 = \"configurable\";\nvar WRITABLE2 = \"writable\";\nobjectDefineProperty2.f = DESCRIPTORS$e2 ? V8_PROTOTYPE_DEFINE_BUG$12 ? function defineProperty6(O, P, Attributes) {\n  anObject$c(O);\n  P = toPropertyKey$22(P);\n  anObject$c(Attributes);\n  if (typeof O === \"function\" && P === \"prototype\" && \"value\" in Attributes && WRITABLE2 in Attributes && !Attributes[WRITABLE2]) {\n    var current = $getOwnPropertyDescriptor$12(O, P);\n    if (current && current[WRITABLE2]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$12 in Attributes ? Attributes[CONFIGURABLE$12] : current[CONFIGURABLE$12],\n        enumerable: ENUMERABLE2 in Attributes ? Attributes[ENUMERABLE2] : current[ENUMERABLE2],\n        writable: false\n      };\n    }\n  }\n  return $defineProperty$12(O, P, Attributes);\n} : $defineProperty$12 : function defineProperty22(O, P, Attributes) {\n  anObject$c(O);\n  P = toPropertyKey$22(P);\n  anObject$c(Attributes);\n  if (IE8_DOM_DEFINE2)\n    try {\n      return $defineProperty$12(O, P, Attributes);\n    } catch (error) {\n    }\n  if (\"get\" in Attributes || \"set\" in Attributes)\n    throw TypeError$d2(\"Accessors not supported\");\n  if (\"value\" in Attributes)\n    O[P] = Attributes.value;\n  return O;\n};\nvar DESCRIPTORS$d2 = descriptors2;\nvar definePropertyModule$42 = objectDefineProperty2;\nvar createPropertyDescriptor$32 = createPropertyDescriptor$52;\nvar createNonEnumerableProperty$62 = DESCRIPTORS$d2 ? function(object2, key, value) {\n  return definePropertyModule$42.f(object2, key, createPropertyDescriptor$32(1, value));\n} : function(object2, key, value) {\n  object2[key] = value;\n  return object2;\n};\nvar global$x2 = global$O;\nvar apply$52 = functionApply2;\nvar uncurryThis$p2 = functionUncurryThis2;\nvar isCallable$a2 = isCallable$h2;\nvar getOwnPropertyDescriptor$7 = objectGetOwnPropertyDescriptor2.f;\nvar isForced2 = isForced_12;\nvar path$w = path$y;\nvar bind$a2 = functionBindContext2;\nvar createNonEnumerableProperty$52 = createNonEnumerableProperty$62;\nvar hasOwn$d2 = hasOwnProperty_12;\nvar wrapConstructor2 = function(NativeConstructor) {\n  var Wrapper = function(a, b, c22) {\n    if (this instanceof Wrapper) {\n      switch (arguments.length) {\n        case 0:\n          return new NativeConstructor();\n        case 1:\n          return new NativeConstructor(a);\n        case 2:\n          return new NativeConstructor(a, b);\n      }\n      return new NativeConstructor(a, b, c22);\n    }\n    return apply$52(NativeConstructor, this, arguments);\n  };\n  Wrapper.prototype = NativeConstructor.prototype;\n  return Wrapper;\n};\nvar _export2 = function(options2, source) {\n  var TARGET = options2.target;\n  var GLOBAL = options2.global;\n  var STATIC = options2.stat;\n  var PROTO = options2.proto;\n  var nativeSource = GLOBAL ? global$x2 : STATIC ? global$x2[TARGET] : (global$x2[TARGET] || {}).prototype;\n  var target = GLOBAL ? path$w : path$w[TARGET] || createNonEnumerableProperty$52(path$w, TARGET, {})[TARGET];\n  var targetPrototype = target.prototype;\n  var FORCED22, USE_NATIVE, VIRTUAL_PROTOTYPE;\n  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;\n  for (key in source) {\n    FORCED22 = isForced2(GLOBAL ? key : TARGET + (STATIC ? \".\" : \"#\") + key, options2.forced);\n    USE_NATIVE = !FORCED22 && nativeSource && hasOwn$d2(nativeSource, key);\n    targetProperty = target[key];\n    if (USE_NATIVE)\n      if (options2.noTargetGet) {\n        descriptor = getOwnPropertyDescriptor$7(nativeSource, key);\n        nativeProperty = descriptor && descriptor.value;\n      } else\n        nativeProperty = nativeSource[key];\n    sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];\n    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty)\n      continue;\n    if (options2.bind && USE_NATIVE)\n      resultProperty = bind$a2(sourceProperty, global$x2);\n    else if (options2.wrap && USE_NATIVE)\n      resultProperty = wrapConstructor2(sourceProperty);\n    else if (PROTO && isCallable$a2(sourceProperty))\n      resultProperty = uncurryThis$p2(sourceProperty);\n    else\n      resultProperty = sourceProperty;\n    if (options2.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {\n      createNonEnumerableProperty$52(resultProperty, \"sham\", true);\n    }\n    createNonEnumerableProperty$52(target, key, resultProperty);\n    if (PROTO) {\n      VIRTUAL_PROTOTYPE = TARGET + \"Prototype\";\n      if (!hasOwn$d2(path$w, VIRTUAL_PROTOTYPE)) {\n        createNonEnumerableProperty$52(path$w, VIRTUAL_PROTOTYPE, {});\n      }\n      createNonEnumerableProperty$52(path$w[VIRTUAL_PROTOTYPE], key, sourceProperty);\n      if (options2.real && targetPrototype && !targetPrototype[key]) {\n        createNonEnumerableProperty$52(targetPrototype, key, sourceProperty);\n      }\n    }\n  }\n};\nvar ceil2 = Math.ceil;\nvar floor$12 = Math.floor;\nvar toIntegerOrInfinity$42 = function(argument) {\n  var number22 = +argument;\n  return number22 !== number22 || number22 === 0 ? 0 : (number22 > 0 ? floor$12 : ceil2)(number22);\n};\nvar toIntegerOrInfinity$32 = toIntegerOrInfinity$42;\nvar max$32 = Math.max;\nvar min$22 = Math.min;\nvar toAbsoluteIndex$52 = function(index2, length2) {\n  var integer = toIntegerOrInfinity$32(index2);\n  return integer < 0 ? max$32(integer + length2, 0) : min$22(integer, length2);\n};\nvar toIntegerOrInfinity$22 = toIntegerOrInfinity$42;\nvar min$12 = Math.min;\nvar toLength$12 = function(argument) {\n  return argument > 0 ? min$12(toIntegerOrInfinity$22(argument), 9007199254740991) : 0;\n};\nvar toLength2 = toLength$12;\nvar lengthOfArrayLike$b2 = function(obj) {\n  return toLength2(obj.length);\n};\nvar toIndexedObject$92 = toIndexedObject$b2;\nvar toAbsoluteIndex$42 = toAbsoluteIndex$52;\nvar lengthOfArrayLike$a2 = lengthOfArrayLike$b2;\nvar createMethod$52 = function(IS_INCLUDES) {\n  return function($this, el, fromIndex) {\n    var O = toIndexedObject$92($this);\n    var length2 = lengthOfArrayLike$a2(O);\n    var index2 = toAbsoluteIndex$42(fromIndex, length2);\n    var value;\n    if (IS_INCLUDES && el != el)\n      while (length2 > index2) {\n        value = O[index2++];\n        if (value != value)\n          return true;\n      }\n    else\n      for (; length2 > index2; index2++) {\n        if ((IS_INCLUDES || index2 in O) && O[index2] === el)\n          return IS_INCLUDES || index2 || 0;\n      }\n    return !IS_INCLUDES && -1;\n  };\n};\nvar arrayIncludes2 = {\n  includes: createMethod$52(true),\n  indexOf: createMethod$52(false)\n};\nvar hiddenKeys$62 = {};\nvar uncurryThis$o2 = functionUncurryThis2;\nvar hasOwn$c2 = hasOwnProperty_12;\nvar toIndexedObject$82 = toIndexedObject$b2;\nvar indexOf$4 = arrayIncludes2.indexOf;\nvar hiddenKeys$52 = hiddenKeys$62;\nvar push$52 = uncurryThis$o2([].push);\nvar objectKeysInternal2 = function(object2, names) {\n  var O = toIndexedObject$82(object2);\n  var i = 0;\n  var result2 = [];\n  var key;\n  for (key in O)\n    !hasOwn$c2(hiddenKeys$52, key) && hasOwn$c2(O, key) && push$52(result2, key);\n  while (names.length > i)\n    if (hasOwn$c2(O, key = names[i++])) {\n      ~indexOf$4(result2, key) || push$52(result2, key);\n    }\n  return result2;\n};\nvar enumBugKeys$32 = [\"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"toLocaleString\", \"toString\", \"valueOf\"];\nvar internalObjectKeys$12 = objectKeysInternal2;\nvar enumBugKeys$22 = enumBugKeys$32;\nvar objectKeys$42 = Object.keys || function keys4(O) {\n  return internalObjectKeys$12(O, enumBugKeys$22);\n};\nvar objectGetOwnPropertySymbols2 = {};\nobjectGetOwnPropertySymbols2.f = Object.getOwnPropertySymbols;\nvar DESCRIPTORS$c2 = descriptors2;\nvar uncurryThis$n2 = functionUncurryThis2;\nvar call$72 = functionCall2;\nvar fails$l2 = fails$t;\nvar objectKeys$32 = objectKeys$42;\nvar getOwnPropertySymbolsModule$22 = objectGetOwnPropertySymbols2;\nvar propertyIsEnumerableModule$12 = objectPropertyIsEnumerable2;\nvar toObject$b2 = toObject$d2;\nvar IndexedObject$22 = indexedObject2;\nvar $assign2 = Object.assign;\nvar defineProperty$d2 = Object.defineProperty;\nvar concat$62 = uncurryThis$n2([].concat);\nvar objectAssign2 = !$assign2 || fails$l2(function() {\n  if (DESCRIPTORS$c2 && $assign2({\n    b: 1\n  }, $assign2(defineProperty$d2({}, \"a\", {\n    enumerable: true,\n    get: function() {\n      defineProperty$d2(this, \"b\", {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), {\n    b: 2\n  })).b !== 1)\n    return true;\n  var A2 = {};\n  var B3 = {};\n  var symbol22 = Symbol();\n  var alphabet = \"abcdefghijklmnopqrst\";\n  A2[symbol22] = 7;\n  alphabet.split(\"\").forEach(function(chr) {\n    B3[chr] = chr;\n  });\n  return $assign2({}, A2)[symbol22] != 7 || objectKeys$32($assign2({}, B3)).join(\"\") != alphabet;\n}) ? function assign3(target, source) {\n  var T = toObject$b2(target);\n  var argumentsLength = arguments.length;\n  var index2 = 1;\n  var getOwnPropertySymbols42 = getOwnPropertySymbolsModule$22.f;\n  var propertyIsEnumerable42 = propertyIsEnumerableModule$12.f;\n  while (argumentsLength > index2) {\n    var S2 = IndexedObject$22(arguments[index2++]);\n    var keys42 = getOwnPropertySymbols42 ? concat$62(objectKeys$32(S2), getOwnPropertySymbols42(S2)) : objectKeys$32(S2);\n    var length2 = keys42.length;\n    var j = 0;\n    var key;\n    while (length2 > j) {\n      key = keys42[j++];\n      if (!DESCRIPTORS$c2 || call$72(propertyIsEnumerable42, S2, key))\n        T[key] = S2[key];\n    }\n  }\n  return T;\n} : $assign2;\nvar $$I = _export2;\nvar assign$52 = objectAssign2;\n$$I({\n  target: \"Object\",\n  stat: true,\n  forced: Object.assign !== assign$52\n}, {\n  assign: assign$52\n});\nvar path$v = path$y;\nvar assign$42 = path$v.Object.assign;\nvar parent$13 = assign$42;\nvar assign$32 = parent$13;\nvar assign$22 = assign$32;\nvar uncurryThis$m2 = functionUncurryThis2;\nvar arraySlice$52 = uncurryThis$m2([].slice);\nvar global$w2 = global$O;\nvar uncurryThis$l2 = functionUncurryThis2;\nvar aCallable$32 = aCallable$62;\nvar isObject$e2 = isObject$j;\nvar hasOwn$b2 = hasOwnProperty_12;\nvar arraySlice$42 = arraySlice$52;\nvar NATIVE_BIND2 = functionBindNative2;\nvar Function$22 = global$w2.Function;\nvar concat$52 = uncurryThis$l2([].concat);\nvar join2 = uncurryThis$l2([].join);\nvar factories2 = {};\nvar construct$42 = function(C3, argsLength, args) {\n  if (!hasOwn$b2(factories2, argsLength)) {\n    for (var list2 = [], i = 0; i < argsLength; i++)\n      list2[i] = \"a[\" + i + \"]\";\n    factories2[argsLength] = Function$22(\"C,a\", \"return new C(\" + join2(list2, \",\") + \")\");\n  }\n  return factories2[argsLength](C3, args);\n};\nvar functionBind2 = NATIVE_BIND2 ? Function$22.bind : function bind3(that) {\n  var F2 = aCallable$32(this);\n  var Prototype = F2.prototype;\n  var partArgs = arraySlice$42(arguments, 1);\n  var boundFunction = function bound() {\n    var args = concat$52(partArgs, arraySlice$42(arguments));\n    return this instanceof boundFunction ? construct$42(F2, args.length, args) : F2.apply(that, args);\n  };\n  if (isObject$e2(Prototype))\n    boundFunction.prototype = Prototype;\n  return boundFunction;\n};\nvar $$H = _export2;\nvar bind$92 = functionBind2;\n$$H({\n  target: \"Function\",\n  proto: true,\n  forced: Function.bind !== bind$92\n}, {\n  bind: bind$92\n});\nvar path$u = path$y;\nvar entryVirtual$i2 = function(CONSTRUCTOR) {\n  return path$u[CONSTRUCTOR + \"Prototype\"];\n};\nvar entryVirtual$h2 = entryVirtual$i2;\nvar bind$82 = entryVirtual$h2(\"Function\").bind;\nvar isPrototypeOf$i2 = objectIsPrototypeOf2;\nvar method$e2 = bind$82;\nvar FunctionPrototype$12 = Function.prototype;\nvar bind$72 = function(it2) {\n  var own = it2.bind;\n  return it2 === FunctionPrototype$12 || isPrototypeOf$i2(FunctionPrototype$12, it2) && own === FunctionPrototype$12.bind ? method$e2 : own;\n};\nvar parent$12 = bind$72;\nvar bind$62 = parent$12;\nvar bind$52 = bind$62;\nfunction drawCircle(ctx, x, y, r) {\n  ctx.beginPath();\n  ctx.arc(x, y, r, 0, 2 * Math.PI, false);\n  ctx.closePath();\n}\nfunction drawSquare(ctx, x, y, r) {\n  ctx.beginPath();\n  ctx.rect(x - r, y - r, r * 2, r * 2);\n  ctx.closePath();\n}\nfunction drawTriangle(ctx, x, y, r) {\n  ctx.beginPath();\n  r *= 1.15;\n  y += 0.275 * r;\n  var s = r * 2;\n  var s2 = s / 2;\n  var ir = Math.sqrt(3) / 6 * s;\n  var h = Math.sqrt(s * s - s2 * s2);\n  ctx.moveTo(x, y - (h - ir));\n  ctx.lineTo(x + s2, y + ir);\n  ctx.lineTo(x - s2, y + ir);\n  ctx.lineTo(x, y - (h - ir));\n  ctx.closePath();\n}\nfunction drawTriangleDown(ctx, x, y, r) {\n  ctx.beginPath();\n  r *= 1.15;\n  y -= 0.275 * r;\n  var s = r * 2;\n  var s2 = s / 2;\n  var ir = Math.sqrt(3) / 6 * s;\n  var h = Math.sqrt(s * s - s2 * s2);\n  ctx.moveTo(x, y + (h - ir));\n  ctx.lineTo(x + s2, y - ir);\n  ctx.lineTo(x - s2, y - ir);\n  ctx.lineTo(x, y + (h - ir));\n  ctx.closePath();\n}\nfunction drawStar(ctx, x, y, r) {\n  ctx.beginPath();\n  r *= 0.82;\n  y += 0.1 * r;\n  for (var n = 0; n < 10; n++) {\n    var radius = n % 2 === 0 ? r * 1.3 : r * 0.5;\n    ctx.lineTo(x + radius * Math.sin(n * 2 * Math.PI / 10), y - radius * Math.cos(n * 2 * Math.PI / 10));\n  }\n  ctx.closePath();\n}\nfunction drawDiamond(ctx, x, y, r) {\n  ctx.beginPath();\n  ctx.lineTo(x, y + r);\n  ctx.lineTo(x + r, y);\n  ctx.lineTo(x, y - r);\n  ctx.lineTo(x - r, y);\n  ctx.closePath();\n}\nfunction drawRoundRect(ctx, x, y, w, h, r) {\n  var r2d = Math.PI / 180;\n  if (w - 2 * r < 0) {\n    r = w / 2;\n  }\n  if (h - 2 * r < 0) {\n    r = h / 2;\n  }\n  ctx.beginPath();\n  ctx.moveTo(x + r, y);\n  ctx.lineTo(x + w - r, y);\n  ctx.arc(x + w - r, y + r, r, r2d * 270, r2d * 360, false);\n  ctx.lineTo(x + w, y + h - r);\n  ctx.arc(x + w - r, y + h - r, r, 0, r2d * 90, false);\n  ctx.lineTo(x + r, y + h);\n  ctx.arc(x + r, y + h - r, r, r2d * 90, r2d * 180, false);\n  ctx.lineTo(x, y + r);\n  ctx.arc(x + r, y + r, r, r2d * 180, r2d * 270, false);\n  ctx.closePath();\n}\nfunction drawEllipse(ctx, x, y, w, h) {\n  var kappa = 0.5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe3 = x + w, ye3 = y + h, xm = x + w / 2, ym = y + h / 2;\n  ctx.beginPath();\n  ctx.moveTo(x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe3, ym - oy, xe3, ym);\n  ctx.bezierCurveTo(xe3, ym + oy, xm + ox, ye3, xm, ye3);\n  ctx.bezierCurveTo(xm - ox, ye3, x, ym + oy, x, ym);\n  ctx.closePath();\n}\nfunction drawDatabase(ctx, x, y, w, h) {\n  var f = 1 / 3;\n  var wEllipse = w;\n  var hEllipse = h * f;\n  var kappa = 0.5522848, ox = wEllipse / 2 * kappa, oy = hEllipse / 2 * kappa, xe3 = x + wEllipse, ye3 = y + hEllipse, xm = x + wEllipse / 2, ym = y + hEllipse / 2, ymb = y + (h - hEllipse / 2), yeb = y + h;\n  ctx.beginPath();\n  ctx.moveTo(xe3, ym);\n  ctx.bezierCurveTo(xe3, ym + oy, xm + ox, ye3, xm, ye3);\n  ctx.bezierCurveTo(xm - ox, ye3, x, ym + oy, x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe3, ym - oy, xe3, ym);\n  ctx.lineTo(xe3, ymb);\n  ctx.bezierCurveTo(xe3, ymb + oy, xm + ox, yeb, xm, yeb);\n  ctx.bezierCurveTo(xm - ox, yeb, x, ymb + oy, x, ymb);\n  ctx.lineTo(x, ym);\n}\nfunction drawDashedLine(ctx, x, y, x2, y2, pattern2) {\n  ctx.beginPath();\n  ctx.moveTo(x, y);\n  var patternLength = pattern2.length;\n  var dx = x2 - x;\n  var dy = y2 - y;\n  var slope = dy / dx;\n  var distRemaining = Math.sqrt(dx * dx + dy * dy);\n  var patternIndex = 0;\n  var draw = true;\n  var xStep = 0;\n  var dashLength = +pattern2[0];\n  while (distRemaining >= 0.1) {\n    dashLength = +pattern2[patternIndex++ % patternLength];\n    if (dashLength > distRemaining) {\n      dashLength = distRemaining;\n    }\n    xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));\n    xStep = dx < 0 ? -xStep : xStep;\n    x += xStep;\n    y += slope * xStep;\n    if (draw === true) {\n      ctx.lineTo(x, y);\n    } else {\n      ctx.moveTo(x, y);\n    }\n    distRemaining -= dashLength;\n    draw = !draw;\n  }\n}\nfunction drawHexagon(ctx, x, y, r) {\n  ctx.beginPath();\n  var sides = 6;\n  var a = Math.PI * 2 / sides;\n  ctx.moveTo(x + r, y);\n  for (var i = 1; i < sides; i++) {\n    ctx.lineTo(x + r * Math.cos(a * i), y + r * Math.sin(a * i));\n  }\n  ctx.closePath();\n}\nvar shapeMap = {\n  circle: drawCircle,\n  dashedLine: drawDashedLine,\n  database: drawDatabase,\n  diamond: drawDiamond,\n  ellipse: drawEllipse,\n  ellipse_vis: drawEllipse,\n  hexagon: drawHexagon,\n  roundRect: drawRoundRect,\n  square: drawSquare,\n  star: drawStar,\n  triangle: drawTriangle,\n  triangleDown: drawTriangleDown\n};\nfunction getShape(name2) {\n  if (Object.prototype.hasOwnProperty.call(shapeMap, name2)) {\n    return shapeMap[name2];\n  } else {\n    return function(ctx) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      CanvasRenderingContext2D.prototype[name2].call(ctx, args);\n    };\n  }\n}\nvar componentEmitter2 = { exports: {} };\n(function(module) {\n  {\n    module.exports = Emitter22;\n  }\n  function Emitter22(obj) {\n    if (obj)\n      return mixin(obj);\n  }\n  function mixin(obj) {\n    for (var key in Emitter22.prototype) {\n      obj[key] = Emitter22.prototype[key];\n    }\n    return obj;\n  }\n  Emitter22.prototype.on = Emitter22.prototype.addEventListener = function(event, fn) {\n    this._callbacks = this._callbacks || {};\n    (this._callbacks[\"$\" + event] = this._callbacks[\"$\" + event] || []).push(fn);\n    return this;\n  };\n  Emitter22.prototype.once = function(event, fn) {\n    function on() {\n      this.off(event, on);\n      fn.apply(this, arguments);\n    }\n    on.fn = fn;\n    this.on(event, on);\n    return this;\n  };\n  Emitter22.prototype.off = Emitter22.prototype.removeListener = Emitter22.prototype.removeAllListeners = Emitter22.prototype.removeEventListener = function(event, fn) {\n    this._callbacks = this._callbacks || {};\n    if (arguments.length == 0) {\n      this._callbacks = {};\n      return this;\n    }\n    var callbacks = this._callbacks[\"$\" + event];\n    if (!callbacks)\n      return this;\n    if (arguments.length == 1) {\n      delete this._callbacks[\"$\" + event];\n      return this;\n    }\n    var cb;\n    for (var i = 0; i < callbacks.length; i++) {\n      cb = callbacks[i];\n      if (cb === fn || cb.fn === fn) {\n        callbacks.splice(i, 1);\n        break;\n      }\n    }\n    if (callbacks.length === 0) {\n      delete this._callbacks[\"$\" + event];\n    }\n    return this;\n  };\n  Emitter22.prototype.emit = function(event) {\n    this._callbacks = this._callbacks || {};\n    var args = new Array(arguments.length - 1), callbacks = this._callbacks[\"$\" + event];\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n    if (callbacks) {\n      callbacks = callbacks.slice(0);\n      for (var i = 0, len = callbacks.length; i < len; ++i) {\n        callbacks[i].apply(this, args);\n      }\n    }\n    return this;\n  };\n  Emitter22.prototype.listeners = function(event) {\n    this._callbacks = this._callbacks || {};\n    return this._callbacks[\"$\" + event] || [];\n  };\n  Emitter22.prototype.hasListeners = function(event) {\n    return !!this.listeners(event).length;\n  };\n})(componentEmitter2);\nvar Emitter2 = componentEmitter2.exports;\nvar wellKnownSymbol$h2 = wellKnownSymbol$j2;\nvar TO_STRING_TAG$32 = wellKnownSymbol$h2(\"toStringTag\");\nvar test$22 = {};\ntest$22[TO_STRING_TAG$32] = \"z\";\nvar toStringTagSupport2 = String(test$22) === \"[object z]\";\nvar global$v2 = global$O;\nvar TO_STRING_TAG_SUPPORT$22 = toStringTagSupport2;\nvar isCallable$92 = isCallable$h2;\nvar classofRaw2 = classofRaw$12;\nvar wellKnownSymbol$g2 = wellKnownSymbol$j2;\nvar TO_STRING_TAG$22 = wellKnownSymbol$g2(\"toStringTag\");\nvar Object$72 = global$v2.Object;\nvar CORRECT_ARGUMENTS2 = classofRaw2(function() {\n  return arguments;\n}()) == \"Arguments\";\nvar tryGet2 = function(it2, key) {\n  try {\n    return it2[key];\n  } catch (error) {\n  }\n};\nvar classof$c2 = TO_STRING_TAG_SUPPORT$22 ? classofRaw2 : function(it2) {\n  var O, tag, result2;\n  return it2 === void 0 ? \"Undefined\" : it2 === null ? \"Null\" : typeof (tag = tryGet2(O = Object$72(it2), TO_STRING_TAG$22)) == \"string\" ? tag : CORRECT_ARGUMENTS2 ? classofRaw2(O) : (result2 = classofRaw2(O)) == \"Object\" && isCallable$92(O.callee) ? \"Arguments\" : result2;\n};\nvar global$u2 = global$O;\nvar classof$b2 = classof$c2;\nvar String$22 = global$u2.String;\nvar toString$82 = function(argument) {\n  if (classof$b2(argument) === \"Symbol\")\n    throw TypeError(\"Cannot convert a Symbol value to a string\");\n  return String$22(argument);\n};\nvar uncurryThis$k2 = functionUncurryThis2;\nvar toIntegerOrInfinity$12 = toIntegerOrInfinity$42;\nvar toString$72 = toString$82;\nvar requireObjectCoercible$22 = requireObjectCoercible$52;\nvar charAt$3 = uncurryThis$k2(\"\".charAt);\nvar charCodeAt$12 = uncurryThis$k2(\"\".charCodeAt);\nvar stringSlice2 = uncurryThis$k2(\"\".slice);\nvar createMethod$42 = function(CONVERT_TO_STRING) {\n  return function($this, pos) {\n    var S2 = toString$72(requireObjectCoercible$22($this));\n    var position = toIntegerOrInfinity$12(pos);\n    var size = S2.length;\n    var first2, second;\n    if (position < 0 || position >= size)\n      return CONVERT_TO_STRING ? \"\" : void 0;\n    first2 = charCodeAt$12(S2, position);\n    return first2 < 55296 || first2 > 56319 || position + 1 === size || (second = charCodeAt$12(S2, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt$3(S2, position) : first2 : CONVERT_TO_STRING ? stringSlice2(S2, position, position + 2) : (first2 - 55296 << 10) + (second - 56320) + 65536;\n  };\n};\nvar stringMultibyte2 = {\n  codeAt: createMethod$42(false),\n  charAt: createMethod$42(true)\n};\nvar uncurryThis$j2 = functionUncurryThis2;\nvar isCallable$82 = isCallable$h2;\nvar store$12 = sharedStore2;\nvar functionToString2 = uncurryThis$j2(Function.toString);\nif (!isCallable$82(store$12.inspectSource)) {\n  store$12.inspectSource = function(it2) {\n    return functionToString2(it2);\n  };\n}\nvar inspectSource$22 = store$12.inspectSource;\nvar global$t2 = global$O;\nvar isCallable$72 = isCallable$h2;\nvar inspectSource$12 = inspectSource$22;\nvar WeakMap$12 = global$t2.WeakMap;\nvar nativeWeakMap2 = isCallable$72(WeakMap$12) && /native code/.test(inspectSource$12(WeakMap$12));\nvar shared$22 = shared$42.exports;\nvar uid$22 = uid$42;\nvar keys$32 = shared$22(\"keys\");\nvar sharedKey$42 = function(key) {\n  return keys$32[key] || (keys$32[key] = uid$22(key));\n};\nvar NATIVE_WEAK_MAP$1 = nativeWeakMap2;\nvar global$s2 = global$O;\nvar uncurryThis$i2 = functionUncurryThis2;\nvar isObject$d2 = isObject$j;\nvar createNonEnumerableProperty$42 = createNonEnumerableProperty$62;\nvar hasOwn$a2 = hasOwnProperty_12;\nvar shared$12 = sharedStore2;\nvar sharedKey$32 = sharedKey$42;\nvar hiddenKeys$42 = hiddenKeys$62;\nvar OBJECT_ALREADY_INITIALIZED2 = \"Object already initialized\";\nvar TypeError$c2 = global$s2.TypeError;\nvar WeakMap3 = global$s2.WeakMap;\nvar set$32;\nvar get$6;\nvar has2;\nvar enforce2 = function(it2) {\n  return has2(it2) ? get$6(it2) : set$32(it2, {});\n};\nvar getterFor2 = function(TYPE) {\n  return function(it2) {\n    var state;\n    if (!isObject$d2(it2) || (state = get$6(it2)).type !== TYPE) {\n      throw TypeError$c2(\"Incompatible receiver, \" + TYPE + \" required\");\n    }\n    return state;\n  };\n};\nif (NATIVE_WEAK_MAP$1 || shared$12.state) {\n  store = shared$12.state || (shared$12.state = new WeakMap3());\n  wmget = uncurryThis$i2(store.get);\n  wmhas = uncurryThis$i2(store.has);\n  wmset = uncurryThis$i2(store.set);\n  set$32 = function(it2, metadata) {\n    if (wmhas(store, it2))\n      throw new TypeError$c2(OBJECT_ALREADY_INITIALIZED2);\n    metadata.facade = it2;\n    wmset(store, it2, metadata);\n    return metadata;\n  };\n  get$6 = function(it2) {\n    return wmget(store, it2) || {};\n  };\n  has2 = function(it2) {\n    return wmhas(store, it2);\n  };\n} else {\n  STATE = sharedKey$32(\"state\");\n  hiddenKeys$42[STATE] = true;\n  set$32 = function(it2, metadata) {\n    if (hasOwn$a2(it2, STATE))\n      throw new TypeError$c2(OBJECT_ALREADY_INITIALIZED2);\n    metadata.facade = it2;\n    createNonEnumerableProperty$42(it2, STATE, metadata);\n    return metadata;\n  };\n  get$6 = function(it2) {\n    return hasOwn$a2(it2, STATE) ? it2[STATE] : {};\n  };\n  has2 = function(it2) {\n    return hasOwn$a2(it2, STATE);\n  };\n}\nvar store;\nvar wmget;\nvar wmhas;\nvar wmset;\nvar STATE;\nvar internalState2 = {\n  set: set$32,\n  get: get$6,\n  has: has2,\n  enforce: enforce2,\n  getterFor: getterFor2\n};\nvar DESCRIPTORS$b2 = descriptors2;\nvar hasOwn$92 = hasOwnProperty_12;\nvar FunctionPrototype2 = Function.prototype;\nvar getDescriptor2 = DESCRIPTORS$b2 && Object.getOwnPropertyDescriptor;\nvar EXISTS2 = hasOwn$92(FunctionPrototype2, \"name\");\nvar PROPER2 = EXISTS2 && function something2() {\n}.name === \"something\";\nvar CONFIGURABLE2 = EXISTS2 && (!DESCRIPTORS$b2 || DESCRIPTORS$b2 && getDescriptor2(FunctionPrototype2, \"name\").configurable);\nvar functionName2 = {\n  EXISTS: EXISTS2,\n  PROPER: PROPER2,\n  CONFIGURABLE: CONFIGURABLE2\n};\nvar objectDefineProperties2 = {};\nvar DESCRIPTORS$a2 = descriptors2;\nvar V8_PROTOTYPE_DEFINE_BUG2 = v8PrototypeDefineBug2;\nvar definePropertyModule$32 = objectDefineProperty2;\nvar anObject$b2 = anObject$d;\nvar toIndexedObject$72 = toIndexedObject$b2;\nvar objectKeys$22 = objectKeys$42;\nobjectDefineProperties2.f = DESCRIPTORS$a2 && !V8_PROTOTYPE_DEFINE_BUG2 ? Object.defineProperties : function defineProperties5(O, Properties) {\n  anObject$b2(O);\n  var props = toIndexedObject$72(Properties);\n  var keys42 = objectKeys$22(Properties);\n  var length2 = keys42.length;\n  var index2 = 0;\n  var key;\n  while (length2 > index2)\n    definePropertyModule$32.f(O, key = keys42[index2++], props[key]);\n  return O;\n};\nvar getBuiltIn$62 = getBuiltIn$92;\nvar html$12 = getBuiltIn$62(\"document\", \"documentElement\");\nvar anObject$a2 = anObject$d;\nvar definePropertiesModule$12 = objectDefineProperties2;\nvar enumBugKeys$12 = enumBugKeys$32;\nvar hiddenKeys$32 = hiddenKeys$62;\nvar html2 = html$12;\nvar documentCreateElement2 = documentCreateElement$12;\nvar sharedKey$22 = sharedKey$42;\nvar GT2 = \">\";\nvar LT2 = \"<\";\nvar PROTOTYPE$12 = \"prototype\";\nvar SCRIPT2 = \"script\";\nvar IE_PROTO$12 = sharedKey$22(\"IE_PROTO\");\nvar EmptyConstructor2 = function() {\n};\nvar scriptTag2 = function(content) {\n  return LT2 + SCRIPT2 + GT2 + content + LT2 + \"/\" + SCRIPT2 + GT2;\n};\nvar NullProtoObjectViaActiveX2 = function(activeXDocument22) {\n  activeXDocument22.write(scriptTag2(\"\"));\n  activeXDocument22.close();\n  var temp = activeXDocument22.parentWindow.Object;\n  activeXDocument22 = null;\n  return temp;\n};\nvar NullProtoObjectViaIFrame2 = function() {\n  var iframe = documentCreateElement2(\"iframe\");\n  var JS = \"java\" + SCRIPT2 + \":\";\n  var iframeDocument;\n  iframe.style.display = \"none\";\n  html2.appendChild(iframe);\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag2(\"document.F=Object\"));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\nvar activeXDocument2;\nvar NullProtoObject2 = function() {\n  try {\n    activeXDocument2 = new ActiveXObject(\"htmlfile\");\n  } catch (error) {\n  }\n  NullProtoObject2 = typeof document != \"undefined\" ? document.domain && activeXDocument2 ? NullProtoObjectViaActiveX2(activeXDocument2) : NullProtoObjectViaIFrame2() : NullProtoObjectViaActiveX2(activeXDocument2);\n  var length2 = enumBugKeys$12.length;\n  while (length2--)\n    delete NullProtoObject2[PROTOTYPE$12][enumBugKeys$12[length2]];\n  return NullProtoObject2();\n};\nhiddenKeys$32[IE_PROTO$12] = true;\nvar objectCreate2 = Object.create || function create5(O, Properties) {\n  var result2;\n  if (O !== null) {\n    EmptyConstructor2[PROTOTYPE$12] = anObject$a2(O);\n    result2 = new EmptyConstructor2();\n    EmptyConstructor2[PROTOTYPE$12] = null;\n    result2[IE_PROTO$12] = O;\n  } else\n    result2 = NullProtoObject2();\n  return Properties === void 0 ? result2 : definePropertiesModule$12.f(result2, Properties);\n};\nvar fails$k2 = fails$t;\nvar correctPrototypeGetter2 = !fails$k2(function() {\n  function F2() {\n  }\n  F2.prototype.constructor = null;\n  return Object.getPrototypeOf(new F2()) !== F2.prototype;\n});\nvar global$r2 = global$O;\nvar hasOwn$82 = hasOwnProperty_12;\nvar isCallable$62 = isCallable$h2;\nvar toObject$a2 = toObject$d2;\nvar sharedKey$12 = sharedKey$42;\nvar CORRECT_PROTOTYPE_GETTER$12 = correctPrototypeGetter2;\nvar IE_PROTO2 = sharedKey$12(\"IE_PROTO\");\nvar Object$62 = global$r2.Object;\nvar ObjectPrototype$22 = Object$62.prototype;\nvar objectGetPrototypeOf2 = CORRECT_PROTOTYPE_GETTER$12 ? Object$62.getPrototypeOf : function(O) {\n  var object2 = toObject$a2(O);\n  if (hasOwn$82(object2, IE_PROTO2))\n    return object2[IE_PROTO2];\n  var constructor = object2.constructor;\n  if (isCallable$62(constructor) && object2 instanceof constructor) {\n    return constructor.prototype;\n  }\n  return object2 instanceof Object$62 ? ObjectPrototype$22 : null;\n};\nvar createNonEnumerableProperty$32 = createNonEnumerableProperty$62;\nvar redefine$42 = function(target, key, value, options2) {\n  if (options2 && options2.enumerable)\n    target[key] = value;\n  else\n    createNonEnumerableProperty$32(target, key, value);\n};\nvar fails$j2 = fails$t;\nvar isCallable$52 = isCallable$h2;\nvar create$a2 = objectCreate2;\nvar getPrototypeOf$8 = objectGetPrototypeOf2;\nvar redefine$32 = redefine$42;\nvar wellKnownSymbol$f2 = wellKnownSymbol$j2;\nvar ITERATOR$6 = wellKnownSymbol$f2(\"iterator\");\nvar BUGGY_SAFARI_ITERATORS$12 = false;\nvar IteratorPrototype$12;\nvar PrototypeOfArrayIteratorPrototype2;\nvar arrayIterator2;\nif ([].keys) {\n  arrayIterator2 = [].keys();\n  if (!(\"next\" in arrayIterator2))\n    BUGGY_SAFARI_ITERATORS$12 = true;\n  else {\n    PrototypeOfArrayIteratorPrototype2 = getPrototypeOf$8(getPrototypeOf$8(arrayIterator2));\n    if (PrototypeOfArrayIteratorPrototype2 !== Object.prototype)\n      IteratorPrototype$12 = PrototypeOfArrayIteratorPrototype2;\n  }\n}\nvar NEW_ITERATOR_PROTOTYPE2 = IteratorPrototype$12 == void 0 || fails$j2(function() {\n  var test22 = {};\n  return IteratorPrototype$12[ITERATOR$6].call(test22) !== test22;\n});\nif (NEW_ITERATOR_PROTOTYPE2)\n  IteratorPrototype$12 = {};\nelse\n  IteratorPrototype$12 = create$a2(IteratorPrototype$12);\nif (!isCallable$52(IteratorPrototype$12[ITERATOR$6])) {\n  redefine$32(IteratorPrototype$12, ITERATOR$6, function() {\n    return this;\n  });\n}\nvar iteratorsCore2 = {\n  IteratorPrototype: IteratorPrototype$12,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$12\n};\nvar TO_STRING_TAG_SUPPORT$12 = toStringTagSupport2;\nvar classof$a2 = classof$c2;\nvar objectToString2 = TO_STRING_TAG_SUPPORT$12 ? {}.toString : function toString3() {\n  return \"[object \" + classof$a2(this) + \"]\";\n};\nvar TO_STRING_TAG_SUPPORT2 = toStringTagSupport2;\nvar defineProperty$c2 = objectDefineProperty2.f;\nvar createNonEnumerableProperty$22 = createNonEnumerableProperty$62;\nvar hasOwn$72 = hasOwnProperty_12;\nvar toString$62 = objectToString2;\nvar wellKnownSymbol$e2 = wellKnownSymbol$j2;\nvar TO_STRING_TAG$12 = wellKnownSymbol$e2(\"toStringTag\");\nvar setToStringTag$52 = function(it2, TAG, STATIC, SET_METHOD) {\n  if (it2) {\n    var target = STATIC ? it2 : it2.prototype;\n    if (!hasOwn$72(target, TO_STRING_TAG$12)) {\n      defineProperty$c2(target, TO_STRING_TAG$12, {\n        configurable: true,\n        value: TAG\n      });\n    }\n    if (SET_METHOD && !TO_STRING_TAG_SUPPORT2) {\n      createNonEnumerableProperty$22(target, \"toString\", toString$62);\n    }\n  }\n};\nvar iterators2 = {};\nvar IteratorPrototype2 = iteratorsCore2.IteratorPrototype;\nvar create$92 = objectCreate2;\nvar createPropertyDescriptor$22 = createPropertyDescriptor$52;\nvar setToStringTag$42 = setToStringTag$52;\nvar Iterators$52 = iterators2;\nvar returnThis$12 = function() {\n  return this;\n};\nvar createIteratorConstructor$12 = function(IteratorConstructor, NAME, next3, ENUMERABLE_NEXT) {\n  var TO_STRING_TAG22 = NAME + \" Iterator\";\n  IteratorConstructor.prototype = create$92(IteratorPrototype2, {\n    next: createPropertyDescriptor$22(+!ENUMERABLE_NEXT, next3)\n  });\n  setToStringTag$42(IteratorConstructor, TO_STRING_TAG22, false, true);\n  Iterators$52[TO_STRING_TAG22] = returnThis$12;\n  return IteratorConstructor;\n};\nvar global$q2 = global$O;\nvar isCallable$42 = isCallable$h2;\nvar String$12 = global$q2.String;\nvar TypeError$b2 = global$q2.TypeError;\nvar aPossiblePrototype$12 = function(argument) {\n  if (typeof argument == \"object\" || isCallable$42(argument))\n    return argument;\n  throw TypeError$b2(\"Can't set \" + String$12(argument) + \" as a prototype\");\n};\nvar uncurryThis$h2 = functionUncurryThis2;\nvar anObject$92 = anObject$d;\nvar aPossiblePrototype2 = aPossiblePrototype$12;\nvar objectSetPrototypeOf2 = Object.setPrototypeOf || (\"__proto__\" in {} ? function() {\n  var CORRECT_SETTER = false;\n  var test22 = {};\n  var setter;\n  try {\n    setter = uncurryThis$h2(Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\").set);\n    setter(test22, []);\n    CORRECT_SETTER = test22 instanceof Array;\n  } catch (error) {\n  }\n  return function setPrototypeOf22(O, proto) {\n    anObject$92(O);\n    aPossiblePrototype2(proto);\n    if (CORRECT_SETTER)\n      setter(O, proto);\n    else\n      O.__proto__ = proto;\n    return O;\n  };\n}() : void 0);\nvar $$G = _export2;\nvar call$62 = functionCall2;\nvar FunctionName2 = functionName2;\nvar createIteratorConstructor2 = createIteratorConstructor$12;\nvar getPrototypeOf$7 = objectGetPrototypeOf2;\nvar setToStringTag$32 = setToStringTag$52;\nvar redefine$22 = redefine$42;\nvar wellKnownSymbol$d2 = wellKnownSymbol$j2;\nvar Iterators$42 = iterators2;\nvar IteratorsCore2 = iteratorsCore2;\nvar PROPER_FUNCTION_NAME$12 = FunctionName2.PROPER;\nvar BUGGY_SAFARI_ITERATORS2 = IteratorsCore2.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$52 = wellKnownSymbol$d2(\"iterator\");\nvar KEYS2 = \"keys\";\nvar VALUES2 = \"values\";\nvar ENTRIES2 = \"entries\";\nvar returnThis2 = function() {\n  return this;\n};\nvar defineIterator$32 = function(Iterable, NAME, IteratorConstructor, next3, DEFAULT, IS_SET, FORCED22) {\n  createIteratorConstructor2(IteratorConstructor, NAME, next3);\n  var getIterationMethod = function(KIND) {\n    if (KIND === DEFAULT && defaultIterator)\n      return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS2 && KIND in IterablePrototype)\n      return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS2:\n        return function keys42() {\n          return new IteratorConstructor(this, KIND);\n        };\n      case VALUES2:\n        return function values32() {\n          return new IteratorConstructor(this, KIND);\n        };\n      case ENTRIES2:\n        return function entries2() {\n          return new IteratorConstructor(this, KIND);\n        };\n    }\n    return function() {\n      return new IteratorConstructor(this);\n    };\n  };\n  var TO_STRING_TAG22 = NAME + \" Iterator\";\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR$52] || IterablePrototype[\"@@iterator\"] || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS2 && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == \"Array\" ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf$7(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      setToStringTag$32(CurrentIteratorPrototype, TO_STRING_TAG22, true, true);\n      Iterators$42[TO_STRING_TAG22] = returnThis2;\n    }\n  }\n  if (PROPER_FUNCTION_NAME$12 && DEFAULT == VALUES2 && nativeIterator && nativeIterator.name !== VALUES2) {\n    {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values32() {\n        return call$62(nativeIterator, this);\n      };\n    }\n  }\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES2),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS2),\n      entries: getIterationMethod(ENTRIES2)\n    };\n    if (FORCED22)\n      for (KEY in methods) {\n        if (BUGGY_SAFARI_ITERATORS2 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n          redefine$22(IterablePrototype, KEY, methods[KEY]);\n        }\n      }\n    else\n      $$G({\n        target: NAME,\n        proto: true,\n        forced: BUGGY_SAFARI_ITERATORS2 || INCORRECT_VALUES_NAME\n      }, methods);\n  }\n  if (FORCED22 && IterablePrototype[ITERATOR$52] !== defaultIterator) {\n    redefine$22(IterablePrototype, ITERATOR$52, defaultIterator, {\n      name: DEFAULT\n    });\n  }\n  Iterators$42[NAME] = defaultIterator;\n  return methods;\n};\nvar charAt$22 = stringMultibyte2.charAt;\nvar toString$52 = toString$82;\nvar InternalStateModule$5 = internalState2;\nvar defineIterator$22 = defineIterator$32;\nvar STRING_ITERATOR2 = \"String Iterator\";\nvar setInternalState$5 = InternalStateModule$5.set;\nvar getInternalState$22 = InternalStateModule$5.getterFor(STRING_ITERATOR2);\ndefineIterator$22(String, \"String\", function(iterated) {\n  setInternalState$5(this, {\n    type: STRING_ITERATOR2,\n    string: toString$52(iterated),\n    index: 0\n  });\n}, function next2() {\n  var state = getInternalState$22(this);\n  var string22 = state.string;\n  var index2 = state.index;\n  var point;\n  if (index2 >= string22.length)\n    return {\n      value: void 0,\n      done: true\n    };\n  point = charAt$22(string22, index2);\n  state.index += point.length;\n  return {\n    value: point,\n    done: false\n  };\n});\nvar call$52 = functionCall2;\nvar anObject$82 = anObject$d;\nvar getMethod$12 = getMethod$32;\nvar iteratorClose$22 = function(iterator22, kind, value) {\n  var innerResult, innerError;\n  anObject$82(iterator22);\n  try {\n    innerResult = getMethod$12(iterator22, \"return\");\n    if (!innerResult) {\n      if (kind === \"throw\")\n        throw value;\n      return value;\n    }\n    innerResult = call$52(innerResult, iterator22);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === \"throw\")\n    throw value;\n  if (innerError)\n    throw innerResult;\n  anObject$82(innerResult);\n  return value;\n};\nvar anObject$72 = anObject$d;\nvar iteratorClose$12 = iteratorClose$22;\nvar callWithSafeIterationClosing$12 = function(iterator22, fn, value, ENTRIES22) {\n  try {\n    return ENTRIES22 ? fn(anObject$72(value)[0], value[1]) : fn(value);\n  } catch (error) {\n    iteratorClose$12(iterator22, \"throw\", error);\n  }\n};\nvar wellKnownSymbol$c2 = wellKnownSymbol$j2;\nvar Iterators$32 = iterators2;\nvar ITERATOR$42 = wellKnownSymbol$c2(\"iterator\");\nvar ArrayPrototype$f = Array.prototype;\nvar isArrayIteratorMethod$22 = function(it2) {\n  return it2 !== void 0 && (Iterators$32.Array === it2 || ArrayPrototype$f[ITERATOR$42] === it2);\n};\nvar uncurryThis$g2 = functionUncurryThis2;\nvar fails$i2 = fails$t;\nvar isCallable$32 = isCallable$h2;\nvar classof$92 = classof$c2;\nvar getBuiltIn$52 = getBuiltIn$92;\nvar inspectSource2 = inspectSource$22;\nvar noop2 = function() {\n};\nvar empty2 = [];\nvar construct$32 = getBuiltIn$52(\"Reflect\", \"construct\");\nvar constructorRegExp2 = /^\\s*(?:class|function)\\b/;\nvar exec$22 = uncurryThis$g2(constructorRegExp2.exec);\nvar INCORRECT_TO_STRING2 = !constructorRegExp2.exec(noop2);\nvar isConstructorModern2 = function isConstructor4(argument) {\n  if (!isCallable$32(argument))\n    return false;\n  try {\n    construct$32(noop2, empty2, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\nvar isConstructorLegacy2 = function isConstructor22(argument) {\n  if (!isCallable$32(argument))\n    return false;\n  switch (classof$92(argument)) {\n    case \"AsyncFunction\":\n    case \"GeneratorFunction\":\n    case \"AsyncGeneratorFunction\":\n      return false;\n  }\n  try {\n    return INCORRECT_TO_STRING2 || !!exec$22(constructorRegExp2, inspectSource2(argument));\n  } catch (error) {\n    return true;\n  }\n};\nisConstructorLegacy2.sham = true;\nvar isConstructor$42 = !construct$32 || fails$i2(function() {\n  var called;\n  return isConstructorModern2(isConstructorModern2.call) || !isConstructorModern2(Object) || !isConstructorModern2(function() {\n    called = true;\n  }) || called;\n}) ? isConstructorLegacy2 : isConstructorModern2;\nvar toPropertyKey$12 = toPropertyKey$42;\nvar definePropertyModule$22 = objectDefineProperty2;\nvar createPropertyDescriptor$12 = createPropertyDescriptor$52;\nvar createProperty$62 = function(object2, key, value) {\n  var propertyKey = toPropertyKey$12(key);\n  if (propertyKey in object2)\n    definePropertyModule$22.f(object2, propertyKey, createPropertyDescriptor$12(0, value));\n  else\n    object2[propertyKey] = value;\n};\nvar classof$82 = classof$c2;\nvar getMethod2 = getMethod$32;\nvar Iterators$22 = iterators2;\nvar wellKnownSymbol$b2 = wellKnownSymbol$j2;\nvar ITERATOR$32 = wellKnownSymbol$b2(\"iterator\");\nvar getIteratorMethod$82 = function(it2) {\n  if (it2 != void 0)\n    return getMethod2(it2, ITERATOR$32) || getMethod2(it2, \"@@iterator\") || Iterators$22[classof$82(it2)];\n};\nvar global$p2 = global$O;\nvar call$42 = functionCall2;\nvar aCallable$22 = aCallable$62;\nvar anObject$62 = anObject$d;\nvar tryToString$22 = tryToString$42;\nvar getIteratorMethod$72 = getIteratorMethod$82;\nvar TypeError$a2 = global$p2.TypeError;\nvar getIterator$22 = function(argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$72(argument) : usingIterator;\n  if (aCallable$22(iteratorMethod))\n    return anObject$62(call$42(iteratorMethod, argument));\n  throw TypeError$a2(tryToString$22(argument) + \" is not iterable\");\n};\nvar global$o2 = global$O;\nvar bind$42 = functionBindContext2;\nvar call$32 = functionCall2;\nvar toObject$92 = toObject$d2;\nvar callWithSafeIterationClosing2 = callWithSafeIterationClosing$12;\nvar isArrayIteratorMethod$12 = isArrayIteratorMethod$22;\nvar isConstructor$32 = isConstructor$42;\nvar lengthOfArrayLike$92 = lengthOfArrayLike$b2;\nvar createProperty$52 = createProperty$62;\nvar getIterator$12 = getIterator$22;\nvar getIteratorMethod$62 = getIteratorMethod$82;\nvar Array$52 = global$o2.Array;\nvar arrayFrom2 = function from3(arrayLike) {\n  var O = toObject$92(arrayLike);\n  var IS_CONSTRUCTOR = isConstructor$32(this);\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;\n  var mapping = mapfn !== void 0;\n  if (mapping)\n    mapfn = bind$42(mapfn, argumentsLength > 2 ? arguments[2] : void 0);\n  var iteratorMethod = getIteratorMethod$62(O);\n  var index2 = 0;\n  var length2, result2, step, iterator22, next3, value;\n  if (iteratorMethod && !(this == Array$52 && isArrayIteratorMethod$12(iteratorMethod))) {\n    iterator22 = getIterator$12(O, iteratorMethod);\n    next3 = iterator22.next;\n    result2 = IS_CONSTRUCTOR ? new this() : [];\n    for (; !(step = call$32(next3, iterator22)).done; index2++) {\n      value = mapping ? callWithSafeIterationClosing2(iterator22, mapfn, [step.value, index2], true) : step.value;\n      createProperty$52(result2, index2, value);\n    }\n  } else {\n    length2 = lengthOfArrayLike$92(O);\n    result2 = IS_CONSTRUCTOR ? new this(length2) : Array$52(length2);\n    for (; length2 > index2; index2++) {\n      value = mapping ? mapfn(O[index2], index2) : O[index2];\n      createProperty$52(result2, index2, value);\n    }\n  }\n  result2.length = index2;\n  return result2;\n};\nvar wellKnownSymbol$a2 = wellKnownSymbol$j2;\nvar ITERATOR$22 = wellKnownSymbol$a2(\"iterator\");\nvar SAFE_CLOSING2 = false;\ntry {\n  called = 0;\n  iteratorWithReturn = {\n    next: function() {\n      return {\n        done: !!called++\n      };\n    },\n    return: function() {\n      SAFE_CLOSING2 = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR$22] = function() {\n    return this;\n  };\n  Array.from(iteratorWithReturn, function() {\n    throw 2;\n  });\n} catch (error) {\n}\nvar called;\nvar iteratorWithReturn;\nvar checkCorrectnessOfIteration$12 = function(exec22, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING2)\n    return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object2 = {};\n    object2[ITERATOR$22] = function() {\n      return {\n        next: function() {\n          return {\n            done: ITERATION_SUPPORT = true\n          };\n        }\n      };\n    };\n    exec22(object2);\n  } catch (error) {\n  }\n  return ITERATION_SUPPORT;\n};\nvar $$F = _export2;\nvar from$62 = arrayFrom2;\nvar checkCorrectnessOfIteration2 = checkCorrectnessOfIteration$12;\nvar INCORRECT_ITERATION2 = !checkCorrectnessOfIteration2(function(iterable) {\n  Array.from(iterable);\n});\n$$F({\n  target: \"Array\",\n  stat: true,\n  forced: INCORRECT_ITERATION2\n}, {\n  from: from$62\n});\nvar path$t = path$y;\nvar from$52 = path$t.Array.from;\nvar parent$11 = from$52;\nvar from$42 = parent$11;\nvar from$32 = from$42;\nvar toIndexedObject$62 = toIndexedObject$b2;\nvar Iterators$12 = iterators2;\nvar InternalStateModule$42 = internalState2;\nvar defineIterator$12 = defineIterator$32;\nvar ARRAY_ITERATOR2 = \"Array Iterator\";\nvar setInternalState$42 = InternalStateModule$42.set;\nvar getInternalState$12 = InternalStateModule$42.getterFor(ARRAY_ITERATOR2);\ndefineIterator$12(Array, \"Array\", function(iterated, kind) {\n  setInternalState$42(this, {\n    type: ARRAY_ITERATOR2,\n    target: toIndexedObject$62(iterated),\n    index: 0,\n    kind\n  });\n}, function() {\n  var state = getInternalState$12(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index2 = state.index++;\n  if (!target || index2 >= target.length) {\n    state.target = void 0;\n    return {\n      value: void 0,\n      done: true\n    };\n  }\n  if (kind == \"keys\")\n    return {\n      value: index2,\n      done: false\n    };\n  if (kind == \"values\")\n    return {\n      value: target[index2],\n      done: false\n    };\n  return {\n    value: [index2, target[index2]],\n    done: false\n  };\n}, \"values\");\nIterators$12.Arguments = Iterators$12.Array;\nvar getIteratorMethod$52 = getIteratorMethod$82;\nvar getIteratorMethod_12 = getIteratorMethod$52;\nvar domIterables2 = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\nvar DOMIterables$22 = domIterables2;\nvar global$n2 = global$O;\nvar classof$72 = classof$c2;\nvar createNonEnumerableProperty$12 = createNonEnumerableProperty$62;\nvar Iterators2 = iterators2;\nvar wellKnownSymbol$92 = wellKnownSymbol$j2;\nvar TO_STRING_TAG2 = wellKnownSymbol$92(\"toStringTag\");\nfor (COLLECTION_NAME in DOMIterables$22) {\n  Collection = global$n2[COLLECTION_NAME];\n  CollectionPrototype = Collection && Collection.prototype;\n  if (CollectionPrototype && classof$72(CollectionPrototype) !== TO_STRING_TAG2) {\n    createNonEnumerableProperty$12(CollectionPrototype, TO_STRING_TAG2, COLLECTION_NAME);\n  }\n  Iterators2[COLLECTION_NAME] = Iterators2.Array;\n}\nvar Collection;\nvar CollectionPrototype;\nvar COLLECTION_NAME;\nvar parent$10 = getIteratorMethod_12;\nvar getIteratorMethod$42 = parent$10;\nvar parent$$ = getIteratorMethod$42;\nvar getIteratorMethod$32 = parent$$;\nvar parent$_ = getIteratorMethod$32;\nvar getIteratorMethod$22 = parent$_;\nvar getIteratorMethod$12 = getIteratorMethod$22;\nvar classof$62 = classofRaw$12;\nvar isArray$c2 = Array.isArray || function isArray3(argument) {\n  return classof$62(argument) == \"Array\";\n};\nvar objectGetOwnPropertyNames2 = {};\nvar internalObjectKeys2 = objectKeysInternal2;\nvar enumBugKeys2 = enumBugKeys$32;\nvar hiddenKeys$22 = enumBugKeys2.concat(\"length\", \"prototype\");\nobjectGetOwnPropertyNames2.f = Object.getOwnPropertyNames || function getOwnPropertyNames4(O) {\n  return internalObjectKeys2(O, hiddenKeys$22);\n};\nvar objectGetOwnPropertyNamesExternal2 = {};\nvar global$m2 = global$O;\nvar toAbsoluteIndex$32 = toAbsoluteIndex$52;\nvar lengthOfArrayLike$82 = lengthOfArrayLike$b2;\nvar createProperty$42 = createProperty$62;\nvar Array$42 = global$m2.Array;\nvar max$22 = Math.max;\nvar arraySliceSimple2 = function(O, start, end) {\n  var length2 = lengthOfArrayLike$82(O);\n  var k2 = toAbsoluteIndex$32(start, length2);\n  var fin = toAbsoluteIndex$32(end === void 0 ? length2 : end, length2);\n  var result2 = Array$42(max$22(fin - k2, 0));\n  for (var n = 0; k2 < fin; k2++, n++)\n    createProperty$42(result2, n, O[k2]);\n  result2.length = n;\n  return result2;\n};\nvar classof$52 = classofRaw$12;\nvar toIndexedObject$52 = toIndexedObject$b2;\nvar $getOwnPropertyNames$12 = objectGetOwnPropertyNames2.f;\nvar arraySlice$32 = arraySliceSimple2;\nvar windowNames2 = typeof window == \"object\" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];\nvar getWindowNames2 = function(it2) {\n  try {\n    return $getOwnPropertyNames$12(it2);\n  } catch (error) {\n    return arraySlice$32(windowNames2);\n  }\n};\nobjectGetOwnPropertyNamesExternal2.f = function getOwnPropertyNames22(it2) {\n  return windowNames2 && classof$52(it2) == \"Window\" ? getWindowNames2(it2) : $getOwnPropertyNames$12(toIndexedObject$52(it2));\n};\nvar wellKnownSymbolWrapped2 = {};\nvar wellKnownSymbol$82 = wellKnownSymbol$j2;\nwellKnownSymbolWrapped2.f = wellKnownSymbol$82;\nvar path$s = path$y;\nvar hasOwn$62 = hasOwnProperty_12;\nvar wrappedWellKnownSymbolModule$12 = wellKnownSymbolWrapped2;\nvar defineProperty$b2 = objectDefineProperty2.f;\nvar defineWellKnownSymbol$l2 = function(NAME) {\n  var Symbol2 = path$s.Symbol || (path$s.Symbol = {});\n  if (!hasOwn$62(Symbol2, NAME))\n    defineProperty$b2(Symbol2, NAME, {\n      value: wrappedWellKnownSymbolModule$12.f(NAME)\n    });\n};\nvar global$l2 = global$O;\nvar isArray$b2 = isArray$c2;\nvar isConstructor$22 = isConstructor$42;\nvar isObject$c2 = isObject$j;\nvar wellKnownSymbol$72 = wellKnownSymbol$j2;\nvar SPECIES$32 = wellKnownSymbol$72(\"species\");\nvar Array$32 = global$l2.Array;\nvar arraySpeciesConstructor$12 = function(originalArray) {\n  var C3;\n  if (isArray$b2(originalArray)) {\n    C3 = originalArray.constructor;\n    if (isConstructor$22(C3) && (C3 === Array$32 || isArray$b2(C3.prototype)))\n      C3 = void 0;\n    else if (isObject$c2(C3)) {\n      C3 = C3[SPECIES$32];\n      if (C3 === null)\n        C3 = void 0;\n    }\n  }\n  return C3 === void 0 ? Array$32 : C3;\n};\nvar arraySpeciesConstructor2 = arraySpeciesConstructor$12;\nvar arraySpeciesCreate$32 = function(originalArray, length2) {\n  return new (arraySpeciesConstructor2(originalArray))(length2 === 0 ? 0 : length2);\n};\nvar bind$32 = functionBindContext2;\nvar uncurryThis$f2 = functionUncurryThis2;\nvar IndexedObject$12 = indexedObject2;\nvar toObject$82 = toObject$d2;\nvar lengthOfArrayLike$72 = lengthOfArrayLike$b2;\nvar arraySpeciesCreate$22 = arraySpeciesCreate$32;\nvar push$42 = uncurryThis$f2([].push);\nvar createMethod$32 = function(TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var IS_FILTER_REJECT = TYPE == 7;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function($this, callbackfn, that, specificCreate) {\n    var O = toObject$82($this);\n    var self2 = IndexedObject$12(O);\n    var boundFunction = bind$32(callbackfn, that);\n    var length2 = lengthOfArrayLike$72(self2);\n    var index2 = 0;\n    var create52 = specificCreate || arraySpeciesCreate$22;\n    var target = IS_MAP ? create52($this, length2) : IS_FILTER || IS_FILTER_REJECT ? create52($this, 0) : void 0;\n    var value, result2;\n    for (; length2 > index2; index2++)\n      if (NO_HOLES || index2 in self2) {\n        value = self2[index2];\n        result2 = boundFunction(value, index2, O);\n        if (TYPE) {\n          if (IS_MAP)\n            target[index2] = result2;\n          else if (result2)\n            switch (TYPE) {\n              case 3:\n                return true;\n              case 5:\n                return value;\n              case 6:\n                return index2;\n              case 2:\n                push$42(target, value);\n            }\n          else\n            switch (TYPE) {\n              case 4:\n                return false;\n              case 7:\n                push$42(target, value);\n            }\n        }\n      }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\nvar arrayIteration2 = {\n  forEach: createMethod$32(0),\n  map: createMethod$32(1),\n  filter: createMethod$32(2),\n  some: createMethod$32(3),\n  every: createMethod$32(4),\n  find: createMethod$32(5),\n  findIndex: createMethod$32(6),\n  filterReject: createMethod$32(7)\n};\nvar $$E = _export2;\nvar global$k2 = global$O;\nvar getBuiltIn$42 = getBuiltIn$92;\nvar apply$42 = functionApply2;\nvar call$22 = functionCall2;\nvar uncurryThis$e2 = functionUncurryThis2;\nvar DESCRIPTORS$92 = descriptors2;\nvar NATIVE_SYMBOL2 = nativeSymbol2;\nvar fails$h2 = fails$t;\nvar hasOwn$52 = hasOwnProperty_12;\nvar isArray$a2 = isArray$c2;\nvar isCallable$22 = isCallable$h2;\nvar isObject$b2 = isObject$j;\nvar isPrototypeOf$h2 = objectIsPrototypeOf2;\nvar isSymbol2 = isSymbol$32;\nvar anObject$52 = anObject$d;\nvar toObject$72 = toObject$d2;\nvar toIndexedObject$42 = toIndexedObject$b2;\nvar toPropertyKey2 = toPropertyKey$42;\nvar $toString2 = toString$82;\nvar createPropertyDescriptor2 = createPropertyDescriptor$52;\nvar nativeObjectCreate2 = objectCreate2;\nvar objectKeys$12 = objectKeys$42;\nvar getOwnPropertyNamesModule$22 = objectGetOwnPropertyNames2;\nvar getOwnPropertyNamesExternal2 = objectGetOwnPropertyNamesExternal2;\nvar getOwnPropertySymbolsModule$12 = objectGetOwnPropertySymbols2;\nvar getOwnPropertyDescriptorModule$2 = objectGetOwnPropertyDescriptor2;\nvar definePropertyModule$12 = objectDefineProperty2;\nvar definePropertiesModule2 = objectDefineProperties2;\nvar propertyIsEnumerableModule2 = objectPropertyIsEnumerable2;\nvar arraySlice$22 = arraySlice$52;\nvar redefine$12 = redefine$42;\nvar shared2 = shared$42.exports;\nvar sharedKey2 = sharedKey$42;\nvar hiddenKeys$12 = hiddenKeys$62;\nvar uid$12 = uid$42;\nvar wellKnownSymbol$62 = wellKnownSymbol$j2;\nvar wrappedWellKnownSymbolModule2 = wellKnownSymbolWrapped2;\nvar defineWellKnownSymbol$k2 = defineWellKnownSymbol$l2;\nvar setToStringTag$22 = setToStringTag$52;\nvar InternalStateModule$32 = internalState2;\nvar $forEach$12 = arrayIteration2.forEach;\nvar HIDDEN2 = sharedKey2(\"hidden\");\nvar SYMBOL2 = \"Symbol\";\nvar PROTOTYPE2 = \"prototype\";\nvar TO_PRIMITIVE2 = wellKnownSymbol$62(\"toPrimitive\");\nvar setInternalState$32 = InternalStateModule$32.set;\nvar getInternalState2 = InternalStateModule$32.getterFor(SYMBOL2);\nvar ObjectPrototype$12 = Object[PROTOTYPE2];\nvar $Symbol2 = global$k2.Symbol;\nvar SymbolPrototype2 = $Symbol2 && $Symbol2[PROTOTYPE2];\nvar TypeError$92 = global$k2.TypeError;\nvar QObject2 = global$k2.QObject;\nvar $stringify$12 = getBuiltIn$42(\"JSON\", \"stringify\");\nvar nativeGetOwnPropertyDescriptor$12 = getOwnPropertyDescriptorModule$2.f;\nvar nativeDefineProperty2 = definePropertyModule$12.f;\nvar nativeGetOwnPropertyNames2 = getOwnPropertyNamesExternal2.f;\nvar nativePropertyIsEnumerable2 = propertyIsEnumerableModule2.f;\nvar push$32 = uncurryThis$e2([].push);\nvar AllSymbols2 = shared2(\"symbols\");\nvar ObjectPrototypeSymbols2 = shared2(\"op-symbols\");\nvar StringToSymbolRegistry2 = shared2(\"string-to-symbol-registry\");\nvar SymbolToStringRegistry2 = shared2(\"symbol-to-string-registry\");\nvar WellKnownSymbolsStore2 = shared2(\"wks\");\nvar USE_SETTER2 = !QObject2 || !QObject2[PROTOTYPE2] || !QObject2[PROTOTYPE2].findChild;\nvar setSymbolDescriptor2 = DESCRIPTORS$92 && fails$h2(function() {\n  return nativeObjectCreate2(nativeDefineProperty2({}, \"a\", {\n    get: function() {\n      return nativeDefineProperty2(this, \"a\", {\n        value: 7\n      }).a;\n    }\n  })).a != 7;\n}) ? function(O, P, Attributes) {\n  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$12(ObjectPrototype$12, P);\n  if (ObjectPrototypeDescriptor)\n    delete ObjectPrototype$12[P];\n  nativeDefineProperty2(O, P, Attributes);\n  if (ObjectPrototypeDescriptor && O !== ObjectPrototype$12) {\n    nativeDefineProperty2(ObjectPrototype$12, P, ObjectPrototypeDescriptor);\n  }\n} : nativeDefineProperty2;\nvar wrap$12 = function(tag, description) {\n  var symbol22 = AllSymbols2[tag] = nativeObjectCreate2(SymbolPrototype2);\n  setInternalState$32(symbol22, {\n    type: SYMBOL2,\n    tag,\n    description\n  });\n  if (!DESCRIPTORS$92)\n    symbol22.description = description;\n  return symbol22;\n};\nvar $defineProperty2 = function defineProperty32(O, P, Attributes) {\n  if (O === ObjectPrototype$12)\n    $defineProperty2(ObjectPrototypeSymbols2, P, Attributes);\n  anObject$52(O);\n  var key = toPropertyKey2(P);\n  anObject$52(Attributes);\n  if (hasOwn$52(AllSymbols2, key)) {\n    if (!Attributes.enumerable) {\n      if (!hasOwn$52(O, HIDDEN2))\n        nativeDefineProperty2(O, HIDDEN2, createPropertyDescriptor2(1, {}));\n      O[HIDDEN2][key] = true;\n    } else {\n      if (hasOwn$52(O, HIDDEN2) && O[HIDDEN2][key])\n        O[HIDDEN2][key] = false;\n      Attributes = nativeObjectCreate2(Attributes, {\n        enumerable: createPropertyDescriptor2(0, false)\n      });\n    }\n    return setSymbolDescriptor2(O, key, Attributes);\n  }\n  return nativeDefineProperty2(O, key, Attributes);\n};\nvar $defineProperties2 = function defineProperties22(O, Properties) {\n  anObject$52(O);\n  var properties = toIndexedObject$42(Properties);\n  var keys42 = objectKeys$12(properties).concat($getOwnPropertySymbols2(properties));\n  $forEach$12(keys42, function(key) {\n    if (!DESCRIPTORS$92 || call$22($propertyIsEnumerable$12, properties, key))\n      $defineProperty2(O, key, properties[key]);\n  });\n  return O;\n};\nvar $create2 = function create22(O, Properties) {\n  return Properties === void 0 ? nativeObjectCreate2(O) : $defineProperties2(nativeObjectCreate2(O), Properties);\n};\nvar $propertyIsEnumerable$12 = function propertyIsEnumerable22(V2) {\n  var P = toPropertyKey2(V2);\n  var enumerable = call$22(nativePropertyIsEnumerable2, this, P);\n  if (this === ObjectPrototype$12 && hasOwn$52(AllSymbols2, P) && !hasOwn$52(ObjectPrototypeSymbols2, P))\n    return false;\n  return enumerable || !hasOwn$52(this, P) || !hasOwn$52(AllSymbols2, P) || hasOwn$52(this, HIDDEN2) && this[HIDDEN2][P] ? enumerable : true;\n};\nvar $getOwnPropertyDescriptor2 = function getOwnPropertyDescriptor22(O, P) {\n  var it2 = toIndexedObject$42(O);\n  var key = toPropertyKey2(P);\n  if (it2 === ObjectPrototype$12 && hasOwn$52(AllSymbols2, key) && !hasOwn$52(ObjectPrototypeSymbols2, key))\n    return;\n  var descriptor = nativeGetOwnPropertyDescriptor$12(it2, key);\n  if (descriptor && hasOwn$52(AllSymbols2, key) && !(hasOwn$52(it2, HIDDEN2) && it2[HIDDEN2][key])) {\n    descriptor.enumerable = true;\n  }\n  return descriptor;\n};\nvar $getOwnPropertyNames2 = function getOwnPropertyNames32(O) {\n  var names = nativeGetOwnPropertyNames2(toIndexedObject$42(O));\n  var result2 = [];\n  $forEach$12(names, function(key) {\n    if (!hasOwn$52(AllSymbols2, key) && !hasOwn$52(hiddenKeys$12, key))\n      push$32(result2, key);\n  });\n  return result2;\n};\nvar $getOwnPropertySymbols2 = function getOwnPropertySymbols4(O) {\n  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$12;\n  var names = nativeGetOwnPropertyNames2(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols2 : toIndexedObject$42(O));\n  var result2 = [];\n  $forEach$12(names, function(key) {\n    if (hasOwn$52(AllSymbols2, key) && (!IS_OBJECT_PROTOTYPE || hasOwn$52(ObjectPrototype$12, key))) {\n      push$32(result2, AllSymbols2[key]);\n    }\n  });\n  return result2;\n};\nif (!NATIVE_SYMBOL2) {\n  $Symbol2 = function Symbol2() {\n    if (isPrototypeOf$h2(SymbolPrototype2, this))\n      throw TypeError$92(\"Symbol is not a constructor\");\n    var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString2(arguments[0]);\n    var tag = uid$12(description);\n    var setter = function(value) {\n      if (this === ObjectPrototype$12)\n        call$22(setter, ObjectPrototypeSymbols2, value);\n      if (hasOwn$52(this, HIDDEN2) && hasOwn$52(this[HIDDEN2], tag))\n        this[HIDDEN2][tag] = false;\n      setSymbolDescriptor2(this, tag, createPropertyDescriptor2(1, value));\n    };\n    if (DESCRIPTORS$92 && USE_SETTER2)\n      setSymbolDescriptor2(ObjectPrototype$12, tag, {\n        configurable: true,\n        set: setter\n      });\n    return wrap$12(tag, description);\n  };\n  SymbolPrototype2 = $Symbol2[PROTOTYPE2];\n  redefine$12(SymbolPrototype2, \"toString\", function toString32() {\n    return getInternalState2(this).tag;\n  });\n  redefine$12($Symbol2, \"withoutSetter\", function(description) {\n    return wrap$12(uid$12(description), description);\n  });\n  propertyIsEnumerableModule2.f = $propertyIsEnumerable$12;\n  definePropertyModule$12.f = $defineProperty2;\n  definePropertiesModule2.f = $defineProperties2;\n  getOwnPropertyDescriptorModule$2.f = $getOwnPropertyDescriptor2;\n  getOwnPropertyNamesModule$22.f = getOwnPropertyNamesExternal2.f = $getOwnPropertyNames2;\n  getOwnPropertySymbolsModule$12.f = $getOwnPropertySymbols2;\n  wrappedWellKnownSymbolModule2.f = function(name2) {\n    return wrap$12(wellKnownSymbol$62(name2), name2);\n  };\n  if (DESCRIPTORS$92) {\n    nativeDefineProperty2(SymbolPrototype2, \"description\", {\n      configurable: true,\n      get: function description() {\n        return getInternalState2(this).description;\n      }\n    });\n  }\n}\n$$E({\n  global: true,\n  wrap: true,\n  forced: !NATIVE_SYMBOL2,\n  sham: !NATIVE_SYMBOL2\n}, {\n  Symbol: $Symbol2\n});\n$forEach$12(objectKeys$12(WellKnownSymbolsStore2), function(name2) {\n  defineWellKnownSymbol$k2(name2);\n});\n$$E({\n  target: SYMBOL2,\n  stat: true,\n  forced: !NATIVE_SYMBOL2\n}, {\n  for: function(key) {\n    var string22 = $toString2(key);\n    if (hasOwn$52(StringToSymbolRegistry2, string22))\n      return StringToSymbolRegistry2[string22];\n    var symbol22 = $Symbol2(string22);\n    StringToSymbolRegistry2[string22] = symbol22;\n    SymbolToStringRegistry2[symbol22] = string22;\n    return symbol22;\n  },\n  keyFor: function keyFor2(sym) {\n    if (!isSymbol2(sym))\n      throw TypeError$92(sym + \" is not a symbol\");\n    if (hasOwn$52(SymbolToStringRegistry2, sym))\n      return SymbolToStringRegistry2[sym];\n  },\n  useSetter: function() {\n    USE_SETTER2 = true;\n  },\n  useSimple: function() {\n    USE_SETTER2 = false;\n  }\n});\n$$E({\n  target: \"Object\",\n  stat: true,\n  forced: !NATIVE_SYMBOL2,\n  sham: !DESCRIPTORS$92\n}, {\n  create: $create2,\n  defineProperty: $defineProperty2,\n  defineProperties: $defineProperties2,\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor2\n});\n$$E({\n  target: \"Object\",\n  stat: true,\n  forced: !NATIVE_SYMBOL2\n}, {\n  getOwnPropertyNames: $getOwnPropertyNames2,\n  getOwnPropertySymbols: $getOwnPropertySymbols2\n});\n$$E({\n  target: \"Object\",\n  stat: true,\n  forced: fails$h2(function() {\n    getOwnPropertySymbolsModule$12.f(1);\n  })\n}, {\n  getOwnPropertySymbols: function getOwnPropertySymbols22(it2) {\n    return getOwnPropertySymbolsModule$12.f(toObject$72(it2));\n  }\n});\nif ($stringify$12) {\n  FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL2 || fails$h2(function() {\n    var symbol22 = $Symbol2();\n    return $stringify$12([symbol22]) != \"[null]\" || $stringify$12({\n      a: symbol22\n    }) != \"{}\" || $stringify$12(Object(symbol22)) != \"{}\";\n  });\n  $$E({\n    target: \"JSON\",\n    stat: true,\n    forced: FORCED_JSON_STRINGIFY\n  }, {\n    stringify: function stringify32(it2, replacer, space) {\n      var args = arraySlice$22(arguments);\n      var $replacer = replacer;\n      if (!isObject$b2(replacer) && it2 === void 0 || isSymbol2(it2))\n        return;\n      if (!isArray$a2(replacer))\n        replacer = function(key, value) {\n          if (isCallable$22($replacer))\n            value = call$22($replacer, this, key, value);\n          if (!isSymbol2(value))\n            return value;\n        };\n      args[1] = replacer;\n      return apply$42($stringify$12, null, args);\n    }\n  });\n}\nvar FORCED_JSON_STRINGIFY;\nif (!SymbolPrototype2[TO_PRIMITIVE2]) {\n  valueOf = SymbolPrototype2.valueOf;\n  redefine$12(SymbolPrototype2, TO_PRIMITIVE2, function(hint) {\n    return call$22(valueOf, this);\n  });\n}\nvar valueOf;\nsetToStringTag$22($Symbol2, SYMBOL2);\nhiddenKeys$12[HIDDEN2] = true;\nvar path$r = path$y;\nvar getOwnPropertySymbols$22 = path$r.Object.getOwnPropertySymbols;\nvar parent$Z = getOwnPropertySymbols$22;\nvar getOwnPropertySymbols$12 = parent$Z;\nvar getOwnPropertySymbols32 = getOwnPropertySymbols$12;\nvar getOwnPropertyDescriptor$6 = { exports: {} };\nvar $$D = _export2;\nvar fails$g2 = fails$t;\nvar toIndexedObject$32 = toIndexedObject$b2;\nvar nativeGetOwnPropertyDescriptor2 = objectGetOwnPropertyDescriptor2.f;\nvar DESCRIPTORS$82 = descriptors2;\nvar FAILS_ON_PRIMITIVES$4 = fails$g2(function() {\n  nativeGetOwnPropertyDescriptor2(1);\n});\nvar FORCED$6 = !DESCRIPTORS$82 || FAILS_ON_PRIMITIVES$4;\n$$D({\n  target: \"Object\",\n  stat: true,\n  forced: FORCED$6,\n  sham: !DESCRIPTORS$82\n}, {\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor32(it2, key) {\n    return nativeGetOwnPropertyDescriptor2(toIndexedObject$32(it2), key);\n  }\n});\nvar path$q2 = path$y;\nvar Object$52 = path$q2.Object;\nvar getOwnPropertyDescriptor$52 = getOwnPropertyDescriptor$6.exports = function getOwnPropertyDescriptor42(it2, key) {\n  return Object$52.getOwnPropertyDescriptor(it2, key);\n};\nif (Object$52.getOwnPropertyDescriptor.sham)\n  getOwnPropertyDescriptor$52.sham = true;\nvar parent$Y = getOwnPropertyDescriptor$6.exports;\nvar getOwnPropertyDescriptor$42 = parent$Y;\nvar getOwnPropertyDescriptor$32 = getOwnPropertyDescriptor$42;\nvar getBuiltIn$32 = getBuiltIn$92;\nvar uncurryThis$d2 = functionUncurryThis2;\nvar getOwnPropertyNamesModule$12 = objectGetOwnPropertyNames2;\nvar getOwnPropertySymbolsModule2 = objectGetOwnPropertySymbols2;\nvar anObject$42 = anObject$d;\nvar concat$42 = uncurryThis$d2([].concat);\nvar ownKeys$62 = getBuiltIn$32(\"Reflect\", \"ownKeys\") || function ownKeys3(it2) {\n  var keys42 = getOwnPropertyNamesModule$12.f(anObject$42(it2));\n  var getOwnPropertySymbols42 = getOwnPropertySymbolsModule2.f;\n  return getOwnPropertySymbols42 ? concat$42(keys42, getOwnPropertySymbols42(it2)) : keys42;\n};\nvar $$C2 = _export2;\nvar DESCRIPTORS$72 = descriptors2;\nvar ownKeys$52 = ownKeys$62;\nvar toIndexedObject$22 = toIndexedObject$b2;\nvar getOwnPropertyDescriptorModule$12 = objectGetOwnPropertyDescriptor2;\nvar createProperty$32 = createProperty$62;\n$$C2({\n  target: \"Object\",\n  stat: true,\n  sham: !DESCRIPTORS$72\n}, {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors3(object2) {\n    var O = toIndexedObject$22(object2);\n    var getOwnPropertyDescriptor62 = getOwnPropertyDescriptorModule$12.f;\n    var keys42 = ownKeys$52(O);\n    var result2 = {};\n    var index2 = 0;\n    var key, descriptor;\n    while (keys42.length > index2) {\n      descriptor = getOwnPropertyDescriptor62(O, key = keys42[index2++]);\n      if (descriptor !== void 0)\n        createProperty$32(result2, key, descriptor);\n    }\n    return result2;\n  }\n});\nvar path$p2 = path$y;\nvar getOwnPropertyDescriptors$22 = path$p2.Object.getOwnPropertyDescriptors;\nvar parent$X = getOwnPropertyDescriptors$22;\nvar getOwnPropertyDescriptors$12 = parent$X;\nvar getOwnPropertyDescriptors22 = getOwnPropertyDescriptors$12;\nvar defineProperties$42 = { exports: {} };\nvar $$B2 = _export2;\nvar DESCRIPTORS$62 = descriptors2;\nvar defineProperties$32 = objectDefineProperties2.f;\n$$B2({\n  target: \"Object\",\n  stat: true,\n  forced: Object.defineProperties !== defineProperties$32,\n  sham: !DESCRIPTORS$62\n}, {\n  defineProperties: defineProperties$32\n});\nvar path$o2 = path$y;\nvar Object$42 = path$o2.Object;\nvar defineProperties$22 = defineProperties$42.exports = function defineProperties32(T, D2) {\n  return Object$42.defineProperties(T, D2);\n};\nif (Object$42.defineProperties.sham)\n  defineProperties$22.sham = true;\nvar parent$W = defineProperties$42.exports;\nvar defineProperties$12 = parent$W;\nvar defineProperties42 = defineProperties$12;\nvar defineProperty$a2 = { exports: {} };\nvar $$A2 = _export2;\nvar DESCRIPTORS$52 = descriptors2;\nvar defineProperty$92 = objectDefineProperty2.f;\n$$A2({\n  target: \"Object\",\n  stat: true,\n  forced: Object.defineProperty !== defineProperty$92,\n  sham: !DESCRIPTORS$52\n}, {\n  defineProperty: defineProperty$92\n});\nvar path$n2 = path$y;\nvar Object$32 = path$n2.Object;\nvar defineProperty$82 = defineProperty$a2.exports = function defineProperty42(it2, key, desc) {\n  return Object$32.defineProperty(it2, key, desc);\n};\nif (Object$32.defineProperty.sham)\n  defineProperty$82.sham = true;\nvar parent$V2 = defineProperty$a2.exports;\nvar defineProperty$72 = parent$V2;\nvar defineProperty$62 = defineProperty$72;\nfunction _classCallCheck2(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar parent$U2 = defineProperty$72;\nvar defineProperty$52 = parent$U2;\nvar parent$T2 = defineProperty$52;\nvar defineProperty$42 = parent$T2;\nvar defineProperty$32 = defineProperty$42;\nfunction _defineProperties2(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor)\n      descriptor.writable = true;\n    defineProperty$32(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass2(Constructor, protoProps, staticProps) {\n  if (protoProps)\n    _defineProperties2(Constructor.prototype, protoProps);\n  if (staticProps)\n    _defineProperties2(Constructor, staticProps);\n  defineProperty$32(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty2(obj, key, value) {\n  if (key in obj) {\n    defineProperty$32(obj, key, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar $$z2 = _export2;\nvar isArray$92 = isArray$c2;\n$$z2({\n  target: \"Array\",\n  stat: true\n}, {\n  isArray: isArray$92\n});\nvar path$m2 = path$y;\nvar isArray$82 = path$m2.Array.isArray;\nvar parent$S2 = isArray$82;\nvar isArray$72 = parent$S2;\nvar parent$R2 = isArray$72;\nvar isArray$62 = parent$R2;\nvar parent$Q2 = isArray$62;\nvar isArray$52 = parent$Q2;\nvar isArray$42 = isArray$52;\nfunction _arrayWithHoles2(arr) {\n  if (isArray$42(arr))\n    return arr;\n}\nvar fails$f2 = fails$t;\nvar wellKnownSymbol$52 = wellKnownSymbol$j2;\nvar V8_VERSION$12 = engineV8Version2;\nvar SPECIES$22 = wellKnownSymbol$52(\"species\");\nvar arrayMethodHasSpeciesSupport$52 = function(METHOD_NAME) {\n  return V8_VERSION$12 >= 51 || !fails$f2(function() {\n    var array2 = [];\n    var constructor = array2.constructor = {};\n    constructor[SPECIES$22] = function() {\n      return {\n        foo: 1\n      };\n    };\n    return array2[METHOD_NAME](Boolean).foo !== 1;\n  });\n};\nvar $$y2 = _export2;\nvar global$j2 = global$O;\nvar fails$e2 = fails$t;\nvar isArray$32 = isArray$c2;\nvar isObject$a2 = isObject$j;\nvar toObject$62 = toObject$d2;\nvar lengthOfArrayLike$62 = lengthOfArrayLike$b2;\nvar createProperty$22 = createProperty$62;\nvar arraySpeciesCreate$12 = arraySpeciesCreate$32;\nvar arrayMethodHasSpeciesSupport$42 = arrayMethodHasSpeciesSupport$52;\nvar wellKnownSymbol$42 = wellKnownSymbol$j2;\nvar V8_VERSION2 = engineV8Version2;\nvar IS_CONCAT_SPREADABLE2 = wellKnownSymbol$42(\"isConcatSpreadable\");\nvar MAX_SAFE_INTEGER$12 = 9007199254740991;\nvar MAXIMUM_ALLOWED_INDEX_EXCEEDED2 = \"Maximum allowed index exceeded\";\nvar TypeError$82 = global$j2.TypeError;\nvar IS_CONCAT_SPREADABLE_SUPPORT2 = V8_VERSION2 >= 51 || !fails$e2(function() {\n  var array2 = [];\n  array2[IS_CONCAT_SPREADABLE2] = false;\n  return array2.concat()[0] !== array2;\n});\nvar SPECIES_SUPPORT2 = arrayMethodHasSpeciesSupport$42(\"concat\");\nvar isConcatSpreadable2 = function(O) {\n  if (!isObject$a2(O))\n    return false;\n  var spreadable = O[IS_CONCAT_SPREADABLE2];\n  return spreadable !== void 0 ? !!spreadable : isArray$32(O);\n};\nvar FORCED$52 = !IS_CONCAT_SPREADABLE_SUPPORT2 || !SPECIES_SUPPORT2;\n$$y2({\n  target: \"Array\",\n  proto: true,\n  forced: FORCED$52\n}, {\n  concat: function concat3(arg) {\n    var O = toObject$62(this);\n    var A2 = arraySpeciesCreate$12(O, 0);\n    var n = 0;\n    var i, k2, length2, len, E;\n    for (i = -1, length2 = arguments.length; i < length2; i++) {\n      E = i === -1 ? O : arguments[i];\n      if (isConcatSpreadable2(E)) {\n        len = lengthOfArrayLike$62(E);\n        if (n + len > MAX_SAFE_INTEGER$12)\n          throw TypeError$82(MAXIMUM_ALLOWED_INDEX_EXCEEDED2);\n        for (k2 = 0; k2 < len; k2++, n++)\n          if (k2 in E)\n            createProperty$22(A2, n, E[k2]);\n      } else {\n        if (n >= MAX_SAFE_INTEGER$12)\n          throw TypeError$82(MAXIMUM_ALLOWED_INDEX_EXCEEDED2);\n        createProperty$22(A2, n++, E);\n      }\n    }\n    A2.length = n;\n    return A2;\n  }\n});\nvar defineWellKnownSymbol$j2 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$j2(\"asyncIterator\");\nvar defineWellKnownSymbol$i2 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$i2(\"hasInstance\");\nvar defineWellKnownSymbol$h2 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$h2(\"isConcatSpreadable\");\nvar defineWellKnownSymbol$g2 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$g2(\"iterator\");\nvar defineWellKnownSymbol$f2 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$f2(\"match\");\nvar defineWellKnownSymbol$e2 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$e2(\"matchAll\");\nvar defineWellKnownSymbol$d2 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$d2(\"replace\");\nvar defineWellKnownSymbol$c2 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$c2(\"search\");\nvar defineWellKnownSymbol$b2 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$b2(\"species\");\nvar defineWellKnownSymbol$a2 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$a2(\"split\");\nvar defineWellKnownSymbol$92 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$92(\"toPrimitive\");\nvar defineWellKnownSymbol$82 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$82(\"toStringTag\");\nvar defineWellKnownSymbol$72 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$72(\"unscopables\");\nvar global$i2 = global$O;\nvar setToStringTag$12 = setToStringTag$52;\nsetToStringTag$12(global$i2.JSON, \"JSON\", true);\nvar path$l2 = path$y;\nvar symbol$52 = path$l2.Symbol;\nvar parent$P2 = symbol$52;\nvar symbol$42 = parent$P2;\nvar parent$O = symbol$42;\nvar symbol$32 = parent$O;\nvar defineWellKnownSymbol$62 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$62(\"asyncDispose\");\nvar defineWellKnownSymbol$52 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$52(\"dispose\");\nvar defineWellKnownSymbol$42 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$42(\"matcher\");\nvar defineWellKnownSymbol$32 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$32(\"metadata\");\nvar defineWellKnownSymbol$22 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$22(\"observable\");\nvar defineWellKnownSymbol$12 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol$12(\"patternMatch\");\nvar defineWellKnownSymbol2 = defineWellKnownSymbol$l2;\ndefineWellKnownSymbol2(\"replaceAll\");\nvar parent$N2 = symbol$32;\nvar symbol$22 = parent$N2;\nvar symbol$12 = symbol$22;\nfunction _iterableToArrayLimit2(arr, i) {\n  var _i = arr == null ? null : typeof symbol$12 !== \"undefined\" && getIteratorMethod$12(arr) || arr[\"@@iterator\"];\n  if (_i == null)\n    return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e3;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i)\n        break;\n    }\n  } catch (err) {\n    _d = true;\n    _e3 = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null)\n        _i[\"return\"]();\n    } finally {\n      if (_d)\n        throw _e3;\n    }\n  }\n  return _arr;\n}\nvar $$x2 = _export2;\nvar global$h2 = global$O;\nvar isArray$22 = isArray$c2;\nvar isConstructor$12 = isConstructor$42;\nvar isObject$92 = isObject$j;\nvar toAbsoluteIndex$22 = toAbsoluteIndex$52;\nvar lengthOfArrayLike$52 = lengthOfArrayLike$b2;\nvar toIndexedObject$12 = toIndexedObject$b2;\nvar createProperty$12 = createProperty$62;\nvar wellKnownSymbol$32 = wellKnownSymbol$j2;\nvar arrayMethodHasSpeciesSupport$32 = arrayMethodHasSpeciesSupport$52;\nvar un$Slice2 = arraySlice$52;\nvar HAS_SPECIES_SUPPORT$32 = arrayMethodHasSpeciesSupport$32(\"slice\");\nvar SPECIES$12 = wellKnownSymbol$32(\"species\");\nvar Array$22 = global$h2.Array;\nvar max$12 = Math.max;\n$$x2({\n  target: \"Array\",\n  proto: true,\n  forced: !HAS_SPECIES_SUPPORT$32\n}, {\n  slice: function slice3(start, end) {\n    var O = toIndexedObject$12(this);\n    var length2 = lengthOfArrayLike$52(O);\n    var k2 = toAbsoluteIndex$22(start, length2);\n    var fin = toAbsoluteIndex$22(end === void 0 ? length2 : end, length2);\n    var Constructor, result2, n;\n    if (isArray$22(O)) {\n      Constructor = O.constructor;\n      if (isConstructor$12(Constructor) && (Constructor === Array$22 || isArray$22(Constructor.prototype))) {\n        Constructor = void 0;\n      } else if (isObject$92(Constructor)) {\n        Constructor = Constructor[SPECIES$12];\n        if (Constructor === null)\n          Constructor = void 0;\n      }\n      if (Constructor === Array$22 || Constructor === void 0) {\n        return un$Slice2(O, k2, fin);\n      }\n    }\n    result2 = new (Constructor === void 0 ? Array$22 : Constructor)(max$12(fin - k2, 0));\n    for (n = 0; k2 < fin; k2++, n++)\n      if (k2 in O)\n        createProperty$12(result2, n, O[k2]);\n    result2.length = n;\n    return result2;\n  }\n});\nvar entryVirtual$g2 = entryVirtual$i2;\nvar slice$62 = entryVirtual$g2(\"Array\").slice;\nvar isPrototypeOf$g2 = objectIsPrototypeOf2;\nvar method$d2 = slice$62;\nvar ArrayPrototype$e2 = Array.prototype;\nvar slice$52 = function(it2) {\n  var own = it2.slice;\n  return it2 === ArrayPrototype$e2 || isPrototypeOf$g2(ArrayPrototype$e2, it2) && own === ArrayPrototype$e2.slice ? method$d2 : own;\n};\nvar parent$M2 = slice$52;\nvar slice$42 = parent$M2;\nvar parent$L2 = slice$42;\nvar slice$32 = parent$L2;\nvar parent$K2 = slice$32;\nvar slice$22 = parent$K2;\nvar slice$12 = slice$22;\nvar parent$J2 = from$42;\nvar from$22 = parent$J2;\nvar parent$I2 = from$22;\nvar from$12 = parent$I2;\nvar from22 = from$12;\nfunction _arrayLikeToArray$8(arr, len) {\n  if (len == null || len > arr.length)\n    len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _unsupportedIterableToArray$8(o, minLen) {\n  var _context;\n  if (!o)\n    return;\n  if (typeof o === \"string\")\n    return _arrayLikeToArray$8(o, minLen);\n  var n = slice$12(_context = Object.prototype.toString.call(o)).call(_context, 8, -1);\n  if (n === \"Object\" && o.constructor)\n    n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\")\n    return from22(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray$8(o, minLen);\n}\nfunction _nonIterableRest2() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray2(arr, i) {\n  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray$8(arr, i) || _nonIterableRest2();\n}\nvar WrappedWellKnownSymbolModule2 = wellKnownSymbolWrapped2;\nvar iterator$42 = WrappedWellKnownSymbolModule2.f(\"iterator\");\nvar parent$H2 = iterator$42;\nvar iterator$32 = parent$H2;\nvar parent$G2 = iterator$32;\nvar iterator$22 = parent$G2;\nvar parent$F2 = iterator$22;\nvar iterator$12 = parent$F2;\nvar iterator2 = iterator$12;\nfunction _typeof2(obj) {\n  \"@babel/helpers - typeof\";\n  return _typeof2 = typeof symbol$12 == \"function\" && typeof iterator2 == \"symbol\" ? function(obj2) {\n    return typeof obj2;\n  } : function(obj2) {\n    return obj2 && typeof symbol$12 == \"function\" && obj2.constructor === symbol$12 && obj2 !== symbol$12.prototype ? \"symbol\" : typeof obj2;\n  }, _typeof2(obj);\n}\nfunction _arrayWithoutHoles2(arr) {\n  if (isArray$42(arr))\n    return _arrayLikeToArray$8(arr);\n}\nfunction _iterableToArray2(iter) {\n  if (typeof symbol$12 !== \"undefined\" && getIteratorMethod$12(iter) != null || iter[\"@@iterator\"] != null)\n    return from22(iter);\n}\nfunction _nonIterableSpread2() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray2(arr) {\n  return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableSpread2();\n}\nvar symbol2 = symbol$42;\nvar entryVirtual$f2 = entryVirtual$i2;\nvar concat$32 = entryVirtual$f2(\"Array\").concat;\nvar isPrototypeOf$f2 = objectIsPrototypeOf2;\nvar method$c2 = concat$32;\nvar ArrayPrototype$d2 = Array.prototype;\nvar concat$22 = function(it2) {\n  var own = it2.concat;\n  return it2 === ArrayPrototype$d2 || isPrototypeOf$f2(ArrayPrototype$d2, it2) && own === ArrayPrototype$d2.concat ? method$c2 : own;\n};\nvar parent$E2 = concat$22;\nvar concat$12 = parent$E2;\nvar concat22 = concat$12;\nvar slice22 = slice$42;\nvar $$w2 = _export2;\nvar ownKeys$42 = ownKeys$62;\n$$w2({\n  target: \"Reflect\",\n  stat: true\n}, {\n  ownKeys: ownKeys$42\n});\nvar path$k2 = path$y;\npath$k2.Reflect.ownKeys;\nvar isArray$12 = isArray$72;\nvar $$v2 = _export2;\nvar $map2 = arrayIteration2.map;\nvar arrayMethodHasSpeciesSupport$22 = arrayMethodHasSpeciesSupport$52;\nvar HAS_SPECIES_SUPPORT$22 = arrayMethodHasSpeciesSupport$22(\"map\");\n$$v2({\n  target: \"Array\",\n  proto: true,\n  forced: !HAS_SPECIES_SUPPORT$22\n}, {\n  map: function map3(callbackfn) {\n    return $map2(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);\n  }\n});\nvar entryVirtual$e2 = entryVirtual$i2;\nvar map$62 = entryVirtual$e2(\"Array\").map;\nvar isPrototypeOf$e2 = objectIsPrototypeOf2;\nvar method$b2 = map$62;\nvar ArrayPrototype$c2 = Array.prototype;\nvar map$52 = function(it2) {\n  var own = it2.map;\n  return it2 === ArrayPrototype$c2 || isPrototypeOf$e2(ArrayPrototype$c2, it2) && own === ArrayPrototype$c2.map ? method$b2 : own;\n};\nvar parent$D2 = map$52;\nvar map$42 = parent$D2;\nvar map$32 = map$42;\nvar $$u2 = _export2;\nvar toObject$52 = toObject$d2;\nvar nativeKeys2 = objectKeys$42;\nvar fails$d2 = fails$t;\nvar FAILS_ON_PRIMITIVES$32 = fails$d2(function() {\n  nativeKeys2(1);\n});\n$$u2({\n  target: \"Object\",\n  stat: true,\n  forced: FAILS_ON_PRIMITIVES$32\n}, {\n  keys: function keys22(it2) {\n    return nativeKeys2(toObject$52(it2));\n  }\n});\nvar path$j2 = path$y;\nvar keys$22 = path$j2.Object.keys;\nvar parent$C2 = keys$22;\nvar keys$12 = parent$C2;\nvar keys32 = keys$12;\nvar $$t2 = _export2;\nvar global$g2 = global$O;\nvar uncurryThis$c2 = functionUncurryThis2;\nvar Date$12 = global$g2.Date;\nvar getTime2 = uncurryThis$c2(Date$12.prototype.getTime);\n$$t2({\n  target: \"Date\",\n  stat: true\n}, {\n  now: function now3() {\n    return getTime2(new Date$12());\n  }\n});\nvar path$i2 = path$y;\nvar now$3 = path$i2.Date.now;\nvar parent$B2 = now$3;\nvar now$2 = parent$B2;\nvar now$1 = now$2;\nvar fails$c2 = fails$t;\nvar arrayMethodIsStrict$6 = function(METHOD_NAME, argument) {\n  var method22 = [][METHOD_NAME];\n  return !!method22 && fails$c2(function() {\n    method22.call(null, argument || function() {\n      return 1;\n    }, 1);\n  });\n};\nvar $forEach2 = arrayIteration2.forEach;\nvar arrayMethodIsStrict$52 = arrayMethodIsStrict$6;\nvar STRICT_METHOD$5 = arrayMethodIsStrict$52(\"forEach\");\nvar arrayForEach2 = !STRICT_METHOD$5 ? function forEach3(callbackfn) {\n  return $forEach2(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);\n} : [].forEach;\nvar $$s2 = _export2;\nvar forEach$6 = arrayForEach2;\n$$s2({\n  target: \"Array\",\n  proto: true,\n  forced: [].forEach != forEach$6\n}, {\n  forEach: forEach$6\n});\nvar entryVirtual$d2 = entryVirtual$i2;\nvar forEach$52 = entryVirtual$d2(\"Array\").forEach;\nvar parent$A2 = forEach$52;\nvar forEach$42 = parent$A2;\nvar classof$42 = classof$c2;\nvar hasOwn$42 = hasOwnProperty_12;\nvar isPrototypeOf$d = objectIsPrototypeOf2;\nvar method$a = forEach$42;\nvar ArrayPrototype$b2 = Array.prototype;\nvar DOMIterables$12 = {\n  DOMTokenList: true,\n  NodeList: true\n};\nvar forEach$32 = function(it2) {\n  var own = it2.forEach;\n  return it2 === ArrayPrototype$b2 || isPrototypeOf$d(ArrayPrototype$b2, it2) && own === ArrayPrototype$b2.forEach || hasOwn$42(DOMIterables$12, classof$42(it2)) ? method$a : own;\n};\nvar forEach$22 = forEach$32;\nvar $$r2 = _export2;\nvar uncurryThis$b2 = functionUncurryThis2;\nvar isArray22 = isArray$c2;\nvar un$Reverse2 = uncurryThis$b2([].reverse);\nvar test$12 = [1, 2];\n$$r2({\n  target: \"Array\",\n  proto: true,\n  forced: String(test$12) === String(test$12.reverse())\n}, {\n  reverse: function reverse3() {\n    if (isArray22(this))\n      this.length = this.length;\n    return un$Reverse2(this);\n  }\n});\nvar entryVirtual$c2 = entryVirtual$i2;\nvar reverse$32 = entryVirtual$c2(\"Array\").reverse;\nvar isPrototypeOf$c2 = objectIsPrototypeOf2;\nvar method$92 = reverse$32;\nvar ArrayPrototype$a2 = Array.prototype;\nvar reverse$22 = function(it2) {\n  var own = it2.reverse;\n  return it2 === ArrayPrototype$a2 || isPrototypeOf$c2(ArrayPrototype$a2, it2) && own === ArrayPrototype$a2.reverse ? method$92 : own;\n};\nvar parent$z2 = reverse$22;\nvar reverse$12 = parent$z2;\nvar reverse22 = reverse$12;\nvar $$q2 = _export2;\nvar global$f2 = global$O;\nvar toAbsoluteIndex$12 = toAbsoluteIndex$52;\nvar toIntegerOrInfinity2 = toIntegerOrInfinity$42;\nvar lengthOfArrayLike$42 = lengthOfArrayLike$b2;\nvar toObject$42 = toObject$d2;\nvar arraySpeciesCreate2 = arraySpeciesCreate$32;\nvar createProperty2 = createProperty$62;\nvar arrayMethodHasSpeciesSupport$12 = arrayMethodHasSpeciesSupport$52;\nvar HAS_SPECIES_SUPPORT$12 = arrayMethodHasSpeciesSupport$12(\"splice\");\nvar TypeError$72 = global$f2.TypeError;\nvar max2 = Math.max;\nvar min2 = Math.min;\nvar MAX_SAFE_INTEGER2 = 9007199254740991;\nvar MAXIMUM_ALLOWED_LENGTH_EXCEEDED2 = \"Maximum allowed length exceeded\";\n$$q2({\n  target: \"Array\",\n  proto: true,\n  forced: !HAS_SPECIES_SUPPORT$12\n}, {\n  splice: function splice3(start, deleteCount) {\n    var O = toObject$42(this);\n    var len = lengthOfArrayLike$42(O);\n    var actualStart = toAbsoluteIndex$12(start, len);\n    var argumentsLength = arguments.length;\n    var insertCount, actualDeleteCount, A2, k2, from32, to;\n    if (argumentsLength === 0) {\n      insertCount = actualDeleteCount = 0;\n    } else if (argumentsLength === 1) {\n      insertCount = 0;\n      actualDeleteCount = len - actualStart;\n    } else {\n      insertCount = argumentsLength - 2;\n      actualDeleteCount = min2(max2(toIntegerOrInfinity2(deleteCount), 0), len - actualStart);\n    }\n    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER2) {\n      throw TypeError$72(MAXIMUM_ALLOWED_LENGTH_EXCEEDED2);\n    }\n    A2 = arraySpeciesCreate2(O, actualDeleteCount);\n    for (k2 = 0; k2 < actualDeleteCount; k2++) {\n      from32 = actualStart + k2;\n      if (from32 in O)\n        createProperty2(A2, k2, O[from32]);\n    }\n    A2.length = actualDeleteCount;\n    if (insertCount < actualDeleteCount) {\n      for (k2 = actualStart; k2 < len - actualDeleteCount; k2++) {\n        from32 = k2 + actualDeleteCount;\n        to = k2 + insertCount;\n        if (from32 in O)\n          O[to] = O[from32];\n        else\n          delete O[to];\n      }\n      for (k2 = len; k2 > len - actualDeleteCount + insertCount; k2--)\n        delete O[k2 - 1];\n    } else if (insertCount > actualDeleteCount) {\n      for (k2 = len - actualDeleteCount; k2 > actualStart; k2--) {\n        from32 = k2 + actualDeleteCount - 1;\n        to = k2 + insertCount - 1;\n        if (from32 in O)\n          O[to] = O[from32];\n        else\n          delete O[to];\n      }\n    }\n    for (k2 = 0; k2 < insertCount; k2++) {\n      O[k2 + actualStart] = arguments[k2 + 2];\n    }\n    O.length = len - actualDeleteCount + insertCount;\n    return A2;\n  }\n});\nvar entryVirtual$b2 = entryVirtual$i2;\nvar splice$4 = entryVirtual$b2(\"Array\").splice;\nvar isPrototypeOf$b2 = objectIsPrototypeOf2;\nvar method$82 = splice$4;\nvar ArrayPrototype$92 = Array.prototype;\nvar splice$32 = function(it2) {\n  var own = it2.splice;\n  return it2 === ArrayPrototype$92 || isPrototypeOf$b2(ArrayPrototype$92, it2) && own === ArrayPrototype$92.splice ? method$82 : own;\n};\nvar parent$y2 = splice$32;\nvar splice$22 = parent$y2;\nvar splice$12 = splice$22;\nvar $$p2 = _export2;\nvar $includes2 = arrayIncludes2.includes;\n$$p2({\n  target: \"Array\",\n  proto: true\n}, {\n  includes: function includes3(el) {\n    return $includes2(this, el, arguments.length > 1 ? arguments[1] : void 0);\n  }\n});\nvar entryVirtual$a2 = entryVirtual$i2;\nvar includes$4 = entryVirtual$a2(\"Array\").includes;\nvar isObject$82 = isObject$j;\nvar classof$32 = classofRaw$12;\nvar wellKnownSymbol$22 = wellKnownSymbol$j2;\nvar MATCH$12 = wellKnownSymbol$22(\"match\");\nvar isRegexp2 = function(it2) {\n  var isRegExp22;\n  return isObject$82(it2) && ((isRegExp22 = it2[MATCH$12]) !== void 0 ? !!isRegExp22 : classof$32(it2) == \"RegExp\");\n};\nvar global$e2 = global$O;\nvar isRegExp2 = isRegexp2;\nvar TypeError$62 = global$e2.TypeError;\nvar notARegexp2 = function(it2) {\n  if (isRegExp2(it2)) {\n    throw TypeError$62(\"The method doesn't accept regular expressions\");\n  }\n  return it2;\n};\nvar wellKnownSymbol$12 = wellKnownSymbol$j2;\nvar MATCH2 = wellKnownSymbol$12(\"match\");\nvar correctIsRegexpLogic2 = function(METHOD_NAME) {\n  var regexp = /./;\n  try {\n    \"/./\"[METHOD_NAME](regexp);\n  } catch (error1) {\n    try {\n      regexp[MATCH2] = false;\n      return \"/./\"[METHOD_NAME](regexp);\n    } catch (error2) {\n    }\n  }\n  return false;\n};\nvar $$o2 = _export2;\nvar uncurryThis$a2 = functionUncurryThis2;\nvar notARegExp2 = notARegexp2;\nvar requireObjectCoercible$12 = requireObjectCoercible$52;\nvar toString$42 = toString$82;\nvar correctIsRegExpLogic2 = correctIsRegexpLogic2;\nvar stringIndexOf2 = uncurryThis$a2(\"\".indexOf);\n$$o2({\n  target: \"String\",\n  proto: true,\n  forced: !correctIsRegExpLogic2(\"includes\")\n}, {\n  includes: function includes22(searchString) {\n    return !!~stringIndexOf2(toString$42(requireObjectCoercible$12(this)), toString$42(notARegExp2(searchString)), arguments.length > 1 ? arguments[1] : void 0);\n  }\n});\nvar entryVirtual$92 = entryVirtual$i2;\nvar includes$3 = entryVirtual$92(\"String\").includes;\nvar isPrototypeOf$a2 = objectIsPrototypeOf2;\nvar arrayMethod = includes$4;\nvar stringMethod = includes$3;\nvar ArrayPrototype$82 = Array.prototype;\nvar StringPrototype = String.prototype;\nvar includes$2 = function(it2) {\n  var own = it2.includes;\n  if (it2 === ArrayPrototype$82 || isPrototypeOf$a2(ArrayPrototype$82, it2) && own === ArrayPrototype$82.includes)\n    return arrayMethod;\n  if (typeof it2 == \"string\" || it2 === StringPrototype || isPrototypeOf$a2(StringPrototype, it2) && own === StringPrototype.includes) {\n    return stringMethod;\n  }\n  return own;\n};\nvar parent$x2 = includes$2;\nvar includes$1 = parent$x2;\nvar includes32 = includes$1;\nvar $$n2 = _export2;\nvar fails$b2 = fails$t;\nvar toObject$32 = toObject$d2;\nvar nativeGetPrototypeOf2 = objectGetPrototypeOf2;\nvar CORRECT_PROTOTYPE_GETTER2 = correctPrototypeGetter2;\nvar FAILS_ON_PRIMITIVES$22 = fails$b2(function() {\n  nativeGetPrototypeOf2(1);\n});\n$$n2({\n  target: \"Object\",\n  stat: true,\n  forced: FAILS_ON_PRIMITIVES$22,\n  sham: !CORRECT_PROTOTYPE_GETTER2\n}, {\n  getPrototypeOf: function getPrototypeOf3(it2) {\n    return nativeGetPrototypeOf2(toObject$32(it2));\n  }\n});\nvar path$h2 = path$y;\nvar getPrototypeOf$62 = path$h2.Object.getPrototypeOf;\nvar parent$w2 = getPrototypeOf$62;\nvar getPrototypeOf$52 = parent$w2;\nvar getPrototypeOf$42 = getPrototypeOf$52;\nvar $$m2 = _export2;\nvar $filter2 = arrayIteration2.filter;\nvar arrayMethodHasSpeciesSupport2 = arrayMethodHasSpeciesSupport$52;\nvar HAS_SPECIES_SUPPORT2 = arrayMethodHasSpeciesSupport2(\"filter\");\n$$m2({\n  target: \"Array\",\n  proto: true,\n  forced: !HAS_SPECIES_SUPPORT2\n}, {\n  filter: function filter3(callbackfn) {\n    return $filter2(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);\n  }\n});\nvar entryVirtual$82 = entryVirtual$i2;\nvar filter$32 = entryVirtual$82(\"Array\").filter;\nvar isPrototypeOf$92 = objectIsPrototypeOf2;\nvar method$72 = filter$32;\nvar ArrayPrototype$72 = Array.prototype;\nvar filter$22 = function(it2) {\n  var own = it2.filter;\n  return it2 === ArrayPrototype$72 || isPrototypeOf$92(ArrayPrototype$72, it2) && own === ArrayPrototype$72.filter ? method$72 : own;\n};\nvar parent$v2 = filter$22;\nvar filter$12 = parent$v2;\nvar filter22 = filter$12;\nvar DESCRIPTORS$42 = descriptors2;\nvar uncurryThis$92 = functionUncurryThis2;\nvar objectKeys2 = objectKeys$42;\nvar toIndexedObject2 = toIndexedObject$b2;\nvar $propertyIsEnumerable2 = objectPropertyIsEnumerable2.f;\nvar propertyIsEnumerable32 = uncurryThis$92($propertyIsEnumerable2);\nvar push$22 = uncurryThis$92([].push);\nvar createMethod$22 = function(TO_ENTRIES) {\n  return function(it2) {\n    var O = toIndexedObject2(it2);\n    var keys42 = objectKeys2(O);\n    var length2 = keys42.length;\n    var i = 0;\n    var result2 = [];\n    var key;\n    while (length2 > i) {\n      key = keys42[i++];\n      if (!DESCRIPTORS$42 || propertyIsEnumerable32(O, key)) {\n        push$22(result2, TO_ENTRIES ? [key, O[key]] : O[key]);\n      }\n    }\n    return result2;\n  };\n};\nvar objectToArray2 = {\n  entries: createMethod$22(true),\n  values: createMethod$22(false)\n};\nvar $$l2 = _export2;\nvar $values2 = objectToArray2.values;\n$$l2({\n  target: \"Object\",\n  stat: true\n}, {\n  values: function values3(O) {\n    return $values2(O);\n  }\n});\nvar path$g2 = path$y;\npath$g2.Object.values;\nvar whitespaces$4 = \"\t\\n\\v\\f\\r \\xA0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF\";\nvar uncurryThis$82 = functionUncurryThis2;\nvar requireObjectCoercible2 = requireObjectCoercible$52;\nvar toString$32 = toString$82;\nvar whitespaces$32 = whitespaces$4;\nvar replace$12 = uncurryThis$82(\"\".replace);\nvar whitespace2 = \"[\" + whitespaces$32 + \"]\";\nvar ltrim2 = RegExp(\"^\" + whitespace2 + whitespace2 + \"*\");\nvar rtrim2 = RegExp(whitespace2 + whitespace2 + \"*$\");\nvar createMethod$12 = function(TYPE) {\n  return function($this) {\n    var string22 = toString$32(requireObjectCoercible2($this));\n    if (TYPE & 1)\n      string22 = replace$12(string22, ltrim2, \"\");\n    if (TYPE & 2)\n      string22 = replace$12(string22, rtrim2, \"\");\n    return string22;\n  };\n};\nvar stringTrim2 = {\n  start: createMethod$12(1),\n  end: createMethod$12(2),\n  trim: createMethod$12(3)\n};\nvar global$d2 = global$O;\nvar fails$a2 = fails$t;\nvar uncurryThis$72 = functionUncurryThis2;\nvar toString$22 = toString$82;\nvar trim$1 = stringTrim2.trim;\nvar whitespaces$22 = whitespaces$4;\nvar $parseInt$12 = global$d2.parseInt;\nvar Symbol$22 = global$d2.Symbol;\nvar ITERATOR$12 = Symbol$22 && Symbol$22.iterator;\nvar hex2 = /^[+-]?0x/i;\nvar exec$12 = uncurryThis$72(hex2.exec);\nvar FORCED$42 = $parseInt$12(whitespaces$22 + \"08\") !== 8 || $parseInt$12(whitespaces$22 + \"0x16\") !== 22 || ITERATOR$12 && !fails$a2(function() {\n  $parseInt$12(Object(ITERATOR$12));\n});\nvar numberParseInt2 = FORCED$42 ? function parseInt22(string22, radix) {\n  var S2 = trim$1(toString$22(string22));\n  return $parseInt$12(S2, radix >>> 0 || (exec$12(hex2, S2) ? 16 : 10));\n} : $parseInt$12;\nvar $$k2 = _export2;\nvar $parseInt2 = numberParseInt2;\n$$k2({\n  global: true,\n  forced: parseInt != $parseInt2\n}, {\n  parseInt: $parseInt2\n});\nvar path$f2 = path$y;\nvar _parseInt$2 = path$f2.parseInt;\nvar parent$u2 = _parseInt$2;\nvar _parseInt$1 = parent$u2;\nvar _parseInt = _parseInt$1;\nvar $$j2 = _export2;\nvar uncurryThis$62 = functionUncurryThis2;\nvar $IndexOf2 = arrayIncludes2.indexOf;\nvar arrayMethodIsStrict$42 = arrayMethodIsStrict$6;\nvar un$IndexOf2 = uncurryThis$62([].indexOf);\nvar NEGATIVE_ZERO2 = !!un$IndexOf2 && 1 / un$IndexOf2([1], 1, -0) < 0;\nvar STRICT_METHOD$42 = arrayMethodIsStrict$42(\"indexOf\");\n$$j2({\n  target: \"Array\",\n  proto: true,\n  forced: NEGATIVE_ZERO2 || !STRICT_METHOD$42\n}, {\n  indexOf: function indexOf3(searchElement) {\n    var fromIndex = arguments.length > 1 ? arguments[1] : void 0;\n    return NEGATIVE_ZERO2 ? un$IndexOf2(this, searchElement, fromIndex) || 0 : $IndexOf2(this, searchElement, fromIndex);\n  }\n});\nvar entryVirtual$72 = entryVirtual$i2;\nvar indexOf$3 = entryVirtual$72(\"Array\").indexOf;\nvar isPrototypeOf$82 = objectIsPrototypeOf2;\nvar method$62 = indexOf$3;\nvar ArrayPrototype$62 = Array.prototype;\nvar indexOf$2 = function(it2) {\n  var own = it2.indexOf;\n  return it2 === ArrayPrototype$62 || isPrototypeOf$82(ArrayPrototype$62, it2) && own === ArrayPrototype$62.indexOf ? method$62 : own;\n};\nvar parent$t2 = indexOf$2;\nvar indexOf$1 = parent$t2;\nvar indexOf22 = indexOf$1;\nvar PROPER_FUNCTION_NAME2 = functionName2.PROPER;\nvar fails$92 = fails$t;\nvar whitespaces$12 = whitespaces$4;\nvar non2 = \"\\u200B\\x85\\u180E\";\nvar stringTrimForced2 = function(METHOD_NAME) {\n  return fails$92(function() {\n    return !!whitespaces$12[METHOD_NAME]() || non2[METHOD_NAME]() !== non2 || PROPER_FUNCTION_NAME2 && whitespaces$12[METHOD_NAME].name !== METHOD_NAME;\n  });\n};\nvar $$i2 = _export2;\nvar $trim2 = stringTrim2.trim;\nvar forcedStringTrimMethod2 = stringTrimForced2;\n$$i2({\n  target: \"String\",\n  proto: true,\n  forced: forcedStringTrimMethod2(\"trim\")\n}, {\n  trim: function trim3() {\n    return $trim2(this);\n  }\n});\nvar entryVirtual$62 = entryVirtual$i2;\nentryVirtual$62(\"String\").trim;\nvar $$h2 = _export2;\nvar DESCRIPTORS$32 = descriptors2;\nvar create$82 = objectCreate2;\n$$h2({\n  target: \"Object\",\n  stat: true,\n  sham: !DESCRIPTORS$32\n}, {\n  create: create$82\n});\nvar path$e2 = path$y;\nvar Object$22 = path$e2.Object;\nvar create$72 = function create32(P, D2) {\n  return Object$22.create(P, D2);\n};\nvar parent$s2 = create$72;\nvar create$62 = parent$s2;\nvar create$52 = create$62;\nvar $$g2 = _export2;\nvar global$c2 = global$O;\nvar getBuiltIn$22 = getBuiltIn$92;\nvar apply$32 = functionApply2;\nvar uncurryThis$52 = functionUncurryThis2;\nvar fails$82 = fails$t;\nvar Array$12 = global$c2.Array;\nvar $stringify2 = getBuiltIn$22(\"JSON\", \"stringify\");\nvar exec2 = uncurryThis$52(/./.exec);\nvar charAt$12 = uncurryThis$52(\"\".charAt);\nvar charCodeAt2 = uncurryThis$52(\"\".charCodeAt);\nvar replace2 = uncurryThis$52(\"\".replace);\nvar numberToString2 = uncurryThis$52(1 .toString);\nvar tester2 = /[\\uD800-\\uDFFF]/g;\nvar low2 = /^[\\uD800-\\uDBFF]$/;\nvar hi2 = /^[\\uDC00-\\uDFFF]$/;\nvar fix2 = function(match22, offset, string22) {\n  var prev = charAt$12(string22, offset - 1);\n  var next3 = charAt$12(string22, offset + 1);\n  if (exec2(low2, match22) && !exec2(hi2, next3) || exec2(hi2, match22) && !exec2(low2, prev)) {\n    return \"\\\\u\" + numberToString2(charCodeAt2(match22, 0), 16);\n  }\n  return match22;\n};\nvar FORCED$32 = fails$82(function() {\n  return $stringify2(\"\\uDF06\\uD834\") !== '\"\\\\udf06\\\\ud834\"' || $stringify2(\"\\uDEAD\") !== '\"\\\\udead\"';\n});\nif ($stringify2) {\n  $$g2({\n    target: \"JSON\",\n    stat: true,\n    forced: FORCED$32\n  }, {\n    stringify: function stringify32(it2, replacer, space) {\n      for (var i = 0, l = arguments.length, args = Array$12(l); i < l; i++)\n        args[i] = arguments[i];\n      var result2 = apply$32($stringify2, null, args);\n      return typeof result2 == \"string\" ? replace2(result2, tester2, fix2) : result2;\n    }\n  });\n}\nvar path$d2 = path$y;\nvar apply$22 = functionApply2;\nif (!path$d2.JSON)\n  path$d2.JSON = {\n    stringify: JSON.stringify\n  };\nvar stringify$32 = function stringify3(it2, replacer, space) {\n  return apply$22(path$d2.JSON.stringify, null, arguments);\n};\nvar parent$r2 = stringify$32;\nvar stringify$22 = parent$r2;\nvar stringify$12 = stringify$22;\nvar global$b2 = global$O;\nvar TypeError$52 = global$b2.TypeError;\nvar validateArgumentsLength$12 = function(passed, required) {\n  if (passed < required)\n    throw TypeError$52(\"Not enough arguments\");\n  return passed;\n};\nvar $$f2 = _export2;\nvar global$a2 = global$O;\nvar apply$12 = functionApply2;\nvar isCallable$12 = isCallable$h2;\nvar userAgent$22 = engineUserAgent2;\nvar arraySlice$12 = arraySlice$52;\nvar validateArgumentsLength2 = validateArgumentsLength$12;\nvar MSIE2 = /MSIE .\\./.test(userAgent$22);\nvar Function$12 = global$a2.Function;\nvar wrap2 = function(scheduler) {\n  return function(handler, timeout) {\n    var boundArgs = validateArgumentsLength2(arguments.length, 1) > 2;\n    var fn = isCallable$12(handler) ? handler : Function$12(handler);\n    var args = boundArgs ? arraySlice$12(arguments, 2) : void 0;\n    return scheduler(boundArgs ? function() {\n      apply$12(fn, this, args);\n    } : fn, timeout);\n  };\n};\n$$f2({\n  global: true,\n  bind: true,\n  forced: MSIE2\n}, {\n  setTimeout: wrap2(global$a2.setTimeout),\n  setInterval: wrap2(global$a2.setInterval)\n});\nvar path$c2 = path$y;\nvar setTimeout$22 = path$c2.setTimeout;\nvar setTimeout$12 = setTimeout$22;\nvar toObject$22 = toObject$d2;\nvar toAbsoluteIndex2 = toAbsoluteIndex$52;\nvar lengthOfArrayLike$32 = lengthOfArrayLike$b2;\nvar arrayFill2 = function fill3(value) {\n  var O = toObject$22(this);\n  var length2 = lengthOfArrayLike$32(O);\n  var argumentsLength = arguments.length;\n  var index2 = toAbsoluteIndex2(argumentsLength > 1 ? arguments[1] : void 0, length2);\n  var end = argumentsLength > 2 ? arguments[2] : void 0;\n  var endPos = end === void 0 ? length2 : toAbsoluteIndex2(end, length2);\n  while (endPos > index2)\n    O[index2++] = value;\n  return O;\n};\nvar $$e2 = _export2;\nvar fill$4 = arrayFill2;\n$$e2({\n  target: \"Array\",\n  proto: true\n}, {\n  fill: fill$4\n});\nvar entryVirtual$52 = entryVirtual$i2;\nvar fill$3 = entryVirtual$52(\"Array\").fill;\nvar isPrototypeOf$72 = objectIsPrototypeOf2;\nvar method$52 = fill$3;\nvar ArrayPrototype$52 = Array.prototype;\nvar fill$2 = function(it2) {\n  var own = it2.fill;\n  return it2 === ArrayPrototype$52 || isPrototypeOf$72(ArrayPrototype$52, it2) && own === ArrayPrototype$52.fill ? method$52 : own;\n};\nvar parent$q2 = fill$2;\nvar fill$1 = parent$q2;\nvar fill22 = fill$1;\nfunction _extends2() {\n  _extends2 = Object.assign || function(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends2.apply(this, arguments);\n}\nfunction _inheritsLoose2(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\nfunction _assertThisInitialized$12(self2) {\n  if (self2 === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self2;\n}\nvar assign22;\nif (typeof Object.assign !== \"function\") {\n  assign22 = function assign32(target) {\n    if (target === void 0 || target === null) {\n      throw new TypeError(\"Cannot convert undefined or null to object\");\n    }\n    var output = Object(target);\n    for (var index2 = 1; index2 < arguments.length; index2++) {\n      var source = arguments[index2];\n      if (source !== void 0 && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n    return output;\n  };\n} else {\n  assign22 = Object.assign;\n}\nvar assign$12 = assign22;\nvar VENDOR_PREFIXES2 = [\"\", \"webkit\", \"Moz\", \"MS\", \"ms\", \"o\"];\nvar TEST_ELEMENT2 = typeof document === \"undefined\" ? {\n  style: {}\n} : document.createElement(\"div\");\nvar TYPE_FUNCTION2 = \"function\";\nvar round2 = Math.round;\nvar abs$1 = Math.abs;\nvar now22 = Date.now;\nfunction prefixed2(obj, property) {\n  var prefix;\n  var prop;\n  var camelProp = property[0].toUpperCase() + property.slice(1);\n  var i = 0;\n  while (i < VENDOR_PREFIXES2.length) {\n    prefix = VENDOR_PREFIXES2[i];\n    prop = prefix ? prefix + camelProp : property;\n    if (prop in obj) {\n      return prop;\n    }\n    i++;\n  }\n  return void 0;\n}\nvar win2;\nif (typeof window === \"undefined\") {\n  win2 = {};\n} else {\n  win2 = window;\n}\nvar PREFIXED_TOUCH_ACTION2 = prefixed2(TEST_ELEMENT2.style, \"touchAction\");\nvar NATIVE_TOUCH_ACTION2 = PREFIXED_TOUCH_ACTION2 !== void 0;\nfunction getTouchActionProps2() {\n  if (!NATIVE_TOUCH_ACTION2) {\n    return false;\n  }\n  var touchMap = {};\n  var cssSupports = win2.CSS && win2.CSS.supports;\n  [\"auto\", \"manipulation\", \"pan-y\", \"pan-x\", \"pan-x pan-y\", \"none\"].forEach(function(val) {\n    return touchMap[val] = cssSupports ? win2.CSS.supports(\"touch-action\", val) : true;\n  });\n  return touchMap;\n}\nvar TOUCH_ACTION_COMPUTE2 = \"compute\";\nvar TOUCH_ACTION_AUTO2 = \"auto\";\nvar TOUCH_ACTION_MANIPULATION2 = \"manipulation\";\nvar TOUCH_ACTION_NONE2 = \"none\";\nvar TOUCH_ACTION_PAN_X2 = \"pan-x\";\nvar TOUCH_ACTION_PAN_Y2 = \"pan-y\";\nvar TOUCH_ACTION_MAP2 = getTouchActionProps2();\nvar MOBILE_REGEX2 = /mobile|tablet|ip(ad|hone|od)|android/i;\nvar SUPPORT_TOUCH2 = \"ontouchstart\" in win2;\nvar SUPPORT_POINTER_EVENTS2 = prefixed2(win2, \"PointerEvent\") !== void 0;\nvar SUPPORT_ONLY_TOUCH2 = SUPPORT_TOUCH2 && MOBILE_REGEX2.test(navigator.userAgent);\nvar INPUT_TYPE_TOUCH2 = \"touch\";\nvar INPUT_TYPE_PEN2 = \"pen\";\nvar INPUT_TYPE_MOUSE2 = \"mouse\";\nvar INPUT_TYPE_KINECT2 = \"kinect\";\nvar COMPUTE_INTERVAL2 = 25;\nvar INPUT_START2 = 1;\nvar INPUT_MOVE2 = 2;\nvar INPUT_END2 = 4;\nvar INPUT_CANCEL2 = 8;\nvar DIRECTION_NONE2 = 1;\nvar DIRECTION_LEFT2 = 2;\nvar DIRECTION_RIGHT2 = 4;\nvar DIRECTION_UP2 = 8;\nvar DIRECTION_DOWN2 = 16;\nvar DIRECTION_HORIZONTAL2 = DIRECTION_LEFT2 | DIRECTION_RIGHT2;\nvar DIRECTION_VERTICAL2 = DIRECTION_UP2 | DIRECTION_DOWN2;\nvar DIRECTION_ALL2 = DIRECTION_HORIZONTAL2 | DIRECTION_VERTICAL2;\nvar PROPS_XY2 = [\"x\", \"y\"];\nvar PROPS_CLIENT_XY2 = [\"clientX\", \"clientY\"];\nfunction each2(obj, iterator22, context) {\n  var i;\n  if (!obj) {\n    return;\n  }\n  if (obj.forEach) {\n    obj.forEach(iterator22, context);\n  } else if (obj.length !== void 0) {\n    i = 0;\n    while (i < obj.length) {\n      iterator22.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator22.call(context, obj[i], i, obj);\n    }\n  }\n}\nfunction boolOrFn2(val, args) {\n  if (typeof val === TYPE_FUNCTION2) {\n    return val.apply(args ? args[0] || void 0 : void 0, args);\n  }\n  return val;\n}\nfunction inStr2(str, find2) {\n  return str.indexOf(find2) > -1;\n}\nfunction cleanTouchActions2(actions) {\n  if (inStr2(actions, TOUCH_ACTION_NONE2)) {\n    return TOUCH_ACTION_NONE2;\n  }\n  var hasPanX = inStr2(actions, TOUCH_ACTION_PAN_X2);\n  var hasPanY = inStr2(actions, TOUCH_ACTION_PAN_Y2);\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE2;\n  }\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X2 : TOUCH_ACTION_PAN_Y2;\n  }\n  if (inStr2(actions, TOUCH_ACTION_MANIPULATION2)) {\n    return TOUCH_ACTION_MANIPULATION2;\n  }\n  return TOUCH_ACTION_AUTO2;\n}\nvar TouchAction2 = /* @__PURE__ */ function() {\n  function TouchAction22(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  var _proto = TouchAction22.prototype;\n  _proto.set = function set22(value) {\n    if (value === TOUCH_ACTION_COMPUTE2) {\n      value = this.compute();\n    }\n    if (NATIVE_TOUCH_ACTION2 && this.manager.element.style && TOUCH_ACTION_MAP2[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION2] = value;\n    }\n    this.actions = value.toLowerCase().trim();\n  };\n  _proto.update = function update() {\n    this.set(this.manager.options.touchAction);\n  };\n  _proto.compute = function compute() {\n    var actions = [];\n    each2(this.manager.recognizers, function(recognizer) {\n      if (boolOrFn2(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions2(actions.join(\" \"));\n  };\n  _proto.preventDefaults = function preventDefaults(input) {\n    var srcEvent = input.srcEvent;\n    var direction = input.offsetDirection;\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n    var actions = this.actions;\n    var hasNone = inStr2(actions, TOUCH_ACTION_NONE2) && !TOUCH_ACTION_MAP2[TOUCH_ACTION_NONE2];\n    var hasPanY = inStr2(actions, TOUCH_ACTION_PAN_Y2) && !TOUCH_ACTION_MAP2[TOUCH_ACTION_PAN_Y2];\n    var hasPanX = inStr2(actions, TOUCH_ACTION_PAN_X2) && !TOUCH_ACTION_MAP2[TOUCH_ACTION_PAN_X2];\n    if (hasNone) {\n      var isTapPointer = input.pointers.length === 1;\n      var isTapMovement = input.distance < 2;\n      var isTapTouchTime = input.deltaTime < 250;\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n    if (hasPanX && hasPanY) {\n      return;\n    }\n    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL2 || hasPanX && direction & DIRECTION_VERTICAL2) {\n      return this.preventSrc(srcEvent);\n    }\n  };\n  _proto.preventSrc = function preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  };\n  return TouchAction22;\n}();\nfunction hasParent2(node, parent22) {\n  while (node) {\n    if (node === parent22) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\nfunction getCenter2(pointers) {\n  var pointersLength = pointers.length;\n  if (pointersLength === 1) {\n    return {\n      x: round2(pointers[0].clientX),\n      y: round2(pointers[0].clientY)\n    };\n  }\n  var x = 0;\n  var y = 0;\n  var i = 0;\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n  return {\n    x: round2(x / pointersLength),\n    y: round2(y / pointersLength)\n  };\n}\nfunction simpleCloneInputData2(input) {\n  var pointers = [];\n  var i = 0;\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round2(input.pointers[i].clientX),\n      clientY: round2(input.pointers[i].clientY)\n    };\n    i++;\n  }\n  return {\n    timeStamp: now22(),\n    pointers,\n    center: getCenter2(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\nfunction getDistance2(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY2;\n  }\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.sqrt(x * x + y * y);\n}\nfunction getAngle2(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY2;\n  }\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\nfunction getDirection2(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE2;\n  }\n  if (abs$1(x) >= abs$1(y)) {\n    return x < 0 ? DIRECTION_LEFT2 : DIRECTION_RIGHT2;\n  }\n  return y < 0 ? DIRECTION_UP2 : DIRECTION_DOWN2;\n}\nfunction computeDeltaXY2(session, input) {\n  var center = input.center;\n  var offset = session.offsetDelta || {};\n  var prevDelta = session.prevDelta || {};\n  var prevInput = session.prevInput || {};\n  if (input.eventType === INPUT_START2 || prevInput.eventType === INPUT_END2) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\nfunction getVelocity2(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\nfunction getScale2(start, end) {\n  return getDistance2(end[0], end[1], PROPS_CLIENT_XY2) / getDistance2(start[0], start[1], PROPS_CLIENT_XY2);\n}\nfunction getRotation2(start, end) {\n  return getAngle2(end[1], end[0], PROPS_CLIENT_XY2) + getAngle2(start[1], start[0], PROPS_CLIENT_XY2);\n}\nfunction computeIntervalInputData2(session, input) {\n  var last = session.lastInterval || input;\n  var deltaTime = input.timeStamp - last.timeStamp;\n  var velocity;\n  var velocityX;\n  var velocityY;\n  var direction;\n  if (input.eventType !== INPUT_CANCEL2 && (deltaTime > COMPUTE_INTERVAL2 || last.velocity === void 0)) {\n    var deltaX = input.deltaX - last.deltaX;\n    var deltaY = input.deltaY - last.deltaY;\n    var v = getVelocity2(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = abs$1(v.x) > abs$1(v.y) ? v.x : v.y;\n    direction = getDirection2(deltaX, deltaY);\n    session.lastInterval = input;\n  } else {\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\nfunction computeInputData2(manager, input) {\n  var session = manager.session;\n  var pointers = input.pointers;\n  var pointersLength = pointers.length;\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData2(input);\n  }\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData2(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n  var firstInput = session.firstInput, firstMultiple = session.firstMultiple;\n  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n  var center = input.center = getCenter2(pointers);\n  input.timeStamp = now22();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n  input.angle = getAngle2(offsetCenter, center);\n  input.distance = getDistance2(offsetCenter, center);\n  computeDeltaXY2(session, input);\n  input.offsetDirection = getDirection2(input.deltaX, input.deltaY);\n  var overallVelocity = getVelocity2(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = abs$1(overallVelocity.x) > abs$1(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n  input.scale = firstMultiple ? getScale2(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation2(firstMultiple.pointers, pointers) : 0;\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n  computeIntervalInputData2(session, input);\n  var target = manager.element;\n  var srcEvent = input.srcEvent;\n  var srcEventTarget;\n  if (srcEvent.composedPath) {\n    srcEventTarget = srcEvent.composedPath()[0];\n  } else if (srcEvent.path) {\n    srcEventTarget = srcEvent.path[0];\n  } else {\n    srcEventTarget = srcEvent.target;\n  }\n  if (hasParent2(srcEventTarget, target)) {\n    target = srcEventTarget;\n  }\n  input.target = target;\n}\nfunction inputHandler2(manager, eventType, input) {\n  var pointersLen = input.pointers.length;\n  var changedPointersLen = input.changedPointers.length;\n  var isFirst = eventType & INPUT_START2 && pointersLen - changedPointersLen === 0;\n  var isFinal = eventType & (INPUT_END2 | INPUT_CANCEL2) && pointersLen - changedPointersLen === 0;\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n  if (isFirst) {\n    manager.session = {};\n  }\n  input.eventType = eventType;\n  computeInputData2(manager, input);\n  manager.emit(\"hammer.input\", input);\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\nfunction splitStr2(str) {\n  return str.trim().split(/\\s+/g);\n}\nfunction addEventListeners2(target, types, handler) {\n  each2(splitStr2(types), function(type2) {\n    target.addEventListener(type2, handler, false);\n  });\n}\nfunction removeEventListeners2(target, types, handler) {\n  each2(splitStr2(types), function(type2) {\n    target.removeEventListener(type2, handler, false);\n  });\n}\nfunction getWindowForElement2(element) {\n  var doc = element.ownerDocument || element;\n  return doc.defaultView || doc.parentWindow || window;\n}\nvar Input2 = /* @__PURE__ */ function() {\n  function Input22(manager, callback) {\n    var self2 = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n    this.domHandler = function(ev) {\n      if (boolOrFn2(manager.options.enable, [manager])) {\n        self2.handler(ev);\n      }\n    };\n    this.init();\n  }\n  var _proto = Input22.prototype;\n  _proto.handler = function handler() {\n  };\n  _proto.init = function init() {\n    this.evEl && addEventListeners2(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners2(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners2(getWindowForElement2(this.element), this.evWin, this.domHandler);\n  };\n  _proto.destroy = function destroy() {\n    this.evEl && removeEventListeners2(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners2(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners2(getWindowForElement2(this.element), this.evWin, this.domHandler);\n  };\n  return Input22;\n}();\nfunction inArray2(src, find2, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find2);\n  } else {\n    var i = 0;\n    while (i < src.length) {\n      if (findByKey && src[i][findByKey] == find2 || !findByKey && src[i] === find2) {\n        return i;\n      }\n      i++;\n    }\n    return -1;\n  }\n}\nvar POINTER_INPUT_MAP2 = {\n  pointerdown: INPUT_START2,\n  pointermove: INPUT_MOVE2,\n  pointerup: INPUT_END2,\n  pointercancel: INPUT_CANCEL2,\n  pointerout: INPUT_CANCEL2\n};\nvar IE10_POINTER_TYPE_ENUM2 = {\n  2: INPUT_TYPE_TOUCH2,\n  3: INPUT_TYPE_PEN2,\n  4: INPUT_TYPE_MOUSE2,\n  5: INPUT_TYPE_KINECT2\n};\nvar POINTER_ELEMENT_EVENTS2 = \"pointerdown\";\nvar POINTER_WINDOW_EVENTS2 = \"pointermove pointerup pointercancel\";\nif (win2.MSPointerEvent && !win2.PointerEvent) {\n  POINTER_ELEMENT_EVENTS2 = \"MSPointerDown\";\n  POINTER_WINDOW_EVENTS2 = \"MSPointerMove MSPointerUp MSPointerCancel\";\n}\nvar PointerEventInput2 = /* @__PURE__ */ function(_Input) {\n  _inheritsLoose2(PointerEventInput22, _Input);\n  function PointerEventInput22() {\n    var _this;\n    var proto = PointerEventInput22.prototype;\n    proto.evEl = POINTER_ELEMENT_EVENTS2;\n    proto.evWin = POINTER_WINDOW_EVENTS2;\n    _this = _Input.apply(this, arguments) || this;\n    _this.store = _this.manager.session.pointerEvents = [];\n    return _this;\n  }\n  var _proto = PointerEventInput22.prototype;\n  _proto.handler = function handler(ev) {\n    var store = this.store;\n    var removePointer = false;\n    var eventTypeNormalized = ev.type.toLowerCase().replace(\"ms\", \"\");\n    var eventType = POINTER_INPUT_MAP2[eventTypeNormalized];\n    var pointerType = IE10_POINTER_TYPE_ENUM2[ev.pointerType] || ev.pointerType;\n    var isTouch = pointerType === INPUT_TYPE_TOUCH2;\n    var storeIndex = inArray2(store, ev.pointerId, \"pointerId\");\n    if (eventType & INPUT_START2 && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END2 | INPUT_CANCEL2)) {\n      removePointer = true;\n    }\n    if (storeIndex < 0) {\n      return;\n    }\n    store[storeIndex] = ev;\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType,\n      srcEvent: ev\n    });\n    if (removePointer) {\n      store.splice(storeIndex, 1);\n    }\n  };\n  return PointerEventInput22;\n}(Input2);\nfunction toArray2(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\nfunction uniqueArray2(src, key, sort32) {\n  var results = [];\n  var values32 = [];\n  var i = 0;\n  while (i < src.length) {\n    var val = key ? src[i][key] : src[i];\n    if (inArray2(values32, val) < 0) {\n      results.push(src[i]);\n    }\n    values32[i] = val;\n    i++;\n  }\n  if (sort32) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort(function(a, b) {\n        return a[key] > b[key];\n      });\n    }\n  }\n  return results;\n}\nvar TOUCH_INPUT_MAP2 = {\n  touchstart: INPUT_START2,\n  touchmove: INPUT_MOVE2,\n  touchend: INPUT_END2,\n  touchcancel: INPUT_CANCEL2\n};\nvar TOUCH_TARGET_EVENTS2 = \"touchstart touchmove touchend touchcancel\";\nvar TouchInput2 = /* @__PURE__ */ function(_Input) {\n  _inheritsLoose2(TouchInput22, _Input);\n  function TouchInput22() {\n    var _this;\n    TouchInput22.prototype.evTarget = TOUCH_TARGET_EVENTS2;\n    _this = _Input.apply(this, arguments) || this;\n    _this.targetIds = {};\n    return _this;\n  }\n  var _proto = TouchInput22.prototype;\n  _proto.handler = function handler(ev) {\n    var type2 = TOUCH_INPUT_MAP2[ev.type];\n    var touches = getTouches2.call(this, ev, type2);\n    if (!touches) {\n      return;\n    }\n    this.callback(this.manager, type2, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH2,\n      srcEvent: ev\n    });\n  };\n  return TouchInput22;\n}(Input2);\nfunction getTouches2(ev, type2) {\n  var allTouches = toArray2(ev.touches);\n  var targetIds = this.targetIds;\n  if (type2 & (INPUT_START2 | INPUT_MOVE2) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n  var i;\n  var targetTouches;\n  var changedTouches = toArray2(ev.changedTouches);\n  var changedTargetTouches = [];\n  var target = this.target;\n  targetTouches = allTouches.filter(function(touch) {\n    return hasParent2(touch.target, target);\n  });\n  if (type2 === INPUT_START2) {\n    i = 0;\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  }\n  i = 0;\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    }\n    if (type2 & (INPUT_END2 | INPUT_CANCEL2)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n    i++;\n  }\n  if (!changedTargetTouches.length) {\n    return;\n  }\n  return [\n    uniqueArray2(targetTouches.concat(changedTargetTouches), \"identifier\", true),\n    changedTargetTouches\n  ];\n}\nvar MOUSE_INPUT_MAP2 = {\n  mousedown: INPUT_START2,\n  mousemove: INPUT_MOVE2,\n  mouseup: INPUT_END2\n};\nvar MOUSE_ELEMENT_EVENTS2 = \"mousedown\";\nvar MOUSE_WINDOW_EVENTS2 = \"mousemove mouseup\";\nvar MouseInput2 = /* @__PURE__ */ function(_Input) {\n  _inheritsLoose2(MouseInput22, _Input);\n  function MouseInput22() {\n    var _this;\n    var proto = MouseInput22.prototype;\n    proto.evEl = MOUSE_ELEMENT_EVENTS2;\n    proto.evWin = MOUSE_WINDOW_EVENTS2;\n    _this = _Input.apply(this, arguments) || this;\n    _this.pressed = false;\n    return _this;\n  }\n  var _proto = MouseInput22.prototype;\n  _proto.handler = function handler(ev) {\n    var eventType = MOUSE_INPUT_MAP2[ev.type];\n    if (eventType & INPUT_START2 && ev.button === 0) {\n      this.pressed = true;\n    }\n    if (eventType & INPUT_MOVE2 && ev.which !== 1) {\n      eventType = INPUT_END2;\n    }\n    if (!this.pressed) {\n      return;\n    }\n    if (eventType & INPUT_END2) {\n      this.pressed = false;\n    }\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE2,\n      srcEvent: ev\n    });\n  };\n  return MouseInput22;\n}(Input2);\nvar DEDUP_TIMEOUT2 = 2500;\nvar DEDUP_DISTANCE2 = 25;\nfunction setLastTouch2(eventData) {\n  var _eventData$changedPoi = eventData.changedPointers, touch = _eventData$changedPoi[0];\n  if (touch.identifier === this.primaryTouch) {\n    var lastTouch = {\n      x: touch.clientX,\n      y: touch.clientY\n    };\n    var lts = this.lastTouches;\n    this.lastTouches.push(lastTouch);\n    var removeLastTouch = function removeLastTouch2() {\n      var i = lts.indexOf(lastTouch);\n      if (i > -1) {\n        lts.splice(i, 1);\n      }\n    };\n    setTimeout(removeLastTouch, DEDUP_TIMEOUT2);\n  }\n}\nfunction recordTouches2(eventType, eventData) {\n  if (eventType & INPUT_START2) {\n    this.primaryTouch = eventData.changedPointers[0].identifier;\n    setLastTouch2.call(this, eventData);\n  } else if (eventType & (INPUT_END2 | INPUT_CANCEL2)) {\n    setLastTouch2.call(this, eventData);\n  }\n}\nfunction isSyntheticEvent2(eventData) {\n  var x = eventData.srcEvent.clientX;\n  var y = eventData.srcEvent.clientY;\n  for (var i = 0; i < this.lastTouches.length; i++) {\n    var t = this.lastTouches[i];\n    var dx = Math.abs(x - t.x);\n    var dy = Math.abs(y - t.y);\n    if (dx <= DEDUP_DISTANCE2 && dy <= DEDUP_DISTANCE2) {\n      return true;\n    }\n  }\n  return false;\n}\nvar TouchMouseInput2 = /* @__PURE__ */ function() {\n  var TouchMouseInput22 = /* @__PURE__ */ function(_Input) {\n    _inheritsLoose2(TouchMouseInput3, _Input);\n    function TouchMouseInput3(_manager, callback) {\n      var _this;\n      _this = _Input.call(this, _manager, callback) || this;\n      _this.handler = function(manager, inputEvent, inputData) {\n        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH2;\n        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE2;\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n          return;\n        }\n        if (isTouch) {\n          recordTouches2.call(_assertThisInitialized$12(_assertThisInitialized$12(_this)), inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent2.call(_assertThisInitialized$12(_assertThisInitialized$12(_this)), inputData)) {\n          return;\n        }\n        _this.callback(manager, inputEvent, inputData);\n      };\n      _this.touch = new TouchInput2(_this.manager, _this.handler);\n      _this.mouse = new MouseInput2(_this.manager, _this.handler);\n      _this.primaryTouch = null;\n      _this.lastTouches = [];\n      return _this;\n    }\n    var _proto = TouchMouseInput3.prototype;\n    _proto.destroy = function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    };\n    return TouchMouseInput3;\n  }(Input2);\n  return TouchMouseInput22;\n}();\nfunction createInputInstance2(manager) {\n  var Type7;\n  var inputClass = manager.options.inputClass;\n  if (inputClass) {\n    Type7 = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS2) {\n    Type7 = PointerEventInput2;\n  } else if (SUPPORT_ONLY_TOUCH2) {\n    Type7 = TouchInput2;\n  } else if (!SUPPORT_TOUCH2) {\n    Type7 = MouseInput2;\n  } else {\n    Type7 = TouchMouseInput2;\n  }\n  return new Type7(manager, inputHandler2);\n}\nfunction invokeArrayArg2(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each2(arg, context[fn], context);\n    return true;\n  }\n  return false;\n}\nvar STATE_POSSIBLE2 = 1;\nvar STATE_BEGAN2 = 2;\nvar STATE_CHANGED2 = 4;\nvar STATE_ENDED2 = 8;\nvar STATE_RECOGNIZED2 = STATE_ENDED2;\nvar STATE_CANCELLED2 = 16;\nvar STATE_FAILED2 = 32;\nvar _uniqueId2 = 1;\nfunction uniqueId2() {\n  return _uniqueId2++;\n}\nfunction getRecognizerByNameIfManager2(otherRecognizer, recognizer) {\n  var manager = recognizer.manager;\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n  return otherRecognizer;\n}\nfunction stateStr2(state) {\n  if (state & STATE_CANCELLED2) {\n    return \"cancel\";\n  } else if (state & STATE_ENDED2) {\n    return \"end\";\n  } else if (state & STATE_CHANGED2) {\n    return \"move\";\n  } else if (state & STATE_BEGAN2) {\n    return \"start\";\n  }\n  return \"\";\n}\nvar Recognizer2 = /* @__PURE__ */ function() {\n  function Recognizer22(options2) {\n    if (options2 === void 0) {\n      options2 = {};\n    }\n    this.options = _extends2({\n      enable: true\n    }, options2);\n    this.id = uniqueId2();\n    this.manager = null;\n    this.state = STATE_POSSIBLE2;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  var _proto = Recognizer22.prototype;\n  _proto.set = function set22(options2) {\n    assign$12(this.options, options2);\n    this.manager && this.manager.touchAction.update();\n    return this;\n  };\n  _proto.recognizeWith = function recognizeWith(otherRecognizer) {\n    if (invokeArrayArg2(otherRecognizer, \"recognizeWith\", this)) {\n      return this;\n    }\n    var simultaneous = this.simultaneous;\n    otherRecognizer = getRecognizerByNameIfManager2(otherRecognizer, this);\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n    return this;\n  };\n  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg2(otherRecognizer, \"dropRecognizeWith\", this)) {\n      return this;\n    }\n    otherRecognizer = getRecognizerByNameIfManager2(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  };\n  _proto.requireFailure = function requireFailure(otherRecognizer) {\n    if (invokeArrayArg2(otherRecognizer, \"requireFailure\", this)) {\n      return this;\n    }\n    var requireFail = this.requireFail;\n    otherRecognizer = getRecognizerByNameIfManager2(otherRecognizer, this);\n    if (inArray2(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n    return this;\n  };\n  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg2(otherRecognizer, \"dropRequireFailure\", this)) {\n      return this;\n    }\n    otherRecognizer = getRecognizerByNameIfManager2(otherRecognizer, this);\n    var index2 = inArray2(this.requireFail, otherRecognizer);\n    if (index2 > -1) {\n      this.requireFail.splice(index2, 1);\n    }\n    return this;\n  };\n  _proto.hasRequireFailures = function hasRequireFailures() {\n    return this.requireFail.length > 0;\n  };\n  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  };\n  _proto.emit = function emit(input) {\n    var self2 = this;\n    var state = this.state;\n    function emit2(event) {\n      self2.manager.emit(event, input);\n    }\n    if (state < STATE_ENDED2) {\n      emit2(self2.options.event + stateStr2(state));\n    }\n    emit2(self2.options.event);\n    if (input.additionalEvent) {\n      emit2(input.additionalEvent);\n    }\n    if (state >= STATE_ENDED2) {\n      emit2(self2.options.event + stateStr2(state));\n    }\n  };\n  _proto.tryEmit = function tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    }\n    this.state = STATE_FAILED2;\n  };\n  _proto.canEmit = function canEmit() {\n    var i = 0;\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED2 | STATE_POSSIBLE2))) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  };\n  _proto.recognize = function recognize(inputData) {\n    var inputDataClone = assign$12({}, inputData);\n    if (!boolOrFn2(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED2;\n      return;\n    }\n    if (this.state & (STATE_RECOGNIZED2 | STATE_CANCELLED2 | STATE_FAILED2)) {\n      this.state = STATE_POSSIBLE2;\n    }\n    this.state = this.process(inputDataClone);\n    if (this.state & (STATE_BEGAN2 | STATE_CHANGED2 | STATE_ENDED2 | STATE_CANCELLED2)) {\n      this.tryEmit(inputDataClone);\n    }\n  };\n  _proto.process = function process22(inputData) {\n  };\n  _proto.getTouchAction = function getTouchAction() {\n  };\n  _proto.reset = function reset() {\n  };\n  return Recognizer22;\n}();\nvar TapRecognizer2 = /* @__PURE__ */ function(_Recognizer) {\n  _inheritsLoose2(TapRecognizer22, _Recognizer);\n  function TapRecognizer22(options2) {\n    var _this;\n    if (options2 === void 0) {\n      options2 = {};\n    }\n    _this = _Recognizer.call(this, _extends2({\n      event: \"tap\",\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      time: 250,\n      threshold: 9,\n      posThreshold: 10\n    }, options2)) || this;\n    _this.pTime = false;\n    _this.pCenter = false;\n    _this._timer = null;\n    _this._input = null;\n    _this.count = 0;\n    return _this;\n  }\n  var _proto = TapRecognizer22.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION2];\n  };\n  _proto.process = function process22(input) {\n    var _this2 = this;\n    var options2 = this.options;\n    var validPointers = input.pointers.length === options2.pointers;\n    var validMovement = input.distance < options2.threshold;\n    var validTouchTime = input.deltaTime < options2.time;\n    this.reset();\n    if (input.eventType & INPUT_START2 && this.count === 0) {\n      return this.failTimeout();\n    }\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END2) {\n        return this.failTimeout();\n      }\n      var validInterval = this.pTime ? input.timeStamp - this.pTime < options2.interval : true;\n      var validMultiTap = !this.pCenter || getDistance2(this.pCenter, input.center) < options2.posThreshold;\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n      this._input = input;\n      var tapCount = this.count % options2.taps;\n      if (tapCount === 0) {\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED2;\n        } else {\n          this._timer = setTimeout(function() {\n            _this2.state = STATE_RECOGNIZED2;\n            _this2.tryEmit();\n          }, options2.interval);\n          return STATE_BEGAN2;\n        }\n      }\n    }\n    return STATE_FAILED2;\n  };\n  _proto.failTimeout = function failTimeout() {\n    var _this3 = this;\n    this._timer = setTimeout(function() {\n      _this3.state = STATE_FAILED2;\n    }, this.options.interval);\n    return STATE_FAILED2;\n  };\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n  _proto.emit = function emit() {\n    if (this.state === STATE_RECOGNIZED2) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n  return TapRecognizer22;\n}(Recognizer2);\nvar AttrRecognizer2 = /* @__PURE__ */ function(_Recognizer) {\n  _inheritsLoose2(AttrRecognizer22, _Recognizer);\n  function AttrRecognizer22(options2) {\n    if (options2 === void 0) {\n      options2 = {};\n    }\n    return _Recognizer.call(this, _extends2({\n      pointers: 1\n    }, options2)) || this;\n  }\n  var _proto = AttrRecognizer22.prototype;\n  _proto.attrTest = function attrTest(input) {\n    var optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  };\n  _proto.process = function process22(input) {\n    var state = this.state;\n    var eventType = input.eventType;\n    var isRecognized = state & (STATE_BEGAN2 | STATE_CHANGED2);\n    var isValid = this.attrTest(input);\n    if (isRecognized && (eventType & INPUT_CANCEL2 || !isValid)) {\n      return state | STATE_CANCELLED2;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END2) {\n        return state | STATE_ENDED2;\n      } else if (!(state & STATE_BEGAN2)) {\n        return STATE_BEGAN2;\n      }\n      return state | STATE_CHANGED2;\n    }\n    return STATE_FAILED2;\n  };\n  return AttrRecognizer22;\n}(Recognizer2);\nfunction directionStr2(direction) {\n  if (direction === DIRECTION_DOWN2) {\n    return \"down\";\n  } else if (direction === DIRECTION_UP2) {\n    return \"up\";\n  } else if (direction === DIRECTION_LEFT2) {\n    return \"left\";\n  } else if (direction === DIRECTION_RIGHT2) {\n    return \"right\";\n  }\n  return \"\";\n}\nvar PanRecognizer2 = /* @__PURE__ */ function(_AttrRecognizer) {\n  _inheritsLoose2(PanRecognizer22, _AttrRecognizer);\n  function PanRecognizer22(options2) {\n    var _this;\n    if (options2 === void 0) {\n      options2 = {};\n    }\n    _this = _AttrRecognizer.call(this, _extends2({\n      event: \"pan\",\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL2\n    }, options2)) || this;\n    _this.pX = null;\n    _this.pY = null;\n    return _this;\n  }\n  var _proto = PanRecognizer22.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    var direction = this.options.direction;\n    var actions = [];\n    if (direction & DIRECTION_HORIZONTAL2) {\n      actions.push(TOUCH_ACTION_PAN_Y2);\n    }\n    if (direction & DIRECTION_VERTICAL2) {\n      actions.push(TOUCH_ACTION_PAN_X2);\n    }\n    return actions;\n  };\n  _proto.directionTest = function directionTest(input) {\n    var options2 = this.options;\n    var hasMoved = true;\n    var distance = input.distance;\n    var direction = input.direction;\n    var x = input.deltaX;\n    var y = input.deltaY;\n    if (!(direction & options2.direction)) {\n      if (options2.direction & DIRECTION_HORIZONTAL2) {\n        direction = x === 0 ? DIRECTION_NONE2 : x < 0 ? DIRECTION_LEFT2 : DIRECTION_RIGHT2;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? DIRECTION_NONE2 : y < 0 ? DIRECTION_UP2 : DIRECTION_DOWN2;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n    input.direction = direction;\n    return hasMoved && distance > options2.threshold && direction & options2.direction;\n  };\n  _proto.attrTest = function attrTest(input) {\n    return AttrRecognizer2.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN2 || !(this.state & STATE_BEGAN2) && this.directionTest(input));\n  };\n  _proto.emit = function emit(input) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n    var direction = directionStr2(input.direction);\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n  return PanRecognizer22;\n}(AttrRecognizer2);\nvar SwipeRecognizer2 = /* @__PURE__ */ function(_AttrRecognizer) {\n  _inheritsLoose2(SwipeRecognizer22, _AttrRecognizer);\n  function SwipeRecognizer22(options2) {\n    if (options2 === void 0) {\n      options2 = {};\n    }\n    return _AttrRecognizer.call(this, _extends2({\n      event: \"swipe\",\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL2 | DIRECTION_VERTICAL2,\n      pointers: 1\n    }, options2)) || this;\n  }\n  var _proto = SwipeRecognizer22.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return PanRecognizer2.prototype.getTouchAction.call(this);\n  };\n  _proto.attrTest = function attrTest(input) {\n    var direction = this.options.direction;\n    var velocity;\n    if (direction & (DIRECTION_HORIZONTAL2 | DIRECTION_VERTICAL2)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL2) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL2) {\n      velocity = input.overallVelocityY;\n    }\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs$1(velocity) > this.options.velocity && input.eventType & INPUT_END2;\n  };\n  _proto.emit = function emit(input) {\n    var direction = directionStr2(input.offsetDirection);\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n    this.manager.emit(this.options.event, input);\n  };\n  return SwipeRecognizer22;\n}(AttrRecognizer2);\nvar PinchRecognizer2 = /* @__PURE__ */ function(_AttrRecognizer) {\n  _inheritsLoose2(PinchRecognizer22, _AttrRecognizer);\n  function PinchRecognizer22(options2) {\n    if (options2 === void 0) {\n      options2 = {};\n    }\n    return _AttrRecognizer.call(this, _extends2({\n      event: \"pinch\",\n      threshold: 0,\n      pointers: 2\n    }, options2)) || this;\n  }\n  var _proto = PinchRecognizer22.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE2];\n  };\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN2);\n  };\n  _proto.emit = function emit(input) {\n    if (input.scale !== 1) {\n      var inOut = input.scale < 1 ? \"in\" : \"out\";\n      input.additionalEvent = this.options.event + inOut;\n    }\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n  return PinchRecognizer22;\n}(AttrRecognizer2);\nvar RotateRecognizer2 = /* @__PURE__ */ function(_AttrRecognizer) {\n  _inheritsLoose2(RotateRecognizer22, _AttrRecognizer);\n  function RotateRecognizer22(options2) {\n    if (options2 === void 0) {\n      options2 = {};\n    }\n    return _AttrRecognizer.call(this, _extends2({\n      event: \"rotate\",\n      threshold: 0,\n      pointers: 2\n    }, options2)) || this;\n  }\n  var _proto = RotateRecognizer22.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE2];\n  };\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN2);\n  };\n  return RotateRecognizer22;\n}(AttrRecognizer2);\nvar PressRecognizer2 = /* @__PURE__ */ function(_Recognizer) {\n  _inheritsLoose2(PressRecognizer22, _Recognizer);\n  function PressRecognizer22(options2) {\n    var _this;\n    if (options2 === void 0) {\n      options2 = {};\n    }\n    _this = _Recognizer.call(this, _extends2({\n      event: \"press\",\n      pointers: 1,\n      time: 251,\n      threshold: 9\n    }, options2)) || this;\n    _this._timer = null;\n    _this._input = null;\n    return _this;\n  }\n  var _proto = PressRecognizer22.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_AUTO2];\n  };\n  _proto.process = function process22(input) {\n    var _this2 = this;\n    var options2 = this.options;\n    var validPointers = input.pointers.length === options2.pointers;\n    var validMovement = input.distance < options2.threshold;\n    var validTime = input.deltaTime > options2.time;\n    this._input = input;\n    if (!validMovement || !validPointers || input.eventType & (INPUT_END2 | INPUT_CANCEL2) && !validTime) {\n      this.reset();\n    } else if (input.eventType & INPUT_START2) {\n      this.reset();\n      this._timer = setTimeout(function() {\n        _this2.state = STATE_RECOGNIZED2;\n        _this2.tryEmit();\n      }, options2.time);\n    } else if (input.eventType & INPUT_END2) {\n      return STATE_RECOGNIZED2;\n    }\n    return STATE_FAILED2;\n  };\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n  _proto.emit = function emit(input) {\n    if (this.state !== STATE_RECOGNIZED2) {\n      return;\n    }\n    if (input && input.eventType & INPUT_END2) {\n      this.manager.emit(this.options.event + \"up\", input);\n    } else {\n      this._input.timeStamp = now22();\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n  return PressRecognizer22;\n}(Recognizer2);\nvar defaults2 = {\n  domEvents: false,\n  touchAction: TOUCH_ACTION_COMPUTE2,\n  enable: true,\n  inputTarget: null,\n  inputClass: null,\n  cssProps: {\n    userSelect: \"none\",\n    touchSelect: \"none\",\n    touchCallout: \"none\",\n    contentZooming: \"none\",\n    userDrag: \"none\",\n    tapHighlightColor: \"rgba(0,0,0,0)\"\n  }\n};\nvar preset2 = [[RotateRecognizer2, {\n  enable: false\n}], [PinchRecognizer2, {\n  enable: false\n}, [\"rotate\"]], [SwipeRecognizer2, {\n  direction: DIRECTION_HORIZONTAL2\n}], [PanRecognizer2, {\n  direction: DIRECTION_HORIZONTAL2\n}, [\"swipe\"]], [TapRecognizer2], [TapRecognizer2, {\n  event: \"doubletap\",\n  taps: 2\n}, [\"tap\"]], [PressRecognizer2]];\nvar STOP2 = 1;\nvar FORCED_STOP2 = 2;\nfunction toggleCssProps2(manager, add) {\n  var element = manager.element;\n  if (!element.style) {\n    return;\n  }\n  var prop;\n  each2(manager.options.cssProps, function(value, name2) {\n    prop = prefixed2(element.style, name2);\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\n    }\n  });\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\nfunction triggerDomEvent2(event, data22) {\n  var gestureEvent = document.createEvent(\"Event\");\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data22;\n  data22.target.dispatchEvent(gestureEvent);\n}\nvar Manager2 = /* @__PURE__ */ function() {\n  function Manager22(element, options2) {\n    var _this = this;\n    this.options = assign$12({}, defaults2, options2 || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance2(this);\n    this.touchAction = new TouchAction2(this, this.options.touchAction);\n    toggleCssProps2(this, true);\n    each2(this.options.recognizers, function(item) {\n      var recognizer = _this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  var _proto = Manager22.prototype;\n  _proto.set = function set22(options2) {\n    assign$12(this.options, options2);\n    if (options2.touchAction) {\n      this.touchAction.update();\n    }\n    if (options2.inputTarget) {\n      this.input.destroy();\n      this.input.target = options2.inputTarget;\n      this.input.init();\n    }\n    return this;\n  };\n  _proto.stop = function stop(force) {\n    this.session.stopped = force ? FORCED_STOP2 : STOP2;\n  };\n  _proto.recognize = function recognize(inputData) {\n    var session = this.session;\n    if (session.stopped) {\n      return;\n    }\n    this.touchAction.preventDefaults(inputData);\n    var recognizer;\n    var recognizers = this.recognizers;\n    var curRecognizer = session.curRecognizer;\n    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED2) {\n      session.curRecognizer = null;\n      curRecognizer = null;\n    }\n    var i = 0;\n    while (i < recognizers.length) {\n      recognizer = recognizers[i];\n      if (session.stopped !== FORCED_STOP2 && (!curRecognizer || recognizer === curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      }\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN2 | STATE_CHANGED2 | STATE_ENDED2)) {\n        session.curRecognizer = recognizer;\n        curRecognizer = recognizer;\n      }\n      i++;\n    }\n  };\n  _proto.get = function get22(recognizer) {\n    if (recognizer instanceof Recognizer2) {\n      return recognizer;\n    }\n    var recognizers = this.recognizers;\n    for (var i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n    return null;\n  };\n  _proto.add = function add(recognizer) {\n    if (invokeArrayArg2(recognizer, \"add\", this)) {\n      return this;\n    }\n    var existing = this.get(recognizer.options.event);\n    if (existing) {\n      this.remove(existing);\n    }\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n    this.touchAction.update();\n    return recognizer;\n  };\n  _proto.remove = function remove(recognizer) {\n    if (invokeArrayArg2(recognizer, \"remove\", this)) {\n      return this;\n    }\n    var targetRecognizer = this.get(recognizer);\n    if (recognizer) {\n      var recognizers = this.recognizers;\n      var index2 = inArray2(recognizers, targetRecognizer);\n      if (index2 !== -1) {\n        recognizers.splice(index2, 1);\n        this.touchAction.update();\n      }\n    }\n    return this;\n  };\n  _proto.on = function on(events, handler) {\n    if (events === void 0 || handler === void 0) {\n      return this;\n    }\n    var handlers = this.handlers;\n    each2(splitStr2(events), function(event) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  };\n  _proto.off = function off(events, handler) {\n    if (events === void 0) {\n      return this;\n    }\n    var handlers = this.handlers;\n    each2(splitStr2(events), function(event) {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray2(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  };\n  _proto.emit = function emit(event, data22) {\n    if (this.options.domEvents) {\n      triggerDomEvent2(event, data22);\n    }\n    var handlers = this.handlers[event] && this.handlers[event].slice();\n    if (!handlers || !handlers.length) {\n      return;\n    }\n    data22.type = event;\n    data22.preventDefault = function() {\n      data22.srcEvent.preventDefault();\n    };\n    var i = 0;\n    while (i < handlers.length) {\n      handlers[i](data22);\n      i++;\n    }\n  };\n  _proto.destroy = function destroy() {\n    this.element && toggleCssProps2(this, false);\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  };\n  return Manager22;\n}();\nvar SINGLE_TOUCH_INPUT_MAP2 = {\n  touchstart: INPUT_START2,\n  touchmove: INPUT_MOVE2,\n  touchend: INPUT_END2,\n  touchcancel: INPUT_CANCEL2\n};\nvar SINGLE_TOUCH_TARGET_EVENTS2 = \"touchstart\";\nvar SINGLE_TOUCH_WINDOW_EVENTS2 = \"touchstart touchmove touchend touchcancel\";\nvar SingleTouchInput2 = /* @__PURE__ */ function(_Input) {\n  _inheritsLoose2(SingleTouchInput22, _Input);\n  function SingleTouchInput22() {\n    var _this;\n    var proto = SingleTouchInput22.prototype;\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS2;\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS2;\n    _this = _Input.apply(this, arguments) || this;\n    _this.started = false;\n    return _this;\n  }\n  var _proto = SingleTouchInput22.prototype;\n  _proto.handler = function handler(ev) {\n    var type2 = SINGLE_TOUCH_INPUT_MAP2[ev.type];\n    if (type2 === INPUT_START2) {\n      this.started = true;\n    }\n    if (!this.started) {\n      return;\n    }\n    var touches = normalizeSingleTouches2.call(this, ev, type2);\n    if (type2 & (INPUT_END2 | INPUT_CANCEL2) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n    this.callback(this.manager, type2, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH2,\n      srcEvent: ev\n    });\n  };\n  return SingleTouchInput22;\n}(Input2);\nfunction normalizeSingleTouches2(ev, type2) {\n  var all = toArray2(ev.touches);\n  var changed = toArray2(ev.changedTouches);\n  if (type2 & (INPUT_END2 | INPUT_CANCEL2)) {\n    all = uniqueArray2(all.concat(changed), \"identifier\", true);\n  }\n  return [all, changed];\n}\nfunction deprecate2(method22, name2, message) {\n  var deprecationMessage = \"DEPRECATED METHOD: \" + name2 + \"\\n\" + message + \" AT \\n\";\n  return function() {\n    var e = new Error(\"get-stack-trace\");\n    var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, \"\").replace(/^\\s+at\\s+/gm, \"\").replace(/^Object.<anonymous>\\s*\\(/gm, \"{anonymous}()@\") : \"Unknown Stack Trace\";\n    var log = window.console && (window.console.warn || window.console.log);\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n    return method22.apply(this, arguments);\n  };\n}\nvar extend2 = deprecate2(function(dest, src, merge22) {\n  var keys42 = Object.keys(src);\n  var i = 0;\n  while (i < keys42.length) {\n    if (!merge22 || merge22 && dest[keys42[i]] === void 0) {\n      dest[keys42[i]] = src[keys42[i]];\n    }\n    i++;\n  }\n  return dest;\n}, \"extend\", \"Use `assign`.\");\nvar merge$2 = deprecate2(function(dest, src) {\n  return extend2(dest, src, true);\n}, \"merge\", \"Use `assign`.\");\nfunction inherit2(child, base, properties) {\n  var baseP = base.prototype;\n  var childP;\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n  if (properties) {\n    assign$12(childP, properties);\n  }\n}\nfunction bindFn2(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\nvar Hammer$2 = /* @__PURE__ */ function() {\n  var Hammer22 = function Hammer3(element, options2) {\n    if (options2 === void 0) {\n      options2 = {};\n    }\n    return new Manager2(element, _extends2({\n      recognizers: preset2.concat()\n    }, options2));\n  };\n  Hammer22.VERSION = \"2.0.17-rc\";\n  Hammer22.DIRECTION_ALL = DIRECTION_ALL2;\n  Hammer22.DIRECTION_DOWN = DIRECTION_DOWN2;\n  Hammer22.DIRECTION_LEFT = DIRECTION_LEFT2;\n  Hammer22.DIRECTION_RIGHT = DIRECTION_RIGHT2;\n  Hammer22.DIRECTION_UP = DIRECTION_UP2;\n  Hammer22.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL2;\n  Hammer22.DIRECTION_VERTICAL = DIRECTION_VERTICAL2;\n  Hammer22.DIRECTION_NONE = DIRECTION_NONE2;\n  Hammer22.DIRECTION_DOWN = DIRECTION_DOWN2;\n  Hammer22.INPUT_START = INPUT_START2;\n  Hammer22.INPUT_MOVE = INPUT_MOVE2;\n  Hammer22.INPUT_END = INPUT_END2;\n  Hammer22.INPUT_CANCEL = INPUT_CANCEL2;\n  Hammer22.STATE_POSSIBLE = STATE_POSSIBLE2;\n  Hammer22.STATE_BEGAN = STATE_BEGAN2;\n  Hammer22.STATE_CHANGED = STATE_CHANGED2;\n  Hammer22.STATE_ENDED = STATE_ENDED2;\n  Hammer22.STATE_RECOGNIZED = STATE_RECOGNIZED2;\n  Hammer22.STATE_CANCELLED = STATE_CANCELLED2;\n  Hammer22.STATE_FAILED = STATE_FAILED2;\n  Hammer22.Manager = Manager2;\n  Hammer22.Input = Input2;\n  Hammer22.TouchAction = TouchAction2;\n  Hammer22.TouchInput = TouchInput2;\n  Hammer22.MouseInput = MouseInput2;\n  Hammer22.PointerEventInput = PointerEventInput2;\n  Hammer22.TouchMouseInput = TouchMouseInput2;\n  Hammer22.SingleTouchInput = SingleTouchInput2;\n  Hammer22.Recognizer = Recognizer2;\n  Hammer22.AttrRecognizer = AttrRecognizer2;\n  Hammer22.Tap = TapRecognizer2;\n  Hammer22.Pan = PanRecognizer2;\n  Hammer22.Swipe = SwipeRecognizer2;\n  Hammer22.Pinch = PinchRecognizer2;\n  Hammer22.Rotate = RotateRecognizer2;\n  Hammer22.Press = PressRecognizer2;\n  Hammer22.on = addEventListeners2;\n  Hammer22.off = removeEventListeners2;\n  Hammer22.each = each2;\n  Hammer22.merge = merge$2;\n  Hammer22.extend = extend2;\n  Hammer22.bindFn = bindFn2;\n  Hammer22.assign = assign$12;\n  Hammer22.inherit = inherit2;\n  Hammer22.bindFn = bindFn2;\n  Hammer22.prefixed = prefixed2;\n  Hammer22.toArray = toArray2;\n  Hammer22.inArray = inArray2;\n  Hammer22.uniqueArray = uniqueArray2;\n  Hammer22.splitStr = splitStr2;\n  Hammer22.boolOrFn = boolOrFn2;\n  Hammer22.hasParent = hasParent2;\n  Hammer22.addEventListeners = addEventListeners2;\n  Hammer22.removeEventListeners = removeEventListeners2;\n  Hammer22.defaults = assign$12({}, defaults2, {\n    preset: preset2\n  });\n  return Hammer22;\n}();\nvar RealHammer2 = Hammer$2;\nfunction _createForOfIteratorHelper$7(o, allowArrayLike) {\n  var it2 = typeof symbol2 !== \"undefined\" && getIteratorMethod$12(o) || o[\"@@iterator\"];\n  if (!it2) {\n    if (isArray$12(o) || (it2 = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it2)\n        o = it2;\n      var i = 0;\n      var F2 = function F22() {\n      };\n      return { s: F2, n: function n() {\n        if (i >= o.length)\n          return { done: true };\n        return { done: false, value: o[i++] };\n      }, e: function e(_e3) {\n        throw _e3;\n      }, f: F2 };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true, didErr = false, err;\n  return { s: function s() {\n    it2 = it2.call(o);\n  }, n: function n() {\n    var step = it2.next();\n    normalCompletion = step.done;\n    return step;\n  }, e: function e(_e22) {\n    didErr = true;\n    err = _e22;\n  }, f: function f() {\n    try {\n      if (!normalCompletion && it2.return != null)\n        it2.return();\n    } finally {\n      if (didErr)\n        throw err;\n    }\n  } };\n}\nfunction _unsupportedIterableToArray$7(o, minLen) {\n  var _context21;\n  if (!o)\n    return;\n  if (typeof o === \"string\")\n    return _arrayLikeToArray$7(o, minLen);\n  var n = slice22(_context21 = Object.prototype.toString.call(o)).call(_context21, 8, -1);\n  if (n === \"Object\" && o.constructor)\n    n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\")\n    return from$32(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray$7(o, minLen);\n}\nfunction _arrayLikeToArray$7(arr, len) {\n  if (len == null || len > arr.length)\n    len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nsymbol2(\"DELETE\");\nfunction Alea() {\n  for (var _len3 = arguments.length, seed = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    seed[_key3] = arguments[_key3];\n  }\n  return AleaImplementation(seed.length ? seed : [now$1()]);\n}\nfunction AleaImplementation(seed) {\n  var _mashSeed = mashSeed(seed), _mashSeed2 = _slicedToArray2(_mashSeed, 3), s0 = _mashSeed2[0], s1 = _mashSeed2[1], s2 = _mashSeed2[2];\n  var c22 = 1;\n  var random = function random2() {\n    var t = 2091639 * s0 + c22 * 23283064365386963e-26;\n    s0 = s1;\n    s1 = s2;\n    return s2 = t - (c22 = t | 0);\n  };\n  random.uint32 = function() {\n    return random() * 4294967296;\n  };\n  random.fract53 = function() {\n    return random() + (random() * 2097152 | 0) * 11102230246251565e-32;\n  };\n  random.algorithm = \"Alea\";\n  random.seed = seed;\n  random.version = \"0.9\";\n  return random;\n}\nfunction mashSeed() {\n  var mash = Mash();\n  var s0 = mash(\" \");\n  var s1 = mash(\" \");\n  var s2 = mash(\" \");\n  for (var i = 0; i < arguments.length; i++) {\n    s0 -= mash(i < 0 || arguments.length <= i ? void 0 : arguments[i]);\n    if (s0 < 0) {\n      s0 += 1;\n    }\n    s1 -= mash(i < 0 || arguments.length <= i ? void 0 : arguments[i]);\n    if (s1 < 0) {\n      s1 += 1;\n    }\n    s2 -= mash(i < 0 || arguments.length <= i ? void 0 : arguments[i]);\n    if (s2 < 0) {\n      s2 += 1;\n    }\n  }\n  return [s0, s1, s2];\n}\nfunction Mash() {\n  var n = 4022871197;\n  return function(data22) {\n    var string22 = data22.toString();\n    for (var i = 0; i < string22.length; i++) {\n      n += string22.charCodeAt(i);\n      var h = 0.02519603282416938 * n;\n      n = h >>> 0;\n      h -= n;\n      h *= n;\n      n = h >>> 0;\n      h -= n;\n      n += h * 4294967296;\n    }\n    return (n >>> 0) * 23283064365386963e-26;\n  };\n}\nfunction hammerMock2() {\n  var noop22 = function noop3() {\n  };\n  return {\n    on: noop22,\n    off: noop22,\n    destroy: noop22,\n    emit: noop22,\n    get: function get22() {\n      return {\n        set: noop22\n      };\n    }\n  };\n}\nvar Hammer$12 = typeof window !== \"undefined\" ? window.Hammer || RealHammer2 : function() {\n  return hammerMock2();\n};\nfunction Activator$12(container) {\n  var _this = this, _context3;\n  this._cleanupQueue = [];\n  this.active = false;\n  this._dom = {\n    container,\n    overlay: document.createElement(\"div\")\n  };\n  this._dom.overlay.classList.add(\"vis-overlay\");\n  this._dom.container.appendChild(this._dom.overlay);\n  this._cleanupQueue.push(function() {\n    _this._dom.overlay.parentNode.removeChild(_this._dom.overlay);\n  });\n  var hammer = Hammer$12(this._dom.overlay);\n  hammer.on(\"tap\", bind$52(_context3 = this._onTapOverlay).call(_context3, this));\n  this._cleanupQueue.push(function() {\n    hammer.destroy();\n  });\n  var events = [\"tap\", \"doubletap\", \"press\", \"pinch\", \"pan\", \"panstart\", \"panmove\", \"panend\"];\n  forEach$22(events).call(events, function(event) {\n    hammer.on(event, function(event2) {\n      event2.srcEvent.stopPropagation();\n    });\n  });\n  if (document && document.body) {\n    this._onClick = function(event) {\n      if (!_hasParent2(event.target, container)) {\n        _this.deactivate();\n      }\n    };\n    document.body.addEventListener(\"click\", this._onClick);\n    this._cleanupQueue.push(function() {\n      document.body.removeEventListener(\"click\", _this._onClick);\n    });\n  }\n  this._escListener = function(event) {\n    if (\"key\" in event ? event.key === \"Escape\" : event.keyCode === 27) {\n      _this.deactivate();\n    }\n  };\n}\nEmitter2(Activator$12.prototype);\nActivator$12.current = null;\nActivator$12.prototype.destroy = function() {\n  var _context4, _context5;\n  this.deactivate();\n  var _iterator2 = _createForOfIteratorHelper$7(reverse22(_context4 = splice$12(_context5 = this._cleanupQueue).call(_context5, 0)).call(_context4)), _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {\n      var callback = _step2.value;\n      callback();\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n};\nActivator$12.prototype.activate = function() {\n  if (Activator$12.current) {\n    Activator$12.current.deactivate();\n  }\n  Activator$12.current = this;\n  this.active = true;\n  this._dom.overlay.style.display = \"none\";\n  this._dom.container.classList.add(\"vis-active\");\n  this.emit(\"change\");\n  this.emit(\"activate\");\n  document.body.addEventListener(\"keydown\", this._escListener);\n};\nActivator$12.prototype.deactivate = function() {\n  this.active = false;\n  this._dom.overlay.style.display = \"block\";\n  this._dom.container.classList.remove(\"vis-active\");\n  document.body.removeEventListener(\"keydown\", this._escListener);\n  this.emit(\"change\");\n  this.emit(\"deactivate\");\n};\nActivator$12.prototype._onTapOverlay = function(event) {\n  this.activate();\n  event.srcEvent.stopPropagation();\n};\nfunction _hasParent2(element, parent22) {\n  while (element) {\n    if (element === parent22) {\n      return true;\n    }\n    element = element.parentNode;\n  }\n  return false;\n}\nvar fullHexRE = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\nvar shortHexRE = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\nvar rgbRE = /^rgb\\( *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *\\)$/i;\nvar rgbaRE = /^rgba\\( *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *([01]|0?\\.\\d+) *\\)$/i;\nfunction recursiveDOMDelete(DOMobject) {\n  if (DOMobject) {\n    while (DOMobject.hasChildNodes() === true) {\n      var child = DOMobject.firstChild;\n      if (child) {\n        recursiveDOMDelete(child);\n        DOMobject.removeChild(child);\n      }\n    }\n  }\n}\nfunction isString(value) {\n  return value instanceof String || typeof value === \"string\";\n}\nfunction isObject$72(value) {\n  return _typeof2(value) === \"object\" && value !== null;\n}\nfunction copyOrDelete(a, b, prop, allowDeletion) {\n  var doDeletion = false;\n  if (allowDeletion === true) {\n    doDeletion = b[prop] === null && a[prop] !== void 0;\n  }\n  if (doDeletion) {\n    delete a[prop];\n  } else {\n    a[prop] = b[prop];\n  }\n}\nfunction fillIfDefined(a, b) {\n  var allowDeletion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n  for (var prop in a) {\n    if (b[prop] !== void 0) {\n      if (b[prop] === null || _typeof2(b[prop]) !== \"object\") {\n        copyOrDelete(a, b, prop, allowDeletion);\n      } else {\n        var aProp = a[prop];\n        var bProp = b[prop];\n        if (isObject$72(aProp) && isObject$72(bProp)) {\n          fillIfDefined(aProp, bProp, allowDeletion);\n        }\n      }\n    }\n  }\n}\nfunction selectiveDeepExtend(props, a, b) {\n  var allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n  if (isArray$12(b)) {\n    throw new TypeError(\"Arrays are not supported by deepExtend\");\n  }\n  for (var p = 0; p < props.length; p++) {\n    var prop = props[p];\n    if (Object.prototype.hasOwnProperty.call(b, prop)) {\n      if (b[prop] && b[prop].constructor === Object) {\n        if (a[prop] === void 0) {\n          a[prop] = {};\n        }\n        if (a[prop].constructor === Object) {\n          deepExtend(a[prop], b[prop], false, allowDeletion);\n        } else {\n          copyOrDelete(a, b, prop, allowDeletion);\n        }\n      } else if (isArray$12(b[prop])) {\n        throw new TypeError(\"Arrays are not supported by deepExtend\");\n      } else {\n        copyOrDelete(a, b, prop, allowDeletion);\n      }\n    }\n  }\n  return a;\n}\nfunction selectiveNotDeepExtend(propsToExclude, a, b) {\n  var allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n  if (isArray$12(b)) {\n    throw new TypeError(\"Arrays are not supported by deepExtend\");\n  }\n  for (var prop in b) {\n    if (!Object.prototype.hasOwnProperty.call(b, prop)) {\n      continue;\n    }\n    if (includes32(propsToExclude).call(propsToExclude, prop)) {\n      continue;\n    }\n    if (b[prop] && b[prop].constructor === Object) {\n      if (a[prop] === void 0) {\n        a[prop] = {};\n      }\n      if (a[prop].constructor === Object) {\n        deepExtend(a[prop], b[prop]);\n      } else {\n        copyOrDelete(a, b, prop, allowDeletion);\n      }\n    } else if (isArray$12(b[prop])) {\n      a[prop] = [];\n      for (var i = 0; i < b[prop].length; i++) {\n        a[prop].push(b[prop][i]);\n      }\n    } else {\n      copyOrDelete(a, b, prop, allowDeletion);\n    }\n  }\n  return a;\n}\nfunction deepExtend(a, b) {\n  var protoExtend = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n  var allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n  for (var prop in b) {\n    if (Object.prototype.hasOwnProperty.call(b, prop) || protoExtend === true) {\n      if (_typeof2(b[prop]) === \"object\" && b[prop] !== null && getPrototypeOf$42(b[prop]) === Object.prototype) {\n        if (a[prop] === void 0) {\n          a[prop] = deepExtend({}, b[prop], protoExtend);\n        } else if (_typeof2(a[prop]) === \"object\" && a[prop] !== null && getPrototypeOf$42(a[prop]) === Object.prototype) {\n          deepExtend(a[prop], b[prop], protoExtend);\n        } else {\n          copyOrDelete(a, b, prop, allowDeletion);\n        }\n      } else if (isArray$12(b[prop])) {\n        var _context6;\n        a[prop] = slice22(_context6 = b[prop]).call(_context6);\n      } else {\n        copyOrDelete(a, b, prop, allowDeletion);\n      }\n    }\n  }\n  return a;\n}\nfunction copyAndExtendArray(arr, newValue) {\n  var _context7;\n  return concat22(_context7 = []).call(_context7, _toConsumableArray2(arr), [newValue]);\n}\nfunction copyArray(arr) {\n  return slice22(arr).call(arr);\n}\nfunction getAbsoluteLeft(elem) {\n  return elem.getBoundingClientRect().left;\n}\nfunction getAbsoluteTop(elem) {\n  return elem.getBoundingClientRect().top;\n}\nfunction forEach$12(object2, callback) {\n  if (isArray$12(object2)) {\n    var len = object2.length;\n    for (var i = 0; i < len; i++) {\n      callback(object2[i], i, object2);\n    }\n  } else {\n    for (var key in object2) {\n      if (Object.prototype.hasOwnProperty.call(object2, key)) {\n        callback(object2[key], key, object2);\n      }\n    }\n  }\n}\nfunction addEventListener(element, action, listener, useCapture) {\n  if (element.addEventListener) {\n    var _context8;\n    if (useCapture === void 0) {\n      useCapture = false;\n    }\n    if (action === \"mousewheel\" && includes32(_context8 = navigator.userAgent).call(_context8, \"Firefox\")) {\n      action = \"DOMMouseScroll\";\n    }\n    element.addEventListener(action, listener, useCapture);\n  } else {\n    element.attachEvent(\"on\" + action, listener);\n  }\n}\nfunction removeEventListener(element, action, listener, useCapture) {\n  if (element.removeEventListener) {\n    var _context9;\n    if (useCapture === void 0) {\n      useCapture = false;\n    }\n    if (action === \"mousewheel\" && includes32(_context9 = navigator.userAgent).call(_context9, \"Firefox\")) {\n      action = \"DOMMouseScroll\";\n    }\n    element.removeEventListener(action, listener, useCapture);\n  } else {\n    element.detachEvent(\"on\" + action, listener);\n  }\n}\nfunction hexToRGB(hex22) {\n  var result2;\n  switch (hex22.length) {\n    case 3:\n    case 4:\n      result2 = shortHexRE.exec(hex22);\n      return result2 ? {\n        r: _parseInt(result2[1] + result2[1], 16),\n        g: _parseInt(result2[2] + result2[2], 16),\n        b: _parseInt(result2[3] + result2[3], 16)\n      } : null;\n    case 6:\n    case 7:\n      result2 = fullHexRE.exec(hex22);\n      return result2 ? {\n        r: _parseInt(result2[1], 16),\n        g: _parseInt(result2[2], 16),\n        b: _parseInt(result2[3], 16)\n      } : null;\n    default:\n      return null;\n  }\n}\nfunction overrideOpacity(color, opacity) {\n  if (includes32(color).call(color, \"rgba\")) {\n    return color;\n  } else if (includes32(color).call(color, \"rgb\")) {\n    var rgb = color.substr(indexOf22(color).call(color, \"(\") + 1).replace(\")\", \"\").split(\",\");\n    return \"rgba(\" + rgb[0] + \",\" + rgb[1] + \",\" + rgb[2] + \",\" + opacity + \")\";\n  } else {\n    var _rgb = hexToRGB(color);\n    if (_rgb == null) {\n      return color;\n    } else {\n      return \"rgba(\" + _rgb.r + \",\" + _rgb.g + \",\" + _rgb.b + \",\" + opacity + \")\";\n    }\n  }\n}\nfunction RGBToHex(red, green, blue) {\n  var _context10;\n  return \"#\" + slice22(_context10 = ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16)).call(_context10, 1);\n}\nfunction parseColor(inputColor, defaultColor) {\n  if (isString(inputColor)) {\n    var colorStr = inputColor;\n    if (isValidRGB(colorStr)) {\n      var _context11;\n      var rgb = map$32(_context11 = colorStr.substr(4).substr(0, colorStr.length - 5).split(\",\")).call(_context11, function(value) {\n        return _parseInt(value);\n      });\n      colorStr = RGBToHex(rgb[0], rgb[1], rgb[2]);\n    }\n    if (isValidHex(colorStr) === true) {\n      var hsv = hexToHSV(colorStr);\n      var lighterColorHSV = {\n        h: hsv.h,\n        s: hsv.s * 0.8,\n        v: Math.min(1, hsv.v * 1.02)\n      };\n      var darkerColorHSV = {\n        h: hsv.h,\n        s: Math.min(1, hsv.s * 1.25),\n        v: hsv.v * 0.8\n      };\n      var darkerColorHex = HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);\n      var lighterColorHex = HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);\n      return {\n        background: colorStr,\n        border: darkerColorHex,\n        highlight: {\n          background: lighterColorHex,\n          border: darkerColorHex\n        },\n        hover: {\n          background: lighterColorHex,\n          border: darkerColorHex\n        }\n      };\n    } else {\n      return {\n        background: colorStr,\n        border: colorStr,\n        highlight: {\n          background: colorStr,\n          border: colorStr\n        },\n        hover: {\n          background: colorStr,\n          border: colorStr\n        }\n      };\n    }\n  } else {\n    if (defaultColor) {\n      var color = {\n        background: inputColor.background || defaultColor.background,\n        border: inputColor.border || defaultColor.border,\n        highlight: isString(inputColor.highlight) ? {\n          border: inputColor.highlight,\n          background: inputColor.highlight\n        } : {\n          background: inputColor.highlight && inputColor.highlight.background || defaultColor.highlight.background,\n          border: inputColor.highlight && inputColor.highlight.border || defaultColor.highlight.border\n        },\n        hover: isString(inputColor.hover) ? {\n          border: inputColor.hover,\n          background: inputColor.hover\n        } : {\n          border: inputColor.hover && inputColor.hover.border || defaultColor.hover.border,\n          background: inputColor.hover && inputColor.hover.background || defaultColor.hover.background\n        }\n      };\n      return color;\n    } else {\n      var _color = {\n        background: inputColor.background || void 0,\n        border: inputColor.border || void 0,\n        highlight: isString(inputColor.highlight) ? {\n          border: inputColor.highlight,\n          background: inputColor.highlight\n        } : {\n          background: inputColor.highlight && inputColor.highlight.background || void 0,\n          border: inputColor.highlight && inputColor.highlight.border || void 0\n        },\n        hover: isString(inputColor.hover) ? {\n          border: inputColor.hover,\n          background: inputColor.hover\n        } : {\n          border: inputColor.hover && inputColor.hover.border || void 0,\n          background: inputColor.hover && inputColor.hover.background || void 0\n        }\n      };\n      return _color;\n    }\n  }\n}\nfunction RGBToHSV(red, green, blue) {\n  red = red / 255;\n  green = green / 255;\n  blue = blue / 255;\n  var minRGB = Math.min(red, Math.min(green, blue));\n  var maxRGB = Math.max(red, Math.max(green, blue));\n  if (minRGB === maxRGB) {\n    return {\n      h: 0,\n      s: 0,\n      v: minRGB\n    };\n  }\n  var d = red === minRGB ? green - blue : blue === minRGB ? red - green : blue - red;\n  var h = red === minRGB ? 3 : blue === minRGB ? 1 : 5;\n  var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;\n  var saturation = (maxRGB - minRGB) / maxRGB;\n  var value = maxRGB;\n  return {\n    h: hue,\n    s: saturation,\n    v: value\n  };\n}\nfunction HSVToRGB(h, s, v) {\n  var r;\n  var g;\n  var b;\n  var i = Math.floor(h * 6);\n  var f = h * 6 - i;\n  var p = v * (1 - s);\n  var q2 = v * (1 - f * s);\n  var t = v * (1 - (1 - f) * s);\n  switch (i % 6) {\n    case 0:\n      r = v, g = t, b = p;\n      break;\n    case 1:\n      r = q2, g = v, b = p;\n      break;\n    case 2:\n      r = p, g = v, b = t;\n      break;\n    case 3:\n      r = p, g = q2, b = v;\n      break;\n    case 4:\n      r = t, g = p, b = v;\n      break;\n    case 5:\n      r = v, g = p, b = q2;\n      break;\n  }\n  return {\n    r: Math.floor(r * 255),\n    g: Math.floor(g * 255),\n    b: Math.floor(b * 255)\n  };\n}\nfunction HSVToHex(h, s, v) {\n  var rgb = HSVToRGB(h, s, v);\n  return RGBToHex(rgb.r, rgb.g, rgb.b);\n}\nfunction hexToHSV(hex22) {\n  var rgb = hexToRGB(hex22);\n  if (!rgb) {\n    throw new TypeError(\"'\".concat(hex22, \"' is not a valid color.\"));\n  }\n  return RGBToHSV(rgb.r, rgb.g, rgb.b);\n}\nfunction isValidHex(hex22) {\n  var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex22);\n  return isOk;\n}\nfunction isValidRGB(rgb) {\n  return rgbRE.test(rgb);\n}\nfunction isValidRGBA(rgba) {\n  return rgbaRE.test(rgba);\n}\nfunction bridgeObject(referenceObject) {\n  if (referenceObject === null || _typeof2(referenceObject) !== \"object\") {\n    return null;\n  }\n  if (referenceObject instanceof Element) {\n    return referenceObject;\n  }\n  var objectTo = create$52(referenceObject);\n  for (var i in referenceObject) {\n    if (Object.prototype.hasOwnProperty.call(referenceObject, i)) {\n      if (_typeof2(referenceObject[i]) == \"object\") {\n        objectTo[i] = bridgeObject(referenceObject[i]);\n      }\n    }\n  }\n  return objectTo;\n}\nfunction mergeOptions(mergeTarget, options2, option) {\n  var globalOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n  var isPresent = function isPresent2(obj) {\n    return obj !== null && obj !== void 0;\n  };\n  var isObject22 = function isObject3(obj) {\n    return obj !== null && _typeof2(obj) === \"object\";\n  };\n  var isEmpty = function isEmpty2(obj) {\n    for (var x in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, x)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  if (!isObject22(mergeTarget)) {\n    throw new Error(\"Parameter mergeTarget must be an object\");\n  }\n  if (!isObject22(options2)) {\n    throw new Error(\"Parameter options must be an object\");\n  }\n  if (!isPresent(option)) {\n    throw new Error(\"Parameter option must have a value\");\n  }\n  if (!isObject22(globalOptions)) {\n    throw new Error(\"Parameter globalOptions must be an object\");\n  }\n  var doMerge = function doMerge2(target, options3, option2) {\n    if (!isObject22(target[option2])) {\n      target[option2] = {};\n    }\n    var src = options3[option2];\n    var dst = target[option2];\n    for (var prop in src) {\n      if (Object.prototype.hasOwnProperty.call(src, prop)) {\n        dst[prop] = src[prop];\n      }\n    }\n  };\n  var srcOption = options2[option];\n  var globalPassed = isObject22(globalOptions) && !isEmpty(globalOptions);\n  var globalOption = globalPassed ? globalOptions[option] : void 0;\n  var globalEnabled = globalOption ? globalOption.enabled : void 0;\n  if (srcOption === void 0) {\n    return;\n  }\n  if (typeof srcOption === \"boolean\") {\n    if (!isObject22(mergeTarget[option])) {\n      mergeTarget[option] = {};\n    }\n    mergeTarget[option].enabled = srcOption;\n    return;\n  }\n  if (srcOption === null && !isObject22(mergeTarget[option])) {\n    if (isPresent(globalOption)) {\n      mergeTarget[option] = create$52(globalOption);\n    } else {\n      return;\n    }\n  }\n  if (!isObject22(srcOption)) {\n    return;\n  }\n  var enabled = true;\n  if (srcOption.enabled !== void 0) {\n    enabled = srcOption.enabled;\n  } else {\n    if (globalEnabled !== void 0) {\n      enabled = globalOption.enabled;\n    }\n  }\n  doMerge(mergeTarget, options2, option);\n  mergeTarget[option].enabled = enabled;\n}\nvar easingFunctions = {\n  linear: function linear(t) {\n    return t;\n  },\n  easeInQuad: function easeInQuad(t) {\n    return t * t;\n  },\n  easeOutQuad: function easeOutQuad(t) {\n    return t * (2 - t);\n  },\n  easeInOutQuad: function easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  },\n  easeInCubic: function easeInCubic(t) {\n    return t * t * t;\n  },\n  easeOutCubic: function easeOutCubic(t) {\n    return --t * t * t + 1;\n  },\n  easeInOutCubic: function easeInOutCubic(t) {\n    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n  },\n  easeInQuart: function easeInQuart(t) {\n    return t * t * t * t;\n  },\n  easeOutQuart: function easeOutQuart(t) {\n    return 1 - --t * t * t * t;\n  },\n  easeInOutQuart: function easeInOutQuart(t) {\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n  },\n  easeInQuint: function easeInQuint(t) {\n    return t * t * t * t * t;\n  },\n  easeOutQuint: function easeOutQuint(t) {\n    return 1 + --t * t * t * t * t;\n  },\n  easeInOutQuint: function easeInOutQuint(t) {\n    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n  }\n};\nfunction topMost(pile, accessors) {\n  var candidate;\n  if (!isArray$12(accessors)) {\n    accessors = [accessors];\n  }\n  var _iterator3 = _createForOfIteratorHelper$7(pile), _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {\n      var member = _step3.value;\n      if (member) {\n        candidate = member[accessors[0]];\n        for (var i = 1; i < accessors.length; i++) {\n          if (candidate) {\n            candidate = candidate[accessors[i]];\n          }\n        }\n        if (typeof candidate !== \"undefined\") {\n          break;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return candidate;\n}\nvar htmlColors = {\n  black: \"#000000\",\n  navy: \"#000080\",\n  darkblue: \"#00008B\",\n  mediumblue: \"#0000CD\",\n  blue: \"#0000FF\",\n  darkgreen: \"#006400\",\n  green: \"#008000\",\n  teal: \"#008080\",\n  darkcyan: \"#008B8B\",\n  deepskyblue: \"#00BFFF\",\n  darkturquoise: \"#00CED1\",\n  mediumspringgreen: \"#00FA9A\",\n  lime: \"#00FF00\",\n  springgreen: \"#00FF7F\",\n  aqua: \"#00FFFF\",\n  cyan: \"#00FFFF\",\n  midnightblue: \"#191970\",\n  dodgerblue: \"#1E90FF\",\n  lightseagreen: \"#20B2AA\",\n  forestgreen: \"#228B22\",\n  seagreen: \"#2E8B57\",\n  darkslategray: \"#2F4F4F\",\n  limegreen: \"#32CD32\",\n  mediumseagreen: \"#3CB371\",\n  turquoise: \"#40E0D0\",\n  royalblue: \"#4169E1\",\n  steelblue: \"#4682B4\",\n  darkslateblue: \"#483D8B\",\n  mediumturquoise: \"#48D1CC\",\n  indigo: \"#4B0082\",\n  darkolivegreen: \"#556B2F\",\n  cadetblue: \"#5F9EA0\",\n  cornflowerblue: \"#6495ED\",\n  mediumaquamarine: \"#66CDAA\",\n  dimgray: \"#696969\",\n  slateblue: \"#6A5ACD\",\n  olivedrab: \"#6B8E23\",\n  slategray: \"#708090\",\n  lightslategray: \"#778899\",\n  mediumslateblue: \"#7B68EE\",\n  lawngreen: \"#7CFC00\",\n  chartreuse: \"#7FFF00\",\n  aquamarine: \"#7FFFD4\",\n  maroon: \"#800000\",\n  purple: \"#800080\",\n  olive: \"#808000\",\n  gray: \"#808080\",\n  skyblue: \"#87CEEB\",\n  lightskyblue: \"#87CEFA\",\n  blueviolet: \"#8A2BE2\",\n  darkred: \"#8B0000\",\n  darkmagenta: \"#8B008B\",\n  saddlebrown: \"#8B4513\",\n  darkseagreen: \"#8FBC8F\",\n  lightgreen: \"#90EE90\",\n  mediumpurple: \"#9370D8\",\n  darkviolet: \"#9400D3\",\n  palegreen: \"#98FB98\",\n  darkorchid: \"#9932CC\",\n  yellowgreen: \"#9ACD32\",\n  sienna: \"#A0522D\",\n  brown: \"#A52A2A\",\n  darkgray: \"#A9A9A9\",\n  lightblue: \"#ADD8E6\",\n  greenyellow: \"#ADFF2F\",\n  paleturquoise: \"#AFEEEE\",\n  lightsteelblue: \"#B0C4DE\",\n  powderblue: \"#B0E0E6\",\n  firebrick: \"#B22222\",\n  darkgoldenrod: \"#B8860B\",\n  mediumorchid: \"#BA55D3\",\n  rosybrown: \"#BC8F8F\",\n  darkkhaki: \"#BDB76B\",\n  silver: \"#C0C0C0\",\n  mediumvioletred: \"#C71585\",\n  indianred: \"#CD5C5C\",\n  peru: \"#CD853F\",\n  chocolate: \"#D2691E\",\n  tan: \"#D2B48C\",\n  lightgrey: \"#D3D3D3\",\n  palevioletred: \"#D87093\",\n  thistle: \"#D8BFD8\",\n  orchid: \"#DA70D6\",\n  goldenrod: \"#DAA520\",\n  crimson: \"#DC143C\",\n  gainsboro: \"#DCDCDC\",\n  plum: \"#DDA0DD\",\n  burlywood: \"#DEB887\",\n  lightcyan: \"#E0FFFF\",\n  lavender: \"#E6E6FA\",\n  darksalmon: \"#E9967A\",\n  violet: \"#EE82EE\",\n  palegoldenrod: \"#EEE8AA\",\n  lightcoral: \"#F08080\",\n  khaki: \"#F0E68C\",\n  aliceblue: \"#F0F8FF\",\n  honeydew: \"#F0FFF0\",\n  azure: \"#F0FFFF\",\n  sandybrown: \"#F4A460\",\n  wheat: \"#F5DEB3\",\n  beige: \"#F5F5DC\",\n  whitesmoke: \"#F5F5F5\",\n  mintcream: \"#F5FFFA\",\n  ghostwhite: \"#F8F8FF\",\n  salmon: \"#FA8072\",\n  antiquewhite: \"#FAEBD7\",\n  linen: \"#FAF0E6\",\n  lightgoldenrodyellow: \"#FAFAD2\",\n  oldlace: \"#FDF5E6\",\n  red: \"#FF0000\",\n  fuchsia: \"#FF00FF\",\n  magenta: \"#FF00FF\",\n  deeppink: \"#FF1493\",\n  orangered: \"#FF4500\",\n  tomato: \"#FF6347\",\n  hotpink: \"#FF69B4\",\n  coral: \"#FF7F50\",\n  darkorange: \"#FF8C00\",\n  lightsalmon: \"#FFA07A\",\n  orange: \"#FFA500\",\n  lightpink: \"#FFB6C1\",\n  pink: \"#FFC0CB\",\n  gold: \"#FFD700\",\n  peachpuff: \"#FFDAB9\",\n  navajowhite: \"#FFDEAD\",\n  moccasin: \"#FFE4B5\",\n  bisque: \"#FFE4C4\",\n  mistyrose: \"#FFE4E1\",\n  blanchedalmond: \"#FFEBCD\",\n  papayawhip: \"#FFEFD5\",\n  lavenderblush: \"#FFF0F5\",\n  seashell: \"#FFF5EE\",\n  cornsilk: \"#FFF8DC\",\n  lemonchiffon: \"#FFFACD\",\n  floralwhite: \"#FFFAF0\",\n  snow: \"#FFFAFA\",\n  yellow: \"#FFFF00\",\n  lightyellow: \"#FFFFE0\",\n  ivory: \"#FFFFF0\",\n  white: \"#FFFFFF\"\n};\nvar ColorPicker$1 = /* @__PURE__ */ function() {\n  function ColorPicker$12() {\n    var pixelRatio = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;\n    _classCallCheck2(this, ColorPicker$12);\n    this.pixelRatio = pixelRatio;\n    this.generated = false;\n    this.centerCoordinates = {\n      x: 289 / 2,\n      y: 289 / 2\n    };\n    this.r = 289 * 0.49;\n    this.color = {\n      r: 255,\n      g: 255,\n      b: 255,\n      a: 1\n    };\n    this.hueCircle = void 0;\n    this.initialColor = {\n      r: 255,\n      g: 255,\n      b: 255,\n      a: 1\n    };\n    this.previousColor = void 0;\n    this.applied = false;\n    this.updateCallback = function() {\n    };\n    this.closeCallback = function() {\n    };\n    this._create();\n  }\n  _createClass2(ColorPicker$12, [{\n    key: \"insertTo\",\n    value: function insertTo(container) {\n      if (this.hammer !== void 0) {\n        this.hammer.destroy();\n        this.hammer = void 0;\n      }\n      this.container = container;\n      this.container.appendChild(this.frame);\n      this._bindHammer();\n      this._setSize();\n    }\n  }, {\n    key: \"setUpdateCallback\",\n    value: function setUpdateCallback(callback) {\n      if (typeof callback === \"function\") {\n        this.updateCallback = callback;\n      } else {\n        throw new Error(\"Function attempted to set as colorPicker update callback is not a function.\");\n      }\n    }\n  }, {\n    key: \"setCloseCallback\",\n    value: function setCloseCallback(callback) {\n      if (typeof callback === \"function\") {\n        this.closeCallback = callback;\n      } else {\n        throw new Error(\"Function attempted to set as colorPicker closing callback is not a function.\");\n      }\n    }\n  }, {\n    key: \"_isColorString\",\n    value: function _isColorString(color) {\n      if (typeof color === \"string\") {\n        return htmlColors[color];\n      }\n    }\n  }, {\n    key: \"setColor\",\n    value: function setColor(color) {\n      var setInitial = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n      if (color === \"none\") {\n        return;\n      }\n      var rgba;\n      var htmlColor = this._isColorString(color);\n      if (htmlColor !== void 0) {\n        color = htmlColor;\n      }\n      if (isString(color) === true) {\n        if (isValidRGB(color) === true) {\n          var rgbaArray = color.substr(4).substr(0, color.length - 5).split(\",\");\n          rgba = {\n            r: rgbaArray[0],\n            g: rgbaArray[1],\n            b: rgbaArray[2],\n            a: 1\n          };\n        } else if (isValidRGBA(color) === true) {\n          var _rgbaArray = color.substr(5).substr(0, color.length - 6).split(\",\");\n          rgba = {\n            r: _rgbaArray[0],\n            g: _rgbaArray[1],\n            b: _rgbaArray[2],\n            a: _rgbaArray[3]\n          };\n        } else if (isValidHex(color) === true) {\n          var rgbObj = hexToRGB(color);\n          rgba = {\n            r: rgbObj.r,\n            g: rgbObj.g,\n            b: rgbObj.b,\n            a: 1\n          };\n        }\n      } else {\n        if (color instanceof Object) {\n          if (color.r !== void 0 && color.g !== void 0 && color.b !== void 0) {\n            var alpha = color.a !== void 0 ? color.a : \"1.0\";\n            rgba = {\n              r: color.r,\n              g: color.g,\n              b: color.b,\n              a: alpha\n            };\n          }\n        }\n      }\n      if (rgba === void 0) {\n        throw new Error(\"Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: \" + stringify$12(color));\n      } else {\n        this._setColor(rgba, setInitial);\n      }\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      if (this.closeCallback !== void 0) {\n        this.closeCallback();\n        this.closeCallback = void 0;\n      }\n      this.applied = false;\n      this.frame.style.display = \"block\";\n      this._generateHueCircle();\n    }\n  }, {\n    key: \"_hide\",\n    value: function _hide() {\n      var _this2 = this;\n      var storePrevious = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n      if (storePrevious === true) {\n        this.previousColor = assign$22({}, this.color);\n      }\n      if (this.applied === true) {\n        this.updateCallback(this.initialColor);\n      }\n      this.frame.style.display = \"none\";\n      setTimeout$12(function() {\n        if (_this2.closeCallback !== void 0) {\n          _this2.closeCallback();\n          _this2.closeCallback = void 0;\n        }\n      }, 0);\n    }\n  }, {\n    key: \"_save\",\n    value: function _save() {\n      this.updateCallback(this.color);\n      this.applied = false;\n      this._hide();\n    }\n  }, {\n    key: \"_apply\",\n    value: function _apply() {\n      this.applied = true;\n      this.updateCallback(this.color);\n      this._updatePicker(this.color);\n    }\n  }, {\n    key: \"_loadLast\",\n    value: function _loadLast() {\n      if (this.previousColor !== void 0) {\n        this.setColor(this.previousColor, false);\n      } else {\n        alert(\"There is no last color to load...\");\n      }\n    }\n  }, {\n    key: \"_setColor\",\n    value: function _setColor(rgba) {\n      var setInitial = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n      if (setInitial === true) {\n        this.initialColor = assign$22({}, rgba);\n      }\n      this.color = rgba;\n      var hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);\n      var angleConvert = 2 * Math.PI;\n      var radius = this.r * hsv.s;\n      var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);\n      var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);\n      this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + \"px\";\n      this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + \"px\";\n      this._updatePicker(rgba);\n    }\n  }, {\n    key: \"_setOpacity\",\n    value: function _setOpacity(value) {\n      this.color.a = value / 100;\n      this._updatePicker(this.color);\n    }\n  }, {\n    key: \"_setBrightness\",\n    value: function _setBrightness(value) {\n      var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);\n      hsv.v = value / 100;\n      var rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);\n      rgba[\"a\"] = this.color.a;\n      this.color = rgba;\n      this._updatePicker();\n    }\n  }, {\n    key: \"_updatePicker\",\n    value: function _updatePicker() {\n      var rgba = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.color;\n      var hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);\n      var ctx = this.colorPickerCanvas.getContext(\"2d\");\n      if (this.pixelRation === void 0) {\n        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);\n      }\n      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n      var w = this.colorPickerCanvas.clientWidth;\n      var h = this.colorPickerCanvas.clientHeight;\n      ctx.clearRect(0, 0, w, h);\n      ctx.putImageData(this.hueCircle, 0, 0);\n      ctx.fillStyle = \"rgba(0,0,0,\" + (1 - hsv.v) + \")\";\n      ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);\n      fill22(ctx).call(ctx);\n      this.brightnessRange.value = 100 * hsv.v;\n      this.opacityRange.value = 100 * rgba.a;\n      this.initialColorDiv.style.backgroundColor = \"rgba(\" + this.initialColor.r + \",\" + this.initialColor.g + \",\" + this.initialColor.b + \",\" + this.initialColor.a + \")\";\n      this.newColorDiv.style.backgroundColor = \"rgba(\" + this.color.r + \",\" + this.color.g + \",\" + this.color.b + \",\" + this.color.a + \")\";\n    }\n  }, {\n    key: \"_setSize\",\n    value: function _setSize() {\n      this.colorPickerCanvas.style.width = \"100%\";\n      this.colorPickerCanvas.style.height = \"100%\";\n      this.colorPickerCanvas.width = 289 * this.pixelRatio;\n      this.colorPickerCanvas.height = 289 * this.pixelRatio;\n    }\n  }, {\n    key: \"_create\",\n    value: function _create() {\n      var _context16, _context17, _context18, _context19;\n      this.frame = document.createElement(\"div\");\n      this.frame.className = \"vis-color-picker\";\n      this.colorPickerDiv = document.createElement(\"div\");\n      this.colorPickerSelector = document.createElement(\"div\");\n      this.colorPickerSelector.className = \"vis-selector\";\n      this.colorPickerDiv.appendChild(this.colorPickerSelector);\n      this.colorPickerCanvas = document.createElement(\"canvas\");\n      this.colorPickerDiv.appendChild(this.colorPickerCanvas);\n      if (!this.colorPickerCanvas.getContext) {\n        var noCanvas = document.createElement(\"DIV\");\n        noCanvas.style.color = \"red\";\n        noCanvas.style.fontWeight = \"bold\";\n        noCanvas.style.padding = \"10px\";\n        noCanvas.innerText = \"Error: your browser does not support HTML canvas\";\n        this.colorPickerCanvas.appendChild(noCanvas);\n      } else {\n        var ctx = this.colorPickerCanvas.getContext(\"2d\");\n        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);\n        this.colorPickerCanvas.getContext(\"2d\").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n      }\n      this.colorPickerDiv.className = \"vis-color\";\n      this.opacityDiv = document.createElement(\"div\");\n      this.opacityDiv.className = \"vis-opacity\";\n      this.brightnessDiv = document.createElement(\"div\");\n      this.brightnessDiv.className = \"vis-brightness\";\n      this.arrowDiv = document.createElement(\"div\");\n      this.arrowDiv.className = \"vis-arrow\";\n      this.opacityRange = document.createElement(\"input\");\n      try {\n        this.opacityRange.type = \"range\";\n        this.opacityRange.min = \"0\";\n        this.opacityRange.max = \"100\";\n      } catch (err) {\n      }\n      this.opacityRange.value = \"100\";\n      this.opacityRange.className = \"vis-range\";\n      this.brightnessRange = document.createElement(\"input\");\n      try {\n        this.brightnessRange.type = \"range\";\n        this.brightnessRange.min = \"0\";\n        this.brightnessRange.max = \"100\";\n      } catch (err) {\n      }\n      this.brightnessRange.value = \"100\";\n      this.brightnessRange.className = \"vis-range\";\n      this.opacityDiv.appendChild(this.opacityRange);\n      this.brightnessDiv.appendChild(this.brightnessRange);\n      var me3 = this;\n      this.opacityRange.onchange = function() {\n        me3._setOpacity(this.value);\n      };\n      this.opacityRange.oninput = function() {\n        me3._setOpacity(this.value);\n      };\n      this.brightnessRange.onchange = function() {\n        me3._setBrightness(this.value);\n      };\n      this.brightnessRange.oninput = function() {\n        me3._setBrightness(this.value);\n      };\n      this.brightnessLabel = document.createElement(\"div\");\n      this.brightnessLabel.className = \"vis-label vis-brightness\";\n      this.brightnessLabel.innerText = \"brightness:\";\n      this.opacityLabel = document.createElement(\"div\");\n      this.opacityLabel.className = \"vis-label vis-opacity\";\n      this.opacityLabel.innerText = \"opacity:\";\n      this.newColorDiv = document.createElement(\"div\");\n      this.newColorDiv.className = \"vis-new-color\";\n      this.newColorDiv.innerText = \"new\";\n      this.initialColorDiv = document.createElement(\"div\");\n      this.initialColorDiv.className = \"vis-initial-color\";\n      this.initialColorDiv.innerText = \"initial\";\n      this.cancelButton = document.createElement(\"div\");\n      this.cancelButton.className = \"vis-button vis-cancel\";\n      this.cancelButton.innerText = \"cancel\";\n      this.cancelButton.onclick = bind$52(_context16 = this._hide).call(_context16, this, false);\n      this.applyButton = document.createElement(\"div\");\n      this.applyButton.className = \"vis-button vis-apply\";\n      this.applyButton.innerText = \"apply\";\n      this.applyButton.onclick = bind$52(_context17 = this._apply).call(_context17, this);\n      this.saveButton = document.createElement(\"div\");\n      this.saveButton.className = \"vis-button vis-save\";\n      this.saveButton.innerText = \"save\";\n      this.saveButton.onclick = bind$52(_context18 = this._save).call(_context18, this);\n      this.loadButton = document.createElement(\"div\");\n      this.loadButton.className = \"vis-button vis-load\";\n      this.loadButton.innerText = \"load last\";\n      this.loadButton.onclick = bind$52(_context19 = this._loadLast).call(_context19, this);\n      this.frame.appendChild(this.colorPickerDiv);\n      this.frame.appendChild(this.arrowDiv);\n      this.frame.appendChild(this.brightnessLabel);\n      this.frame.appendChild(this.brightnessDiv);\n      this.frame.appendChild(this.opacityLabel);\n      this.frame.appendChild(this.opacityDiv);\n      this.frame.appendChild(this.newColorDiv);\n      this.frame.appendChild(this.initialColorDiv);\n      this.frame.appendChild(this.cancelButton);\n      this.frame.appendChild(this.applyButton);\n      this.frame.appendChild(this.saveButton);\n      this.frame.appendChild(this.loadButton);\n    }\n  }, {\n    key: \"_bindHammer\",\n    value: function _bindHammer() {\n      var _this3 = this;\n      this.drag = {};\n      this.pinch = {};\n      this.hammer = new Hammer$12(this.colorPickerCanvas);\n      this.hammer.get(\"pinch\").set({\n        enable: true\n      });\n      this.hammer.on(\"hammer.input\", function(event) {\n        if (event.isFirst) {\n          _this3._moveSelector(event);\n        }\n      });\n      this.hammer.on(\"tap\", function(event) {\n        _this3._moveSelector(event);\n      });\n      this.hammer.on(\"panstart\", function(event) {\n        _this3._moveSelector(event);\n      });\n      this.hammer.on(\"panmove\", function(event) {\n        _this3._moveSelector(event);\n      });\n      this.hammer.on(\"panend\", function(event) {\n        _this3._moveSelector(event);\n      });\n    }\n  }, {\n    key: \"_generateHueCircle\",\n    value: function _generateHueCircle() {\n      if (this.generated === false) {\n        var ctx = this.colorPickerCanvas.getContext(\"2d\");\n        if (this.pixelRation === void 0) {\n          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);\n        }\n        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n        var w = this.colorPickerCanvas.clientWidth;\n        var h = this.colorPickerCanvas.clientHeight;\n        ctx.clearRect(0, 0, w, h);\n        var x, y, hue, sat;\n        this.centerCoordinates = {\n          x: w * 0.5,\n          y: h * 0.5\n        };\n        this.r = 0.49 * w;\n        var angleConvert = 2 * Math.PI / 360;\n        var hfac = 1 / 360;\n        var sfac = 1 / this.r;\n        var rgb;\n        for (hue = 0; hue < 360; hue++) {\n          for (sat = 0; sat < this.r; sat++) {\n            x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);\n            y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);\n            rgb = HSVToRGB(hue * hfac, sat * sfac, 1);\n            ctx.fillStyle = \"rgb(\" + rgb.r + \",\" + rgb.g + \",\" + rgb.b + \")\";\n            ctx.fillRect(x - 0.5, y - 0.5, 2, 2);\n          }\n        }\n        ctx.strokeStyle = \"rgba(0,0,0,1)\";\n        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);\n        ctx.stroke();\n        this.hueCircle = ctx.getImageData(0, 0, w, h);\n      }\n      this.generated = true;\n    }\n  }, {\n    key: \"_moveSelector\",\n    value: function _moveSelector(event) {\n      var rect = this.colorPickerDiv.getBoundingClientRect();\n      var left = event.center.x - rect.left;\n      var top = event.center.y - rect.top;\n      var centerY = 0.5 * this.colorPickerDiv.clientHeight;\n      var centerX = 0.5 * this.colorPickerDiv.clientWidth;\n      var x = left - centerX;\n      var y = top - centerY;\n      var angle = Math.atan2(x, y);\n      var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);\n      var newTop = Math.cos(angle) * radius + centerY;\n      var newLeft = Math.sin(angle) * radius + centerX;\n      this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + \"px\";\n      this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + \"px\";\n      var h = angle / (2 * Math.PI);\n      h = h < 0 ? h + 1 : h;\n      var s = radius / this.r;\n      var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);\n      hsv.h = h;\n      hsv.s = s;\n      var rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);\n      rgba[\"a\"] = this.color.a;\n      this.color = rgba;\n      this.initialColorDiv.style.backgroundColor = \"rgba(\" + this.initialColor.r + \",\" + this.initialColor.g + \",\" + this.initialColor.b + \",\" + this.initialColor.a + \")\";\n      this.newColorDiv.style.backgroundColor = \"rgba(\" + this.color.r + \",\" + this.color.g + \",\" + this.color.b + \",\" + this.color.a + \")\";\n    }\n  }]);\n  return ColorPicker$12;\n}();\nfunction wrapInTag() {\n  for (var _len5 = arguments.length, rest = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    rest[_key5] = arguments[_key5];\n  }\n  if (rest.length < 1) {\n    throw new TypeError(\"Invalid arguments.\");\n  } else if (rest.length === 1) {\n    return document.createTextNode(rest[0]);\n  } else {\n    var element = document.createElement(rest[0]);\n    element.appendChild(wrapInTag.apply(void 0, _toConsumableArray2(slice22(rest).call(rest, 1))));\n    return element;\n  }\n}\nvar Configurator$1 = /* @__PURE__ */ function() {\n  function Configurator$12(parentModule, defaultContainer, configureOptions2) {\n    var pixelRatio = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n    var hideOption = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : function() {\n      return false;\n    };\n    _classCallCheck2(this, Configurator$12);\n    this.parent = parentModule;\n    this.changedOptions = [];\n    this.container = defaultContainer;\n    this.allowCreation = false;\n    this.hideOption = hideOption;\n    this.options = {};\n    this.initialized = false;\n    this.popupCounter = 0;\n    this.defaultOptions = {\n      enabled: false,\n      filter: true,\n      container: void 0,\n      showButton: true\n    };\n    assign$22(this.options, this.defaultOptions);\n    this.configureOptions = configureOptions2;\n    this.moduleOptions = {};\n    this.domElements = [];\n    this.popupDiv = {};\n    this.popupLimit = 5;\n    this.popupHistory = {};\n    this.colorPicker = new ColorPicker$1(pixelRatio);\n    this.wrapper = void 0;\n  }\n  _createClass2(Configurator$12, [{\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      if (options2 !== void 0) {\n        this.popupHistory = {};\n        this._removePopup();\n        var enabled = true;\n        if (typeof options2 === \"string\") {\n          this.options.filter = options2;\n        } else if (isArray$12(options2)) {\n          this.options.filter = options2.join();\n        } else if (_typeof2(options2) === \"object\") {\n          if (options2 == null) {\n            throw new TypeError(\"options cannot be null\");\n          }\n          if (options2.container !== void 0) {\n            this.options.container = options2.container;\n          }\n          if (filter22(options2) !== void 0) {\n            this.options.filter = filter22(options2);\n          }\n          if (options2.showButton !== void 0) {\n            this.options.showButton = options2.showButton;\n          }\n          if (options2.enabled !== void 0) {\n            enabled = options2.enabled;\n          }\n        } else if (typeof options2 === \"boolean\") {\n          this.options.filter = true;\n          enabled = options2;\n        } else if (typeof options2 === \"function\") {\n          this.options.filter = options2;\n          enabled = true;\n        }\n        if (filter22(this.options) === false) {\n          enabled = false;\n        }\n        this.options.enabled = enabled;\n      }\n      this._clean();\n    }\n  }, {\n    key: \"setModuleOptions\",\n    value: function setModuleOptions(moduleOptions) {\n      this.moduleOptions = moduleOptions;\n      if (this.options.enabled === true) {\n        this._clean();\n        if (this.options.container !== void 0) {\n          this.container = this.options.container;\n        }\n        this._create();\n      }\n    }\n  }, {\n    key: \"_create\",\n    value: function _create() {\n      this._clean();\n      this.changedOptions = [];\n      var filter$122 = filter22(this.options);\n      var counter = 0;\n      var show = false;\n      for (var _option in this.configureOptions) {\n        if (Object.prototype.hasOwnProperty.call(this.configureOptions, _option)) {\n          this.allowCreation = false;\n          show = false;\n          if (typeof filter$122 === \"function\") {\n            show = filter$122(_option, []);\n            show = show || this._handleObject(this.configureOptions[_option], [_option], true);\n          } else if (filter$122 === true || indexOf22(filter$122).call(filter$122, _option) !== -1) {\n            show = true;\n          }\n          if (show !== false) {\n            this.allowCreation = true;\n            if (counter > 0) {\n              this._makeItem([]);\n            }\n            this._makeHeader(_option);\n            this._handleObject(this.configureOptions[_option], [_option]);\n          }\n          counter++;\n        }\n      }\n      this._makeButton();\n      this._push();\n    }\n  }, {\n    key: \"_push\",\n    value: function _push() {\n      this.wrapper = document.createElement(\"div\");\n      this.wrapper.className = \"vis-configuration-wrapper\";\n      this.container.appendChild(this.wrapper);\n      for (var i = 0; i < this.domElements.length; i++) {\n        this.wrapper.appendChild(this.domElements[i]);\n      }\n      this._showPopupIfNeeded();\n    }\n  }, {\n    key: \"_clean\",\n    value: function _clean() {\n      for (var i = 0; i < this.domElements.length; i++) {\n        this.wrapper.removeChild(this.domElements[i]);\n      }\n      if (this.wrapper !== void 0) {\n        this.container.removeChild(this.wrapper);\n        this.wrapper = void 0;\n      }\n      this.domElements = [];\n      this._removePopup();\n    }\n  }, {\n    key: \"_getValue\",\n    value: function _getValue(path22) {\n      var base = this.moduleOptions;\n      for (var i = 0; i < path22.length; i++) {\n        if (base[path22[i]] !== void 0) {\n          base = base[path22[i]];\n        } else {\n          base = void 0;\n          break;\n        }\n      }\n      return base;\n    }\n  }, {\n    key: \"_makeItem\",\n    value: function _makeItem(path22) {\n      if (this.allowCreation === true) {\n        var item = document.createElement(\"div\");\n        item.className = \"vis-configuration vis-config-item vis-config-s\" + path22.length;\n        for (var _len6 = arguments.length, domElements = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n          domElements[_key6 - 1] = arguments[_key6];\n        }\n        forEach$22(domElements).call(domElements, function(element) {\n          item.appendChild(element);\n        });\n        this.domElements.push(item);\n        return this.domElements.length;\n      }\n      return 0;\n    }\n  }, {\n    key: \"_makeHeader\",\n    value: function _makeHeader(name2) {\n      var div = document.createElement(\"div\");\n      div.className = \"vis-configuration vis-config-header\";\n      div.innerText = name2;\n      this._makeItem([], div);\n    }\n  }, {\n    key: \"_makeLabel\",\n    value: function _makeLabel(name2, path22) {\n      var objectLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n      var div = document.createElement(\"div\");\n      div.className = \"vis-configuration vis-config-label vis-config-s\" + path22.length;\n      if (objectLabel === true) {\n        while (div.firstChild) {\n          div.removeChild(div.firstChild);\n        }\n        div.appendChild(wrapInTag(\"i\", \"b\", name2));\n      } else {\n        div.innerText = name2 + \":\";\n      }\n      return div;\n    }\n  }, {\n    key: \"_makeDropdown\",\n    value: function _makeDropdown(arr, value, path22) {\n      var select = document.createElement(\"select\");\n      select.className = \"vis-configuration vis-config-select\";\n      var selectedValue = 0;\n      if (value !== void 0) {\n        if (indexOf22(arr).call(arr, value) !== -1) {\n          selectedValue = indexOf22(arr).call(arr, value);\n        }\n      }\n      for (var i = 0; i < arr.length; i++) {\n        var _option2 = document.createElement(\"option\");\n        _option2.value = arr[i];\n        if (i === selectedValue) {\n          _option2.selected = \"selected\";\n        }\n        _option2.innerText = arr[i];\n        select.appendChild(_option2);\n      }\n      var me3 = this;\n      select.onchange = function() {\n        me3._update(this.value, path22);\n      };\n      var label = this._makeLabel(path22[path22.length - 1], path22);\n      this._makeItem(path22, label, select);\n    }\n  }, {\n    key: \"_makeRange\",\n    value: function _makeRange(arr, value, path22) {\n      var defaultValue = arr[0];\n      var min22 = arr[1];\n      var max22 = arr[2];\n      var step = arr[3];\n      var range = document.createElement(\"input\");\n      range.className = \"vis-configuration vis-config-range\";\n      try {\n        range.type = \"range\";\n        range.min = min22;\n        range.max = max22;\n      } catch (err) {\n      }\n      range.step = step;\n      var popupString = \"\";\n      var popupValue = 0;\n      if (value !== void 0) {\n        var factor = 1.2;\n        if (value < 0 && value * factor < min22) {\n          range.min = Math.ceil(value * factor);\n          popupValue = range.min;\n          popupString = \"range increased\";\n        } else if (value / factor < min22) {\n          range.min = Math.ceil(value / factor);\n          popupValue = range.min;\n          popupString = \"range increased\";\n        }\n        if (value * factor > max22 && max22 !== 1) {\n          range.max = Math.ceil(value * factor);\n          popupValue = range.max;\n          popupString = \"range increased\";\n        }\n        range.value = value;\n      } else {\n        range.value = defaultValue;\n      }\n      var input = document.createElement(\"input\");\n      input.className = \"vis-configuration vis-config-rangeinput\";\n      input.value = range.value;\n      var me3 = this;\n      range.onchange = function() {\n        input.value = this.value;\n        me3._update(Number(this.value), path22);\n      };\n      range.oninput = function() {\n        input.value = this.value;\n      };\n      var label = this._makeLabel(path22[path22.length - 1], path22);\n      var itemIndex = this._makeItem(path22, label, range, input);\n      if (popupString !== \"\" && this.popupHistory[itemIndex] !== popupValue) {\n        this.popupHistory[itemIndex] = popupValue;\n        this._setupPopup(popupString, itemIndex);\n      }\n    }\n  }, {\n    key: \"_makeButton\",\n    value: function _makeButton() {\n      var _this4 = this;\n      if (this.options.showButton === true) {\n        var generateButton = document.createElement(\"div\");\n        generateButton.className = \"vis-configuration vis-config-button\";\n        generateButton.innerText = \"generate options\";\n        generateButton.onclick = function() {\n          _this4._printOptions();\n        };\n        generateButton.onmouseover = function() {\n          generateButton.className = \"vis-configuration vis-config-button hover\";\n        };\n        generateButton.onmouseout = function() {\n          generateButton.className = \"vis-configuration vis-config-button\";\n        };\n        this.optionsContainer = document.createElement(\"div\");\n        this.optionsContainer.className = \"vis-configuration vis-config-option-container\";\n        this.domElements.push(this.optionsContainer);\n        this.domElements.push(generateButton);\n      }\n    }\n  }, {\n    key: \"_setupPopup\",\n    value: function _setupPopup(string22, index2) {\n      var _this5 = this;\n      if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {\n        var div = document.createElement(\"div\");\n        div.id = \"vis-configuration-popup\";\n        div.className = \"vis-configuration-popup\";\n        div.innerText = string22;\n        div.onclick = function() {\n          _this5._removePopup();\n        };\n        this.popupCounter += 1;\n        this.popupDiv = {\n          html: div,\n          index: index2\n        };\n      }\n    }\n  }, {\n    key: \"_removePopup\",\n    value: function _removePopup() {\n      if (this.popupDiv.html !== void 0) {\n        this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);\n        clearTimeout(this.popupDiv.hideTimeout);\n        clearTimeout(this.popupDiv.deleteTimeout);\n        this.popupDiv = {};\n      }\n    }\n  }, {\n    key: \"_showPopupIfNeeded\",\n    value: function _showPopupIfNeeded() {\n      var _this6 = this;\n      if (this.popupDiv.html !== void 0) {\n        var correspondingElement = this.domElements[this.popupDiv.index];\n        var rect = correspondingElement.getBoundingClientRect();\n        this.popupDiv.html.style.left = rect.left + \"px\";\n        this.popupDiv.html.style.top = rect.top - 30 + \"px\";\n        document.body.appendChild(this.popupDiv.html);\n        this.popupDiv.hideTimeout = setTimeout$12(function() {\n          _this6.popupDiv.html.style.opacity = 0;\n        }, 1500);\n        this.popupDiv.deleteTimeout = setTimeout$12(function() {\n          _this6._removePopup();\n        }, 1800);\n      }\n    }\n  }, {\n    key: \"_makeCheckbox\",\n    value: function _makeCheckbox(defaultValue, value, path22) {\n      var checkbox = document.createElement(\"input\");\n      checkbox.type = \"checkbox\";\n      checkbox.className = \"vis-configuration vis-config-checkbox\";\n      checkbox.checked = defaultValue;\n      if (value !== void 0) {\n        checkbox.checked = value;\n        if (value !== defaultValue) {\n          if (_typeof2(defaultValue) === \"object\") {\n            if (value !== defaultValue.enabled) {\n              this.changedOptions.push({\n                path: path22,\n                value\n              });\n            }\n          } else {\n            this.changedOptions.push({\n              path: path22,\n              value\n            });\n          }\n        }\n      }\n      var me3 = this;\n      checkbox.onchange = function() {\n        me3._update(this.checked, path22);\n      };\n      var label = this._makeLabel(path22[path22.length - 1], path22);\n      this._makeItem(path22, label, checkbox);\n    }\n  }, {\n    key: \"_makeTextInput\",\n    value: function _makeTextInput(defaultValue, value, path22) {\n      var checkbox = document.createElement(\"input\");\n      checkbox.type = \"text\";\n      checkbox.className = \"vis-configuration vis-config-text\";\n      checkbox.value = value;\n      if (value !== defaultValue) {\n        this.changedOptions.push({\n          path: path22,\n          value\n        });\n      }\n      var me3 = this;\n      checkbox.onchange = function() {\n        me3._update(this.value, path22);\n      };\n      var label = this._makeLabel(path22[path22.length - 1], path22);\n      this._makeItem(path22, label, checkbox);\n    }\n  }, {\n    key: \"_makeColorField\",\n    value: function _makeColorField(arr, value, path22) {\n      var _this7 = this;\n      var defaultColor = arr[1];\n      var div = document.createElement(\"div\");\n      value = value === void 0 ? defaultColor : value;\n      if (value !== \"none\") {\n        div.className = \"vis-configuration vis-config-colorBlock\";\n        div.style.backgroundColor = value;\n      } else {\n        div.className = \"vis-configuration vis-config-colorBlock none\";\n      }\n      value = value === void 0 ? defaultColor : value;\n      div.onclick = function() {\n        _this7._showColorPicker(value, div, path22);\n      };\n      var label = this._makeLabel(path22[path22.length - 1], path22);\n      this._makeItem(path22, label, div);\n    }\n  }, {\n    key: \"_showColorPicker\",\n    value: function _showColorPicker(value, div, path22) {\n      var _this8 = this;\n      div.onclick = function() {\n      };\n      this.colorPicker.insertTo(div);\n      this.colorPicker.show();\n      this.colorPicker.setColor(value);\n      this.colorPicker.setUpdateCallback(function(color) {\n        var colorString = \"rgba(\" + color.r + \",\" + color.g + \",\" + color.b + \",\" + color.a + \")\";\n        div.style.backgroundColor = colorString;\n        _this8._update(colorString, path22);\n      });\n      this.colorPicker.setCloseCallback(function() {\n        div.onclick = function() {\n          _this8._showColorPicker(value, div, path22);\n        };\n      });\n    }\n  }, {\n    key: \"_handleObject\",\n    value: function _handleObject(obj) {\n      var path22 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n      var checkOnly = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n      var show = false;\n      var filter$122 = filter22(this.options);\n      var visibleInSet = false;\n      for (var subObj in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, subObj)) {\n          show = true;\n          var item = obj[subObj];\n          var newPath = copyAndExtendArray(path22, subObj);\n          if (typeof filter$122 === \"function\") {\n            show = filter$122(subObj, path22);\n            if (show === false) {\n              if (!isArray$12(item) && typeof item !== \"string\" && typeof item !== \"boolean\" && item instanceof Object) {\n                this.allowCreation = false;\n                show = this._handleObject(item, newPath, true);\n                this.allowCreation = checkOnly === false;\n              }\n            }\n          }\n          if (show !== false) {\n            visibleInSet = true;\n            var value = this._getValue(newPath);\n            if (isArray$12(item)) {\n              this._handleArray(item, value, newPath);\n            } else if (typeof item === \"string\") {\n              this._makeTextInput(item, value, newPath);\n            } else if (typeof item === \"boolean\") {\n              this._makeCheckbox(item, value, newPath);\n            } else if (item instanceof Object) {\n              if (!this.hideOption(path22, subObj, this.moduleOptions)) {\n                if (item.enabled !== void 0) {\n                  var enabledPath = copyAndExtendArray(newPath, \"enabled\");\n                  var enabledValue = this._getValue(enabledPath);\n                  if (enabledValue === true) {\n                    var label = this._makeLabel(subObj, newPath, true);\n                    this._makeItem(newPath, label);\n                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;\n                  } else {\n                    this._makeCheckbox(item, enabledValue, newPath);\n                  }\n                } else {\n                  var _label = this._makeLabel(subObj, newPath, true);\n                  this._makeItem(newPath, _label);\n                  visibleInSet = this._handleObject(item, newPath) || visibleInSet;\n                }\n              }\n            } else {\n              console.error(\"dont know how to handle\", item, subObj, newPath);\n            }\n          }\n        }\n      }\n      return visibleInSet;\n    }\n  }, {\n    key: \"_handleArray\",\n    value: function _handleArray(arr, value, path22) {\n      if (typeof arr[0] === \"string\" && arr[0] === \"color\") {\n        this._makeColorField(arr, value, path22);\n        if (arr[1] !== value) {\n          this.changedOptions.push({\n            path: path22,\n            value\n          });\n        }\n      } else if (typeof arr[0] === \"string\") {\n        this._makeDropdown(arr, value, path22);\n        if (arr[0] !== value) {\n          this.changedOptions.push({\n            path: path22,\n            value\n          });\n        }\n      } else if (typeof arr[0] === \"number\") {\n        this._makeRange(arr, value, path22);\n        if (arr[0] !== value) {\n          this.changedOptions.push({\n            path: path22,\n            value: Number(value)\n          });\n        }\n      }\n    }\n  }, {\n    key: \"_update\",\n    value: function _update(value, path22) {\n      var options2 = this._constructOptions(value, path22);\n      if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {\n        this.parent.body.emitter.emit(\"configChange\", options2);\n      }\n      this.initialized = true;\n      this.parent.setOptions(options2);\n    }\n  }, {\n    key: \"_constructOptions\",\n    value: function _constructOptions(value, path22) {\n      var optionsObj = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n      var pointer = optionsObj;\n      value = value === \"true\" ? true : value;\n      value = value === \"false\" ? false : value;\n      for (var i = 0; i < path22.length; i++) {\n        if (path22[i] !== \"global\") {\n          if (pointer[path22[i]] === void 0) {\n            pointer[path22[i]] = {};\n          }\n          if (i !== path22.length - 1) {\n            pointer = pointer[path22[i]];\n          } else {\n            pointer[path22[i]] = value;\n          }\n        }\n      }\n      return optionsObj;\n    }\n  }, {\n    key: \"_printOptions\",\n    value: function _printOptions() {\n      var options2 = this.getOptions();\n      while (this.optionsContainer.firstChild) {\n        this.optionsContainer.removeChild(this.optionsContainer.firstChild);\n      }\n      this.optionsContainer.appendChild(wrapInTag(\"pre\", \"const options = \" + stringify$12(options2, null, 2)));\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      var options2 = {};\n      for (var i = 0; i < this.changedOptions.length; i++) {\n        this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options2);\n      }\n      return options2;\n    }\n  }]);\n  return Configurator$12;\n}();\nvar Popup$1 = /* @__PURE__ */ function() {\n  function Popup$12(container, overflowMethod) {\n    _classCallCheck2(this, Popup$12);\n    this.container = container;\n    this.overflowMethod = overflowMethod || \"cap\";\n    this.x = 0;\n    this.y = 0;\n    this.padding = 5;\n    this.hidden = false;\n    this.frame = document.createElement(\"div\");\n    this.frame.className = \"vis-tooltip\";\n    this.container.appendChild(this.frame);\n  }\n  _createClass2(Popup$12, [{\n    key: \"setPosition\",\n    value: function setPosition(x, y) {\n      this.x = _parseInt(x);\n      this.y = _parseInt(y);\n    }\n  }, {\n    key: \"setText\",\n    value: function setText(content) {\n      if (content instanceof Element) {\n        while (this.frame.firstChild) {\n          this.frame.removeChild(this.frame.firstChild);\n        }\n        this.frame.appendChild(content);\n      } else {\n        this.frame.innerText = content;\n      }\n    }\n  }, {\n    key: \"show\",\n    value: function show(doShow) {\n      if (doShow === void 0) {\n        doShow = true;\n      }\n      if (doShow === true) {\n        var height = this.frame.clientHeight;\n        var width = this.frame.clientWidth;\n        var maxHeight = this.frame.parentNode.clientHeight;\n        var maxWidth = this.frame.parentNode.clientWidth;\n        var left = 0, top = 0;\n        if (this.overflowMethod == \"flip\") {\n          var isLeft = false, isTop = true;\n          if (this.y - height < this.padding) {\n            isTop = false;\n          }\n          if (this.x + width > maxWidth - this.padding) {\n            isLeft = true;\n          }\n          if (isLeft) {\n            left = this.x - width;\n          } else {\n            left = this.x;\n          }\n          if (isTop) {\n            top = this.y - height;\n          } else {\n            top = this.y;\n          }\n        } else {\n          top = this.y - height;\n          if (top + height + this.padding > maxHeight) {\n            top = maxHeight - height - this.padding;\n          }\n          if (top < this.padding) {\n            top = this.padding;\n          }\n          left = this.x;\n          if (left + width + this.padding > maxWidth) {\n            left = maxWidth - width - this.padding;\n          }\n          if (left < this.padding) {\n            left = this.padding;\n          }\n        }\n        this.frame.style.left = left + \"px\";\n        this.frame.style.top = top + \"px\";\n        this.frame.style.visibility = \"visible\";\n        this.hidden = false;\n      } else {\n        this.hide();\n      }\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      this.hidden = true;\n      this.frame.style.left = \"0\";\n      this.frame.style.top = \"0\";\n      this.frame.style.visibility = \"hidden\";\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.frame.parentNode.removeChild(this.frame);\n    }\n  }]);\n  return Popup$12;\n}();\nvar errorFound = false;\nvar allOptions$1;\nvar VALIDATOR_PRINT_STYLE$1 = \"background: #FFeeee; color: #dd0000\";\nvar Validator$1 = /* @__PURE__ */ function() {\n  function Validator$12() {\n    _classCallCheck2(this, Validator$12);\n  }\n  _createClass2(Validator$12, null, [{\n    key: \"validate\",\n    value: function validate22(options2, referenceOptions, subObject) {\n      errorFound = false;\n      allOptions$1 = referenceOptions;\n      var usedOptions = referenceOptions;\n      if (subObject !== void 0) {\n        usedOptions = referenceOptions[subObject];\n      }\n      Validator$12.parse(options2, usedOptions, []);\n      return errorFound;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(options2, referenceOptions, path22) {\n      for (var _option3 in options2) {\n        if (Object.prototype.hasOwnProperty.call(options2, _option3)) {\n          Validator$12.check(_option3, options2, referenceOptions, path22);\n        }\n      }\n    }\n  }, {\n    key: \"check\",\n    value: function check22(option, options2, referenceOptions, path22) {\n      if (referenceOptions[option] === void 0 && referenceOptions.__any__ === void 0) {\n        Validator$12.getSuggestion(option, referenceOptions, path22);\n        return;\n      }\n      var referenceOption = option;\n      var is_object = true;\n      if (referenceOptions[option] === void 0 && referenceOptions.__any__ !== void 0) {\n        referenceOption = \"__any__\";\n        is_object = Validator$12.getType(options2[option]) === \"object\";\n      }\n      var refOptionObj = referenceOptions[referenceOption];\n      if (is_object && refOptionObj.__type__ !== void 0) {\n        refOptionObj = refOptionObj.__type__;\n      }\n      Validator$12.checkFields(option, options2, referenceOptions, referenceOption, refOptionObj, path22);\n    }\n  }, {\n    key: \"checkFields\",\n    value: function checkFields(option, options2, referenceOptions, referenceOption, refOptionObj, path22) {\n      var log = function log2(message) {\n        console.error(\"%c\" + message + Validator$12.printLocation(path22, option), VALIDATOR_PRINT_STYLE$1);\n      };\n      var optionType = Validator$12.getType(options2[option]);\n      var refOptionType = refOptionObj[optionType];\n      if (refOptionType !== void 0) {\n        if (Validator$12.getType(refOptionType) === \"array\" && indexOf22(refOptionType).call(refOptionType, options2[option]) === -1) {\n          log('Invalid option detected in \"' + option + '\". Allowed values are:' + Validator$12.print(refOptionType) + ' not \"' + options2[option] + '\". ');\n          errorFound = true;\n        } else if (optionType === \"object\" && referenceOption !== \"__any__\") {\n          path22 = copyAndExtendArray(path22, option);\n          Validator$12.parse(options2[option], referenceOptions[referenceOption], path22);\n        }\n      } else if (refOptionObj[\"any\"] === void 0) {\n        log('Invalid type received for \"' + option + '\". Expected: ' + Validator$12.print(keys32(refOptionObj)) + \". Received [\" + optionType + '] \"' + options2[option] + '\"');\n        errorFound = true;\n      }\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(object2) {\n      var type2 = _typeof2(object2);\n      if (type2 === \"object\") {\n        if (object2 === null) {\n          return \"null\";\n        }\n        if (object2 instanceof Boolean) {\n          return \"boolean\";\n        }\n        if (object2 instanceof Number) {\n          return \"number\";\n        }\n        if (object2 instanceof String) {\n          return \"string\";\n        }\n        if (isArray$12(object2)) {\n          return \"array\";\n        }\n        if (object2 instanceof Date) {\n          return \"date\";\n        }\n        if (object2.nodeType !== void 0) {\n          return \"dom\";\n        }\n        if (object2._isAMomentObject === true) {\n          return \"moment\";\n        }\n        return \"object\";\n      } else if (type2 === \"number\") {\n        return \"number\";\n      } else if (type2 === \"boolean\") {\n        return \"boolean\";\n      } else if (type2 === \"string\") {\n        return \"string\";\n      } else if (type2 === void 0) {\n        return \"undefined\";\n      }\n      return type2;\n    }\n  }, {\n    key: \"getSuggestion\",\n    value: function getSuggestion(option, options2, path22) {\n      var localSearch = Validator$12.findInOptions(option, options2, path22, false);\n      var globalSearch = Validator$12.findInOptions(option, allOptions$1, [], true);\n      var localSearchThreshold = 8;\n      var globalSearchThreshold = 4;\n      var msg;\n      if (localSearch.indexMatch !== void 0) {\n        msg = \" in \" + Validator$12.printLocation(localSearch.path, option, \"\") + 'Perhaps it was incomplete? Did you mean: \"' + localSearch.indexMatch + '\"?\\n\\n';\n      } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {\n        msg = \" in \" + Validator$12.printLocation(localSearch.path, option, \"\") + \"Perhaps it was misplaced? Matching option found at: \" + Validator$12.printLocation(globalSearch.path, globalSearch.closestMatch, \"\");\n      } else if (localSearch.distance <= localSearchThreshold) {\n        msg = '. Did you mean \"' + localSearch.closestMatch + '\"?' + Validator$12.printLocation(localSearch.path, option);\n      } else {\n        msg = \". Did you mean one of these: \" + Validator$12.print(keys32(options2)) + Validator$12.printLocation(path22, option);\n      }\n      console.error('%cUnknown option detected: \"' + option + '\"' + msg, VALIDATOR_PRINT_STYLE$1);\n      errorFound = true;\n    }\n  }, {\n    key: \"findInOptions\",\n    value: function findInOptions(option, options2, path22) {\n      var recursive = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n      var min22 = 1e9;\n      var closestMatch = \"\";\n      var closestMatchPath = [];\n      var lowerCaseOption = option.toLowerCase();\n      var indexMatch = void 0;\n      for (var op in options2) {\n        var distance = void 0;\n        if (options2[op].__type__ !== void 0 && recursive === true) {\n          var result2 = Validator$12.findInOptions(option, options2[op], copyAndExtendArray(path22, op));\n          if (min22 > result2.distance) {\n            closestMatch = result2.closestMatch;\n            closestMatchPath = result2.path;\n            min22 = result2.distance;\n            indexMatch = result2.indexMatch;\n          }\n        } else {\n          var _context20;\n          if (indexOf22(_context20 = op.toLowerCase()).call(_context20, lowerCaseOption) !== -1) {\n            indexMatch = op;\n          }\n          distance = Validator$12.levenshteinDistance(option, op);\n          if (min22 > distance) {\n            closestMatch = op;\n            closestMatchPath = copyArray(path22);\n            min22 = distance;\n          }\n        }\n      }\n      return {\n        closestMatch,\n        path: closestMatchPath,\n        distance: min22,\n        indexMatch\n      };\n    }\n  }, {\n    key: \"printLocation\",\n    value: function printLocation(path22, option) {\n      var prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"Problem value found at: \\n\";\n      var str = \"\\n\\n\" + prefix + \"options = {\\n\";\n      for (var i = 0; i < path22.length; i++) {\n        for (var j = 0; j < i + 1; j++) {\n          str += \"  \";\n        }\n        str += path22[i] + \": {\\n\";\n      }\n      for (var _j = 0; _j < path22.length + 1; _j++) {\n        str += \"  \";\n      }\n      str += option + \"\\n\";\n      for (var _i3 = 0; _i3 < path22.length + 1; _i3++) {\n        for (var _j2 = 0; _j2 < path22.length - _i3; _j2++) {\n          str += \"  \";\n        }\n        str += \"}\\n\";\n      }\n      return str + \"\\n\\n\";\n    }\n  }, {\n    key: \"print\",\n    value: function print(options2) {\n      return stringify$12(options2).replace(/(\")|(\\[)|(\\])|(,\"__type__\")/g, \"\").replace(/(,)/g, \", \");\n    }\n  }, {\n    key: \"levenshteinDistance\",\n    value: function levenshteinDistance(a, b) {\n      if (a.length === 0)\n        return b.length;\n      if (b.length === 0)\n        return a.length;\n      var matrix = [];\n      var i;\n      for (i = 0; i <= b.length; i++) {\n        matrix[i] = [i];\n      }\n      var j;\n      for (j = 0; j <= a.length; j++) {\n        matrix[0][j] = j;\n      }\n      for (i = 1; i <= b.length; i++) {\n        for (j = 1; j <= a.length; j++) {\n          if (b.charAt(i - 1) == a.charAt(j - 1)) {\n            matrix[i][j] = matrix[i - 1][j - 1];\n          } else {\n            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));\n          }\n        }\n      }\n      return matrix[b.length][a.length];\n    }\n  }]);\n  return Validator$12;\n}();\nvar Activator = Activator$12;\nvar Configurator = Configurator$1;\nvar Hammer2 = Hammer$12;\nvar Popup = Popup$1;\nvar VALIDATOR_PRINT_STYLE = VALIDATOR_PRINT_STYLE$1;\nvar Validator = Validator$1;\nfunction parseDOT(data22) {\n  dot = data22;\n  return parseGraph();\n}\nvar NODE_ATTR_MAPPING = {\n  fontsize: \"font.size\",\n  fontcolor: \"font.color\",\n  labelfontcolor: \"font.color\",\n  fontname: \"font.face\",\n  color: [\"color.border\", \"color.background\"],\n  fillcolor: \"color.background\",\n  tooltip: \"title\",\n  labeltooltip: \"title\"\n};\nvar EDGE_ATTR_MAPPING = create$52(NODE_ATTR_MAPPING);\nEDGE_ATTR_MAPPING.color = \"color.color\";\nEDGE_ATTR_MAPPING.style = \"dashes\";\nvar TOKENTYPE = {\n  NULL: 0,\n  DELIMITER: 1,\n  IDENTIFIER: 2,\n  UNKNOWN: 3\n};\nvar DELIMITERS = {\n  \"{\": true,\n  \"}\": true,\n  \"[\": true,\n  \"]\": true,\n  \";\": true,\n  \"=\": true,\n  \",\": true,\n  \"->\": true,\n  \"--\": true\n};\nvar dot = \"\";\nvar index = 0;\nvar c2 = \"\";\nvar token = \"\";\nvar tokenType = TOKENTYPE.NULL;\nfunction first() {\n  index = 0;\n  c2 = dot.charAt(0);\n}\nfunction next22() {\n  index++;\n  c2 = dot.charAt(index);\n}\nfunction nextPreview() {\n  return dot.charAt(index + 1);\n}\nfunction isAlphaNumeric(c22) {\n  var charCode = c22.charCodeAt(0);\n  if (charCode < 47) {\n    return charCode === 35 || charCode === 46;\n  }\n  if (charCode < 59) {\n    return charCode > 47;\n  }\n  if (charCode < 91) {\n    return charCode > 64;\n  }\n  if (charCode < 96) {\n    return charCode === 95;\n  }\n  if (charCode < 123) {\n    return charCode > 96;\n  }\n  return false;\n}\nfunction merge$12(a, b) {\n  if (!a) {\n    a = {};\n  }\n  if (b) {\n    for (var name2 in b) {\n      if (b.hasOwnProperty(name2)) {\n        a[name2] = b[name2];\n      }\n    }\n  }\n  return a;\n}\nfunction setValue(obj, path22, value) {\n  var keys42 = path22.split(\".\");\n  var o = obj;\n  while (keys42.length) {\n    var key = keys42.shift();\n    if (keys42.length) {\n      if (!o[key]) {\n        o[key] = {};\n      }\n      o = o[key];\n    } else {\n      o[key] = value;\n    }\n  }\n}\nfunction addNode(graph, node) {\n  var i, len;\n  var current = null;\n  var graphs = [graph];\n  var root = graph;\n  while (root.parent) {\n    graphs.push(root.parent);\n    root = root.parent;\n  }\n  if (root.nodes) {\n    for (i = 0, len = root.nodes.length; i < len; i++) {\n      if (node.id === root.nodes[i].id) {\n        current = root.nodes[i];\n        break;\n      }\n    }\n  }\n  if (!current) {\n    current = {\n      id: node.id\n    };\n    if (graph.node) {\n      current.attr = merge$12(current.attr, graph.node);\n    }\n  }\n  for (i = graphs.length - 1; i >= 0; i--) {\n    var _context;\n    var g = graphs[i];\n    if (!g.nodes) {\n      g.nodes = [];\n    }\n    if (indexOf22(_context = g.nodes).call(_context, current) === -1) {\n      g.nodes.push(current);\n    }\n  }\n  if (node.attr) {\n    current.attr = merge$12(current.attr, node.attr);\n  }\n}\nfunction addEdge(graph, edge) {\n  if (!graph.edges) {\n    graph.edges = [];\n  }\n  graph.edges.push(edge);\n  if (graph.edge) {\n    var attr = merge$12({}, graph.edge);\n    edge.attr = merge$12(attr, edge.attr);\n  }\n}\nfunction createEdge(graph, from32, to, type2, attr) {\n  var edge = {\n    from: from32,\n    to,\n    type: type2\n  };\n  if (graph.edge) {\n    edge.attr = merge$12({}, graph.edge);\n  }\n  edge.attr = merge$12(edge.attr || {}, attr);\n  if (attr != null) {\n    if (attr.hasOwnProperty(\"arrows\") && attr[\"arrows\"] != null) {\n      edge[\"arrows\"] = {\n        to: {\n          enabled: true,\n          type: attr.arrows.type\n        }\n      };\n      attr[\"arrows\"] = null;\n    }\n  }\n  return edge;\n}\nfunction getToken() {\n  tokenType = TOKENTYPE.NULL;\n  token = \"\";\n  while (c2 === \" \" || c2 === \"\t\" || c2 === \"\\n\" || c2 === \"\\r\") {\n    next22();\n  }\n  do {\n    var isComment = false;\n    if (c2 === \"#\") {\n      var i = index - 1;\n      while (dot.charAt(i) === \" \" || dot.charAt(i) === \"\t\") {\n        i--;\n      }\n      if (dot.charAt(i) === \"\\n\" || dot.charAt(i) === \"\") {\n        while (c2 != \"\" && c2 != \"\\n\") {\n          next22();\n        }\n        isComment = true;\n      }\n    }\n    if (c2 === \"/\" && nextPreview() === \"/\") {\n      while (c2 != \"\" && c2 != \"\\n\") {\n        next22();\n      }\n      isComment = true;\n    }\n    if (c2 === \"/\" && nextPreview() === \"*\") {\n      while (c2 != \"\") {\n        if (c2 === \"*\" && nextPreview() === \"/\") {\n          next22();\n          next22();\n          break;\n        } else {\n          next22();\n        }\n      }\n      isComment = true;\n    }\n    while (c2 === \" \" || c2 === \"\t\" || c2 === \"\\n\" || c2 === \"\\r\") {\n      next22();\n    }\n  } while (isComment);\n  if (c2 === \"\") {\n    tokenType = TOKENTYPE.DELIMITER;\n    return;\n  }\n  var c22 = c2 + nextPreview();\n  if (DELIMITERS[c22]) {\n    tokenType = TOKENTYPE.DELIMITER;\n    token = c22;\n    next22();\n    next22();\n    return;\n  }\n  if (DELIMITERS[c2]) {\n    tokenType = TOKENTYPE.DELIMITER;\n    token = c2;\n    next22();\n    return;\n  }\n  if (isAlphaNumeric(c2) || c2 === \"-\") {\n    token += c2;\n    next22();\n    while (isAlphaNumeric(c2)) {\n      token += c2;\n      next22();\n    }\n    if (token === \"false\") {\n      token = false;\n    } else if (token === \"true\") {\n      token = true;\n    } else if (!isNaN(Number(token))) {\n      token = Number(token);\n    }\n    tokenType = TOKENTYPE.IDENTIFIER;\n    return;\n  }\n  if (c2 === '\"') {\n    next22();\n    while (c2 != \"\" && (c2 != '\"' || c2 === '\"' && nextPreview() === '\"')) {\n      if (c2 === '\"') {\n        token += c2;\n        next22();\n      } else if (c2 === \"\\\\\" && nextPreview() === \"n\") {\n        token += \"\\n\";\n        next22();\n      } else {\n        token += c2;\n      }\n      next22();\n    }\n    if (c2 != '\"') {\n      throw newSyntaxError('End of string \" expected');\n    }\n    next22();\n    tokenType = TOKENTYPE.IDENTIFIER;\n    return;\n  }\n  tokenType = TOKENTYPE.UNKNOWN;\n  while (c2 != \"\") {\n    token += c2;\n    next22();\n  }\n  throw new SyntaxError('Syntax error in part \"' + chop(token, 30) + '\"');\n}\nfunction parseGraph() {\n  var graph = {};\n  first();\n  getToken();\n  if (token === \"strict\") {\n    graph.strict = true;\n    getToken();\n  }\n  if (token === \"graph\" || token === \"digraph\") {\n    graph.type = token;\n    getToken();\n  }\n  if (tokenType === TOKENTYPE.IDENTIFIER) {\n    graph.id = token;\n    getToken();\n  }\n  if (token != \"{\") {\n    throw newSyntaxError(\"Angle bracket { expected\");\n  }\n  getToken();\n  parseStatements(graph);\n  if (token != \"}\") {\n    throw newSyntaxError(\"Angle bracket } expected\");\n  }\n  getToken();\n  if (token !== \"\") {\n    throw newSyntaxError(\"End of file expected\");\n  }\n  getToken();\n  delete graph.node;\n  delete graph.edge;\n  delete graph.graph;\n  return graph;\n}\nfunction parseStatements(graph) {\n  while (token !== \"\" && token != \"}\") {\n    parseStatement(graph);\n    if (token === \";\") {\n      getToken();\n    }\n  }\n}\nfunction parseStatement(graph) {\n  var subgraph = parseSubgraph(graph);\n  if (subgraph) {\n    parseEdge(graph, subgraph);\n    return;\n  }\n  var attr = parseAttributeStatement(graph);\n  if (attr) {\n    return;\n  }\n  if (tokenType != TOKENTYPE.IDENTIFIER) {\n    throw newSyntaxError(\"Identifier expected\");\n  }\n  var id22 = token;\n  getToken();\n  if (token === \"=\") {\n    getToken();\n    if (tokenType != TOKENTYPE.IDENTIFIER) {\n      throw newSyntaxError(\"Identifier expected\");\n    }\n    graph[id22] = token;\n    getToken();\n  } else {\n    parseNodeStatement(graph, id22);\n  }\n}\nfunction parseSubgraph(graph) {\n  var subgraph = null;\n  if (token === \"subgraph\") {\n    subgraph = {};\n    subgraph.type = \"subgraph\";\n    getToken();\n    if (tokenType === TOKENTYPE.IDENTIFIER) {\n      subgraph.id = token;\n      getToken();\n    }\n  }\n  if (token === \"{\") {\n    getToken();\n    if (!subgraph) {\n      subgraph = {};\n    }\n    subgraph.parent = graph;\n    subgraph.node = graph.node;\n    subgraph.edge = graph.edge;\n    subgraph.graph = graph.graph;\n    parseStatements(subgraph);\n    if (token != \"}\") {\n      throw newSyntaxError(\"Angle bracket } expected\");\n    }\n    getToken();\n    delete subgraph.node;\n    delete subgraph.edge;\n    delete subgraph.graph;\n    delete subgraph.parent;\n    if (!graph.subgraphs) {\n      graph.subgraphs = [];\n    }\n    graph.subgraphs.push(subgraph);\n  }\n  return subgraph;\n}\nfunction parseAttributeStatement(graph) {\n  if (token === \"node\") {\n    getToken();\n    graph.node = parseAttributeList();\n    return \"node\";\n  } else if (token === \"edge\") {\n    getToken();\n    graph.edge = parseAttributeList();\n    return \"edge\";\n  } else if (token === \"graph\") {\n    getToken();\n    graph.graph = parseAttributeList();\n    return \"graph\";\n  }\n  return null;\n}\nfunction parseNodeStatement(graph, id22) {\n  var node = {\n    id: id22\n  };\n  var attr = parseAttributeList();\n  if (attr) {\n    node.attr = attr;\n  }\n  addNode(graph, node);\n  parseEdge(graph, id22);\n}\nfunction parseEdge(graph, from32) {\n  while (token === \"->\" || token === \"--\") {\n    var to;\n    var type2 = token;\n    getToken();\n    var subgraph = parseSubgraph(graph);\n    if (subgraph) {\n      to = subgraph;\n    } else {\n      if (tokenType != TOKENTYPE.IDENTIFIER) {\n        throw newSyntaxError(\"Identifier or subgraph expected\");\n      }\n      to = token;\n      addNode(graph, {\n        id: to\n      });\n      getToken();\n    }\n    var attr = parseAttributeList();\n    var edge = createEdge(graph, from32, to, type2, attr);\n    addEdge(graph, edge);\n    from32 = to;\n  }\n}\nfunction parseAttributeList() {\n  var i;\n  var attr = null;\n  var edgeStyles = {\n    dashed: true,\n    solid: false,\n    dotted: [1, 5]\n  };\n  var arrowTypes = {\n    dot: \"circle\",\n    box: \"box\",\n    crow: \"crow\",\n    curve: \"curve\",\n    icurve: \"inv_curve\",\n    normal: \"triangle\",\n    inv: \"inv_triangle\",\n    diamond: \"diamond\",\n    tee: \"bar\",\n    vee: \"vee\"\n  };\n  var attr_list = new Array();\n  var attr_names = new Array();\n  while (token === \"[\") {\n    getToken();\n    attr = {};\n    while (token !== \"\" && token != \"]\") {\n      if (tokenType != TOKENTYPE.IDENTIFIER) {\n        throw newSyntaxError(\"Attribute name expected\");\n      }\n      var name2 = token;\n      getToken();\n      if (token != \"=\") {\n        throw newSyntaxError(\"Equal sign = expected\");\n      }\n      getToken();\n      if (tokenType != TOKENTYPE.IDENTIFIER) {\n        throw newSyntaxError(\"Attribute value expected\");\n      }\n      var value = token;\n      if (name2 === \"style\") {\n        value = edgeStyles[value];\n      }\n      var arrowType;\n      if (name2 === \"arrowhead\") {\n        arrowType = arrowTypes[value];\n        name2 = \"arrows\";\n        value = {\n          to: {\n            enabled: true,\n            type: arrowType\n          }\n        };\n      }\n      if (name2 === \"arrowtail\") {\n        arrowType = arrowTypes[value];\n        name2 = \"arrows\";\n        value = {\n          from: {\n            enabled: true,\n            type: arrowType\n          }\n        };\n      }\n      attr_list.push({\n        attr,\n        name: name2,\n        value\n      });\n      attr_names.push(name2);\n      getToken();\n      if (token == \",\") {\n        getToken();\n      }\n    }\n    if (token != \"]\") {\n      throw newSyntaxError(\"Bracket ] expected\");\n    }\n    getToken();\n  }\n  if (includes32(attr_names).call(attr_names, \"dir\")) {\n    var idx = {};\n    idx.arrows = {};\n    for (i = 0; i < attr_list.length; i++) {\n      if (attr_list[i].name === \"arrows\") {\n        if (attr_list[i].value.to != null) {\n          idx.arrows.to = i;\n        } else if (attr_list[i].value.from != null) {\n          idx.arrows.from = i;\n        } else {\n          throw newSyntaxError(\"Invalid value of arrows\");\n        }\n      } else if (attr_list[i].name === \"dir\") {\n        idx.dir = i;\n      }\n    }\n    var dir_type = attr_list[idx.dir].value;\n    if (!includes32(attr_names).call(attr_names, \"arrows\")) {\n      if (dir_type === \"both\") {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: {\n            to: {\n              enabled: true\n            }\n          }\n        });\n        idx.arrows.to = attr_list.length - 1;\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: {\n            from: {\n              enabled: true\n            }\n          }\n        });\n        idx.arrows.from = attr_list.length - 1;\n      } else if (dir_type === \"forward\") {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: {\n            to: {\n              enabled: true\n            }\n          }\n        });\n        idx.arrows.to = attr_list.length - 1;\n      } else if (dir_type === \"back\") {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: {\n            from: {\n              enabled: true\n            }\n          }\n        });\n        idx.arrows.from = attr_list.length - 1;\n      } else if (dir_type === \"none\") {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: \"\"\n        });\n        idx.arrows.to = attr_list.length - 1;\n      } else {\n        throw newSyntaxError('Invalid dir type \"' + dir_type + '\"');\n      }\n    }\n    var from_type;\n    var to_type;\n    if (dir_type === \"both\") {\n      if (idx.arrows.to && idx.arrows.from) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n        splice$12(attr_list).call(attr_list, idx.arrows.from, 1);\n      } else if (idx.arrows.to) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = \"arrow\";\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n      } else if (idx.arrows.from) {\n        to_type = \"arrow\";\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.from] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n      }\n    } else if (dir_type === \"back\") {\n      if (idx.arrows.to && idx.arrows.from) {\n        to_type = \"\";\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.from] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n      } else if (idx.arrows.to) {\n        to_type = \"\";\n        from_type = \"arrow\";\n        idx.arrows.from = idx.arrows.to;\n        attr_list[idx.arrows.from] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n      } else if (idx.arrows.from) {\n        to_type = \"\";\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n      }\n      attr_list[idx.arrows.from] = {\n        attr: attr_list[idx.arrows.from].attr,\n        name: attr_list[idx.arrows.from].name,\n        value: {\n          from: {\n            enabled: true,\n            type: attr_list[idx.arrows.from].value.from.type\n          }\n        }\n      };\n    } else if (dir_type === \"none\") {\n      var idx_arrow;\n      if (idx.arrows.to) {\n        idx_arrow = idx.arrows.to;\n      } else {\n        idx_arrow = idx.arrows.from;\n      }\n      attr_list[idx_arrow] = {\n        attr: attr_list[idx_arrow].attr,\n        name: attr_list[idx_arrow].name,\n        value: \"\"\n      };\n    } else if (dir_type === \"forward\") {\n      if (idx.arrows.to && idx.arrows.from) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = \"\";\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n      } else if (idx.arrows.to) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = \"\";\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n      } else if (idx.arrows.from) {\n        to_type = \"arrow\";\n        from_type = \"\";\n        idx.arrows.to = idx.arrows.from;\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n      }\n      attr_list[idx.arrows.to] = {\n        attr: attr_list[idx.arrows.to].attr,\n        name: attr_list[idx.arrows.to].name,\n        value: {\n          to: {\n            enabled: true,\n            type: attr_list[idx.arrows.to].value.to.type\n          }\n        }\n      };\n    } else {\n      throw newSyntaxError('Invalid dir type \"' + dir_type + '\"');\n    }\n    splice$12(attr_list).call(attr_list, idx.dir, 1);\n  }\n  var nof_attr_list;\n  if (includes32(attr_names).call(attr_names, \"penwidth\")) {\n    var tmp_attr_list = [];\n    nof_attr_list = attr_list.length;\n    for (i = 0; i < nof_attr_list; i++) {\n      if (attr_list[i].name !== \"width\") {\n        if (attr_list[i].name === \"penwidth\") {\n          attr_list[i].name = \"width\";\n        }\n        tmp_attr_list.push(attr_list[i]);\n      }\n    }\n    attr_list = tmp_attr_list;\n  }\n  nof_attr_list = attr_list.length;\n  for (i = 0; i < nof_attr_list; i++) {\n    setValue(attr_list[i].attr, attr_list[i].name, attr_list[i].value);\n  }\n  return attr;\n}\nfunction newSyntaxError(message) {\n  return new SyntaxError(message + ', got \"' + chop(token, 30) + '\" (char ' + index + \")\");\n}\nfunction chop(text, maxLength) {\n  return text.length <= maxLength ? text : text.substr(0, 27) + \"...\";\n}\nfunction forEach22(array1, array2, fn) {\n  if (isArray$12(array1)) {\n    forEach$22(array1).call(array1, function(elem1) {\n      if (isArray$12(array2)) {\n        forEach$22(array2).call(array2, function(elem2) {\n          fn(elem1, elem2);\n        });\n      } else {\n        fn(elem1, array2);\n      }\n    });\n  } else {\n    if (isArray$12(array2)) {\n      forEach$22(array2).call(array2, function(elem2) {\n        fn(array1, elem2);\n      });\n    } else {\n      fn(array1, array2);\n    }\n  }\n}\nfunction setProp(object2, path22, value) {\n  var names = path22.split(\".\");\n  var prop = names.pop();\n  var obj = object2;\n  for (var i = 0; i < names.length; i++) {\n    var name2 = names[i];\n    if (!(name2 in obj)) {\n      obj[name2] = {};\n    }\n    obj = obj[name2];\n  }\n  obj[prop] = value;\n  return object2;\n}\nfunction convertAttr(attr, mapping) {\n  var converted = {};\n  for (var prop in attr) {\n    if (attr.hasOwnProperty(prop)) {\n      var visProp = mapping[prop];\n      if (isArray$12(visProp)) {\n        forEach$22(visProp).call(visProp, function(visPropI) {\n          setProp(converted, visPropI, attr[prop]);\n        });\n      } else if (typeof visProp === \"string\") {\n        setProp(converted, visProp, attr[prop]);\n      } else {\n        setProp(converted, prop, attr[prop]);\n      }\n    }\n  }\n  return converted;\n}\nfunction DOTToGraph(data22) {\n  var dotData = parseDOT(data22);\n  var graphData = {\n    nodes: [],\n    edges: [],\n    options: {}\n  };\n  if (dotData.nodes) {\n    var _context2;\n    forEach$22(_context2 = dotData.nodes).call(_context2, function(dotNode) {\n      var graphNode = {\n        id: dotNode.id,\n        label: String(dotNode.label || dotNode.id)\n      };\n      merge$12(graphNode, convertAttr(dotNode.attr, NODE_ATTR_MAPPING));\n      if (graphNode.image) {\n        graphNode.shape = \"image\";\n      }\n      graphData.nodes.push(graphNode);\n    });\n  }\n  if (dotData.edges) {\n    var _context3;\n    var convertEdge = function convertEdge2(dotEdge) {\n      var graphEdge = {\n        from: dotEdge.from,\n        to: dotEdge.to\n      };\n      merge$12(graphEdge, convertAttr(dotEdge.attr, EDGE_ATTR_MAPPING));\n      if (graphEdge.arrows == null && dotEdge.type === \"->\") {\n        graphEdge.arrows = \"to\";\n      }\n      return graphEdge;\n    };\n    forEach$22(_context3 = dotData.edges).call(_context3, function(dotEdge) {\n      var from32, to;\n      if (dotEdge.from instanceof Object) {\n        from32 = dotEdge.from.nodes;\n      } else {\n        from32 = {\n          id: dotEdge.from\n        };\n      }\n      if (dotEdge.to instanceof Object) {\n        to = dotEdge.to.nodes;\n      } else {\n        to = {\n          id: dotEdge.to\n        };\n      }\n      if (dotEdge.from instanceof Object && dotEdge.from.edges) {\n        var _context4;\n        forEach$22(_context4 = dotEdge.from.edges).call(_context4, function(subEdge) {\n          var graphEdge = convertEdge(subEdge);\n          graphData.edges.push(graphEdge);\n        });\n      }\n      forEach22(from32, to, function(from4, to2) {\n        var subEdge = createEdge(graphData, from4.id, to2.id, dotEdge.type, dotEdge.attr);\n        var graphEdge = convertEdge(subEdge);\n        graphData.edges.push(graphEdge);\n      });\n      if (dotEdge.to instanceof Object && dotEdge.to.edges) {\n        var _context5;\n        forEach$22(_context5 = dotEdge.to.edges).call(_context5, function(subEdge) {\n          var graphEdge = convertEdge(subEdge);\n          graphData.edges.push(graphEdge);\n        });\n      }\n    });\n  }\n  if (dotData.attr) {\n    graphData.options = dotData.attr;\n  }\n  return graphData;\n}\nfunction parseGephi(gephiJSON, optionsObj) {\n  var _context;\n  var options2 = {\n    edges: {\n      inheritColor: false\n    },\n    nodes: {\n      fixed: false,\n      parseColor: false\n    }\n  };\n  if (optionsObj != null) {\n    if (optionsObj.fixed != null) {\n      options2.nodes.fixed = optionsObj.fixed;\n    }\n    if (optionsObj.parseColor != null) {\n      options2.nodes.parseColor = optionsObj.parseColor;\n    }\n    if (optionsObj.inheritColor != null) {\n      options2.edges.inheritColor = optionsObj.inheritColor;\n    }\n  }\n  var gEdges = gephiJSON.edges;\n  var vEdges = map$32(gEdges).call(gEdges, function(gEdge) {\n    var vEdge = {\n      from: gEdge.source,\n      id: gEdge.id,\n      to: gEdge.target\n    };\n    if (gEdge.attributes != null) {\n      vEdge.attributes = gEdge.attributes;\n    }\n    if (gEdge.label != null) {\n      vEdge.label = gEdge.label;\n    }\n    if (gEdge.attributes != null && gEdge.attributes.title != null) {\n      vEdge.title = gEdge.attributes.title;\n    }\n    if (gEdge.type === \"Directed\") {\n      vEdge.arrows = \"to\";\n    }\n    if (gEdge.color && options2.edges.inheritColor === false) {\n      vEdge.color = gEdge.color;\n    }\n    return vEdge;\n  });\n  var vNodes = map$32(_context = gephiJSON.nodes).call(_context, function(gNode) {\n    var vNode = {\n      id: gNode.id,\n      fixed: options2.nodes.fixed && gNode.x != null && gNode.y != null\n    };\n    if (gNode.attributes != null) {\n      vNode.attributes = gNode.attributes;\n    }\n    if (gNode.label != null) {\n      vNode.label = gNode.label;\n    }\n    if (gNode.size != null) {\n      vNode.size = gNode.size;\n    }\n    if (gNode.attributes != null && gNode.attributes.title != null) {\n      vNode.title = gNode.attributes.title;\n    }\n    if (gNode.title != null) {\n      vNode.title = gNode.title;\n    }\n    if (gNode.x != null) {\n      vNode.x = gNode.x;\n    }\n    if (gNode.y != null) {\n      vNode.y = gNode.y;\n    }\n    if (gNode.color != null) {\n      if (options2.nodes.parseColor === true) {\n        vNode.color = gNode.color;\n      } else {\n        vNode.color = {\n          background: gNode.color,\n          border: gNode.color,\n          highlight: {\n            background: gNode.color,\n            border: gNode.color\n          },\n          hover: {\n            background: gNode.color,\n            border: gNode.color\n          }\n        };\n      }\n    }\n    return vNode;\n  });\n  return {\n    nodes: vNodes,\n    edges: vEdges\n  };\n}\nvar en = {\n  addDescription: \"Click in an empty space to place a new node.\",\n  addEdge: \"Add Edge\",\n  addNode: \"Add Node\",\n  back: \"Back\",\n  close: \"Close\",\n  createEdgeError: \"Cannot link edges to a cluster.\",\n  del: \"Delete selected\",\n  deleteClusterError: \"Clusters cannot be deleted.\",\n  edgeDescription: \"Click on a node and drag the edge to another node to connect them.\",\n  edit: \"Edit\",\n  editClusterError: \"Clusters cannot be edited.\",\n  editEdge: \"Edit Edge\",\n  editEdgeDescription: \"Click on the control points and drag them to a node to connect to it.\",\n  editNode: \"Edit Node\"\n};\nvar de3 = {\n  addDescription: \"Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.\",\n  addEdge: \"Kante hinzuf\\xFCgen\",\n  addNode: \"Knoten hinzuf\\xFCgen\",\n  back: \"Zur\\xFCck\",\n  close: \"Schlie\\xDFen\",\n  createEdgeError: \"Es ist nicht m\\xF6glich, Kanten mit Clustern zu verbinden.\",\n  del: \"L\\xF6sche Auswahl\",\n  deleteClusterError: \"Cluster k\\xF6nnen nicht gel\\xF6scht werden.\",\n  edgeDescription: \"Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.\",\n  edit: \"Editieren\",\n  editClusterError: \"Cluster k\\xF6nnen nicht editiert werden.\",\n  editEdge: \"Kante editieren\",\n  editEdgeDescription: \"Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.\",\n  editNode: \"Knoten editieren\"\n};\nvar es = {\n  addDescription: \"Haga clic en un lugar vac\\xEDo para colocar un nuevo nodo.\",\n  addEdge: \"A\\xF1adir arista\",\n  addNode: \"A\\xF1adir nodo\",\n  back: \"Atr\\xE1s\",\n  close: \"Cerrar\",\n  createEdgeError: \"No se puede conectar una arista a un grupo.\",\n  del: \"Eliminar selecci\\xF3n\",\n  deleteClusterError: \"No es posible eliminar grupos.\",\n  edgeDescription: \"Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.\",\n  edit: \"Editar\",\n  editClusterError: \"No es posible editar grupos.\",\n  editEdge: \"Editar arista\",\n  editEdgeDescription: \"Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.\",\n  editNode: \"Editar nodo\"\n};\nvar it = {\n  addDescription: \"Clicca per aggiungere un nuovo nodo\",\n  addEdge: \"Aggiungi un vertice\",\n  addNode: \"Aggiungi un nodo\",\n  back: \"Indietro\",\n  close: \"Chiudere\",\n  createEdgeError: \"Non si possono collegare vertici ad un cluster\",\n  del: \"Cancella la selezione\",\n  deleteClusterError: \"I cluster non possono essere cancellati\",\n  edgeDescription: \"Clicca su un nodo e trascinalo ad un altro nodo per connetterli.\",\n  edit: \"Modifica\",\n  editClusterError: \"I clusters non possono essere modificati.\",\n  editEdge: \"Modifica il vertice\",\n  editEdgeDescription: \"Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.\",\n  editNode: \"Modifica il nodo\"\n};\nvar nl = {\n  addDescription: \"Klik op een leeg gebied om een nieuwe node te maken.\",\n  addEdge: \"Link toevoegen\",\n  addNode: \"Node toevoegen\",\n  back: \"Terug\",\n  close: \"Sluiten\",\n  createEdgeError: \"Kan geen link maken naar een cluster.\",\n  del: \"Selectie verwijderen\",\n  deleteClusterError: \"Clusters kunnen niet worden verwijderd.\",\n  edgeDescription: \"Klik op een node en sleep de link naar een andere node om ze te verbinden.\",\n  edit: \"Wijzigen\",\n  editClusterError: \"Clusters kunnen niet worden aangepast.\",\n  editEdge: \"Link wijzigen\",\n  editEdgeDescription: \"Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.\",\n  editNode: \"Node wijzigen\"\n};\nvar pt = {\n  addDescription: \"Clique em um espa\\xE7o em branco para adicionar um novo n\\xF3\",\n  addEdge: \"Adicionar aresta\",\n  addNode: \"Adicionar n\\xF3\",\n  back: \"Voltar\",\n  close: \"Fechar\",\n  createEdgeError: \"N\\xE3o foi poss\\xEDvel linkar arestas a um cluster.\",\n  del: \"Remover selecionado\",\n  deleteClusterError: \"Clusters n\\xE3o puderam ser removidos.\",\n  edgeDescription: \"Clique em um n\\xF3 e arraste a aresta at\\xE9 outro n\\xF3 para conect\\xE1-los\",\n  edit: \"Editar\",\n  editClusterError: \"Clusters n\\xE3o puderam ser editados.\",\n  editEdge: \"Editar aresta\",\n  editEdgeDescription: \"Clique nos pontos de controle e os arraste para um n\\xF3 para conect\\xE1-los\",\n  editNode: \"Editar n\\xF3\"\n};\nvar ru = {\n  addDescription: \"\\u041A\\u043B\\u0438\\u043A\\u043D\\u0438\\u0442\\u0435 \\u0432 \\u0441\\u0432\\u043E\\u0431\\u043E\\u0434\\u043D\\u043E\\u0435 \\u043C\\u0435\\u0441\\u0442\\u043E, \\u0447\\u0442\\u043E\\u0431\\u044B \\u0434\\u043E\\u0431\\u0430\\u0432\\u0438\\u0442\\u044C \\u043D\\u043E\\u0432\\u044B\\u0439 \\u0443\\u0437\\u0435\\u043B.\",\n  addEdge: \"\\u0414\\u043E\\u0431\\u0430\\u0432\\u0438\\u0442\\u044C \\u0440\\u0435\\u0431\\u0440\\u043E\",\n  addNode: \"\\u0414\\u043E\\u0431\\u0430\\u0432\\u0438\\u0442\\u044C \\u0443\\u0437\\u0435\\u043B\",\n  back: \"\\u041D\\u0430\\u0437\\u0430\\u0434\",\n  close: \"\\u0417\\u0430\\u043A\\u0440\\u044B\\u0432\\u0430\\u0442\\u044C\",\n  createEdgeError: \"\\u041D\\u0435\\u0432\\u043E\\u0437\\u043C\\u043E\\u0436\\u043D\\u043E \\u0441\\u043E\\u0435\\u0434\\u0438\\u043D\\u0438\\u0442\\u044C \\u0440\\u0435\\u0431\\u0440\\u0430 \\u0432 \\u043A\\u043B\\u0430\\u0441\\u0442\\u0435\\u0440.\",\n  del: \"\\u0423\\u0434\\u0430\\u043B\\u0438\\u0442\\u044C \\u0432\\u044B\\u0431\\u0440\\u0430\\u043D\\u043D\\u043E\\u0435\",\n  deleteClusterError: \"\\u041A\\u043B\\u0430\\u0441\\u0442\\u0435\\u0440\\u044B \\u043D\\u0435 \\u043C\\u043E\\u0433\\u0443\\u0442 \\u0431\\u044B\\u0442\\u044C \\u0443\\u0434\\u0430\\u043B\\u0435\\u043D\\u044B\",\n  edgeDescription: \"\\u041A\\u043B\\u0438\\u043A\\u043D\\u0438\\u0442\\u0435 \\u043D\\u0430 \\u0443\\u0437\\u0435\\u043B \\u0438 \\u043F\\u0440\\u043E\\u0442\\u044F\\u043D\\u0438\\u0442\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E \\u043A \\u0434\\u0440\\u0443\\u0433\\u043E\\u043C\\u0443 \\u0443\\u0437\\u043B\\u0443, \\u0447\\u0442\\u043E\\u0431\\u044B \\u0441\\u043E\\u0435\\u0434\\u0438\\u043D\\u0438\\u0442\\u044C \\u0438\\u0445.\",\n  edit: \"\\u0420\\u0435\\u0434\\u0430\\u043A\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u0442\\u044C\",\n  editClusterError: \"\\u041A\\u043B\\u0430\\u0441\\u0442\\u0435\\u0440\\u044B \\u043D\\u0435\\u0434\\u043E\\u0441\\u0442\\u0443\\u043F\\u043D\\u044B \\u0434\\u043B\\u044F \\u0440\\u0435\\u0434\\u0430\\u043A\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u0438\\u044F.\",\n  editEdge: \"\\u0420\\u0435\\u0434\\u0430\\u043A\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u0442\\u044C \\u0440\\u0435\\u0431\\u0440\\u043E\",\n  editEdgeDescription: \"\\u041A\\u043B\\u0438\\u043A\\u043D\\u0438\\u0442\\u0435 \\u043D\\u0430 \\u043A\\u043E\\u043D\\u0442\\u0440\\u043E\\u043B\\u044C\\u043D\\u044B\\u0435 \\u0442\\u043E\\u0447\\u043A\\u0438 \\u0438 \\u043F\\u0435\\u0440\\u0435\\u0442\\u0430\\u0449\\u0438\\u0442\\u0435 \\u0438\\u0445 \\u0432 \\u0443\\u0437\\u0435\\u043B, \\u0447\\u0442\\u043E\\u0431\\u044B \\u043F\\u043E\\u0434\\u043A\\u043B\\u044E\\u0447\\u0438\\u0442\\u044C\\u0441\\u044F \\u043A \\u043D\\u0435\\u043C\\u0443.\",\n  editNode: \"\\u0420\\u0435\\u0434\\u0430\\u043A\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u0442\\u044C \\u0443\\u0437\\u0435\\u043B\"\n};\nvar cn = {\n  addDescription: \"\\u5355\\u51FB\\u7A7A\\u767D\\u5904\\u653E\\u7F6E\\u65B0\\u8282\\u70B9\\u3002\",\n  addEdge: \"\\u6DFB\\u52A0\\u8FDE\\u63A5\\u7EBF\",\n  addNode: \"\\u6DFB\\u52A0\\u8282\\u70B9\",\n  back: \"\\u8FD4\\u56DE\",\n  close: \"\\u95DC\\u9589\",\n  createEdgeError: \"\\u65E0\\u6CD5\\u5C06\\u8FDE\\u63A5\\u7EBF\\u8FDE\\u63A5\\u5230\\u7FA4\\u96C6\\u3002\",\n  del: \"\\u5220\\u9664\\u9009\\u5B9A\",\n  deleteClusterError: \"\\u65E0\\u6CD5\\u5220\\u9664\\u7FA4\\u96C6\\u3002\",\n  edgeDescription: \"\\u5355\\u51FB\\u67D0\\u4E2A\\u8282\\u70B9\\u5E76\\u5C06\\u8BE5\\u8FDE\\u63A5\\u7EBF\\u62D6\\u52A8\\u5230\\u53E6\\u4E00\\u4E2A\\u8282\\u70B9\\u4EE5\\u8FDE\\u63A5\\u5B83\\u4EEC\\u3002\",\n  edit: \"\\u7F16\\u8F91\",\n  editClusterError: \"\\u65E0\\u6CD5\\u7F16\\u8F91\\u7FA4\\u96C6\\u3002\",\n  editEdge: \"\\u7F16\\u8F91\\u8FDE\\u63A5\\u7EBF\",\n  editEdgeDescription: \"\\u5355\\u51FB\\u63A7\\u5236\\u8282\\u70B9\\u5E76\\u5C06\\u5B83\\u4EEC\\u62D6\\u5230\\u8282\\u70B9\\u4E0A\\u8FDE\\u63A5\\u3002\",\n  editNode: \"\\u7F16\\u8F91\\u8282\\u70B9\"\n};\nvar uk = {\n  addDescription: \"K\\u043B\\u0456\\u043A\\u043D\\u0456\\u0442\\u044C \\u043D\\u0430 \\u0432\\u0456\\u043B\\u044C\\u043D\\u0435 \\u043C\\u0456\\u0441\\u0446\\u0435, \\u0449\\u043E\\u0431 \\u0434\\u043E\\u0434\\u0430\\u0442\\u0438 \\u043D\\u043E\\u0432\\u0438\\u0439 \\u0432\\u0443\\u0437\\u043E\\u043B.\",\n  addEdge: \"\\u0414\\u043E\\u0434\\u0430\\u0442\\u0438 \\u043A\\u0440\\u0430\\u0439\",\n  addNode: \"\\u0414\\u043E\\u0434\\u0430\\u0442\\u0438 \\u0432\\u0443\\u0437\\u043E\\u043B\",\n  back: \"\\u041D\\u0430\\u0437\\u0430\\u0434\",\n  close: \"\\u0417\\u0430\\u043A\\u0440\\u0438\\u0442\\u0438\",\n  createEdgeError: \"\\u041D\\u0435 \\u043C\\u043E\\u0436\\u043B\\u0438\\u0432\\u043E \\u043E\\u0431'\\u0454\\u0434\\u043D\\u0430\\u0442\\u0438 \\u043A\\u0440\\u0430\\u0457 \\u0432 \\u0433\\u0440\\u0443\\u043F\\u0443.\",\n  del: \"\\u0412\\u0438\\u0434\\u0430\\u043B\\u0438\\u0442\\u0438 \\u043E\\u0431\\u0440\\u0430\\u043D\\u0435\",\n  deleteClusterError: \"\\u0413\\u0440\\u0443\\u043F\\u0438 \\u043D\\u0435 \\u043C\\u043E\\u0436\\u0443\\u0442\\u044C \\u0431\\u0443\\u0442\\u0438 \\u0432\\u0438\\u0434\\u0430\\u043B\\u0435\\u043D\\u0456.\",\n  edgeDescription: \"\\u041A\\u043B\\u0456\\u043A\\u043D\\u0456\\u0442\\u044C \\u043D\\u0430 \\u0432\\u0443\\u0437\\u043E\\u043B \\u0456 \\u043F\\u0435\\u0440\\u0435\\u0442\\u044F\\u0433\\u043D\\u0456\\u0442\\u044C \\u043A\\u0440\\u0430\\u0439 \\u0434\\u043E \\u0456\\u043D\\u0448\\u043E\\u0433\\u043E \\u0432\\u0443\\u0437\\u043B\\u0430, \\u0449\\u043E\\u0431 \\u0457\\u0445 \\u0437'\\u0454\\u0434\\u043D\\u0430\\u0442\\u0438.\",\n  edit: \"\\u0420\\u0435\\u0434\\u0430\\u0433\\u0443\\u0432\\u0430\\u0442\\u0438\",\n  editClusterError: \"\\u0413\\u0440\\u0443\\u043F\\u0438 \\u043D\\u0435\\u0434\\u043E\\u0441\\u0442\\u0443\\u043F\\u043D\\u0456 \\u0434\\u043B\\u044F \\u0440\\u0435\\u0434\\u0430\\u0433\\u0443\\u0432\\u0430\\u043D\\u043D\\u044F.\",\n  editEdge: \"\\u0420\\u0435\\u0434\\u0430\\u0433\\u0443\\u0432\\u0430\\u0442\\u0438 \\u043A\\u0440\\u0430\\u0439\",\n  editEdgeDescription: \"\\u041A\\u043B\\u0456\\u043A\\u043D\\u0456\\u0442\\u044C \\u043D\\u0430 \\u043A\\u043E\\u043D\\u0442\\u0440\\u043E\\u043B\\u044C\\u043D\\u0456 \\u0442\\u043E\\u0447\\u043A\\u0438 \\u0456 \\u043F\\u0435\\u0440\\u0435\\u0442\\u044F\\u0433\\u043D\\u0456\\u0442\\u044C \\u0457\\u0445 \\u0443 \\u0432\\u0443\\u0437\\u043E\\u043B, \\u0449\\u043E\\u0431 \\u043F\\u0456\\u0434\\u043A\\u043B\\u044E\\u0447\\u0438\\u0442\\u0438\\u0441\\u044F \\u0434\\u043E \\u043D\\u044C\\u043E\\u0433\\u043E.\",\n  editNode: \"\\u0420\\u0435\\u0434\\u0430\\u0433\\u0443\\u0432\\u0430\\u0442\\u0438 \\u0432\\u0443\\u0437\\u043E\\u043B\"\n};\nvar fr = {\n  addDescription: \"Cliquez dans un endroit vide pour placer un n\\u0153ud.\",\n  addEdge: \"Ajouter un lien\",\n  addNode: \"Ajouter un n\\u0153ud\",\n  back: \"Retour\",\n  close: \"Fermer\",\n  createEdgeError: \"Impossible de cr\\xE9er un lien vers un cluster.\",\n  del: \"Effacer la s\\xE9lection\",\n  deleteClusterError: \"Les clusters ne peuvent pas \\xEAtre effac\\xE9s.\",\n  edgeDescription: \"Cliquez sur un n\\u0153ud et glissez le lien vers un autre n\\u0153ud pour les connecter.\",\n  edit: \"\\xC9diter\",\n  editClusterError: \"Les clusters ne peuvent pas \\xEAtre \\xE9dit\\xE9s.\",\n  editEdge: \"\\xC9diter le lien\",\n  editEdgeDescription: \"Cliquez sur les points de contr\\xF4le et glissez-les pour connecter un n\\u0153ud.\",\n  editNode: \"\\xC9diter le n\\u0153ud\"\n};\nvar cs = {\n  addDescription: \"Kluknut\\xEDm do pr\\xE1zdn\\xE9ho prostoru m\\u016F\\u017Eete p\\u0159idat nov\\xFD vrchol.\",\n  addEdge: \"P\\u0159idat hranu\",\n  addNode: \"P\\u0159idat vrchol\",\n  back: \"Zp\\u011Bt\",\n  close: \"Zav\\u0159\\xEDt\",\n  createEdgeError: \"Nelze p\\u0159ipojit hranu ke shluku.\",\n  del: \"Smazat v\\xFDb\\u011Br\",\n  deleteClusterError: \"Nelze mazat shluky.\",\n  edgeDescription: \"P\\u0159eta\\u017Een\\xEDm z jednoho vrcholu do druh\\xE9ho m\\u016F\\u017Eete spojit tyto vrcholy novou hranou.\",\n  edit: \"Upravit\",\n  editClusterError: \"Nelze upravovat shluky.\",\n  editEdge: \"Upravit hranu\",\n  editEdgeDescription: \"P\\u0159eta\\u017Een\\xEDm kontroln\\xEDho vrcholu hrany ji m\\u016F\\u017Eete p\\u0159ipojit k jin\\xE9mu vrcholu.\",\n  editNode: \"Upravit vrchol\"\n};\nvar locales = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  en,\n  de: de3,\n  es,\n  it,\n  nl,\n  pt,\n  ru,\n  cn,\n  uk,\n  fr,\n  cs\n});\nfunction normalizeLanguageCode(locales2, rawCode) {\n  try {\n    var _rawCode$split = rawCode.split(/[-_ /]/, 2), _rawCode$split2 = _slicedToArray2(_rawCode$split, 2), rawLanguage = _rawCode$split2[0], rawCountry = _rawCode$split2[1];\n    var language = rawLanguage != null ? rawLanguage.toLowerCase() : null;\n    var country = rawCountry != null ? rawCountry.toUpperCase() : null;\n    if (language && country) {\n      var code = language + \"-\" + country;\n      if (Object.prototype.hasOwnProperty.call(locales2, code)) {\n        return code;\n      } else {\n        var _context;\n        console.warn(concat22(_context = \"Unknown variant \".concat(country, \" of language \")).call(_context, language, \".\"));\n      }\n    }\n    if (language) {\n      var _code = language;\n      if (Object.prototype.hasOwnProperty.call(locales2, _code)) {\n        return _code;\n      } else {\n        console.warn(\"Unknown language \".concat(language));\n      }\n    }\n    console.warn(\"Unknown locale \".concat(rawCode, \", falling back to English.\"));\n    return \"en\";\n  } catch (error) {\n    console.error(error);\n    console.warn(\"Unexpected error while normalizing locale \".concat(rawCode, \", falling back to English.\"));\n    return \"en\";\n  }\n}\nvar CachedImage = /* @__PURE__ */ function() {\n  function CachedImage2() {\n    _classCallCheck2(this, CachedImage2);\n    this.NUM_ITERATIONS = 4;\n    this.image = new Image();\n    this.canvas = document.createElement(\"canvas\");\n  }\n  _createClass2(CachedImage2, [{\n    key: \"init\",\n    value: function init() {\n      if (this.initialized())\n        return;\n      this.src = this.image.src;\n      var w = this.image.width;\n      var h = this.image.height;\n      this.width = w;\n      this.height = h;\n      var h2 = Math.floor(h / 2);\n      var h4 = Math.floor(h / 4);\n      var h8 = Math.floor(h / 8);\n      var h16 = Math.floor(h / 16);\n      var w2 = Math.floor(w / 2);\n      var w4 = Math.floor(w / 4);\n      var w8 = Math.floor(w / 8);\n      var w16 = Math.floor(w / 16);\n      this.canvas.width = 3 * w4;\n      this.canvas.height = h2;\n      this.coordinates = [[0, 0, w2, h2], [w2, 0, w4, h4], [w2, h4, w8, h8], [5 * w8, h4, w16, h16]];\n      this._fillMipMap();\n    }\n  }, {\n    key: \"initialized\",\n    value: function initialized() {\n      return this.coordinates !== void 0;\n    }\n  }, {\n    key: \"_fillMipMap\",\n    value: function _fillMipMap() {\n      var ctx = this.canvas.getContext(\"2d\");\n      var to = this.coordinates[0];\n      ctx.drawImage(this.image, to[0], to[1], to[2], to[3]);\n      for (var iterations = 1; iterations < this.NUM_ITERATIONS; iterations++) {\n        var from32 = this.coordinates[iterations - 1];\n        var _to = this.coordinates[iterations];\n        ctx.drawImage(this.canvas, from32[0], from32[1], from32[2], from32[3], _to[0], _to[1], _to[2], _to[3]);\n      }\n    }\n  }, {\n    key: \"drawImageAtPosition\",\n    value: function drawImageAtPosition(ctx, factor, left, top, width, height) {\n      if (!this.initialized())\n        return;\n      if (factor > 2) {\n        factor *= 0.5;\n        var iterations = 0;\n        while (factor > 2 && iterations < this.NUM_ITERATIONS) {\n          factor *= 0.5;\n          iterations += 1;\n        }\n        if (iterations >= this.NUM_ITERATIONS) {\n          iterations = this.NUM_ITERATIONS - 1;\n        }\n        var from32 = this.coordinates[iterations];\n        ctx.drawImage(this.canvas, from32[0], from32[1], from32[2], from32[3], left, top, width, height);\n      } else {\n        ctx.drawImage(this.image, left, top, width, height);\n      }\n    }\n  }]);\n  return CachedImage2;\n}();\nvar Images = /* @__PURE__ */ function() {\n  function Images2(callback) {\n    _classCallCheck2(this, Images2);\n    this.images = {};\n    this.imageBroken = {};\n    this.callback = callback;\n  }\n  _createClass2(Images2, [{\n    key: \"_tryloadBrokenUrl\",\n    value: function _tryloadBrokenUrl(url, brokenUrl, imageToLoadBrokenUrlOn) {\n      if (url === void 0 || imageToLoadBrokenUrlOn === void 0)\n        return;\n      if (brokenUrl === void 0) {\n        console.warn(\"No broken url image defined\");\n        return;\n      }\n      imageToLoadBrokenUrlOn.image.onerror = function() {\n        console.error(\"Could not load brokenImage:\", brokenUrl);\n      };\n      imageToLoadBrokenUrlOn.image.src = brokenUrl;\n    }\n  }, {\n    key: \"_redrawWithImage\",\n    value: function _redrawWithImage(imageToRedrawWith) {\n      if (this.callback) {\n        this.callback(imageToRedrawWith);\n      }\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, brokenUrl) {\n      var _this = this;\n      var cachedImage = this.images[url];\n      if (cachedImage)\n        return cachedImage;\n      var img = new CachedImage();\n      this.images[url] = img;\n      img.image.onload = function() {\n        _this._fixImageCoordinates(img.image);\n        img.init();\n        _this._redrawWithImage(img);\n      };\n      img.image.onerror = function() {\n        console.error(\"Could not load image:\", url);\n        _this._tryloadBrokenUrl(url, brokenUrl, img);\n      };\n      img.image.src = url;\n      return img;\n    }\n  }, {\n    key: \"_fixImageCoordinates\",\n    value: function _fixImageCoordinates(imageToCache) {\n      if (imageToCache.width === 0) {\n        document.body.appendChild(imageToCache);\n        imageToCache.width = imageToCache.offsetWidth;\n        imageToCache.height = imageToCache.offsetHeight;\n        document.body.removeChild(imageToCache);\n      }\n    }\n  }]);\n  return Images2;\n}();\nvar internalMetadata2 = { exports: {} };\nvar fails$72 = fails$t;\nvar arrayBufferNonExtensible2 = fails$72(function() {\n  if (typeof ArrayBuffer == \"function\") {\n    var buffer = new ArrayBuffer(8);\n    if (Object.isExtensible(buffer))\n      Object.defineProperty(buffer, \"a\", {\n        value: 8\n      });\n  }\n});\nvar fails$62 = fails$t;\nvar isObject$62 = isObject$j;\nvar classof$22 = classofRaw$12;\nvar ARRAY_BUFFER_NON_EXTENSIBLE2 = arrayBufferNonExtensible2;\nvar $isExtensible2 = Object.isExtensible;\nvar FAILS_ON_PRIMITIVES$12 = fails$62(function() {\n  $isExtensible2(1);\n});\nvar objectIsExtensible2 = FAILS_ON_PRIMITIVES$12 || ARRAY_BUFFER_NON_EXTENSIBLE2 ? function isExtensible3(it2) {\n  if (!isObject$62(it2))\n    return false;\n  if (ARRAY_BUFFER_NON_EXTENSIBLE2 && classof$22(it2) == \"ArrayBuffer\")\n    return false;\n  return $isExtensible2 ? $isExtensible2(it2) : true;\n} : $isExtensible2;\nvar fails$52 = fails$t;\nvar freezing2 = !fails$52(function() {\n  return Object.isExtensible(Object.preventExtensions({}));\n});\nvar $$d2 = _export2;\nvar uncurryThis$42 = functionUncurryThis2;\nvar hiddenKeys2 = hiddenKeys$62;\nvar isObject$52 = isObject$j;\nvar hasOwn$32 = hasOwnProperty_12;\nvar defineProperty$22 = objectDefineProperty2.f;\nvar getOwnPropertyNamesModule2 = objectGetOwnPropertyNames2;\nvar getOwnPropertyNamesExternalModule2 = objectGetOwnPropertyNamesExternal2;\nvar isExtensible$1 = objectIsExtensible2;\nvar uid2 = uid$42;\nvar FREEZING2 = freezing2;\nvar REQUIRED2 = false;\nvar METADATA2 = uid2(\"meta\");\nvar id$12 = 0;\nvar setMetadata2 = function(it2) {\n  defineProperty$22(it2, METADATA2, {\n    value: {\n      objectID: \"O\" + id$12++,\n      weakData: {}\n    }\n  });\n};\nvar fastKey$12 = function(it2, create52) {\n  if (!isObject$52(it2))\n    return typeof it2 == \"symbol\" ? it2 : (typeof it2 == \"string\" ? \"S\" : \"P\") + it2;\n  if (!hasOwn$32(it2, METADATA2)) {\n    if (!isExtensible$1(it2))\n      return \"F\";\n    if (!create52)\n      return \"E\";\n    setMetadata2(it2);\n  }\n  return it2[METADATA2].objectID;\n};\nvar getWeakData$1 = function(it2, create52) {\n  if (!hasOwn$32(it2, METADATA2)) {\n    if (!isExtensible$1(it2))\n      return true;\n    if (!create52)\n      return false;\n    setMetadata2(it2);\n  }\n  return it2[METADATA2].weakData;\n};\nvar onFreeze2 = function(it2) {\n  if (FREEZING2 && REQUIRED2 && isExtensible$1(it2) && !hasOwn$32(it2, METADATA2))\n    setMetadata2(it2);\n  return it2;\n};\nvar enable2 = function() {\n  meta2.enable = function() {\n  };\n  REQUIRED2 = true;\n  var getOwnPropertyNames6 = getOwnPropertyNamesModule2.f;\n  var splice32 = uncurryThis$42([].splice);\n  var test22 = {};\n  test22[METADATA2] = 1;\n  if (getOwnPropertyNames6(test22).length) {\n    getOwnPropertyNamesModule2.f = function(it2) {\n      var result2 = getOwnPropertyNames6(it2);\n      for (var i = 0, length2 = result2.length; i < length2; i++) {\n        if (result2[i] === METADATA2) {\n          splice32(result2, i, 1);\n          break;\n        }\n      }\n      return result2;\n    };\n    $$d2({\n      target: \"Object\",\n      stat: true,\n      forced: true\n    }, {\n      getOwnPropertyNames: getOwnPropertyNamesExternalModule2.f\n    });\n  }\n};\nvar meta2 = internalMetadata2.exports = {\n  enable: enable2,\n  fastKey: fastKey$12,\n  getWeakData: getWeakData$1,\n  onFreeze: onFreeze2\n};\nhiddenKeys2[METADATA2] = true;\nvar global$92 = global$O;\nvar bind$22 = functionBindContext2;\nvar call$12 = functionCall2;\nvar anObject$32 = anObject$d;\nvar tryToString$12 = tryToString$42;\nvar isArrayIteratorMethod2 = isArrayIteratorMethod$22;\nvar lengthOfArrayLike$22 = lengthOfArrayLike$b2;\nvar isPrototypeOf$62 = objectIsPrototypeOf2;\nvar getIterator2 = getIterator$22;\nvar getIteratorMethod2 = getIteratorMethod$82;\nvar iteratorClose2 = iteratorClose$22;\nvar TypeError$42 = global$92.TypeError;\nvar Result4 = function(stopped, result2) {\n  this.stopped = stopped;\n  this.result = result2;\n};\nvar ResultPrototype2 = Result4.prototype;\nvar iterate$3 = function(iterable, unboundFunction, options2) {\n  var that = options2 && options2.that;\n  var AS_ENTRIES = !!(options2 && options2.AS_ENTRIES);\n  var IS_ITERATOR = !!(options2 && options2.IS_ITERATOR);\n  var INTERRUPTED = !!(options2 && options2.INTERRUPTED);\n  var fn = bind$22(unboundFunction, that);\n  var iterator22, iterFn, index2, length2, result2, next3, step;\n  var stop = function(condition) {\n    if (iterator22)\n      iteratorClose2(iterator22, \"normal\", condition);\n    return new Result4(true, condition);\n  };\n  var callFn = function(value) {\n    if (AS_ENTRIES) {\n      anObject$32(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    }\n    return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n  if (IS_ITERATOR) {\n    iterator22 = iterable;\n  } else {\n    iterFn = getIteratorMethod2(iterable);\n    if (!iterFn)\n      throw TypeError$42(tryToString$12(iterable) + \" is not iterable\");\n    if (isArrayIteratorMethod2(iterFn)) {\n      for (index2 = 0, length2 = lengthOfArrayLike$22(iterable); length2 > index2; index2++) {\n        result2 = callFn(iterable[index2]);\n        if (result2 && isPrototypeOf$62(ResultPrototype2, result2))\n          return result2;\n      }\n      return new Result4(false);\n    }\n    iterator22 = getIterator2(iterable, iterFn);\n  }\n  next3 = iterator22.next;\n  while (!(step = call$12(next3, iterator22)).done) {\n    try {\n      result2 = callFn(step.value);\n    } catch (error) {\n      iteratorClose2(iterator22, \"throw\", error);\n    }\n    if (typeof result2 == \"object\" && result2 && isPrototypeOf$62(ResultPrototype2, result2))\n      return result2;\n  }\n  return new Result4(false);\n};\nvar global$82 = global$O;\nvar isPrototypeOf$52 = objectIsPrototypeOf2;\nvar TypeError$32 = global$82.TypeError;\nvar anInstance$3 = function(it2, Prototype) {\n  if (isPrototypeOf$52(Prototype, it2))\n    return it2;\n  throw TypeError$32(\"Incorrect invocation\");\n};\nvar $$c2 = _export2;\nvar global$72 = global$O;\nvar InternalMetadataModule$1 = internalMetadata2.exports;\nvar fails$42 = fails$t;\nvar createNonEnumerableProperty2 = createNonEnumerableProperty$62;\nvar iterate$22 = iterate$3;\nvar anInstance$22 = anInstance$3;\nvar isCallable2 = isCallable$h2;\nvar isObject$42 = isObject$j;\nvar setToStringTag2 = setToStringTag$52;\nvar defineProperty$12 = objectDefineProperty2.f;\nvar forEach32 = arrayIteration2.forEach;\nvar DESCRIPTORS$22 = descriptors2;\nvar InternalStateModule$22 = internalState2;\nvar setInternalState$22 = InternalStateModule$22.set;\nvar internalStateGetterFor$2 = InternalStateModule$22.getterFor;\nvar collection$3 = function(CONSTRUCTOR_NAME, wrapper2, common) {\n  var IS_MAP = CONSTRUCTOR_NAME.indexOf(\"Map\") !== -1;\n  var IS_WEAK = CONSTRUCTOR_NAME.indexOf(\"Weak\") !== -1;\n  var ADDER = IS_MAP ? \"set\" : \"add\";\n  var NativeConstructor = global$72[CONSTRUCTOR_NAME];\n  var NativePrototype = NativeConstructor && NativeConstructor.prototype;\n  var exported = {};\n  var Constructor;\n  if (!DESCRIPTORS$22 || !isCallable2(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$42(function() {\n    new NativeConstructor().entries().next();\n  }))) {\n    Constructor = common.getConstructor(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER);\n    InternalMetadataModule$1.enable();\n  } else {\n    Constructor = wrapper2(function(target, iterable) {\n      setInternalState$22(anInstance$22(target, Prototype), {\n        type: CONSTRUCTOR_NAME,\n        collection: new NativeConstructor()\n      });\n      if (iterable != void 0)\n        iterate$22(iterable, target[ADDER], {\n          that: target,\n          AS_ENTRIES: IS_MAP\n        });\n    });\n    var Prototype = Constructor.prototype;\n    var getInternalState22 = internalStateGetterFor$2(CONSTRUCTOR_NAME);\n    forEach32([\"add\", \"clear\", \"delete\", \"forEach\", \"get\", \"has\", \"set\", \"keys\", \"values\", \"entries\"], function(KEY) {\n      var IS_ADDER = KEY == \"add\" || KEY == \"set\";\n      if (KEY in NativePrototype && !(IS_WEAK && KEY == \"clear\")) {\n        createNonEnumerableProperty2(Prototype, KEY, function(a, b) {\n          var collection22 = getInternalState22(this).collection;\n          if (!IS_ADDER && IS_WEAK && !isObject$42(a))\n            return KEY == \"get\" ? void 0 : false;\n          var result2 = collection22[KEY](a === 0 ? 0 : a, b);\n          return IS_ADDER ? this : result2;\n        });\n      }\n    });\n    IS_WEAK || defineProperty$12(Prototype, \"size\", {\n      configurable: true,\n      get: function() {\n        return getInternalState22(this).collection.size;\n      }\n    });\n  }\n  setToStringTag2(Constructor, CONSTRUCTOR_NAME, false, true);\n  exported[CONSTRUCTOR_NAME] = Constructor;\n  $$c2({\n    global: true,\n    forced: true\n  }, exported);\n  if (!IS_WEAK)\n    common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);\n  return Constructor;\n};\nvar redefine2 = redefine$42;\nvar redefineAll$3 = function(target, src, options2) {\n  for (var key in src) {\n    if (options2 && options2.unsafe && target[key])\n      target[key] = src[key];\n    else\n      redefine2(target, key, src[key], options2);\n  }\n  return target;\n};\nvar getBuiltIn$12 = getBuiltIn$92;\nvar definePropertyModule2 = objectDefineProperty2;\nvar wellKnownSymbol2 = wellKnownSymbol$j2;\nvar DESCRIPTORS$12 = descriptors2;\nvar SPECIES2 = wellKnownSymbol2(\"species\");\nvar setSpecies$12 = function(CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn$12(CONSTRUCTOR_NAME);\n  var defineProperty62 = definePropertyModule2.f;\n  if (DESCRIPTORS$12 && Constructor && !Constructor[SPECIES2]) {\n    defineProperty62(Constructor, SPECIES2, {\n      configurable: true,\n      get: function() {\n        return this;\n      }\n    });\n  }\n};\nvar defineProperty52 = objectDefineProperty2.f;\nvar create$42 = objectCreate2;\nvar redefineAll$2 = redefineAll$3;\nvar bind$12 = functionBindContext2;\nvar anInstance$12 = anInstance$3;\nvar iterate$12 = iterate$3;\nvar defineIterator2 = defineIterator$32;\nvar setSpecies2 = setSpecies$12;\nvar DESCRIPTORS2 = descriptors2;\nvar fastKey2 = internalMetadata2.exports.fastKey;\nvar InternalStateModule$12 = internalState2;\nvar setInternalState$12 = InternalStateModule$12.set;\nvar internalStateGetterFor$12 = InternalStateModule$12.getterFor;\nvar collectionStrong$22 = {\n  getConstructor: function(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n    var Constructor = wrapper2(function(that, iterable) {\n      anInstance$12(that, Prototype);\n      setInternalState$12(that, {\n        type: CONSTRUCTOR_NAME,\n        index: create$42(null),\n        first: void 0,\n        last: void 0,\n        size: 0\n      });\n      if (!DESCRIPTORS2)\n        that.size = 0;\n      if (iterable != void 0)\n        iterate$12(iterable, that[ADDER], {\n          that,\n          AS_ENTRIES: IS_MAP\n        });\n    });\n    var Prototype = Constructor.prototype;\n    var getInternalState22 = internalStateGetterFor$12(CONSTRUCTOR_NAME);\n    var define = function(that, key, value) {\n      var state = getInternalState22(that);\n      var entry = getEntry(that, key);\n      var previous, index2;\n      if (entry) {\n        entry.value = value;\n      } else {\n        state.last = entry = {\n          index: index2 = fastKey2(key, true),\n          key,\n          value,\n          previous: previous = state.last,\n          next: void 0,\n          removed: false\n        };\n        if (!state.first)\n          state.first = entry;\n        if (previous)\n          previous.next = entry;\n        if (DESCRIPTORS2)\n          state.size++;\n        else\n          that.size++;\n        if (index2 !== \"F\")\n          state.index[index2] = entry;\n      }\n      return that;\n    };\n    var getEntry = function(that, key) {\n      var state = getInternalState22(that);\n      var index2 = fastKey2(key);\n      var entry;\n      if (index2 !== \"F\")\n        return state.index[index2];\n      for (entry = state.first; entry; entry = entry.next) {\n        if (entry.key == key)\n          return entry;\n      }\n    };\n    redefineAll$2(Prototype, {\n      clear: function clear() {\n        var that = this;\n        var state = getInternalState22(that);\n        var data22 = state.index;\n        var entry = state.first;\n        while (entry) {\n          entry.removed = true;\n          if (entry.previous)\n            entry.previous = entry.previous.next = void 0;\n          delete data22[entry.index];\n          entry = entry.next;\n        }\n        state.first = state.last = void 0;\n        if (DESCRIPTORS2)\n          state.size = 0;\n        else\n          that.size = 0;\n      },\n      delete: function(key) {\n        var that = this;\n        var state = getInternalState22(that);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next3 = entry.next;\n          var prev = entry.previous;\n          delete state.index[entry.index];\n          entry.removed = true;\n          if (prev)\n            prev.next = next3;\n          if (next3)\n            next3.previous = prev;\n          if (state.first == entry)\n            state.first = next3;\n          if (state.last == entry)\n            state.last = prev;\n          if (DESCRIPTORS2)\n            state.size--;\n          else\n            that.size--;\n        }\n        return !!entry;\n      },\n      forEach: function forEach4(callbackfn) {\n        var state = getInternalState22(this);\n        var boundFunction = bind$12(callbackfn, arguments.length > 1 ? arguments[1] : void 0);\n        var entry;\n        while (entry = entry ? entry.next : state.first) {\n          boundFunction(entry.value, entry.key, this);\n          while (entry && entry.removed)\n            entry = entry.previous;\n        }\n      },\n      has: function has22(key) {\n        return !!getEntry(this, key);\n      }\n    });\n    redefineAll$2(Prototype, IS_MAP ? {\n      get: function get22(key) {\n        var entry = getEntry(this, key);\n        return entry && entry.value;\n      },\n      set: function set22(key, value) {\n        return define(this, key === 0 ? 0 : key, value);\n      }\n    } : {\n      add: function add(value) {\n        return define(this, value = value === 0 ? 0 : value, value);\n      }\n    });\n    if (DESCRIPTORS2)\n      defineProperty52(Prototype, \"size\", {\n        get: function() {\n          return getInternalState22(this).size;\n        }\n      });\n    return Constructor;\n  },\n  setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {\n    var ITERATOR_NAME = CONSTRUCTOR_NAME + \" Iterator\";\n    var getInternalCollectionState = internalStateGetterFor$12(CONSTRUCTOR_NAME);\n    var getInternalIteratorState = internalStateGetterFor$12(ITERATOR_NAME);\n    defineIterator2(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {\n      setInternalState$12(this, {\n        type: ITERATOR_NAME,\n        target: iterated,\n        state: getInternalCollectionState(iterated),\n        kind,\n        last: void 0\n      });\n    }, function() {\n      var state = getInternalIteratorState(this);\n      var kind = state.kind;\n      var entry = state.last;\n      while (entry && entry.removed)\n        entry = entry.previous;\n      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {\n        state.target = void 0;\n        return {\n          value: void 0,\n          done: true\n        };\n      }\n      if (kind == \"keys\")\n        return {\n          value: entry.key,\n          done: false\n        };\n      if (kind == \"values\")\n        return {\n          value: entry.value,\n          done: false\n        };\n      return {\n        value: [entry.key, entry.value],\n        done: false\n      };\n    }, IS_MAP ? \"entries\" : \"values\", !IS_MAP, true);\n    setSpecies2(CONSTRUCTOR_NAME);\n  }\n};\nvar collection$22 = collection$3;\nvar collectionStrong$12 = collectionStrong$22;\ncollection$22(\"Map\", function(init) {\n  return function Map2() {\n    return init(this, arguments.length ? arguments[0] : void 0);\n  };\n}, collectionStrong$12);\nvar path$b2 = path$y;\nvar map$22 = path$b2.Map;\nvar parent$p2 = map$22;\nvar map$12 = parent$p2;\nvar map23 = map$12;\nvar Groups = /* @__PURE__ */ function() {\n  function Groups2() {\n    _classCallCheck2(this, Groups2);\n    this.clear();\n    this._defaultIndex = 0;\n    this._groupIndex = 0;\n    this._defaultGroups = [\n      {\n        border: \"#2B7CE9\",\n        background: \"#97C2FC\",\n        highlight: {\n          border: \"#2B7CE9\",\n          background: \"#D2E5FF\"\n        },\n        hover: {\n          border: \"#2B7CE9\",\n          background: \"#D2E5FF\"\n        }\n      },\n      {\n        border: \"#FFA500\",\n        background: \"#FFFF00\",\n        highlight: {\n          border: \"#FFA500\",\n          background: \"#FFFFA3\"\n        },\n        hover: {\n          border: \"#FFA500\",\n          background: \"#FFFFA3\"\n        }\n      },\n      {\n        border: \"#FA0A10\",\n        background: \"#FB7E81\",\n        highlight: {\n          border: \"#FA0A10\",\n          background: \"#FFAFB1\"\n        },\n        hover: {\n          border: \"#FA0A10\",\n          background: \"#FFAFB1\"\n        }\n      },\n      {\n        border: \"#41A906\",\n        background: \"#7BE141\",\n        highlight: {\n          border: \"#41A906\",\n          background: \"#A1EC76\"\n        },\n        hover: {\n          border: \"#41A906\",\n          background: \"#A1EC76\"\n        }\n      },\n      {\n        border: \"#E129F0\",\n        background: \"#EB7DF4\",\n        highlight: {\n          border: \"#E129F0\",\n          background: \"#F0B3F5\"\n        },\n        hover: {\n          border: \"#E129F0\",\n          background: \"#F0B3F5\"\n        }\n      },\n      {\n        border: \"#7C29F0\",\n        background: \"#AD85E4\",\n        highlight: {\n          border: \"#7C29F0\",\n          background: \"#D3BDF0\"\n        },\n        hover: {\n          border: \"#7C29F0\",\n          background: \"#D3BDF0\"\n        }\n      },\n      {\n        border: \"#C37F00\",\n        background: \"#FFA807\",\n        highlight: {\n          border: \"#C37F00\",\n          background: \"#FFCA66\"\n        },\n        hover: {\n          border: \"#C37F00\",\n          background: \"#FFCA66\"\n        }\n      },\n      {\n        border: \"#4220FB\",\n        background: \"#6E6EFD\",\n        highlight: {\n          border: \"#4220FB\",\n          background: \"#9B9BFD\"\n        },\n        hover: {\n          border: \"#4220FB\",\n          background: \"#9B9BFD\"\n        }\n      },\n      {\n        border: \"#FD5A77\",\n        background: \"#FFC0CB\",\n        highlight: {\n          border: \"#FD5A77\",\n          background: \"#FFD1D9\"\n        },\n        hover: {\n          border: \"#FD5A77\",\n          background: \"#FFD1D9\"\n        }\n      },\n      {\n        border: \"#4AD63A\",\n        background: \"#C2FABC\",\n        highlight: {\n          border: \"#4AD63A\",\n          background: \"#E6FFE3\"\n        },\n        hover: {\n          border: \"#4AD63A\",\n          background: \"#E6FFE3\"\n        }\n      },\n      {\n        border: \"#990000\",\n        background: \"#EE0000\",\n        highlight: {\n          border: \"#BB0000\",\n          background: \"#FF3333\"\n        },\n        hover: {\n          border: \"#BB0000\",\n          background: \"#FF3333\"\n        }\n      },\n      {\n        border: \"#FF6000\",\n        background: \"#FF6000\",\n        highlight: {\n          border: \"#FF6000\",\n          background: \"#FF6000\"\n        },\n        hover: {\n          border: \"#FF6000\",\n          background: \"#FF6000\"\n        }\n      },\n      {\n        border: \"#97C2FC\",\n        background: \"#2B7CE9\",\n        highlight: {\n          border: \"#D2E5FF\",\n          background: \"#2B7CE9\"\n        },\n        hover: {\n          border: \"#D2E5FF\",\n          background: \"#2B7CE9\"\n        }\n      },\n      {\n        border: \"#399605\",\n        background: \"#255C03\",\n        highlight: {\n          border: \"#399605\",\n          background: \"#255C03\"\n        },\n        hover: {\n          border: \"#399605\",\n          background: \"#255C03\"\n        }\n      },\n      {\n        border: \"#B70054\",\n        background: \"#FF007E\",\n        highlight: {\n          border: \"#B70054\",\n          background: \"#FF007E\"\n        },\n        hover: {\n          border: \"#B70054\",\n          background: \"#FF007E\"\n        }\n      },\n      {\n        border: \"#AD85E4\",\n        background: \"#7C29F0\",\n        highlight: {\n          border: \"#D3BDF0\",\n          background: \"#7C29F0\"\n        },\n        hover: {\n          border: \"#D3BDF0\",\n          background: \"#7C29F0\"\n        }\n      },\n      {\n        border: \"#4557FA\",\n        background: \"#000EA1\",\n        highlight: {\n          border: \"#6E6EFD\",\n          background: \"#000EA1\"\n        },\n        hover: {\n          border: \"#6E6EFD\",\n          background: \"#000EA1\"\n        }\n      },\n      {\n        border: \"#FFC0CB\",\n        background: \"#FD5A77\",\n        highlight: {\n          border: \"#FFD1D9\",\n          background: \"#FD5A77\"\n        },\n        hover: {\n          border: \"#FFD1D9\",\n          background: \"#FD5A77\"\n        }\n      },\n      {\n        border: \"#C2FABC\",\n        background: \"#74D66A\",\n        highlight: {\n          border: \"#E6FFE3\",\n          background: \"#74D66A\"\n        },\n        hover: {\n          border: \"#E6FFE3\",\n          background: \"#74D66A\"\n        }\n      },\n      {\n        border: \"#EE0000\",\n        background: \"#990000\",\n        highlight: {\n          border: \"#FF3333\",\n          background: \"#BB0000\"\n        },\n        hover: {\n          border: \"#FF3333\",\n          background: \"#BB0000\"\n        }\n      }\n    ];\n    this.options = {};\n    this.defaultOptions = {\n      useDefaultGroups: true\n    };\n    assign$22(this.options, this.defaultOptions);\n  }\n  _createClass2(Groups2, [{\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      var optionFields = [\"useDefaultGroups\"];\n      if (options2 !== void 0) {\n        for (var groupName in options2) {\n          if (Object.prototype.hasOwnProperty.call(options2, groupName)) {\n            if (indexOf22(optionFields).call(optionFields, groupName) === -1) {\n              var group = options2[groupName];\n              this.add(groupName, group);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._groups = new map23();\n      this._groupNames = [];\n    }\n  }, {\n    key: \"get\",\n    value: function get22(groupname) {\n      var shouldCreate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n      var group = this._groups.get(groupname);\n      if (group === void 0 && shouldCreate) {\n        if (this.options.useDefaultGroups === false && this._groupNames.length > 0) {\n          var index2 = this._groupIndex % this._groupNames.length;\n          ++this._groupIndex;\n          group = {};\n          group.color = this._groups.get(this._groupNames[index2]);\n          this._groups.set(groupname, group);\n        } else {\n          var _index = this._defaultIndex % this._defaultGroups.length;\n          this._defaultIndex++;\n          group = {};\n          group.color = this._defaultGroups[_index];\n          this._groups.set(groupname, group);\n        }\n      }\n      return group;\n    }\n  }, {\n    key: \"add\",\n    value: function add(groupName, style2) {\n      if (!this._groups.has(groupName)) {\n        this._groupNames.push(groupName);\n      }\n      this._groups.set(groupName, style2);\n      return style2;\n    }\n  }]);\n  return Groups2;\n}();\nvar $$b2 = _export2;\n$$b2({\n  target: \"Number\",\n  stat: true\n}, {\n  isNaN: function isNaN2(number22) {\n    return number22 != number22;\n  }\n});\nvar path$a2 = path$y;\nvar isNan$2 = path$a2.Number.isNaN;\nvar parent$o2 = isNan$2;\nvar isNan$1 = parent$o2;\nvar isNan = isNan$1;\nvar global$62 = global$O;\nvar globalIsFinite = global$62.isFinite;\nvar numberIsFinite$1 = Number.isFinite || function isFinite(it2) {\n  return typeof it2 == \"number\" && globalIsFinite(it2);\n};\nvar $$a2 = _export2;\nvar numberIsFinite = numberIsFinite$1;\n$$a2({\n  target: \"Number\",\n  stat: true\n}, {\n  isFinite: numberIsFinite\n});\nvar path$92 = path$y;\nvar _isFinite$2 = path$92.Number.isFinite;\nvar parent$n2 = _isFinite$2;\nvar _isFinite$1 = parent$n2;\nvar _isFinite = _isFinite$1;\nvar $$92 = _export2;\nvar $some2 = arrayIteration2.some;\nvar arrayMethodIsStrict$32 = arrayMethodIsStrict$6;\nvar STRICT_METHOD$32 = arrayMethodIsStrict$32(\"some\");\n$$92({\n  target: \"Array\",\n  proto: true,\n  forced: !STRICT_METHOD$32\n}, {\n  some: function some3(callbackfn) {\n    return $some2(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);\n  }\n});\nvar entryVirtual$42 = entryVirtual$i2;\nvar some$32 = entryVirtual$42(\"Array\").some;\nvar isPrototypeOf$42 = objectIsPrototypeOf2;\nvar method$42 = some$32;\nvar ArrayPrototype$42 = Array.prototype;\nvar some$22 = function(it2) {\n  var own = it2.some;\n  return it2 === ArrayPrototype$42 || isPrototypeOf$42(ArrayPrototype$42, it2) && own === ArrayPrototype$42.some ? method$42 : own;\n};\nvar parent$m2 = some$22;\nvar some$12 = parent$m2;\nvar some22 = some$12;\nvar global$52 = global$O;\nvar fails$32 = fails$t;\nvar uncurryThis$32 = functionUncurryThis2;\nvar toString$12 = toString$82;\nvar trim22 = stringTrim2.trim;\nvar whitespaces2 = whitespaces$4;\nvar charAt2 = uncurryThis$32(\"\".charAt);\nvar n$ParseFloat = global$52.parseFloat;\nvar Symbol$12 = global$52.Symbol;\nvar ITERATOR2 = Symbol$12 && Symbol$12.iterator;\nvar FORCED$22 = 1 / n$ParseFloat(whitespaces2 + \"-0\") !== -Infinity || ITERATOR2 && !fails$32(function() {\n  n$ParseFloat(Object(ITERATOR2));\n});\nvar numberParseFloat = FORCED$22 ? function parseFloat2(string22) {\n  var trimmedString = trim22(toString$12(string22));\n  var result2 = n$ParseFloat(trimmedString);\n  return result2 === 0 && charAt2(trimmedString, 0) == \"-\" ? -0 : result2;\n} : n$ParseFloat;\nvar $$82 = _export2;\nvar $parseFloat = numberParseFloat;\n$$82({\n  global: true,\n  forced: parseFloat != $parseFloat\n}, {\n  parseFloat: $parseFloat\n});\nvar path$82 = path$y;\nvar _parseFloat$2 = path$82.parseFloat;\nvar parent$l2 = _parseFloat$2;\nvar _parseFloat$1 = parent$l2;\nvar _parseFloat = _parseFloat$1;\nvar $$72 = _export2;\nvar fails$22 = fails$t;\nvar getOwnPropertyNames$3 = objectGetOwnPropertyNamesExternal2.f;\nvar FAILS_ON_PRIMITIVES2 = fails$22(function() {\n  return !Object.getOwnPropertyNames(1);\n});\n$$72({\n  target: \"Object\",\n  stat: true,\n  forced: FAILS_ON_PRIMITIVES2\n}, {\n  getOwnPropertyNames: getOwnPropertyNames$3\n});\nvar path$7 = path$y;\nvar Object$12 = path$7.Object;\nvar getOwnPropertyNames$2 = function getOwnPropertyNames42(it2) {\n  return Object$12.getOwnPropertyNames(it2);\n};\nvar parent$k2 = getOwnPropertyNames$2;\nvar getOwnPropertyNames$1 = parent$k2;\nvar getOwnPropertyNames5 = getOwnPropertyNames$1;\nfunction choosify(subOption, pile) {\n  var allowed = [\"node\", \"edge\", \"label\"];\n  var value = true;\n  var chosen = topMost(pile, \"chosen\");\n  if (typeof chosen === \"boolean\") {\n    value = chosen;\n  } else if (_typeof2(chosen) === \"object\") {\n    if (indexOf22(allowed).call(allowed, subOption) === -1) {\n      throw new Error(\"choosify: subOption '\" + subOption + \"' should be one of '\" + allowed.join(\"', '\") + \"'\");\n    }\n    var chosenEdge = topMost(pile, [\"chosen\", subOption]);\n    if (typeof chosenEdge === \"boolean\" || typeof chosenEdge === \"function\") {\n      value = chosenEdge;\n    }\n  }\n  return value;\n}\nfunction pointInRect(rect, point, rotationPoint) {\n  if (rect.width <= 0 || rect.height <= 0) {\n    return false;\n  }\n  if (rotationPoint !== void 0) {\n    var tmp = {\n      x: point.x - rotationPoint.x,\n      y: point.y - rotationPoint.y\n    };\n    if (rotationPoint.angle !== 0) {\n      var angle = -rotationPoint.angle;\n      var tmp2 = {\n        x: Math.cos(angle) * tmp.x - Math.sin(angle) * tmp.y,\n        y: Math.sin(angle) * tmp.x + Math.cos(angle) * tmp.y\n      };\n      point = tmp2;\n    } else {\n      point = tmp;\n    }\n  }\n  var right = rect.x + rect.width;\n  var bottom = rect.y + rect.width;\n  return rect.left < point.x && right > point.x && rect.top < point.y && bottom > point.y;\n}\nfunction isValidLabel(text) {\n  return typeof text === \"string\" && text !== \"\";\n}\nfunction getSelfRefCoordinates(ctx, angle, radius, node) {\n  var x = node.x;\n  var y = node.y;\n  if (typeof node.distanceToBorder === \"function\") {\n    var toBorderDist = node.distanceToBorder(ctx, angle);\n    var yFromNodeCenter = Math.sin(angle) * toBorderDist;\n    var xFromNodeCenter = Math.cos(angle) * toBorderDist;\n    if (xFromNodeCenter === toBorderDist) {\n      x += toBorderDist;\n      y = node.y;\n    } else if (yFromNodeCenter === toBorderDist) {\n      x = node.x;\n      y -= toBorderDist;\n    } else {\n      x += xFromNodeCenter;\n      y -= yFromNodeCenter;\n    }\n  } else if (node.shape.width > node.shape.height) {\n    x = node.x + node.shape.width * 0.5;\n    y = node.y - radius;\n  } else {\n    x = node.x + radius;\n    y = node.y - node.shape.height * 0.5;\n  }\n  return {\n    x,\n    y\n  };\n}\nvar entryVirtual$32 = entryVirtual$i2;\nvar values$32 = entryVirtual$32(\"Array\").values;\nvar parent$j2 = values$32;\nvar values$22 = parent$j2;\nvar classof$12 = classof$c2;\nvar hasOwn$22 = hasOwnProperty_12;\nvar isPrototypeOf$32 = objectIsPrototypeOf2;\nvar method$32 = values$22;\nvar ArrayPrototype$32 = Array.prototype;\nvar DOMIterables2 = {\n  DOMTokenList: true,\n  NodeList: true\n};\nvar values$12 = function(it2) {\n  var own = it2.values;\n  return it2 === ArrayPrototype$32 || isPrototypeOf$32(ArrayPrototype$32, it2) && own === ArrayPrototype$32.values || hasOwn$22(DOMIterables2, classof$12(it2)) ? method$32 : own;\n};\nvar values22 = values$12;\nvar LabelAccumulator = /* @__PURE__ */ function() {\n  function LabelAccumulator2(measureText) {\n    _classCallCheck2(this, LabelAccumulator2);\n    this.measureText = measureText;\n    this.current = 0;\n    this.width = 0;\n    this.height = 0;\n    this.lines = [];\n  }\n  _createClass2(LabelAccumulator2, [{\n    key: \"_add\",\n    value: function _add(l, text) {\n      var mod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"normal\";\n      if (this.lines[l] === void 0) {\n        this.lines[l] = {\n          width: 0,\n          height: 0,\n          blocks: []\n        };\n      }\n      var tmpText = text;\n      if (text === void 0 || text === \"\")\n        tmpText = \" \";\n      var result2 = this.measureText(tmpText, mod);\n      var block = assign$22({}, values22(result2));\n      block.text = text;\n      block.width = result2.width;\n      block.mod = mod;\n      if (text === void 0 || text === \"\") {\n        block.width = 0;\n      }\n      this.lines[l].blocks.push(block);\n      this.lines[l].width += block.width;\n    }\n  }, {\n    key: \"curWidth\",\n    value: function curWidth() {\n      var line = this.lines[this.current];\n      if (line === void 0)\n        return 0;\n      return line.width;\n    }\n  }, {\n    key: \"append\",\n    value: function append(text) {\n      var mod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"normal\";\n      this._add(this.current, text, mod);\n    }\n  }, {\n    key: \"newLine\",\n    value: function newLine(text) {\n      var mod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"normal\";\n      this._add(this.current, text, mod);\n      this.current++;\n    }\n  }, {\n    key: \"determineLineHeights\",\n    value: function determineLineHeights() {\n      for (var k2 = 0; k2 < this.lines.length; k2++) {\n        var line = this.lines[k2];\n        var height = 0;\n        if (line.blocks !== void 0) {\n          for (var l = 0; l < line.blocks.length; l++) {\n            var block = line.blocks[l];\n            if (height < block.height) {\n              height = block.height;\n            }\n          }\n        }\n        line.height = height;\n      }\n    }\n  }, {\n    key: \"determineLabelSize\",\n    value: function determineLabelSize() {\n      var width = 0;\n      var height = 0;\n      for (var k2 = 0; k2 < this.lines.length; k2++) {\n        var line = this.lines[k2];\n        if (line.width > width) {\n          width = line.width;\n        }\n        height += line.height;\n      }\n      this.width = width;\n      this.height = height;\n    }\n  }, {\n    key: \"removeEmptyBlocks\",\n    value: function removeEmptyBlocks() {\n      var tmpLines = [];\n      for (var k2 = 0; k2 < this.lines.length; k2++) {\n        var line = this.lines[k2];\n        if (line.blocks.length === 0)\n          continue;\n        if (k2 === this.lines.length - 1) {\n          if (line.width === 0)\n            continue;\n        }\n        var tmpLine = {};\n        assign$22(tmpLine, line);\n        tmpLine.blocks = [];\n        var firstEmptyBlock = void 0;\n        var tmpBlocks = [];\n        for (var l = 0; l < line.blocks.length; l++) {\n          var block = line.blocks[l];\n          if (block.width !== 0) {\n            tmpBlocks.push(block);\n          } else {\n            if (firstEmptyBlock === void 0) {\n              firstEmptyBlock = block;\n            }\n          }\n        }\n        if (tmpBlocks.length === 0 && firstEmptyBlock !== void 0) {\n          tmpBlocks.push(firstEmptyBlock);\n        }\n        tmpLine.blocks = tmpBlocks;\n        tmpLines.push(tmpLine);\n      }\n      return tmpLines;\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      this.determineLineHeights();\n      this.determineLabelSize();\n      var tmpLines = this.removeEmptyBlocks();\n      return {\n        width: this.width,\n        height: this.height,\n        lines: tmpLines\n      };\n    }\n  }]);\n  return LabelAccumulator2;\n}();\nvar tagPattern = {\n  \"<b>\": /<b>/,\n  \"<i>\": /<i>/,\n  \"<code>\": /<code>/,\n  \"</b>\": /<\\/b>/,\n  \"</i>\": /<\\/i>/,\n  \"</code>\": /<\\/code>/,\n  \"*\": /\\*/,\n  _: /_/,\n  \"`\": /`/,\n  afterBold: /[^*]/,\n  afterItal: /[^_]/,\n  afterMono: /[^`]/\n};\nvar MarkupAccumulator = /* @__PURE__ */ function() {\n  function MarkupAccumulator2(text) {\n    _classCallCheck2(this, MarkupAccumulator2);\n    this.text = text;\n    this.bold = false;\n    this.ital = false;\n    this.mono = false;\n    this.spacing = false;\n    this.position = 0;\n    this.buffer = \"\";\n    this.modStack = [];\n    this.blocks = [];\n  }\n  _createClass2(MarkupAccumulator2, [{\n    key: \"mod\",\n    value: function mod() {\n      return this.modStack.length === 0 ? \"normal\" : this.modStack[0];\n    }\n  }, {\n    key: \"modName\",\n    value: function modName() {\n      if (this.modStack.length === 0)\n        return \"normal\";\n      else if (this.modStack[0] === \"mono\")\n        return \"mono\";\n      else {\n        if (this.bold && this.ital) {\n          return \"boldital\";\n        } else if (this.bold) {\n          return \"bold\";\n        } else if (this.ital) {\n          return \"ital\";\n        }\n      }\n    }\n  }, {\n    key: \"emitBlock\",\n    value: function emitBlock() {\n      if (this.spacing) {\n        this.add(\" \");\n        this.spacing = false;\n      }\n      if (this.buffer.length > 0) {\n        this.blocks.push({\n          text: this.buffer,\n          mod: this.modName()\n        });\n        this.buffer = \"\";\n      }\n    }\n  }, {\n    key: \"add\",\n    value: function add(text) {\n      if (text === \" \") {\n        this.spacing = true;\n      }\n      if (this.spacing) {\n        this.buffer += \" \";\n        this.spacing = false;\n      }\n      if (text != \" \") {\n        this.buffer += text;\n      }\n    }\n  }, {\n    key: \"parseWS\",\n    value: function parseWS(ch) {\n      if (/[ \\t]/.test(ch)) {\n        if (!this.mono) {\n          this.spacing = true;\n        } else {\n          this.add(ch);\n        }\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"setTag\",\n    value: function setTag(tagName) {\n      this.emitBlock();\n      this[tagName] = true;\n      this.modStack.unshift(tagName);\n    }\n  }, {\n    key: \"unsetTag\",\n    value: function unsetTag(tagName) {\n      this.emitBlock();\n      this[tagName] = false;\n      this.modStack.shift();\n    }\n  }, {\n    key: \"parseStartTag\",\n    value: function parseStartTag(tagName, tag) {\n      if (!this.mono && !this[tagName] && this.match(tag)) {\n        this.setTag(tagName);\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"match\",\n    value: function match22(tag) {\n      var advance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n      var _this$prepareRegExp = this.prepareRegExp(tag), _this$prepareRegExp2 = _slicedToArray2(_this$prepareRegExp, 2), regExp = _this$prepareRegExp2[0], length2 = _this$prepareRegExp2[1];\n      var matched = regExp.test(this.text.substr(this.position, length2));\n      if (matched && advance) {\n        this.position += length2 - 1;\n      }\n      return matched;\n    }\n  }, {\n    key: \"parseEndTag\",\n    value: function parseEndTag(tagName, tag, nextTag) {\n      var checkTag = this.mod() === tagName;\n      if (tagName === \"mono\") {\n        checkTag = checkTag && this.mono;\n      } else {\n        checkTag = checkTag && !this.mono;\n      }\n      if (checkTag && this.match(tag)) {\n        if (nextTag !== void 0) {\n          if (this.position === this.text.length - 1 || this.match(nextTag, false)) {\n            this.unsetTag(tagName);\n          }\n        } else {\n          this.unsetTag(tagName);\n        }\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"replace\",\n    value: function replace22(tag, value) {\n      if (this.match(tag)) {\n        this.add(value);\n        this.position += length - 1;\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"prepareRegExp\",\n    value: function prepareRegExp(tag) {\n      var length2;\n      var regExp;\n      if (tag instanceof RegExp) {\n        regExp = tag;\n        length2 = 1;\n      } else {\n        var prepared = tagPattern[tag];\n        if (prepared !== void 0) {\n          regExp = prepared;\n        } else {\n          regExp = new RegExp(tag);\n        }\n        length2 = tag.length;\n      }\n      return [regExp, length2];\n    }\n  }]);\n  return MarkupAccumulator2;\n}();\nvar LabelSplitter = /* @__PURE__ */ function() {\n  function LabelSplitter2(ctx, parent22, selected, hover) {\n    var _this = this;\n    _classCallCheck2(this, LabelSplitter2);\n    this.ctx = ctx;\n    this.parent = parent22;\n    this.selected = selected;\n    this.hover = hover;\n    var textWidth = function textWidth2(text, mod) {\n      if (text === void 0)\n        return 0;\n      var values32 = _this.parent.getFormattingValues(ctx, selected, hover, mod);\n      var width = 0;\n      if (text !== \"\") {\n        var measure = _this.ctx.measureText(text);\n        width = measure.width;\n      }\n      return {\n        width,\n        values: values32\n      };\n    };\n    this.lines = new LabelAccumulator(textWidth);\n  }\n  _createClass2(LabelSplitter2, [{\n    key: \"process\",\n    value: function process22(text) {\n      if (!isValidLabel(text)) {\n        return this.lines.finalize();\n      }\n      var font = this.parent.fontOptions;\n      text = text.replace(/\\r\\n/g, \"\\n\");\n      text = text.replace(/\\r/g, \"\\n\");\n      var nlLines = String(text).split(\"\\n\");\n      var lineCount = nlLines.length;\n      if (font.multi) {\n        for (var i = 0; i < lineCount; i++) {\n          var blocks = this.splitBlocks(nlLines[i], font.multi);\n          if (blocks === void 0)\n            continue;\n          if (blocks.length === 0) {\n            this.lines.newLine(\"\");\n            continue;\n          }\n          if (font.maxWdt > 0) {\n            for (var j = 0; j < blocks.length; j++) {\n              var mod = blocks[j].mod;\n              var _text = blocks[j].text;\n              this.splitStringIntoLines(_text, mod, true);\n            }\n          } else {\n            for (var _j = 0; _j < blocks.length; _j++) {\n              var _mod = blocks[_j].mod;\n              var _text2 = blocks[_j].text;\n              this.lines.append(_text2, _mod);\n            }\n          }\n          this.lines.newLine();\n        }\n      } else {\n        if (font.maxWdt > 0) {\n          for (var _i = 0; _i < lineCount; _i++) {\n            this.splitStringIntoLines(nlLines[_i]);\n          }\n        } else {\n          for (var _i2 = 0; _i2 < lineCount; _i2++) {\n            this.lines.newLine(nlLines[_i2]);\n          }\n        }\n      }\n      return this.lines.finalize();\n    }\n  }, {\n    key: \"decodeMarkupSystem\",\n    value: function decodeMarkupSystem(markupSystem) {\n      var system = \"none\";\n      if (markupSystem === \"markdown\" || markupSystem === \"md\") {\n        system = \"markdown\";\n      } else if (markupSystem === true || markupSystem === \"html\") {\n        system = \"html\";\n      }\n      return system;\n    }\n  }, {\n    key: \"splitHtmlBlocks\",\n    value: function splitHtmlBlocks(text) {\n      var s = new MarkupAccumulator(text);\n      var parseEntities = function parseEntities2(ch2) {\n        if (/&/.test(ch2)) {\n          var parsed2 = s.replace(s.text, \"&lt;\", \"<\") || s.replace(s.text, \"&amp;\", \"&\");\n          if (!parsed2) {\n            s.add(\"&\");\n          }\n          return true;\n        }\n        return false;\n      };\n      while (s.position < s.text.length) {\n        var ch = s.text.charAt(s.position);\n        var parsed = s.parseWS(ch) || /</.test(ch) && (s.parseStartTag(\"bold\", \"<b>\") || s.parseStartTag(\"ital\", \"<i>\") || s.parseStartTag(\"mono\", \"<code>\") || s.parseEndTag(\"bold\", \"</b>\") || s.parseEndTag(\"ital\", \"</i>\") || s.parseEndTag(\"mono\", \"</code>\")) || parseEntities(ch);\n        if (!parsed) {\n          s.add(ch);\n        }\n        s.position++;\n      }\n      s.emitBlock();\n      return s.blocks;\n    }\n  }, {\n    key: \"splitMarkdownBlocks\",\n    value: function splitMarkdownBlocks(text) {\n      var _this2 = this;\n      var s = new MarkupAccumulator(text);\n      var beginable = true;\n      var parseOverride = function parseOverride2(ch2) {\n        if (/\\\\/.test(ch2)) {\n          if (s.position < _this2.text.length + 1) {\n            s.position++;\n            ch2 = _this2.text.charAt(s.position);\n            if (/ \\t/.test(ch2)) {\n              s.spacing = true;\n            } else {\n              s.add(ch2);\n              beginable = false;\n            }\n          }\n          return true;\n        }\n        return false;\n      };\n      while (s.position < s.text.length) {\n        var ch = s.text.charAt(s.position);\n        var parsed = s.parseWS(ch) || parseOverride(ch) || (beginable || s.spacing) && (s.parseStartTag(\"bold\", \"*\") || s.parseStartTag(\"ital\", \"_\") || s.parseStartTag(\"mono\", \"`\")) || s.parseEndTag(\"bold\", \"*\", \"afterBold\") || s.parseEndTag(\"ital\", \"_\", \"afterItal\") || s.parseEndTag(\"mono\", \"`\", \"afterMono\");\n        if (!parsed) {\n          s.add(ch);\n          beginable = false;\n        }\n        s.position++;\n      }\n      s.emitBlock();\n      return s.blocks;\n    }\n  }, {\n    key: \"splitBlocks\",\n    value: function splitBlocks(text, markupSystem) {\n      var system = this.decodeMarkupSystem(markupSystem);\n      if (system === \"none\") {\n        return [{\n          text,\n          mod: \"normal\"\n        }];\n      } else if (system === \"markdown\") {\n        return this.splitMarkdownBlocks(text);\n      } else if (system === \"html\") {\n        return this.splitHtmlBlocks(text);\n      }\n    }\n  }, {\n    key: \"overMaxWidth\",\n    value: function overMaxWidth(text) {\n      var width = this.ctx.measureText(text).width;\n      return this.lines.curWidth() + width > this.parent.fontOptions.maxWdt;\n    }\n  }, {\n    key: \"getLongestFit\",\n    value: function getLongestFit(words) {\n      var text = \"\";\n      var w = 0;\n      while (w < words.length) {\n        var pre = text === \"\" ? \"\" : \" \";\n        var newText = text + pre + words[w];\n        if (this.overMaxWidth(newText))\n          break;\n        text = newText;\n        w++;\n      }\n      return w;\n    }\n  }, {\n    key: \"getLongestFitWord\",\n    value: function getLongestFitWord(words) {\n      var w = 0;\n      while (w < words.length) {\n        if (this.overMaxWidth(slice22(words).call(words, 0, w)))\n          break;\n        w++;\n      }\n      return w;\n    }\n  }, {\n    key: \"splitStringIntoLines\",\n    value: function splitStringIntoLines(str) {\n      var mod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"normal\";\n      var appendLast = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n      this.parent.getFormattingValues(this.ctx, this.selected, this.hover, mod);\n      str = str.replace(/^( +)/g, \"$1\\r\");\n      str = str.replace(/([^\\r][^ ]*)( +)/g, \"$1\\r$2\\r\");\n      var words = str.split(\"\\r\");\n      while (words.length > 0) {\n        var w = this.getLongestFit(words);\n        if (w === 0) {\n          var word = words[0];\n          var x = this.getLongestFitWord(word);\n          this.lines.newLine(slice22(word).call(word, 0, x), mod);\n          words[0] = slice22(word).call(word, x);\n        } else {\n          var newW = w;\n          if (words[w - 1] === \" \") {\n            w--;\n          } else if (words[newW] === \" \") {\n            newW++;\n          }\n          var text = slice22(words).call(words, 0, w).join(\"\");\n          if (w == words.length && appendLast) {\n            this.lines.append(text, mod);\n          } else {\n            this.lines.newLine(text, mod);\n          }\n          words = slice22(words).call(words, newW);\n        }\n      }\n    }\n  }]);\n  return LabelSplitter2;\n}();\nvar multiFontStyle = [\"bold\", \"ital\", \"boldital\", \"mono\"];\nvar Label = /* @__PURE__ */ function() {\n  function Label2(body, options2) {\n    var edgelabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    _classCallCheck2(this, Label2);\n    this.body = body;\n    this.pointToSelf = false;\n    this.baseSize = void 0;\n    this.fontOptions = {};\n    this.setOptions(options2);\n    this.size = {\n      top: 0,\n      left: 0,\n      width: 0,\n      height: 0,\n      yLine: 0\n    };\n    this.isEdgeLabel = edgelabel;\n  }\n  _createClass2(Label2, [{\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      this.elementOptions = options2;\n      this.initFontOptions(options2.font);\n      if (isValidLabel(options2.label)) {\n        this.labelDirty = true;\n      } else {\n        options2.label = void 0;\n      }\n      if (options2.font !== void 0 && options2.font !== null) {\n        if (typeof options2.font === \"string\") {\n          this.baseSize = this.fontOptions.size;\n        } else if (_typeof2(options2.font) === \"object\") {\n          var size = options2.font.size;\n          if (size !== void 0) {\n            this.baseSize = size;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"initFontOptions\",\n    value: function initFontOptions(newFontOptions) {\n      var _this = this;\n      forEach$12(multiFontStyle, function(style2) {\n        _this.fontOptions[style2] = {};\n      });\n      if (Label2.parseFontString(this.fontOptions, newFontOptions)) {\n        this.fontOptions.vadjust = 0;\n        return;\n      }\n      forEach$12(newFontOptions, function(prop, n) {\n        if (prop !== void 0 && prop !== null && _typeof2(prop) !== \"object\") {\n          _this.fontOptions[n] = prop;\n        }\n      });\n    }\n  }, {\n    key: \"constrain\",\n    value: function constrain(pile) {\n      var fontOptions = {\n        constrainWidth: false,\n        maxWdt: -1,\n        minWdt: -1,\n        constrainHeight: false,\n        minHgt: -1,\n        valign: \"middle\"\n      };\n      var widthConstraint = topMost(pile, \"widthConstraint\");\n      if (typeof widthConstraint === \"number\") {\n        fontOptions.maxWdt = Number(widthConstraint);\n        fontOptions.minWdt = Number(widthConstraint);\n      } else if (_typeof2(widthConstraint) === \"object\") {\n        var widthConstraintMaximum = topMost(pile, [\"widthConstraint\", \"maximum\"]);\n        if (typeof widthConstraintMaximum === \"number\") {\n          fontOptions.maxWdt = Number(widthConstraintMaximum);\n        }\n        var widthConstraintMinimum = topMost(pile, [\"widthConstraint\", \"minimum\"]);\n        if (typeof widthConstraintMinimum === \"number\") {\n          fontOptions.minWdt = Number(widthConstraintMinimum);\n        }\n      }\n      var heightConstraint = topMost(pile, \"heightConstraint\");\n      if (typeof heightConstraint === \"number\") {\n        fontOptions.minHgt = Number(heightConstraint);\n      } else if (_typeof2(heightConstraint) === \"object\") {\n        var heightConstraintMinimum = topMost(pile, [\"heightConstraint\", \"minimum\"]);\n        if (typeof heightConstraintMinimum === \"number\") {\n          fontOptions.minHgt = Number(heightConstraintMinimum);\n        }\n        var heightConstraintValign = topMost(pile, [\"heightConstraint\", \"valign\"]);\n        if (typeof heightConstraintValign === \"string\") {\n          if (heightConstraintValign === \"top\" || heightConstraintValign === \"bottom\") {\n            fontOptions.valign = heightConstraintValign;\n          }\n        }\n      }\n      return fontOptions;\n    }\n  }, {\n    key: \"update\",\n    value: function update(options2, pile) {\n      this.setOptions(options2, true);\n      this.propagateFonts(pile);\n      deepExtend(this.fontOptions, this.constrain(pile));\n      this.fontOptions.chooser = choosify(\"label\", pile);\n    }\n  }, {\n    key: \"adjustSizes\",\n    value: function adjustSizes(margins) {\n      var widthBias = margins ? margins.right + margins.left : 0;\n      if (this.fontOptions.constrainWidth) {\n        this.fontOptions.maxWdt -= widthBias;\n        this.fontOptions.minWdt -= widthBias;\n      }\n      var heightBias = margins ? margins.top + margins.bottom : 0;\n      if (this.fontOptions.constrainHeight) {\n        this.fontOptions.minHgt -= heightBias;\n      }\n    }\n  }, {\n    key: \"addFontOptionsToPile\",\n    value: function addFontOptionsToPile(dstPile, srcPile) {\n      for (var i = 0; i < srcPile.length; ++i) {\n        this.addFontToPile(dstPile, srcPile[i]);\n      }\n    }\n  }, {\n    key: \"addFontToPile\",\n    value: function addFontToPile(pile, options2) {\n      if (options2 === void 0)\n        return;\n      if (options2.font === void 0 || options2.font === null)\n        return;\n      var item = options2.font;\n      pile.push(item);\n    }\n  }, {\n    key: \"getBasicOptions\",\n    value: function getBasicOptions(pile) {\n      var ret = {};\n      for (var n = 0; n < pile.length; ++n) {\n        var fontOptions = pile[n];\n        var tmpShorthand = {};\n        if (Label2.parseFontString(tmpShorthand, fontOptions)) {\n          fontOptions = tmpShorthand;\n        }\n        forEach$12(fontOptions, function(opt, name2) {\n          if (opt === void 0)\n            return;\n          if (Object.prototype.hasOwnProperty.call(ret, name2))\n            return;\n          if (indexOf22(multiFontStyle).call(multiFontStyle, name2) !== -1) {\n            ret[name2] = {};\n          } else {\n            ret[name2] = opt;\n          }\n        });\n      }\n      return ret;\n    }\n  }, {\n    key: \"getFontOption\",\n    value: function getFontOption(pile, multiName, option) {\n      var multiFont;\n      for (var n = 0; n < pile.length; ++n) {\n        var fontOptions = pile[n];\n        if (Object.prototype.hasOwnProperty.call(fontOptions, multiName)) {\n          multiFont = fontOptions[multiName];\n          if (multiFont === void 0 || multiFont === null)\n            continue;\n          var tmpShorthand = {};\n          if (Label2.parseFontString(tmpShorthand, multiFont)) {\n            multiFont = tmpShorthand;\n          }\n          if (Object.prototype.hasOwnProperty.call(multiFont, option)) {\n            return multiFont[option];\n          }\n        }\n      }\n      if (Object.prototype.hasOwnProperty.call(this.fontOptions, option)) {\n        return this.fontOptions[option];\n      }\n      throw new Error(\"Did not find value for multi-font for property: '\" + option + \"'\");\n    }\n  }, {\n    key: \"getFontOptions\",\n    value: function getFontOptions(pile, multiName) {\n      var result2 = {};\n      var optionNames = [\"color\", \"size\", \"face\", \"mod\", \"vadjust\"];\n      for (var i = 0; i < optionNames.length; ++i) {\n        var mod = optionNames[i];\n        result2[mod] = this.getFontOption(pile, multiName, mod);\n      }\n      return result2;\n    }\n  }, {\n    key: \"propagateFonts\",\n    value: function propagateFonts(pile) {\n      var _this2 = this;\n      var fontPile = [];\n      this.addFontOptionsToPile(fontPile, pile);\n      this.fontOptions = this.getBasicOptions(fontPile);\n      var _loop = function _loop2(i2) {\n        var mod = multiFontStyle[i2];\n        var modOptions = _this2.fontOptions[mod];\n        var tmpMultiFontOptions = _this2.getFontOptions(fontPile, mod);\n        forEach$12(tmpMultiFontOptions, function(option, n) {\n          modOptions[n] = option;\n        });\n        modOptions.size = Number(modOptions.size);\n        modOptions.vadjust = Number(modOptions.vadjust);\n      };\n      for (var i = 0; i < multiFontStyle.length; ++i) {\n        _loop(i);\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover) {\n      var baseline = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"middle\";\n      if (this.elementOptions.label === void 0)\n        return;\n      var viewFontSize = this.fontOptions.size * this.body.view.scale;\n      if (this.elementOptions.label && viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1)\n        return;\n      if (viewFontSize >= this.elementOptions.scaling.label.maxVisible) {\n        viewFontSize = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale;\n      }\n      this.calculateLabelSize(ctx, selected, hover, x, y, baseline);\n      this._drawBackground(ctx);\n      this._drawText(ctx, x, this.size.yLine, baseline, viewFontSize);\n    }\n  }, {\n    key: \"_drawBackground\",\n    value: function _drawBackground(ctx) {\n      if (this.fontOptions.background !== void 0 && this.fontOptions.background !== \"none\") {\n        ctx.fillStyle = this.fontOptions.background;\n        var size = this.getSize();\n        ctx.fillRect(size.left, size.top, size.width, size.height);\n      }\n    }\n  }, {\n    key: \"_drawText\",\n    value: function _drawText(ctx, x, y) {\n      var baseline = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"middle\";\n      var viewFontSize = arguments.length > 4 ? arguments[4] : void 0;\n      var _this$_setAlignment = this._setAlignment(ctx, x, y, baseline);\n      var _this$_setAlignment2 = _slicedToArray2(_this$_setAlignment, 2);\n      x = _this$_setAlignment2[0];\n      y = _this$_setAlignment2[1];\n      ctx.textAlign = \"left\";\n      x = x - this.size.width / 2;\n      if (this.fontOptions.valign && this.size.height > this.size.labelHeight) {\n        if (this.fontOptions.valign === \"top\") {\n          y -= (this.size.height - this.size.labelHeight) / 2;\n        }\n        if (this.fontOptions.valign === \"bottom\") {\n          y += (this.size.height - this.size.labelHeight) / 2;\n        }\n      }\n      for (var i = 0; i < this.lineCount; i++) {\n        var line = this.lines[i];\n        if (line && line.blocks) {\n          var width = 0;\n          if (this.isEdgeLabel || this.fontOptions.align === \"center\") {\n            width += (this.size.width - line.width) / 2;\n          } else if (this.fontOptions.align === \"right\") {\n            width += this.size.width - line.width;\n          }\n          for (var j = 0; j < line.blocks.length; j++) {\n            var block = line.blocks[j];\n            ctx.font = block.font;\n            var _this$_getColor = this._getColor(block.color, viewFontSize, block.strokeColor), _this$_getColor2 = _slicedToArray2(_this$_getColor, 2), fontColor = _this$_getColor2[0], strokeColor = _this$_getColor2[1];\n            if (block.strokeWidth > 0) {\n              ctx.lineWidth = block.strokeWidth;\n              ctx.strokeStyle = strokeColor;\n              ctx.lineJoin = \"round\";\n            }\n            ctx.fillStyle = fontColor;\n            if (block.strokeWidth > 0) {\n              ctx.strokeText(block.text, x + width, y + block.vadjust);\n            }\n            ctx.fillText(block.text, x + width, y + block.vadjust);\n            width += block.width;\n          }\n          y += line.height;\n        }\n      }\n    }\n  }, {\n    key: \"_setAlignment\",\n    value: function _setAlignment(ctx, x, y, baseline) {\n      if (this.isEdgeLabel && this.fontOptions.align !== \"horizontal\" && this.pointToSelf === false) {\n        x = 0;\n        y = 0;\n        var lineMargin = 2;\n        if (this.fontOptions.align === \"top\") {\n          ctx.textBaseline = \"alphabetic\";\n          y -= 2 * lineMargin;\n        } else if (this.fontOptions.align === \"bottom\") {\n          ctx.textBaseline = \"hanging\";\n          y += 2 * lineMargin;\n        } else {\n          ctx.textBaseline = \"middle\";\n        }\n      } else {\n        ctx.textBaseline = baseline;\n      }\n      return [x, y];\n    }\n  }, {\n    key: \"_getColor\",\n    value: function _getColor(color, viewFontSize, initialStrokeColor) {\n      var fontColor = color || \"#000000\";\n      var strokeColor = initialStrokeColor || \"#ffffff\";\n      if (viewFontSize <= this.elementOptions.scaling.label.drawThreshold) {\n        var opacity = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - viewFontSize)));\n        fontColor = overrideOpacity(fontColor, opacity);\n        strokeColor = overrideOpacity(strokeColor, opacity);\n      }\n      return [fontColor, strokeColor];\n    }\n  }, {\n    key: \"getTextSize\",\n    value: function getTextSize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n      var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n      this._processLabel(ctx, selected, hover);\n      return {\n        width: this.size.width,\n        height: this.size.height,\n        lineCount: this.lineCount\n      };\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      var lineMargin = 2;\n      var x = this.size.left;\n      var y = this.size.top - 0.5 * lineMargin;\n      if (this.isEdgeLabel) {\n        var x2 = -this.size.width * 0.5;\n        switch (this.fontOptions.align) {\n          case \"middle\":\n            x = x2;\n            y = -this.size.height * 0.5;\n            break;\n          case \"top\":\n            x = x2;\n            y = -(this.size.height + lineMargin);\n            break;\n          case \"bottom\":\n            x = x2;\n            y = lineMargin;\n            break;\n        }\n      }\n      var ret = {\n        left: x,\n        top: y,\n        width: this.size.width,\n        height: this.size.height\n      };\n      return ret;\n    }\n  }, {\n    key: \"calculateLabelSize\",\n    value: function calculateLabelSize(ctx, selected, hover) {\n      var x = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;\n      var y = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;\n      var baseline = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"middle\";\n      this._processLabel(ctx, selected, hover);\n      this.size.left = x - this.size.width * 0.5;\n      this.size.top = y - this.size.height * 0.5;\n      this.size.yLine = y + (1 - this.lineCount) * 0.5 * this.fontOptions.size;\n      if (baseline === \"hanging\") {\n        this.size.top += 0.5 * this.fontOptions.size;\n        this.size.top += 4;\n        this.size.yLine += 4;\n      }\n    }\n  }, {\n    key: \"getFormattingValues\",\n    value: function getFormattingValues(ctx, selected, hover, mod) {\n      var getValue = function getValue2(fontOptions, mod2, option) {\n        if (mod2 === \"normal\") {\n          if (option === \"mod\")\n            return \"\";\n          return fontOptions[option];\n        }\n        if (fontOptions[mod2][option] !== void 0) {\n          return fontOptions[mod2][option];\n        } else {\n          return fontOptions[option];\n        }\n      };\n      var values32 = {\n        color: getValue(this.fontOptions, mod, \"color\"),\n        size: getValue(this.fontOptions, mod, \"size\"),\n        face: getValue(this.fontOptions, mod, \"face\"),\n        mod: getValue(this.fontOptions, mod, \"mod\"),\n        vadjust: getValue(this.fontOptions, mod, \"vadjust\"),\n        strokeWidth: this.fontOptions.strokeWidth,\n        strokeColor: this.fontOptions.strokeColor\n      };\n      if (selected || hover) {\n        if (mod === \"normal\" && this.fontOptions.chooser === true && this.elementOptions.labelHighlightBold) {\n          values32.mod = \"bold\";\n        } else {\n          if (typeof this.fontOptions.chooser === \"function\") {\n            this.fontOptions.chooser(values32, this.elementOptions.id, selected, hover);\n          }\n        }\n      }\n      var fontString = \"\";\n      if (values32.mod !== void 0 && values32.mod !== \"\") {\n        fontString += values32.mod + \" \";\n      }\n      fontString += values32.size + \"px \" + values32.face;\n      ctx.font = fontString.replace(/\"/g, \"\");\n      values32.font = ctx.font;\n      values32.height = values32.size;\n      return values32;\n    }\n  }, {\n    key: \"differentState\",\n    value: function differentState(selected, hover) {\n      return selected !== this.selectedState || hover !== this.hoverState;\n    }\n  }, {\n    key: \"_processLabelText\",\n    value: function _processLabelText(ctx, selected, hover, inText) {\n      var splitter = new LabelSplitter(ctx, this, selected, hover);\n      return splitter.process(inText);\n    }\n  }, {\n    key: \"_processLabel\",\n    value: function _processLabel(ctx, selected, hover) {\n      if (this.labelDirty === false && !this.differentState(selected, hover))\n        return;\n      var state = this._processLabelText(ctx, selected, hover, this.elementOptions.label);\n      if (this.fontOptions.minWdt > 0 && state.width < this.fontOptions.minWdt) {\n        state.width = this.fontOptions.minWdt;\n      }\n      this.size.labelHeight = state.height;\n      if (this.fontOptions.minHgt > 0 && state.height < this.fontOptions.minHgt) {\n        state.height = this.fontOptions.minHgt;\n      }\n      this.lines = state.lines;\n      this.lineCount = state.lines.length;\n      this.size.width = state.width;\n      this.size.height = state.height;\n      this.selectedState = selected;\n      this.hoverState = hover;\n      this.labelDirty = false;\n    }\n  }, {\n    key: \"visible\",\n    value: function visible() {\n      if (this.size.width === 0 || this.size.height === 0 || this.elementOptions.label === void 0) {\n        return false;\n      }\n      var viewFontSize = this.fontOptions.size * this.body.view.scale;\n      if (viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) {\n        return false;\n      }\n      return true;\n    }\n  }], [{\n    key: \"parseFontString\",\n    value: function parseFontString(outOptions, inOptions) {\n      if (!inOptions || typeof inOptions !== \"string\")\n        return false;\n      var newOptionsArray = inOptions.split(\" \");\n      outOptions.size = +newOptionsArray[0].replace(\"px\", \"\");\n      outOptions.face = newOptionsArray[1];\n      outOptions.color = newOptionsArray[2];\n      return true;\n    }\n  }]);\n  return Label2;\n}();\nvar global$42 = global$O;\nvar isConstructor32 = isConstructor$42;\nvar tryToString2 = tryToString$42;\nvar TypeError$22 = global$42.TypeError;\nvar aConstructor$12 = function(argument) {\n  if (isConstructor32(argument))\n    return argument;\n  throw TypeError$22(tryToString2(argument) + \" is not a constructor\");\n};\nvar $$62 = _export2;\nvar getBuiltIn2 = getBuiltIn$92;\nvar apply2 = functionApply2;\nvar bind22 = functionBind2;\nvar aConstructor2 = aConstructor$12;\nvar anObject$22 = anObject$d;\nvar isObject$32 = isObject$j;\nvar create$32 = objectCreate2;\nvar fails$12 = fails$t;\nvar nativeConstruct2 = getBuiltIn2(\"Reflect\", \"construct\");\nvar ObjectPrototype2 = Object.prototype;\nvar push$12 = [].push;\nvar NEW_TARGET_BUG2 = fails$12(function() {\n  function F2() {\n  }\n  return !(nativeConstruct2(function() {\n  }, [], F2) instanceof F2);\n});\nvar ARGS_BUG2 = !fails$12(function() {\n  nativeConstruct2(function() {\n  });\n});\nvar FORCED$12 = NEW_TARGET_BUG2 || ARGS_BUG2;\n$$62({\n  target: \"Reflect\",\n  stat: true,\n  forced: FORCED$12,\n  sham: FORCED$12\n}, {\n  construct: function construct3(Target, args) {\n    aConstructor2(Target);\n    anObject$22(args);\n    var newTarget = arguments.length < 3 ? Target : aConstructor2(arguments[2]);\n    if (ARGS_BUG2 && !NEW_TARGET_BUG2)\n      return nativeConstruct2(Target, args, newTarget);\n    if (Target == newTarget) {\n      switch (args.length) {\n        case 0:\n          return new Target();\n        case 1:\n          return new Target(args[0]);\n        case 2:\n          return new Target(args[0], args[1]);\n        case 3:\n          return new Target(args[0], args[1], args[2]);\n        case 4:\n          return new Target(args[0], args[1], args[2], args[3]);\n      }\n      var $args = [null];\n      apply2(push$12, $args, args);\n      return new (apply2(bind22, Target, $args))();\n    }\n    var proto = newTarget.prototype;\n    var instance = create$32(isObject$32(proto) ? proto : ObjectPrototype2);\n    var result2 = apply2(Target, instance, args);\n    return isObject$32(result2) ? result2 : instance;\n  }\n});\nvar path$62 = path$y;\nvar construct$22 = path$62.Reflect.construct;\nvar parent$i2 = construct$22;\nvar construct$12 = parent$i2;\nvar construct22 = construct$12;\nvar parent$h2 = create$62;\nvar create$22 = parent$h2;\nvar parent$g2 = create$22;\nvar create$12 = parent$g2;\nvar create42 = create$12;\nvar $$52 = _export2;\nvar setPrototypeOf$52 = objectSetPrototypeOf2;\n$$52({\n  target: \"Object\",\n  stat: true\n}, {\n  setPrototypeOf: setPrototypeOf$52\n});\nvar path$52 = path$y;\nvar setPrototypeOf$42 = path$52.Object.setPrototypeOf;\nvar parent$f2 = setPrototypeOf$42;\nvar setPrototypeOf$32 = parent$f2;\nvar parent$e2 = setPrototypeOf$32;\nvar setPrototypeOf$22 = parent$e2;\nvar parent$d2 = setPrototypeOf$22;\nvar setPrototypeOf$12 = parent$d2;\nvar setPrototypeOf2 = setPrototypeOf$12;\nfunction _setPrototypeOf2(o, p) {\n  _setPrototypeOf2 = setPrototypeOf2 || function _setPrototypeOf22(o2, p2) {\n    o2.__proto__ = p2;\n    return o2;\n  };\n  return _setPrototypeOf2(o, p);\n}\nfunction _inherits2(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = create42(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  defineProperty$32(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass)\n    _setPrototypeOf2(subClass, superClass);\n}\nfunction _assertThisInitialized2(self2) {\n  if (self2 === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self2;\n}\nfunction _possibleConstructorReturn2(self2, call22) {\n  if (call22 && (_typeof2(call22) === \"object\" || typeof call22 === \"function\")) {\n    return call22;\n  } else if (call22 !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized2(self2);\n}\nvar parent$c2 = getPrototypeOf$52;\nvar getPrototypeOf$32 = parent$c2;\nvar parent$b2 = getPrototypeOf$32;\nvar getPrototypeOf$22 = parent$b2;\nvar getPrototypeOf$12 = getPrototypeOf$22;\nfunction _getPrototypeOf2(o) {\n  _getPrototypeOf2 = setPrototypeOf2 ? getPrototypeOf$12 : function _getPrototypeOf22(o2) {\n    return o2.__proto__ || getPrototypeOf$12(o2);\n  };\n  return _getPrototypeOf2(o);\n}\nvar NodeBase = /* @__PURE__ */ function() {\n  function NodeBase2(options2, body, labelModule) {\n    _classCallCheck2(this, NodeBase2);\n    this.body = body;\n    this.labelModule = labelModule;\n    this.setOptions(options2);\n    this.top = void 0;\n    this.left = void 0;\n    this.height = void 0;\n    this.width = void 0;\n    this.radius = void 0;\n    this.margin = void 0;\n    this.refreshNeeded = true;\n    this.boundingBox = {\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0\n    };\n  }\n  _createClass2(NodeBase2, [{\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      this.options = options2;\n    }\n  }, {\n    key: \"_setMargins\",\n    value: function _setMargins(labelModule) {\n      this.margin = {};\n      if (this.options.margin) {\n        if (_typeof2(this.options.margin) == \"object\") {\n          this.margin.top = this.options.margin.top;\n          this.margin.right = this.options.margin.right;\n          this.margin.bottom = this.options.margin.bottom;\n          this.margin.left = this.options.margin.left;\n        } else {\n          this.margin.top = this.options.margin;\n          this.margin.right = this.options.margin;\n          this.margin.bottom = this.options.margin;\n          this.margin.left = this.options.margin;\n        }\n      }\n      labelModule.adjustSizes(this.margin);\n    }\n  }, {\n    key: \"_distanceToBorder\",\n    value: function _distanceToBorder(ctx, angle) {\n      var borderWidth = this.options.borderWidth;\n      if (ctx) {\n        this.resize(ctx);\n      }\n      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;\n    }\n  }, {\n    key: \"enableShadow\",\n    value: function enableShadow(ctx, values32) {\n      if (values32.shadow) {\n        ctx.shadowColor = values32.shadowColor;\n        ctx.shadowBlur = values32.shadowSize;\n        ctx.shadowOffsetX = values32.shadowX;\n        ctx.shadowOffsetY = values32.shadowY;\n      }\n    }\n  }, {\n    key: \"disableShadow\",\n    value: function disableShadow(ctx, values32) {\n      if (values32.shadow) {\n        ctx.shadowColor = \"rgba(0,0,0,0)\";\n        ctx.shadowBlur = 0;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n      }\n    }\n  }, {\n    key: \"enableBorderDashes\",\n    value: function enableBorderDashes(ctx, values32) {\n      if (values32.borderDashes !== false) {\n        if (ctx.setLineDash !== void 0) {\n          var dashes = values32.borderDashes;\n          if (dashes === true) {\n            dashes = [5, 15];\n          }\n          ctx.setLineDash(dashes);\n        } else {\n          console.warn(\"setLineDash is not supported in this browser. The dashed borders cannot be used.\");\n          this.options.shapeProperties.borderDashes = false;\n          values32.borderDashes = false;\n        }\n      }\n    }\n  }, {\n    key: \"disableBorderDashes\",\n    value: function disableBorderDashes(ctx, values32) {\n      if (values32.borderDashes !== false) {\n        if (ctx.setLineDash !== void 0) {\n          ctx.setLineDash([0]);\n        } else {\n          console.warn(\"setLineDash is not supported in this browser. The dashed borders cannot be used.\");\n          this.options.shapeProperties.borderDashes = false;\n          values32.borderDashes = false;\n        }\n      }\n    }\n  }, {\n    key: \"needsRefresh\",\n    value: function needsRefresh(selected, hover) {\n      if (this.refreshNeeded === true) {\n        this.refreshNeeded = false;\n        return true;\n      }\n      return this.width === void 0 || this.labelModule.differentState(selected, hover);\n    }\n  }, {\n    key: \"initContextForDraw\",\n    value: function initContextForDraw(ctx, values32) {\n      var borderWidth = values32.borderWidth / this.body.view.scale;\n      ctx.lineWidth = Math.min(this.width, borderWidth);\n      ctx.strokeStyle = values32.borderColor;\n      ctx.fillStyle = values32.color;\n    }\n  }, {\n    key: \"performStroke\",\n    value: function performStroke(ctx, values32) {\n      var borderWidth = values32.borderWidth / this.body.view.scale;\n      ctx.save();\n      if (borderWidth > 0) {\n        this.enableBorderDashes(ctx, values32);\n        ctx.stroke();\n        this.disableBorderDashes(ctx, values32);\n      }\n      ctx.restore();\n    }\n  }, {\n    key: \"performFill\",\n    value: function performFill(ctx, values32) {\n      ctx.save();\n      ctx.fillStyle = values32.color;\n      this.enableShadow(ctx, values32);\n      fill22(ctx).call(ctx);\n      this.disableShadow(ctx, values32);\n      ctx.restore();\n      this.performStroke(ctx, values32);\n    }\n  }, {\n    key: \"_addBoundingBoxMargin\",\n    value: function _addBoundingBoxMargin(margin) {\n      this.boundingBox.left -= margin;\n      this.boundingBox.top -= margin;\n      this.boundingBox.bottom += margin;\n      this.boundingBox.right += margin;\n    }\n  }, {\n    key: \"_updateBoundingBox\",\n    value: function _updateBoundingBox(x, y, ctx, selected, hover) {\n      if (ctx !== void 0) {\n        this.resize(ctx, selected, hover);\n      }\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this.boundingBox.left = this.left;\n      this.boundingBox.top = this.top;\n      this.boundingBox.bottom = this.top + this.height;\n      this.boundingBox.right = this.left + this.width;\n    }\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y, ctx, selected, hover) {\n      this._updateBoundingBox(x, y, ctx, selected, hover);\n    }\n  }, {\n    key: \"getDimensionsFromLabel\",\n    value: function getDimensionsFromLabel(ctx, selected, hover) {\n      this.textSize = this.labelModule.getTextSize(ctx, selected, hover);\n      var width = this.textSize.width;\n      var height = this.textSize.height;\n      var DEFAULT_SIZE = 14;\n      if (width === 0) {\n        width = DEFAULT_SIZE;\n        height = DEFAULT_SIZE;\n      }\n      return {\n        width,\n        height\n      };\n    }\n  }]);\n  return NodeBase2;\n}();\nfunction _createSuper$s(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$s();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$s() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Box$1 = /* @__PURE__ */ function(_NodeBase) {\n  _inherits2(Box2, _NodeBase);\n  var _super = _createSuper$s(Box2);\n  function Box2(options2, body, labelModule) {\n    var _this;\n    _classCallCheck2(this, Box2);\n    _this = _super.call(this, options2, body, labelModule);\n    _this._setMargins(labelModule);\n    return _this;\n  }\n  _createClass2(Box2, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n        this.width = dimensions.width + this.margin.right + this.margin.left;\n        this.height = dimensions.height + this.margin.top + this.margin.bottom;\n        this.radius = this.width / 2;\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values32) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this.initContextForDraw(ctx, values32);\n      drawRoundRect(ctx, this.left, this.top, this.width, this.height, values32.borderRadius);\n      this.performFill(ctx, values32);\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);\n    }\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y, ctx, selected, hover) {\n      this._updateBoundingBox(x, y, ctx, selected, hover);\n      var borderRadius = this.options.shapeProperties.borderRadius;\n      this._addBoundingBoxMargin(borderRadius);\n    }\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n      var borderWidth = this.options.borderWidth;\n      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;\n    }\n  }]);\n  return Box2;\n}(NodeBase);\nfunction _createSuper$r(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$r();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$r() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar CircleImageBase = /* @__PURE__ */ function(_NodeBase) {\n  _inherits2(CircleImageBase2, _NodeBase);\n  var _super = _createSuper$r(CircleImageBase2);\n  function CircleImageBase2(options2, body, labelModule) {\n    var _this;\n    _classCallCheck2(this, CircleImageBase2);\n    _this = _super.call(this, options2, body, labelModule);\n    _this.labelOffset = 0;\n    _this.selected = false;\n    return _this;\n  }\n  _createClass2(CircleImageBase2, [{\n    key: \"setOptions\",\n    value: function setOptions(options2, imageObj, imageObjAlt) {\n      this.options = options2;\n      if (!(imageObj === void 0 && imageObjAlt === void 0)) {\n        this.setImages(imageObj, imageObjAlt);\n      }\n    }\n  }, {\n    key: \"setImages\",\n    value: function setImages(imageObj, imageObjAlt) {\n      if (imageObjAlt && this.selected) {\n        this.imageObj = imageObjAlt;\n        this.imageObjAlt = imageObj;\n      } else {\n        this.imageObj = imageObj;\n        this.imageObjAlt = imageObjAlt;\n      }\n    }\n  }, {\n    key: \"switchImages\",\n    value: function switchImages(selected) {\n      var selection_changed = selected && !this.selected || !selected && this.selected;\n      this.selected = selected;\n      if (this.imageObjAlt !== void 0 && selection_changed) {\n        var imageTmp = this.imageObj;\n        this.imageObj = this.imageObjAlt;\n        this.imageObjAlt = imageTmp;\n      }\n    }\n  }, {\n    key: \"_getImagePadding\",\n    value: function _getImagePadding() {\n      var imgPadding = {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      };\n      if (this.options.imagePadding) {\n        var optImgPadding = this.options.imagePadding;\n        if (_typeof2(optImgPadding) == \"object\") {\n          imgPadding.top = optImgPadding.top;\n          imgPadding.right = optImgPadding.right;\n          imgPadding.bottom = optImgPadding.bottom;\n          imgPadding.left = optImgPadding.left;\n        } else {\n          imgPadding.top = optImgPadding;\n          imgPadding.right = optImgPadding;\n          imgPadding.bottom = optImgPadding;\n          imgPadding.left = optImgPadding;\n        }\n      }\n      return imgPadding;\n    }\n  }, {\n    key: \"_resizeImage\",\n    value: function _resizeImage() {\n      var width, height;\n      if (this.options.shapeProperties.useImageSize === false) {\n        var ratio_width = 1;\n        var ratio_height = 1;\n        if (this.imageObj.width && this.imageObj.height) {\n          if (this.imageObj.width > this.imageObj.height) {\n            ratio_width = this.imageObj.width / this.imageObj.height;\n          } else {\n            ratio_height = this.imageObj.height / this.imageObj.width;\n          }\n        }\n        width = this.options.size * 2 * ratio_width;\n        height = this.options.size * 2 * ratio_height;\n      } else {\n        var imgPadding = this._getImagePadding();\n        width = this.imageObj.width + imgPadding.left + imgPadding.right;\n        height = this.imageObj.height + imgPadding.top + imgPadding.bottom;\n      }\n      this.width = width;\n      this.height = height;\n      this.radius = 0.5 * this.width;\n    }\n  }, {\n    key: \"_drawRawCircle\",\n    value: function _drawRawCircle(ctx, x, y, values32) {\n      this.initContextForDraw(ctx, values32);\n      drawCircle(ctx, x, y, values32.size);\n      this.performFill(ctx, values32);\n    }\n  }, {\n    key: \"_drawImageAtPosition\",\n    value: function _drawImageAtPosition(ctx, values32) {\n      if (this.imageObj.width != 0) {\n        ctx.globalAlpha = values32.opacity !== void 0 ? values32.opacity : 1;\n        this.enableShadow(ctx, values32);\n        var factor = 1;\n        if (this.options.shapeProperties.interpolation === true) {\n          factor = this.imageObj.width / this.width / this.body.view.scale;\n        }\n        var imgPadding = this._getImagePadding();\n        var imgPosLeft = this.left + imgPadding.left;\n        var imgPosTop = this.top + imgPadding.top;\n        var imgWidth = this.width - imgPadding.left - imgPadding.right;\n        var imgHeight = this.height - imgPadding.top - imgPadding.bottom;\n        this.imageObj.drawImageAtPosition(ctx, factor, imgPosLeft, imgPosTop, imgWidth, imgHeight);\n        this.disableShadow(ctx, values32);\n      }\n    }\n  }, {\n    key: \"_drawImageLabel\",\n    value: function _drawImageLabel(ctx, x, y, selected, hover) {\n      var offset = 0;\n      if (this.height !== void 0) {\n        offset = this.height * 0.5;\n        var labelDimensions = this.labelModule.getTextSize(ctx, selected, hover);\n        if (labelDimensions.lineCount >= 1) {\n          offset += labelDimensions.height / 2;\n        }\n      }\n      var yLabel = y + offset;\n      if (this.options.label) {\n        this.labelOffset = offset;\n      }\n      this.labelModule.draw(ctx, x, yLabel, selected, hover, \"hanging\");\n    }\n  }]);\n  return CircleImageBase2;\n}(NodeBase);\nfunction _createSuper$q(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$q();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$q() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Circle$1 = /* @__PURE__ */ function(_CircleImageBase) {\n  _inherits2(Circle2, _CircleImageBase);\n  var _super = _createSuper$q(Circle2);\n  function Circle2(options2, body, labelModule) {\n    var _this;\n    _classCallCheck2(this, Circle2);\n    _this = _super.call(this, options2, body, labelModule);\n    _this._setMargins(labelModule);\n    return _this;\n  }\n  _createClass2(Circle2, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n        var diameter = Math.max(dimensions.width + this.margin.right + this.margin.left, dimensions.height + this.margin.top + this.margin.bottom);\n        this.options.size = diameter / 2;\n        this.width = diameter;\n        this.height = diameter;\n        this.radius = this.width / 2;\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values32) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this._drawRawCircle(ctx, x, y, values32);\n      this.updateBoundingBox(x, y);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, y, selected, hover);\n    }\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      this.boundingBox.top = y - this.options.size;\n      this.boundingBox.left = x - this.options.size;\n      this.boundingBox.right = x + this.options.size;\n      this.boundingBox.bottom = y + this.options.size;\n    }\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n      return this.width * 0.5;\n    }\n  }]);\n  return Circle2;\n}(CircleImageBase);\nfunction _createSuper$p(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$p();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$p() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar CircularImage = /* @__PURE__ */ function(_CircleImageBase) {\n  _inherits2(CircularImage2, _CircleImageBase);\n  var _super = _createSuper$p(CircularImage2);\n  function CircularImage2(options2, body, labelModule, imageObj, imageObjAlt) {\n    var _this;\n    _classCallCheck2(this, CircularImage2);\n    _this = _super.call(this, options2, body, labelModule);\n    _this.setImages(imageObj, imageObjAlt);\n    return _this;\n  }\n  _createClass2(CircularImage2, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;\n      var imageAbsent = this.imageObj.src === void 0 || this.imageObj.width === void 0 || this.imageObj.height === void 0;\n      if (imageAbsent) {\n        var diameter = this.options.size * 2;\n        this.width = diameter;\n        this.height = diameter;\n        this.radius = 0.5 * this.width;\n        return;\n      }\n      if (this.needsRefresh(selected, hover)) {\n        this._resizeImage();\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values32) {\n      this.switchImages(selected);\n      this.resize();\n      var labelX = x, labelY = y;\n      if (this.options.shapeProperties.coordinateOrigin === \"top-left\") {\n        this.left = x;\n        this.top = y;\n        labelX += this.width / 2;\n        labelY += this.height / 2;\n      } else {\n        this.left = x - this.width / 2;\n        this.top = y - this.height / 2;\n      }\n      this._drawRawCircle(ctx, labelX, labelY, values32);\n      ctx.save();\n      ctx.clip();\n      this._drawImageAtPosition(ctx, values32);\n      ctx.restore();\n      this._drawImageLabel(ctx, labelX, labelY, selected, hover);\n      this.updateBoundingBox(x, y);\n    }\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      if (this.options.shapeProperties.coordinateOrigin === \"top-left\") {\n        this.boundingBox.top = y;\n        this.boundingBox.left = x;\n        this.boundingBox.right = x + this.options.size * 2;\n        this.boundingBox.bottom = y + this.options.size * 2;\n      } else {\n        this.boundingBox.top = y - this.options.size;\n        this.boundingBox.left = x - this.options.size;\n        this.boundingBox.right = x + this.options.size;\n        this.boundingBox.bottom = y + this.options.size;\n      }\n      this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n      this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n      this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);\n    }\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n      return this.width * 0.5;\n    }\n  }]);\n  return CircularImage2;\n}(CircleImageBase);\nfunction _createSuper$o(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$o();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$o() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar ShapeBase = /* @__PURE__ */ function(_NodeBase) {\n  _inherits2(ShapeBase2, _NodeBase);\n  var _super = _createSuper$o(ShapeBase2);\n  function ShapeBase2(options2, body, labelModule) {\n    _classCallCheck2(this, ShapeBase2);\n    return _super.call(this, options2, body, labelModule);\n  }\n  _createClass2(ShapeBase2, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;\n      var values32 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {\n        size: this.options.size\n      };\n      if (this.needsRefresh(selected, hover)) {\n        var _this$customSizeWidth, _this$customSizeHeigh;\n        this.labelModule.getTextSize(ctx, selected, hover);\n        var size = 2 * values32.size;\n        this.width = (_this$customSizeWidth = this.customSizeWidth) !== null && _this$customSizeWidth !== void 0 ? _this$customSizeWidth : size;\n        this.height = (_this$customSizeHeigh = this.customSizeHeight) !== null && _this$customSizeHeigh !== void 0 ? _this$customSizeHeigh : size;\n        this.radius = 0.5 * this.width;\n      }\n    }\n  }, {\n    key: \"_drawShape\",\n    value: function _drawShape(ctx, shape, sizeMultiplier, x, y, selected, hover, values32) {\n      var _this = this;\n      this.resize(ctx, selected, hover, values32);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this.initContextForDraw(ctx, values32);\n      getShape(shape)(ctx, x, y, values32.size);\n      this.performFill(ctx, values32);\n      if (this.options.icon !== void 0) {\n        if (this.options.icon.code !== void 0) {\n          ctx.font = (selected ? \"bold \" : \"\") + this.height / 2 + \"px \" + (this.options.icon.face || \"FontAwesome\");\n          ctx.fillStyle = this.options.icon.color || \"black\";\n          ctx.textAlign = \"center\";\n          ctx.textBaseline = \"middle\";\n          ctx.fillText(this.options.icon.code, x, y);\n        }\n      }\n      return {\n        drawExternalLabel: function drawExternalLabel() {\n          if (_this.options.label !== void 0) {\n            _this.labelModule.calculateLabelSize(ctx, selected, hover, x, y, \"hanging\");\n            var yLabel = y + 0.5 * _this.height + 0.5 * _this.labelModule.size.height;\n            _this.labelModule.draw(ctx, x, yLabel, selected, hover, \"hanging\");\n          }\n          _this.updateBoundingBox(x, y);\n        }\n      };\n    }\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      this.boundingBox.top = y - this.options.size;\n      this.boundingBox.left = x - this.options.size;\n      this.boundingBox.right = x + this.options.size;\n      this.boundingBox.bottom = y + this.options.size;\n      if (this.options.label !== void 0 && this.labelModule.size.width > 0) {\n        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height);\n      }\n    }\n  }]);\n  return ShapeBase2;\n}(NodeBase);\nfunction ownKeys$32(object2, enumerableOnly) {\n  var keys$122 = keys32(object2);\n  if (getOwnPropertySymbols32) {\n    var symbols = getOwnPropertySymbols32(object2);\n    enumerableOnly && (symbols = filter22(symbols).call(symbols, function(sym) {\n      return getOwnPropertyDescriptor$32(object2, sym).enumerable;\n    })), keys$122.push.apply(keys$122, symbols);\n  }\n  return keys$122;\n}\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var _context, _context2;\n    var source = arguments[i] != null ? arguments[i] : {};\n    i % 2 ? forEach$22(_context = ownKeys$32(Object(source), true)).call(_context, function(key) {\n      _defineProperty2(target, key, source[key]);\n    }) : getOwnPropertyDescriptors22 ? defineProperties42(target, getOwnPropertyDescriptors22(source)) : forEach$22(_context2 = ownKeys$32(Object(source))).call(_context2, function(key) {\n      defineProperty$62(target, key, getOwnPropertyDescriptor$32(source, key));\n    });\n  }\n  return target;\n}\nfunction _createSuper$n(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$n();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$n() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar CustomShape = /* @__PURE__ */ function(_ShapeBase) {\n  _inherits2(CustomShape2, _ShapeBase);\n  var _super = _createSuper$n(CustomShape2);\n  function CustomShape2(options2, body, labelModule, ctxRenderer) {\n    var _this;\n    _classCallCheck2(this, CustomShape2);\n    _this = _super.call(this, options2, body, labelModule, ctxRenderer);\n    _this.ctxRenderer = ctxRenderer;\n    return _this;\n  }\n  _createClass2(CustomShape2, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values32) {\n      this.resize(ctx, selected, hover, values32);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      ctx.save();\n      var drawLater = this.ctxRenderer({\n        ctx,\n        id: this.options.id,\n        x,\n        y,\n        state: {\n          selected,\n          hover\n        },\n        style: _objectSpread$3({}, values32),\n        label: this.options.label\n      });\n      if (drawLater.drawNode != null) {\n        drawLater.drawNode();\n      }\n      ctx.restore();\n      if (drawLater.drawExternalLabel) {\n        var drawExternalLabel = drawLater.drawExternalLabel;\n        drawLater.drawExternalLabel = function() {\n          ctx.save();\n          drawExternalLabel();\n          ctx.restore();\n        };\n      }\n      if (drawLater.nodeDimensions) {\n        this.customSizeWidth = drawLater.nodeDimensions.width;\n        this.customSizeHeight = drawLater.nodeDimensions.height;\n      }\n      return drawLater;\n    }\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return CustomShape2;\n}(ShapeBase);\nfunction _createSuper$m(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$m();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$m() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Database = /* @__PURE__ */ function(_NodeBase) {\n  _inherits2(Database2, _NodeBase);\n  var _super = _createSuper$m(Database2);\n  function Database2(options2, body, labelModule) {\n    var _this;\n    _classCallCheck2(this, Database2);\n    _this = _super.call(this, options2, body, labelModule);\n    _this._setMargins(labelModule);\n    return _this;\n  }\n  _createClass2(Database2, [{\n    key: \"resize\",\n    value: function resize(ctx, selected, hover) {\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n        var size = dimensions.width + this.margin.right + this.margin.left;\n        this.width = size;\n        this.height = size;\n        this.radius = this.width / 2;\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values32) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this.initContextForDraw(ctx, values32);\n      drawDatabase(ctx, x - this.width / 2, y - this.height / 2, this.width, this.height);\n      this.performFill(ctx, values32);\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);\n    }\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Database2;\n}(NodeBase);\nfunction _createSuper$l(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$l();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$l() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Diamond$1 = /* @__PURE__ */ function(_ShapeBase) {\n  _inherits2(Diamond2, _ShapeBase);\n  var _super = _createSuper$l(Diamond2);\n  function Diamond2(options2, body, labelModule) {\n    _classCallCheck2(this, Diamond2);\n    return _super.call(this, options2, body, labelModule);\n  }\n  _createClass2(Diamond2, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values32) {\n      return this._drawShape(ctx, \"diamond\", 4, x, y, selected, hover, values32);\n    }\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Diamond2;\n}(ShapeBase);\nfunction _createSuper$k(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$k();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$k() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Dot = /* @__PURE__ */ function(_ShapeBase) {\n  _inherits2(Dot2, _ShapeBase);\n  var _super = _createSuper$k(Dot2);\n  function Dot2(options2, body, labelModule) {\n    _classCallCheck2(this, Dot2);\n    return _super.call(this, options2, body, labelModule);\n  }\n  _createClass2(Dot2, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values32) {\n      return this._drawShape(ctx, \"circle\", 2, x, y, selected, hover, values32);\n    }\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n      return this.options.size;\n    }\n  }]);\n  return Dot2;\n}(ShapeBase);\nfunction _createSuper$j(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$j();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$j() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Ellipse = /* @__PURE__ */ function(_NodeBase) {\n  _inherits2(Ellipse2, _NodeBase);\n  var _super = _createSuper$j(Ellipse2);\n  function Ellipse2(options2, body, labelModule) {\n    _classCallCheck2(this, Ellipse2);\n    return _super.call(this, options2, body, labelModule);\n  }\n  _createClass2(Ellipse2, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n        this.height = dimensions.height * 2;\n        this.width = dimensions.width + dimensions.height;\n        this.radius = 0.5 * this.width;\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values32) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width * 0.5;\n      this.top = y - this.height * 0.5;\n      this.initContextForDraw(ctx, values32);\n      drawEllipse(ctx, this.left, this.top, this.width, this.height);\n      this.performFill(ctx, values32);\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n      this.labelModule.draw(ctx, x, y, selected, hover);\n    }\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n      var a = this.width * 0.5;\n      var b = this.height * 0.5;\n      var w = Math.sin(angle) * a;\n      var h = Math.cos(angle) * b;\n      return a * b / Math.sqrt(w * w + h * h);\n    }\n  }]);\n  return Ellipse2;\n}(NodeBase);\nfunction _createSuper$i(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$i();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$i() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Icon = /* @__PURE__ */ function(_NodeBase) {\n  _inherits2(Icon2, _NodeBase);\n  var _super = _createSuper$i(Icon2);\n  function Icon2(options2, body, labelModule) {\n    var _this;\n    _classCallCheck2(this, Icon2);\n    _this = _super.call(this, options2, body, labelModule);\n    _this._setMargins(labelModule);\n    return _this;\n  }\n  _createClass2(Icon2, [{\n    key: \"resize\",\n    value: function resize(ctx, selected, hover) {\n      if (this.needsRefresh(selected, hover)) {\n        this.iconSize = {\n          width: Number(this.options.icon.size),\n          height: Number(this.options.icon.size)\n        };\n        this.width = this.iconSize.width + this.margin.right + this.margin.left;\n        this.height = this.iconSize.height + this.margin.top + this.margin.bottom;\n        this.radius = 0.5 * this.width;\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values32) {\n      var _this2 = this;\n      this.resize(ctx, selected, hover);\n      this.options.icon.size = this.options.icon.size || 50;\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this._icon(ctx, x, y, selected, hover, values32);\n      return {\n        drawExternalLabel: function drawExternalLabel() {\n          if (_this2.options.label !== void 0) {\n            var iconTextSpacing = 5;\n            _this2.labelModule.draw(ctx, _this2.left + _this2.iconSize.width / 2 + _this2.margin.left, y + _this2.height / 2 + iconTextSpacing, selected);\n          }\n          _this2.updateBoundingBox(x, y);\n        }\n      };\n    }\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      this.boundingBox.top = y - this.options.icon.size * 0.5;\n      this.boundingBox.left = x - this.options.icon.size * 0.5;\n      this.boundingBox.right = x + this.options.icon.size * 0.5;\n      this.boundingBox.bottom = y + this.options.icon.size * 0.5;\n      if (this.options.label !== void 0 && this.labelModule.size.width > 0) {\n        var iconTextSpacing = 5;\n        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + iconTextSpacing);\n      }\n    }\n  }, {\n    key: \"_icon\",\n    value: function _icon(ctx, x, y, selected, hover, values32) {\n      var iconSize = Number(this.options.icon.size);\n      if (this.options.icon.code !== void 0) {\n        ctx.font = [\n          this.options.icon.weight != null ? this.options.icon.weight : selected ? \"bold\" : \"\",\n          (this.options.icon.weight != null && selected ? 5 : 0) + iconSize + \"px\",\n          this.options.icon.face\n        ].join(\" \");\n        ctx.fillStyle = this.options.icon.color || \"black\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        this.enableShadow(ctx, values32);\n        ctx.fillText(this.options.icon.code, x, y);\n        this.disableShadow(ctx, values32);\n      } else {\n        console.error(\"When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.\");\n      }\n    }\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Icon2;\n}(NodeBase);\nfunction _createSuper$h(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$h();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$h() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Image$2 = /* @__PURE__ */ function(_CircleImageBase) {\n  _inherits2(Image2, _CircleImageBase);\n  var _super = _createSuper$h(Image2);\n  function Image2(options2, body, labelModule, imageObj, imageObjAlt) {\n    var _this;\n    _classCallCheck2(this, Image2);\n    _this = _super.call(this, options2, body, labelModule);\n    _this.setImages(imageObj, imageObjAlt);\n    return _this;\n  }\n  _createClass2(Image2, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;\n      var imageAbsent = this.imageObj.src === void 0 || this.imageObj.width === void 0 || this.imageObj.height === void 0;\n      if (imageAbsent) {\n        var side = this.options.size * 2;\n        this.width = side;\n        this.height = side;\n        return;\n      }\n      if (this.needsRefresh(selected, hover)) {\n        this._resizeImage();\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values32) {\n      ctx.save();\n      this.switchImages(selected);\n      this.resize();\n      var labelX = x, labelY = y;\n      if (this.options.shapeProperties.coordinateOrigin === \"top-left\") {\n        this.left = x;\n        this.top = y;\n        labelX += this.width / 2;\n        labelY += this.height / 2;\n      } else {\n        this.left = x - this.width / 2;\n        this.top = y - this.height / 2;\n      }\n      if (this.options.shapeProperties.useBorderWithImage === true) {\n        var neutralborderWidth = this.options.borderWidth;\n        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;\n        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;\n        ctx.lineWidth = Math.min(this.width, borderWidth);\n        ctx.beginPath();\n        var strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;\n        var fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;\n        if (values32.opacity !== void 0) {\n          strokeStyle = overrideOpacity(strokeStyle, values32.opacity);\n          fillStyle = overrideOpacity(fillStyle, values32.opacity);\n        }\n        ctx.strokeStyle = strokeStyle;\n        ctx.fillStyle = fillStyle;\n        ctx.rect(this.left - 0.5 * ctx.lineWidth, this.top - 0.5 * ctx.lineWidth, this.width + ctx.lineWidth, this.height + ctx.lineWidth);\n        fill22(ctx).call(ctx);\n        this.performStroke(ctx, values32);\n        ctx.closePath();\n      }\n      this._drawImageAtPosition(ctx, values32);\n      this._drawImageLabel(ctx, labelX, labelY, selected, hover);\n      this.updateBoundingBox(x, y);\n      ctx.restore();\n    }\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      this.resize();\n      if (this.options.shapeProperties.coordinateOrigin === \"top-left\") {\n        this.left = x;\n        this.top = y;\n      } else {\n        this.left = x - this.width / 2;\n        this.top = y - this.height / 2;\n      }\n      this.boundingBox.left = this.left;\n      this.boundingBox.top = this.top;\n      this.boundingBox.bottom = this.top + this.height;\n      this.boundingBox.right = this.left + this.width;\n      if (this.options.label !== void 0 && this.labelModule.size.width > 0) {\n        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);\n      }\n    }\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Image2;\n}(CircleImageBase);\nfunction _createSuper$g(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$g();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$g() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Square = /* @__PURE__ */ function(_ShapeBase) {\n  _inherits2(Square2, _ShapeBase);\n  var _super = _createSuper$g(Square2);\n  function Square2(options2, body, labelModule) {\n    _classCallCheck2(this, Square2);\n    return _super.call(this, options2, body, labelModule);\n  }\n  _createClass2(Square2, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values32) {\n      return this._drawShape(ctx, \"square\", 2, x, y, selected, hover, values32);\n    }\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Square2;\n}(ShapeBase);\nfunction _createSuper$f(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$f() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Hexagon = /* @__PURE__ */ function(_ShapeBase) {\n  _inherits2(Hexagon2, _ShapeBase);\n  var _super = _createSuper$f(Hexagon2);\n  function Hexagon2(options2, body, labelModule) {\n    _classCallCheck2(this, Hexagon2);\n    return _super.call(this, options2, body, labelModule);\n  }\n  _createClass2(Hexagon2, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values32) {\n      return this._drawShape(ctx, \"hexagon\", 4, x, y, selected, hover, values32);\n    }\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Hexagon2;\n}(ShapeBase);\nfunction _createSuper$e(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$e() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Star = /* @__PURE__ */ function(_ShapeBase) {\n  _inherits2(Star2, _ShapeBase);\n  var _super = _createSuper$e(Star2);\n  function Star2(options2, body, labelModule) {\n    _classCallCheck2(this, Star2);\n    return _super.call(this, options2, body, labelModule);\n  }\n  _createClass2(Star2, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values32) {\n      return this._drawShape(ctx, \"star\", 4, x, y, selected, hover, values32);\n    }\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Star2;\n}(ShapeBase);\nfunction _createSuper$d(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$d() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Text = /* @__PURE__ */ function(_NodeBase) {\n  _inherits2(Text2, _NodeBase);\n  var _super = _createSuper$d(Text2);\n  function Text2(options2, body, labelModule) {\n    var _this;\n    _classCallCheck2(this, Text2);\n    _this = _super.call(this, options2, body, labelModule);\n    _this._setMargins(labelModule);\n    return _this;\n  }\n  _createClass2(Text2, [{\n    key: \"resize\",\n    value: function resize(ctx, selected, hover) {\n      if (this.needsRefresh(selected, hover)) {\n        this.textSize = this.labelModule.getTextSize(ctx, selected, hover);\n        this.width = this.textSize.width + this.margin.right + this.margin.left;\n        this.height = this.textSize.height + this.margin.top + this.margin.bottom;\n        this.radius = 0.5 * this.width;\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values32) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this.enableShadow(ctx, values32);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);\n      this.disableShadow(ctx, values32);\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n    }\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Text2;\n}(NodeBase);\nfunction _createSuper$c(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$c() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Triangle$1 = /* @__PURE__ */ function(_ShapeBase) {\n  _inherits2(Triangle2, _ShapeBase);\n  var _super = _createSuper$c(Triangle2);\n  function Triangle2(options2, body, labelModule) {\n    _classCallCheck2(this, Triangle2);\n    return _super.call(this, options2, body, labelModule);\n  }\n  _createClass2(Triangle2, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values32) {\n      return this._drawShape(ctx, \"triangle\", 3, x, y, selected, hover, values32);\n    }\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Triangle2;\n}(ShapeBase);\nfunction _createSuper$b(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$b() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar TriangleDown = /* @__PURE__ */ function(_ShapeBase) {\n  _inherits2(TriangleDown2, _ShapeBase);\n  var _super = _createSuper$b(TriangleDown2);\n  function TriangleDown2(options2, body, labelModule) {\n    _classCallCheck2(this, TriangleDown2);\n    return _super.call(this, options2, body, labelModule);\n  }\n  _createClass2(TriangleDown2, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values32) {\n      return this._drawShape(ctx, \"triangleDown\", 3, x, y, selected, hover, values32);\n    }\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return TriangleDown2;\n}(ShapeBase);\nfunction ownKeys$22(object2, enumerableOnly) {\n  var keys$122 = keys32(object2);\n  if (getOwnPropertySymbols32) {\n    var symbols = getOwnPropertySymbols32(object2);\n    enumerableOnly && (symbols = filter22(symbols).call(symbols, function(sym) {\n      return getOwnPropertyDescriptor$32(object2, sym).enumerable;\n    })), keys$122.push.apply(keys$122, symbols);\n  }\n  return keys$122;\n}\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var _context5, _context6;\n    var source = arguments[i] != null ? arguments[i] : {};\n    i % 2 ? forEach$22(_context5 = ownKeys$22(Object(source), true)).call(_context5, function(key) {\n      _defineProperty2(target, key, source[key]);\n    }) : getOwnPropertyDescriptors22 ? defineProperties42(target, getOwnPropertyDescriptors22(source)) : forEach$22(_context6 = ownKeys$22(Object(source))).call(_context6, function(key) {\n      defineProperty$62(target, key, getOwnPropertyDescriptor$32(source, key));\n    });\n  }\n  return target;\n}\nvar Node = /* @__PURE__ */ function() {\n  function Node2(options2, body, imagelist, grouplist, globalOptions, defaultOptions) {\n    _classCallCheck2(this, Node2);\n    this.options = bridgeObject(globalOptions);\n    this.globalOptions = globalOptions;\n    this.defaultOptions = defaultOptions;\n    this.body = body;\n    this.edges = [];\n    this.id = void 0;\n    this.imagelist = imagelist;\n    this.grouplist = grouplist;\n    this.x = void 0;\n    this.y = void 0;\n    this.baseSize = this.options.size;\n    this.baseFontSize = this.options.font.size;\n    this.predefinedPosition = false;\n    this.selected = false;\n    this.hover = false;\n    this.labelModule = new Label(this.body, this.options, false);\n    this.setOptions(options2);\n  }\n  _createClass2(Node2, [{\n    key: \"attachEdge\",\n    value: function attachEdge(edge) {\n      var _context;\n      if (indexOf22(_context = this.edges).call(_context, edge) === -1) {\n        this.edges.push(edge);\n      }\n    }\n  }, {\n    key: \"detachEdge\",\n    value: function detachEdge(edge) {\n      var _context2;\n      var index2 = indexOf22(_context2 = this.edges).call(_context2, edge);\n      if (index2 != -1) {\n        var _context3;\n        splice$12(_context3 = this.edges).call(_context3, index2, 1);\n      }\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      var currentShape = this.options.shape;\n      if (!options2) {\n        return;\n      }\n      if (typeof options2.color !== \"undefined\") {\n        this._localColor = options2.color;\n      }\n      if (options2.id !== void 0) {\n        this.id = options2.id;\n      }\n      if (this.id === void 0) {\n        throw new Error(\"Node must have an id\");\n      }\n      Node2.checkMass(options2, this.id);\n      if (options2.x !== void 0) {\n        if (options2.x === null) {\n          this.x = void 0;\n          this.predefinedPosition = false;\n        } else {\n          this.x = _parseInt(options2.x);\n          this.predefinedPosition = true;\n        }\n      }\n      if (options2.y !== void 0) {\n        if (options2.y === null) {\n          this.y = void 0;\n          this.predefinedPosition = false;\n        } else {\n          this.y = _parseInt(options2.y);\n          this.predefinedPosition = true;\n        }\n      }\n      if (options2.size !== void 0) {\n        this.baseSize = options2.size;\n      }\n      if (options2.value !== void 0) {\n        options2.value = _parseFloat(options2.value);\n      }\n      Node2.parseOptions(this.options, options2, true, this.globalOptions, this.grouplist);\n      var pile = [options2, this.options, this.defaultOptions];\n      this.chooser = choosify(\"node\", pile);\n      this._load_images();\n      this.updateLabelModule(options2);\n      if (options2.opacity !== void 0 && Node2.checkOpacity(options2.opacity)) {\n        this.options.opacity = options2.opacity;\n      }\n      this.updateShape(currentShape);\n      return options2.hidden !== void 0 || options2.physics !== void 0;\n    }\n  }, {\n    key: \"_load_images\",\n    value: function _load_images() {\n      if (this.options.shape === \"circularImage\" || this.options.shape === \"image\") {\n        if (this.options.image === void 0) {\n          throw new Error(\"Option image must be defined for node type '\" + this.options.shape + \"'\");\n        }\n      }\n      if (this.options.image === void 0) {\n        return;\n      }\n      if (this.imagelist === void 0) {\n        throw new Error(\"Internal Error: No images provided\");\n      }\n      if (typeof this.options.image === \"string\") {\n        this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);\n      } else {\n        if (this.options.image.unselected === void 0) {\n          throw new Error(\"No unselected image provided\");\n        }\n        this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id);\n        if (this.options.image.selected !== void 0) {\n          this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id);\n        } else {\n          this.imageObjAlt = void 0;\n        }\n      }\n    }\n  }, {\n    key: \"getFormattingValues\",\n    value: function getFormattingValues() {\n      var values32 = {\n        color: this.options.color.background,\n        opacity: this.options.opacity,\n        borderWidth: this.options.borderWidth,\n        borderColor: this.options.color.border,\n        size: this.options.size,\n        borderDashes: this.options.shapeProperties.borderDashes,\n        borderRadius: this.options.shapeProperties.borderRadius,\n        shadow: this.options.shadow.enabled,\n        shadowColor: this.options.shadow.color,\n        shadowSize: this.options.shadow.size,\n        shadowX: this.options.shadow.x,\n        shadowY: this.options.shadow.y\n      };\n      if (this.selected || this.hover) {\n        if (this.chooser === true) {\n          if (this.selected) {\n            if (this.options.borderWidthSelected != null) {\n              values32.borderWidth = this.options.borderWidthSelected;\n            } else {\n              values32.borderWidth *= 2;\n            }\n            values32.color = this.options.color.highlight.background;\n            values32.borderColor = this.options.color.highlight.border;\n            values32.shadow = this.options.shadow.enabled;\n          } else if (this.hover) {\n            values32.color = this.options.color.hover.background;\n            values32.borderColor = this.options.color.hover.border;\n            values32.shadow = this.options.shadow.enabled;\n          }\n        } else if (typeof this.chooser === \"function\") {\n          this.chooser(values32, this.options.id, this.selected, this.hover);\n          if (values32.shadow === false) {\n            if (values32.shadowColor !== this.options.shadow.color || values32.shadowSize !== this.options.shadow.size || values32.shadowX !== this.options.shadow.x || values32.shadowY !== this.options.shadow.y) {\n              values32.shadow = true;\n            }\n          }\n        }\n      } else {\n        values32.shadow = this.options.shadow.enabled;\n      }\n      if (this.options.opacity !== void 0) {\n        var opacity = this.options.opacity;\n        values32.borderColor = overrideOpacity(values32.borderColor, opacity);\n        values32.color = overrideOpacity(values32.color, opacity);\n        values32.shadowColor = overrideOpacity(values32.shadowColor, opacity);\n      }\n      return values32;\n    }\n  }, {\n    key: \"updateLabelModule\",\n    value: function updateLabelModule(options2) {\n      if (this.options.label === void 0 || this.options.label === null) {\n        this.options.label = \"\";\n      }\n      Node2.updateGroupOptions(this.options, _objectSpread$2(_objectSpread$2({}, options2), {}, {\n        color: options2 && options2.color || this._localColor || void 0\n      }), this.grouplist);\n      var currentGroup = this.grouplist.get(this.options.group, false);\n      var pile = [\n        options2,\n        this.options,\n        currentGroup,\n        this.globalOptions,\n        this.defaultOptions\n      ];\n      this.labelModule.update(this.options, pile);\n      if (this.labelModule.baseSize !== void 0) {\n        this.baseFontSize = this.labelModule.baseSize;\n      }\n    }\n  }, {\n    key: \"updateShape\",\n    value: function updateShape(currentShape) {\n      if (currentShape === this.options.shape && this.shape) {\n        this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt);\n      } else {\n        switch (this.options.shape) {\n          case \"box\":\n            this.shape = new Box$1(this.options, this.body, this.labelModule);\n            break;\n          case \"circle\":\n            this.shape = new Circle$1(this.options, this.body, this.labelModule);\n            break;\n          case \"circularImage\":\n            this.shape = new CircularImage(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);\n            break;\n          case \"custom\":\n            this.shape = new CustomShape(this.options, this.body, this.labelModule, this.options.ctxRenderer);\n            break;\n          case \"database\":\n            this.shape = new Database(this.options, this.body, this.labelModule);\n            break;\n          case \"diamond\":\n            this.shape = new Diamond$1(this.options, this.body, this.labelModule);\n            break;\n          case \"dot\":\n            this.shape = new Dot(this.options, this.body, this.labelModule);\n            break;\n          case \"ellipse\":\n            this.shape = new Ellipse(this.options, this.body, this.labelModule);\n            break;\n          case \"icon\":\n            this.shape = new Icon(this.options, this.body, this.labelModule);\n            break;\n          case \"image\":\n            this.shape = new Image$2(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);\n            break;\n          case \"square\":\n            this.shape = new Square(this.options, this.body, this.labelModule);\n            break;\n          case \"hexagon\":\n            this.shape = new Hexagon(this.options, this.body, this.labelModule);\n            break;\n          case \"star\":\n            this.shape = new Star(this.options, this.body, this.labelModule);\n            break;\n          case \"text\":\n            this.shape = new Text(this.options, this.body, this.labelModule);\n            break;\n          case \"triangle\":\n            this.shape = new Triangle$1(this.options, this.body, this.labelModule);\n            break;\n          case \"triangleDown\":\n            this.shape = new TriangleDown(this.options, this.body, this.labelModule);\n            break;\n          default:\n            this.shape = new Ellipse(this.options, this.body, this.labelModule);\n            break;\n        }\n      }\n      this.needsRefresh();\n    }\n  }, {\n    key: \"select\",\n    value: function select() {\n      this.selected = true;\n      this.needsRefresh();\n    }\n  }, {\n    key: \"unselect\",\n    value: function unselect() {\n      this.selected = false;\n      this.needsRefresh();\n    }\n  }, {\n    key: \"needsRefresh\",\n    value: function needsRefresh() {\n      this.shape.refreshNeeded = true;\n    }\n  }, {\n    key: \"getTitle\",\n    value: function getTitle() {\n      return this.options.title;\n    }\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this.shape.distanceToBorder(ctx, angle);\n    }\n  }, {\n    key: \"isFixed\",\n    value: function isFixed() {\n      return this.options.fixed.x && this.options.fixed.y;\n    }\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return this.selected;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.options.value;\n    }\n  }, {\n    key: \"getLabelSize\",\n    value: function getLabelSize() {\n      return this.labelModule.size();\n    }\n  }, {\n    key: \"setValueRange\",\n    value: function setValueRange(min22, max22, total) {\n      if (this.options.value !== void 0) {\n        var scale = this.options.scaling.customScalingFunction(min22, max22, total, this.options.value);\n        var sizeDiff = this.options.scaling.max - this.options.scaling.min;\n        if (this.options.scaling.label.enabled === true) {\n          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;\n          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;\n        }\n        this.options.size = this.options.scaling.min + scale * sizeDiff;\n      } else {\n        this.options.size = this.baseSize;\n        this.options.font.size = this.baseFontSize;\n      }\n      this.updateLabelModule();\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      var values32 = this.getFormattingValues();\n      return this.shape.draw(ctx, this.x, this.y, this.selected, this.hover, values32) || {};\n    }\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(ctx) {\n      this.shape.updateBoundingBox(this.x, this.y, ctx);\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(ctx) {\n      var values32 = this.getFormattingValues();\n      this.shape.resize(ctx, this.selected, this.hover, values32);\n    }\n  }, {\n    key: \"getItemsOnPoint\",\n    value: function getItemsOnPoint(point) {\n      var ret = [];\n      if (this.labelModule.visible()) {\n        if (pointInRect(this.labelModule.getSize(), point)) {\n          ret.push({\n            nodeId: this.id,\n            labelId: 0\n          });\n        }\n      }\n      if (pointInRect(this.shape.boundingBox, point)) {\n        ret.push({\n          nodeId: this.id\n        });\n      }\n      return ret;\n    }\n  }, {\n    key: \"isOverlappingWith\",\n    value: function isOverlappingWith(obj) {\n      return this.shape.left < obj.right && this.shape.left + this.shape.width > obj.left && this.shape.top < obj.bottom && this.shape.top + this.shape.height > obj.top;\n    }\n  }, {\n    key: \"isBoundingBoxOverlappingWith\",\n    value: function isBoundingBoxOverlappingWith(obj) {\n      return this.shape.boundingBox.left < obj.right && this.shape.boundingBox.right > obj.left && this.shape.boundingBox.top < obj.bottom && this.shape.boundingBox.bottom > obj.top;\n    }\n  }], [{\n    key: \"checkOpacity\",\n    value: function checkOpacity(opacity) {\n      return 0 <= opacity && opacity <= 1;\n    }\n  }, {\n    key: \"checkCoordinateOrigin\",\n    value: function checkCoordinateOrigin(origin) {\n      return origin === void 0 || origin === \"center\" || origin === \"top-left\";\n    }\n  }, {\n    key: \"updateGroupOptions\",\n    value: function updateGroupOptions(parentOptions, newOptions, groupList) {\n      var _context4;\n      if (groupList === void 0)\n        return;\n      var group = parentOptions.group;\n      if (newOptions !== void 0 && newOptions.group !== void 0 && group !== newOptions.group) {\n        throw new Error(\"updateGroupOptions: group values in options don't match.\");\n      }\n      var hasGroup = typeof group === \"number\" || typeof group === \"string\" && group != \"\";\n      if (!hasGroup)\n        return;\n      var groupObj = groupList.get(group);\n      if (groupObj.opacity !== void 0 && newOptions.opacity === void 0) {\n        if (!Node2.checkOpacity(groupObj.opacity)) {\n          console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + groupObj.opacity);\n          groupObj.opacity = void 0;\n        }\n      }\n      var skipProperties = filter22(_context4 = getOwnPropertyNames5(newOptions)).call(_context4, function(p) {\n        return newOptions[p] != null;\n      });\n      skipProperties.push(\"font\");\n      selectiveNotDeepExtend(skipProperties, parentOptions, groupObj);\n      parentOptions.color = parseColor(parentOptions.color);\n    }\n  }, {\n    key: \"parseOptions\",\n    value: function parseOptions(parentOptions, newOptions) {\n      var allowDeletion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n      var globalOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n      var groupList = arguments.length > 4 ? arguments[4] : void 0;\n      var fields = [\"color\", \"fixed\", \"shadow\"];\n      selectiveNotDeepExtend(fields, parentOptions, newOptions, allowDeletion);\n      Node2.checkMass(newOptions);\n      if (parentOptions.opacity !== void 0) {\n        if (!Node2.checkOpacity(parentOptions.opacity)) {\n          console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + parentOptions.opacity);\n          parentOptions.opacity = void 0;\n        }\n      }\n      if (newOptions.opacity !== void 0) {\n        if (!Node2.checkOpacity(newOptions.opacity)) {\n          console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + newOptions.opacity);\n          newOptions.opacity = void 0;\n        }\n      }\n      if (newOptions.shapeProperties && !Node2.checkCoordinateOrigin(newOptions.shapeProperties.coordinateOrigin)) {\n        console.error(\"Invalid option for node coordinateOrigin, found: \" + newOptions.shapeProperties.coordinateOrigin);\n      }\n      mergeOptions(parentOptions, newOptions, \"shadow\", globalOptions);\n      if (newOptions.color !== void 0 && newOptions.color !== null) {\n        var parsedColor = parseColor(newOptions.color);\n        fillIfDefined(parentOptions.color, parsedColor);\n      } else if (allowDeletion === true && newOptions.color === null) {\n        parentOptions.color = bridgeObject(globalOptions.color);\n      }\n      if (newOptions.fixed !== void 0 && newOptions.fixed !== null) {\n        if (typeof newOptions.fixed === \"boolean\") {\n          parentOptions.fixed.x = newOptions.fixed;\n          parentOptions.fixed.y = newOptions.fixed;\n        } else {\n          if (newOptions.fixed.x !== void 0 && typeof newOptions.fixed.x === \"boolean\") {\n            parentOptions.fixed.x = newOptions.fixed.x;\n          }\n          if (newOptions.fixed.y !== void 0 && typeof newOptions.fixed.y === \"boolean\") {\n            parentOptions.fixed.y = newOptions.fixed.y;\n          }\n        }\n      }\n      if (allowDeletion === true && newOptions.font === null) {\n        parentOptions.font = bridgeObject(globalOptions.font);\n      }\n      Node2.updateGroupOptions(parentOptions, newOptions, groupList);\n      if (newOptions.scaling !== void 0) {\n        mergeOptions(parentOptions.scaling, newOptions.scaling, \"label\", globalOptions.scaling);\n      }\n    }\n  }, {\n    key: \"checkMass\",\n    value: function checkMass(options2, id22) {\n      if (options2.mass !== void 0 && options2.mass <= 0) {\n        var strId = \"\";\n        if (id22 !== void 0) {\n          strId = \" in node id: \" + id22;\n        }\n        console.error(\"%cNegative or zero mass disallowed\" + strId + \", setting mass to 1.\", VALIDATOR_PRINT_STYLE);\n        options2.mass = 1;\n      }\n    }\n  }]);\n  return Node2;\n}();\nfunction _createForOfIteratorHelper$6(o, allowArrayLike) {\n  var it2 = typeof symbol2 !== \"undefined\" && getIteratorMethod$12(o) || o[\"@@iterator\"];\n  if (!it2) {\n    if (isArray$12(o) || (it2 = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it2)\n        o = it2;\n      var i = 0;\n      var F2 = function F22() {\n      };\n      return { s: F2, n: function n() {\n        if (i >= o.length)\n          return { done: true };\n        return { done: false, value: o[i++] };\n      }, e: function e(_e3) {\n        throw _e3;\n      }, f: F2 };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true, didErr = false, err;\n  return { s: function s() {\n    it2 = it2.call(o);\n  }, n: function n() {\n    var step = it2.next();\n    normalCompletion = step.done;\n    return step;\n  }, e: function e(_e22) {\n    didErr = true;\n    err = _e22;\n  }, f: function f() {\n    try {\n      if (!normalCompletion && it2.return != null)\n        it2.return();\n    } finally {\n      if (didErr)\n        throw err;\n    }\n  } };\n}\nfunction _unsupportedIterableToArray$6(o, minLen) {\n  var _context4;\n  if (!o)\n    return;\n  if (typeof o === \"string\")\n    return _arrayLikeToArray$6(o, minLen);\n  var n = slice22(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1);\n  if (n === \"Object\" && o.constructor)\n    n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\")\n    return from$32(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray$6(o, minLen);\n}\nfunction _arrayLikeToArray$6(arr, len) {\n  if (len == null || len > arr.length)\n    len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar NodesHandler = /* @__PURE__ */ function() {\n  function NodesHandler2(body, images, groups, layoutEngine) {\n    var _context, _this = this;\n    _classCallCheck2(this, NodesHandler2);\n    this.body = body;\n    this.images = images;\n    this.groups = groups;\n    this.layoutEngine = layoutEngine;\n    this.body.functions.createNode = bind$52(_context = this.create).call(_context, this);\n    this.nodesListeners = {\n      add: function add(event, params) {\n        _this.add(params.items);\n      },\n      update: function update(event, params) {\n        _this.update(params.items, params.data, params.oldData);\n      },\n      remove: function remove(event, params) {\n        _this.remove(params.items);\n      }\n    };\n    this.defaultOptions = {\n      borderWidth: 1,\n      borderWidthSelected: void 0,\n      brokenImage: void 0,\n      color: {\n        border: \"#2B7CE9\",\n        background: \"#97C2FC\",\n        highlight: {\n          border: \"#2B7CE9\",\n          background: \"#D2E5FF\"\n        },\n        hover: {\n          border: \"#2B7CE9\",\n          background: \"#D2E5FF\"\n        }\n      },\n      opacity: void 0,\n      fixed: {\n        x: false,\n        y: false\n      },\n      font: {\n        color: \"#343434\",\n        size: 14,\n        face: \"arial\",\n        background: \"none\",\n        strokeWidth: 0,\n        strokeColor: \"#ffffff\",\n        align: \"center\",\n        vadjust: 0,\n        multi: false,\n        bold: {\n          mod: \"bold\"\n        },\n        boldital: {\n          mod: \"bold italic\"\n        },\n        ital: {\n          mod: \"italic\"\n        },\n        mono: {\n          mod: \"\",\n          size: 15,\n          face: \"monospace\",\n          vadjust: 2\n        }\n      },\n      group: void 0,\n      hidden: false,\n      icon: {\n        face: \"FontAwesome\",\n        code: void 0,\n        size: 50,\n        color: \"#2B7CE9\"\n      },\n      image: void 0,\n      imagePadding: {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      },\n      label: void 0,\n      labelHighlightBold: true,\n      level: void 0,\n      margin: {\n        top: 5,\n        right: 5,\n        bottom: 5,\n        left: 5\n      },\n      mass: 1,\n      physics: true,\n      scaling: {\n        min: 10,\n        max: 30,\n        label: {\n          enabled: false,\n          min: 14,\n          max: 30,\n          maxVisible: 30,\n          drawThreshold: 5\n        },\n        customScalingFunction: function customScalingFunction(min22, max22, total, value) {\n          if (max22 === min22) {\n            return 0.5;\n          } else {\n            var scale = 1 / (max22 - min22);\n            return Math.max(0, (value - min22) * scale);\n          }\n        }\n      },\n      shadow: {\n        enabled: false,\n        color: \"rgba(0,0,0,0.5)\",\n        size: 10,\n        x: 5,\n        y: 5\n      },\n      shape: \"ellipse\",\n      shapeProperties: {\n        borderDashes: false,\n        borderRadius: 6,\n        interpolation: true,\n        useImageSize: false,\n        useBorderWithImage: false,\n        coordinateOrigin: \"center\"\n      },\n      size: 25,\n      title: void 0,\n      value: void 0,\n      x: void 0,\n      y: void 0\n    };\n    if (this.defaultOptions.mass <= 0) {\n      throw \"Internal error: mass in defaultOptions of NodesHandler may not be zero or negative\";\n    }\n    this.options = bridgeObject(this.defaultOptions);\n    this.bindEventListeners();\n  }\n  _createClass2(NodesHandler2, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _context2, _context3, _this2 = this;\n      this.body.emitter.on(\"refreshNodes\", bind$52(_context2 = this.refresh).call(_context2, this));\n      this.body.emitter.on(\"refresh\", bind$52(_context3 = this.refresh).call(_context3, this));\n      this.body.emitter.on(\"destroy\", function() {\n        forEach$12(_this2.nodesListeners, function(callback, event) {\n          if (_this2.body.data.nodes)\n            _this2.body.data.nodes.off(event, callback);\n        });\n        delete _this2.body.functions.createNode;\n        delete _this2.nodesListeners.add;\n        delete _this2.nodesListeners.update;\n        delete _this2.nodesListeners.remove;\n        delete _this2.nodesListeners;\n      });\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      if (options2 !== void 0) {\n        Node.parseOptions(this.options, options2);\n        if (options2.opacity !== void 0) {\n          if (isNan(options2.opacity) || !_isFinite(options2.opacity) || options2.opacity < 0 || options2.opacity > 1) {\n            console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + options2.opacity);\n          } else {\n            this.options.opacity = options2.opacity;\n          }\n        }\n        if (options2.shape !== void 0) {\n          for (var nodeId in this.body.nodes) {\n            if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {\n              this.body.nodes[nodeId].updateShape();\n            }\n          }\n        }\n        if (typeof options2.font !== \"undefined\" || typeof options2.widthConstraint !== \"undefined\" || typeof options2.heightConstraint !== \"undefined\") {\n          for (var _i = 0, _Object$keys = keys32(this.body.nodes); _i < _Object$keys.length; _i++) {\n            var _nodeId = _Object$keys[_i];\n            this.body.nodes[_nodeId].updateLabelModule();\n            this.body.nodes[_nodeId].needsRefresh();\n          }\n        }\n        if (options2.size !== void 0) {\n          for (var _nodeId2 in this.body.nodes) {\n            if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {\n              this.body.nodes[_nodeId2].needsRefresh();\n            }\n          }\n        }\n        if (options2.hidden !== void 0 || options2.physics !== void 0) {\n          this.body.emitter.emit(\"_dataChanged\");\n        }\n      }\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(nodes) {\n      var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n      var oldNodesData = this.body.data.nodes;\n      if (isDataViewLike(\"id\", nodes)) {\n        this.body.data.nodes = nodes;\n      } else if (isArray$12(nodes)) {\n        this.body.data.nodes = new DataSet();\n        this.body.data.nodes.add(nodes);\n      } else if (!nodes) {\n        this.body.data.nodes = new DataSet();\n      } else {\n        throw new TypeError(\"Array or DataSet expected\");\n      }\n      if (oldNodesData) {\n        forEach$12(this.nodesListeners, function(callback, event) {\n          oldNodesData.off(event, callback);\n        });\n      }\n      this.body.nodes = {};\n      if (this.body.data.nodes) {\n        var me3 = this;\n        forEach$12(this.nodesListeners, function(callback, event) {\n          me3.body.data.nodes.on(event, callback);\n        });\n        var ids = this.body.data.nodes.getIds();\n        this.add(ids, true);\n      }\n      if (doNotEmit === false) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n  }, {\n    key: \"add\",\n    value: function add(ids) {\n      var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n      var id22;\n      var newNodes = [];\n      for (var i = 0; i < ids.length; i++) {\n        id22 = ids[i];\n        var properties = this.body.data.nodes.get(id22);\n        var node = this.create(properties);\n        newNodes.push(node);\n        this.body.nodes[id22] = node;\n      }\n      this.layoutEngine.positionInitially(newNodes);\n      if (doNotEmit === false) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(ids, changedData, oldData) {\n      var nodes = this.body.nodes;\n      var dataChanged = false;\n      for (var i = 0; i < ids.length; i++) {\n        var id22 = ids[i];\n        var node = nodes[id22];\n        var data22 = changedData[i];\n        if (node !== void 0) {\n          if (node.setOptions(data22)) {\n            dataChanged = true;\n          }\n        } else {\n          dataChanged = true;\n          node = this.create(data22);\n          nodes[id22] = node;\n        }\n      }\n      if (!dataChanged && oldData !== void 0) {\n        dataChanged = some22(changedData).call(changedData, function(newValue, index2) {\n          var oldValue = oldData[index2];\n          return oldValue && oldValue.level !== newValue.level;\n        });\n      }\n      if (dataChanged === true) {\n        this.body.emitter.emit(\"_dataChanged\");\n      } else {\n        this.body.emitter.emit(\"_dataUpdated\");\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(ids) {\n      var nodes = this.body.nodes;\n      for (var i = 0; i < ids.length; i++) {\n        var id22 = ids[i];\n        delete nodes[id22];\n      }\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n  }, {\n    key: \"create\",\n    value: function create52(properties) {\n      var constructorClass = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Node;\n      return new constructorClass(properties, this.body, this.images, this.groups, this.options, this.defaultOptions);\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var _this3 = this;\n      var clearPositions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n      forEach$12(this.body.nodes, function(node, nodeId) {\n        var data22 = _this3.body.data.nodes.get(nodeId);\n        if (data22 !== void 0) {\n          if (clearPositions === true) {\n            node.setOptions({\n              x: null,\n              y: null\n            });\n          }\n          node.setOptions({\n            fixed: false\n          });\n          node.setOptions(data22);\n        }\n      });\n    }\n  }, {\n    key: \"getPositions\",\n    value: function getPositions(ids) {\n      var dataArray = {};\n      if (ids !== void 0) {\n        if (isArray$12(ids) === true) {\n          for (var i = 0; i < ids.length; i++) {\n            if (this.body.nodes[ids[i]] !== void 0) {\n              var node = this.body.nodes[ids[i]];\n              dataArray[ids[i]] = {\n                x: Math.round(node.x),\n                y: Math.round(node.y)\n              };\n            }\n          }\n        } else {\n          if (this.body.nodes[ids] !== void 0) {\n            var _node = this.body.nodes[ids];\n            dataArray[ids] = {\n              x: Math.round(_node.x),\n              y: Math.round(_node.y)\n            };\n          }\n        }\n      } else {\n        for (var _i2 = 0; _i2 < this.body.nodeIndices.length; _i2++) {\n          var _node2 = this.body.nodes[this.body.nodeIndices[_i2]];\n          dataArray[this.body.nodeIndices[_i2]] = {\n            x: Math.round(_node2.x),\n            y: Math.round(_node2.y)\n          };\n        }\n      }\n      return dataArray;\n    }\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(id22) {\n      if (id22 == void 0) {\n        throw new TypeError(\"No id was specified for getPosition method.\");\n      } else if (this.body.nodes[id22] == void 0) {\n        throw new ReferenceError(\"NodeId provided for getPosition does not exist. Provided: \".concat(id22));\n      } else {\n        return {\n          x: Math.round(this.body.nodes[id22].x),\n          y: Math.round(this.body.nodes[id22].y)\n        };\n      }\n    }\n  }, {\n    key: \"storePositions\",\n    value: function storePositions() {\n      var dataArray = [];\n      var dataset = this.body.data.nodes.getDataSet();\n      var _iterator = _createForOfIteratorHelper$6(dataset.get()), _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done; ) {\n          var dsNode = _step.value;\n          var id22 = dsNode.id;\n          var bodyNode = this.body.nodes[id22];\n          var x = Math.round(bodyNode.x);\n          var y = Math.round(bodyNode.y);\n          if (dsNode.x !== x || dsNode.y !== y) {\n            dataArray.push({\n              id: id22,\n              x,\n              y\n            });\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      dataset.update(dataArray);\n    }\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox(nodeId) {\n      if (this.body.nodes[nodeId] !== void 0) {\n        return this.body.nodes[nodeId].shape.boundingBox;\n      }\n    }\n  }, {\n    key: \"getConnectedNodes\",\n    value: function getConnectedNodes(nodeId, direction) {\n      var nodeList = [];\n      if (this.body.nodes[nodeId] !== void 0) {\n        var node = this.body.nodes[nodeId];\n        var nodeObj = {};\n        for (var i = 0; i < node.edges.length; i++) {\n          var edge = node.edges[i];\n          if (direction !== \"to\" && edge.toId == node.id) {\n            if (nodeObj[edge.fromId] === void 0) {\n              nodeList.push(edge.fromId);\n              nodeObj[edge.fromId] = true;\n            }\n          } else if (direction !== \"from\" && edge.fromId == node.id) {\n            if (nodeObj[edge.toId] === void 0) {\n              nodeList.push(edge.toId);\n              nodeObj[edge.toId] = true;\n            }\n          }\n        }\n      }\n      return nodeList;\n    }\n  }, {\n    key: \"getConnectedEdges\",\n    value: function getConnectedEdges(nodeId) {\n      var edgeList = [];\n      if (this.body.nodes[nodeId] !== void 0) {\n        var node = this.body.nodes[nodeId];\n        for (var i = 0; i < node.edges.length; i++) {\n          edgeList.push(node.edges[i].id);\n        }\n      } else {\n        console.error(\"NodeId provided for getConnectedEdges does not exist. Provided: \", nodeId);\n      }\n      return edgeList;\n    }\n  }, {\n    key: \"moveNode\",\n    value: function moveNode(nodeId, x, y) {\n      var _this4 = this;\n      if (this.body.nodes[nodeId] !== void 0) {\n        this.body.nodes[nodeId].x = Number(x);\n        this.body.nodes[nodeId].y = Number(y);\n        setTimeout$12(function() {\n          _this4.body.emitter.emit(\"startSimulation\");\n        }, 0);\n      } else {\n        console.error(\"Node id supplied to moveNode does not exist. Provided: \", nodeId);\n      }\n    }\n  }]);\n  return NodesHandler2;\n}();\nvar hasOwn$12 = hasOwnProperty_12;\nvar isDataDescriptor$1 = function(descriptor) {\n  return descriptor !== void 0 && (hasOwn$12(descriptor, \"value\") || hasOwn$12(descriptor, \"writable\"));\n};\nvar $$42 = _export2;\nvar call2 = functionCall2;\nvar isObject$22 = isObject$j;\nvar anObject$12 = anObject$d;\nvar isDataDescriptor = isDataDescriptor$1;\nvar getOwnPropertyDescriptorModule2 = objectGetOwnPropertyDescriptor2;\nvar getPrototypeOf22 = objectGetPrototypeOf2;\nfunction get$5(target, propertyKey) {\n  var receiver = arguments.length < 3 ? target : arguments[2];\n  var descriptor, prototype;\n  if (anObject$12(target) === receiver)\n    return target[propertyKey];\n  descriptor = getOwnPropertyDescriptorModule2.f(target, propertyKey);\n  if (descriptor)\n    return isDataDescriptor(descriptor) ? descriptor.value : descriptor.get === void 0 ? void 0 : call2(descriptor.get, receiver);\n  if (isObject$22(prototype = getPrototypeOf22(target)))\n    return get$5(prototype, propertyKey, receiver);\n}\n$$42({\n  target: \"Reflect\",\n  stat: true\n}, {\n  get: get$5\n});\nvar path$42 = path$y;\nvar get$4 = path$42.Reflect.get;\nvar parent$a2 = get$4;\nvar get$3 = parent$a2;\nvar parent$92 = get$3;\nvar get$2 = parent$92;\nvar parent$82 = get$2;\nvar get$1 = parent$82;\nvar get2 = get$1;\nvar parent$72 = getOwnPropertyDescriptor$42;\nvar getOwnPropertyDescriptor$22 = parent$72;\nvar parent$62 = getOwnPropertyDescriptor$22;\nvar getOwnPropertyDescriptor$12 = parent$62;\nvar getOwnPropertyDescriptor52 = getOwnPropertyDescriptor$12;\nfunction _superPropBase(object2, property) {\n  while (!Object.prototype.hasOwnProperty.call(object2, property)) {\n    object2 = _getPrototypeOf2(object2);\n    if (object2 === null)\n      break;\n  }\n  return object2;\n}\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && get2) {\n    _get = get2;\n  } else {\n    _get = function _get2(target, property, receiver) {\n      var base = _superPropBase(target, property);\n      if (!base)\n        return;\n      var desc = getOwnPropertyDescriptor52(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}\nvar $$32 = _export2;\nvar $hypot = Math.hypot;\nvar abs2 = Math.abs;\nvar sqrt = Math.sqrt;\nvar BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity;\n$$32({\n  target: \"Math\",\n  stat: true,\n  forced: BUGGY\n}, {\n  hypot: function hypot(value1, value2) {\n    var sum = 0;\n    var i = 0;\n    var aLen = arguments.length;\n    var larg = 0;\n    var arg, div;\n    while (i < aLen) {\n      arg = abs2(arguments[i++]);\n      if (larg < arg) {\n        div = larg / arg;\n        sum = sum * div * div + 1;\n        larg = arg;\n      } else if (arg > 0) {\n        div = arg / larg;\n        sum += div * div;\n      } else\n        sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * sqrt(sum);\n  }\n});\nvar path$32 = path$y;\nvar hypot$2 = path$32.Math.hypot;\nvar parent$52 = hypot$2;\nvar hypot$1 = parent$52;\nvar hypot2 = hypot$1;\nfunction _createSuper$a(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$a() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar EndPoint = /* @__PURE__ */ function() {\n  function EndPoint2() {\n    _classCallCheck2(this, EndPoint2);\n  }\n  _createClass2(EndPoint2, null, [{\n    key: \"transform\",\n    value: function transform(points, arrowData) {\n      if (!isArray$12(points)) {\n        points = [points];\n      }\n      var x = arrowData.point.x;\n      var y = arrowData.point.y;\n      var angle = arrowData.angle;\n      var length2 = arrowData.length;\n      for (var i = 0; i < points.length; ++i) {\n        var p = points[i];\n        var xt = p.x * Math.cos(angle) - p.y * Math.sin(angle);\n        var yt = p.x * Math.sin(angle) + p.y * Math.cos(angle);\n        p.x = x + length2 * xt;\n        p.y = y + length2 * yt;\n      }\n    }\n  }, {\n    key: \"drawPath\",\n    value: function drawPath(ctx, points) {\n      ctx.beginPath();\n      ctx.moveTo(points[0].x, points[0].y);\n      for (var i = 1; i < points.length; ++i) {\n        ctx.lineTo(points[i].x, points[i].y);\n      }\n      ctx.closePath();\n    }\n  }]);\n  return EndPoint2;\n}();\nvar Image$1 = /* @__PURE__ */ function(_EndPoint) {\n  _inherits2(Image2, _EndPoint);\n  var _super = _createSuper$a(Image2);\n  function Image2() {\n    _classCallCheck2(this, Image2);\n    return _super.apply(this, arguments);\n  }\n  _createClass2(Image2, null, [{\n    key: \"draw\",\n    value: function draw(ctx, arrowData) {\n      if (arrowData.image) {\n        ctx.save();\n        ctx.translate(arrowData.point.x, arrowData.point.y);\n        ctx.rotate(Math.PI / 2 + arrowData.angle);\n        var width = arrowData.imageWidth != null ? arrowData.imageWidth : arrowData.image.width;\n        var height = arrowData.imageHeight != null ? arrowData.imageHeight : arrowData.image.height;\n        arrowData.image.drawImageAtPosition(ctx, 1, -width / 2, 0, width, height);\n        ctx.restore();\n      }\n      return false;\n    }\n  }]);\n  return Image2;\n}(EndPoint);\nvar Arrow = /* @__PURE__ */ function(_EndPoint2) {\n  _inherits2(Arrow2, _EndPoint2);\n  var _super2 = _createSuper$a(Arrow2);\n  function Arrow2() {\n    _classCallCheck2(this, Arrow2);\n    return _super2.apply(this, arguments);\n  }\n  _createClass2(Arrow2, null, [{\n    key: \"draw\",\n    value: function draw(ctx, arrowData) {\n      var points = [{\n        x: 0,\n        y: 0\n      }, {\n        x: -1,\n        y: 0.3\n      }, {\n        x: -0.9,\n        y: 0\n      }, {\n        x: -1,\n        y: -0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Arrow2;\n}(EndPoint);\nvar Crow = /* @__PURE__ */ function() {\n  function Crow2() {\n    _classCallCheck2(this, Crow2);\n  }\n  _createClass2(Crow2, null, [{\n    key: \"draw\",\n    value: function draw(ctx, arrowData) {\n      var points = [{\n        x: -1,\n        y: 0\n      }, {\n        x: 0,\n        y: 0.3\n      }, {\n        x: -0.4,\n        y: 0\n      }, {\n        x: 0,\n        y: -0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Crow2;\n}();\nvar Curve = /* @__PURE__ */ function() {\n  function Curve2() {\n    _classCallCheck2(this, Curve2);\n  }\n  _createClass2(Curve2, null, [{\n    key: \"draw\",\n    value: function draw(ctx, arrowData) {\n      var point = {\n        x: -0.4,\n        y: 0\n      };\n      EndPoint.transform(point, arrowData);\n      ctx.strokeStyle = ctx.fillStyle;\n      ctx.fillStyle = \"rgba(0, 0, 0, 0)\";\n      var pi = Math.PI;\n      var startAngle = arrowData.angle - pi / 2;\n      var endAngle = arrowData.angle + pi / 2;\n      ctx.beginPath();\n      ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);\n      ctx.stroke();\n      return true;\n    }\n  }]);\n  return Curve2;\n}();\nvar InvertedCurve = /* @__PURE__ */ function() {\n  function InvertedCurve2() {\n    _classCallCheck2(this, InvertedCurve2);\n  }\n  _createClass2(InvertedCurve2, null, [{\n    key: \"draw\",\n    value: function draw(ctx, arrowData) {\n      var point = {\n        x: -0.3,\n        y: 0\n      };\n      EndPoint.transform(point, arrowData);\n      ctx.strokeStyle = ctx.fillStyle;\n      ctx.fillStyle = \"rgba(0, 0, 0, 0)\";\n      var pi = Math.PI;\n      var startAngle = arrowData.angle + pi / 2;\n      var endAngle = arrowData.angle + 3 * pi / 2;\n      ctx.beginPath();\n      ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);\n      ctx.stroke();\n      return true;\n    }\n  }]);\n  return InvertedCurve2;\n}();\nvar Triangle = /* @__PURE__ */ function() {\n  function Triangle2() {\n    _classCallCheck2(this, Triangle2);\n  }\n  _createClass2(Triangle2, null, [{\n    key: \"draw\",\n    value: function draw(ctx, arrowData) {\n      var points = [{\n        x: 0.02,\n        y: 0\n      }, {\n        x: -1,\n        y: 0.3\n      }, {\n        x: -1,\n        y: -0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Triangle2;\n}();\nvar InvertedTriangle = /* @__PURE__ */ function() {\n  function InvertedTriangle2() {\n    _classCallCheck2(this, InvertedTriangle2);\n  }\n  _createClass2(InvertedTriangle2, null, [{\n    key: \"draw\",\n    value: function draw(ctx, arrowData) {\n      var points = [{\n        x: 0,\n        y: 0.3\n      }, {\n        x: 0,\n        y: -0.3\n      }, {\n        x: -1,\n        y: 0\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return InvertedTriangle2;\n}();\nvar Circle = /* @__PURE__ */ function() {\n  function Circle2() {\n    _classCallCheck2(this, Circle2);\n  }\n  _createClass2(Circle2, null, [{\n    key: \"draw\",\n    value: function draw(ctx, arrowData) {\n      var point = {\n        x: -0.4,\n        y: 0\n      };\n      EndPoint.transform(point, arrowData);\n      drawCircle(ctx, point.x, point.y, arrowData.length * 0.4);\n      return true;\n    }\n  }]);\n  return Circle2;\n}();\nvar Bar = /* @__PURE__ */ function() {\n  function Bar2() {\n    _classCallCheck2(this, Bar2);\n  }\n  _createClass2(Bar2, null, [{\n    key: \"draw\",\n    value: function draw(ctx, arrowData) {\n      var points = [{\n        x: 0,\n        y: 0.5\n      }, {\n        x: 0,\n        y: -0.5\n      }, {\n        x: -0.15,\n        y: -0.5\n      }, {\n        x: -0.15,\n        y: 0.5\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Bar2;\n}();\nvar Box = /* @__PURE__ */ function() {\n  function Box2() {\n    _classCallCheck2(this, Box2);\n  }\n  _createClass2(Box2, null, [{\n    key: \"draw\",\n    value: function draw(ctx, arrowData) {\n      var points = [{\n        x: 0,\n        y: 0.3\n      }, {\n        x: 0,\n        y: -0.3\n      }, {\n        x: -0.6,\n        y: -0.3\n      }, {\n        x: -0.6,\n        y: 0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Box2;\n}();\nvar Diamond = /* @__PURE__ */ function() {\n  function Diamond2() {\n    _classCallCheck2(this, Diamond2);\n  }\n  _createClass2(Diamond2, null, [{\n    key: \"draw\",\n    value: function draw(ctx, arrowData) {\n      var points = [{\n        x: 0,\n        y: 0\n      }, {\n        x: -0.5,\n        y: -0.3\n      }, {\n        x: -1,\n        y: 0\n      }, {\n        x: -0.5,\n        y: 0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Diamond2;\n}();\nvar Vee = /* @__PURE__ */ function() {\n  function Vee2() {\n    _classCallCheck2(this, Vee2);\n  }\n  _createClass2(Vee2, null, [{\n    key: \"draw\",\n    value: function draw(ctx, arrowData) {\n      var points = [{\n        x: -1,\n        y: 0.3\n      }, {\n        x: -0.5,\n        y: 0\n      }, {\n        x: -1,\n        y: -0.3\n      }, {\n        x: 0,\n        y: 0\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Vee2;\n}();\nvar EndPoints = /* @__PURE__ */ function() {\n  function EndPoints2() {\n    _classCallCheck2(this, EndPoints2);\n  }\n  _createClass2(EndPoints2, null, [{\n    key: \"draw\",\n    value: function draw(ctx, arrowData) {\n      var type2;\n      if (arrowData.type) {\n        type2 = arrowData.type.toLowerCase();\n      }\n      switch (type2) {\n        case \"image\":\n          return Image$1.draw(ctx, arrowData);\n        case \"circle\":\n          return Circle.draw(ctx, arrowData);\n        case \"box\":\n          return Box.draw(ctx, arrowData);\n        case \"crow\":\n          return Crow.draw(ctx, arrowData);\n        case \"curve\":\n          return Curve.draw(ctx, arrowData);\n        case \"diamond\":\n          return Diamond.draw(ctx, arrowData);\n        case \"inv_curve\":\n          return InvertedCurve.draw(ctx, arrowData);\n        case \"triangle\":\n          return Triangle.draw(ctx, arrowData);\n        case \"inv_triangle\":\n          return InvertedTriangle.draw(ctx, arrowData);\n        case \"bar\":\n          return Bar.draw(ctx, arrowData);\n        case \"vee\":\n          return Vee.draw(ctx, arrowData);\n        case \"arrow\":\n        default:\n          return Arrow.draw(ctx, arrowData);\n      }\n    }\n  }]);\n  return EndPoints2;\n}();\nfunction ownKeys$12(object2, enumerableOnly) {\n  var keys$122 = keys32(object2);\n  if (getOwnPropertySymbols32) {\n    var symbols = getOwnPropertySymbols32(object2);\n    enumerableOnly && (symbols = filter22(symbols).call(symbols, function(sym) {\n      return getOwnPropertyDescriptor$32(object2, sym).enumerable;\n    })), keys$122.push.apply(keys$122, symbols);\n  }\n  return keys$122;\n}\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var _context2, _context3;\n    var source = arguments[i] != null ? arguments[i] : {};\n    i % 2 ? forEach$22(_context2 = ownKeys$12(Object(source), true)).call(_context2, function(key) {\n      _defineProperty2(target, key, source[key]);\n    }) : getOwnPropertyDescriptors22 ? defineProperties42(target, getOwnPropertyDescriptors22(source)) : forEach$22(_context3 = ownKeys$12(Object(source))).call(_context3, function(key) {\n      defineProperty$62(target, key, getOwnPropertyDescriptor$32(source, key));\n    });\n  }\n  return target;\n}\nvar EdgeBase = /* @__PURE__ */ function() {\n  function EdgeBase2(options2, _body, _labelModule) {\n    _classCallCheck2(this, EdgeBase2);\n    this._body = _body;\n    this._labelModule = _labelModule;\n    this.color = {};\n    this.colorDirty = true;\n    this.hoverWidth = 1.5;\n    this.selectionWidth = 2;\n    this.setOptions(options2);\n    this.fromPoint = this.from;\n    this.toPoint = this.to;\n  }\n  _createClass2(EdgeBase2, [{\n    key: \"connect\",\n    value: function connect() {\n      this.from = this._body.nodes[this.options.from];\n      this.to = this._body.nodes[this.options.to];\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      return false;\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      this.options = options2;\n      this.from = this._body.nodes[this.options.from];\n      this.to = this._body.nodes[this.options.to];\n      this.id = this.options.id;\n    }\n  }, {\n    key: \"drawLine\",\n    value: function drawLine(ctx, values32, _selected, _hover) {\n      var viaNode = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.getViaNode();\n      ctx.strokeStyle = this.getColor(ctx, values32);\n      ctx.lineWidth = values32.width;\n      if (values32.dashes !== false) {\n        this._drawDashedLine(ctx, values32, viaNode);\n      } else {\n        this._drawLine(ctx, values32, viaNode);\n      }\n    }\n  }, {\n    key: \"_drawLine\",\n    value: function _drawLine(ctx, values32, viaNode, fromPoint, toPoint) {\n      if (this.from != this.to) {\n        this._line(ctx, values32, viaNode, fromPoint, toPoint);\n      } else {\n        var _this$_getCircleData = this._getCircleData(ctx), _this$_getCircleData2 = _slicedToArray2(_this$_getCircleData, 3), x = _this$_getCircleData2[0], y = _this$_getCircleData2[1], radius = _this$_getCircleData2[2];\n        this._circle(ctx, values32, x, y, radius);\n      }\n    }\n  }, {\n    key: \"_drawDashedLine\",\n    value: function _drawDashedLine(ctx, values32, viaNode, _fromPoint, _toPoint) {\n      ctx.lineCap = \"round\";\n      var pattern2 = isArray$12(values32.dashes) ? values32.dashes : [5, 5];\n      if (ctx.setLineDash !== void 0) {\n        ctx.save();\n        ctx.setLineDash(pattern2);\n        ctx.lineDashOffset = 0;\n        if (this.from != this.to) {\n          this._line(ctx, values32, viaNode);\n        } else {\n          var _this$_getCircleData3 = this._getCircleData(ctx), _this$_getCircleData4 = _slicedToArray2(_this$_getCircleData3, 3), x = _this$_getCircleData4[0], y = _this$_getCircleData4[1], radius = _this$_getCircleData4[2];\n          this._circle(ctx, values32, x, y, radius);\n        }\n        ctx.setLineDash([0]);\n        ctx.lineDashOffset = 0;\n        ctx.restore();\n      } else {\n        if (this.from != this.to) {\n          drawDashedLine(ctx, this.from.x, this.from.y, this.to.x, this.to.y, pattern2);\n        } else {\n          var _this$_getCircleData5 = this._getCircleData(ctx), _this$_getCircleData6 = _slicedToArray2(_this$_getCircleData5, 3), _x = _this$_getCircleData6[0], _y = _this$_getCircleData6[1], _radius = _this$_getCircleData6[2];\n          this._circle(ctx, values32, _x, _y, _radius);\n        }\n        this.enableShadow(ctx, values32);\n        ctx.stroke();\n        this.disableShadow(ctx, values32);\n      }\n    }\n  }, {\n    key: \"findBorderPosition\",\n    value: function findBorderPosition(node, ctx, options2) {\n      if (this.from != this.to) {\n        return this._findBorderPosition(node, ctx, options2);\n      } else {\n        return this._findBorderPositionCircle(node, ctx, options2);\n      }\n    }\n  }, {\n    key: \"findBorderPositions\",\n    value: function findBorderPositions(ctx) {\n      if (this.from != this.to) {\n        return {\n          from: this._findBorderPosition(this.from, ctx),\n          to: this._findBorderPosition(this.to, ctx)\n        };\n      } else {\n        var _context;\n        var _this$_getCircleData$ = slice22(_context = this._getCircleData(ctx)).call(_context, 0, 2), _this$_getCircleData$2 = _slicedToArray2(_this$_getCircleData$, 2), x = _this$_getCircleData$2[0], y = _this$_getCircleData$2[1];\n        return {\n          from: this._findBorderPositionCircle(this.from, ctx, {\n            x,\n            y,\n            low: 0.25,\n            high: 0.6,\n            direction: -1\n          }),\n          to: this._findBorderPositionCircle(this.from, ctx, {\n            x,\n            y,\n            low: 0.6,\n            high: 0.8,\n            direction: 1\n          })\n        };\n      }\n    }\n  }, {\n    key: \"_getCircleData\",\n    value: function _getCircleData(ctx) {\n      var radius = this.options.selfReference.size;\n      if (ctx !== void 0) {\n        if (this.from.shape.width === void 0) {\n          this.from.shape.resize(ctx);\n        }\n      }\n      var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, radius, this.from);\n      return [coordinates.x, coordinates.y, radius];\n    }\n  }, {\n    key: \"_pointOnCircle\",\n    value: function _pointOnCircle(x, y, radius, position) {\n      var angle = position * 2 * Math.PI;\n      return {\n        x: x + radius * Math.cos(angle),\n        y: y - radius * Math.sin(angle)\n      };\n    }\n  }, {\n    key: \"_findBorderPositionCircle\",\n    value: function _findBorderPositionCircle(nearNode, ctx, options2) {\n      var x = options2.x;\n      var y = options2.y;\n      var low22 = options2.low;\n      var high = options2.high;\n      var direction = options2.direction;\n      var maxIterations = 10;\n      var radius = this.options.selfReference.size;\n      var threshold = 0.05;\n      var pos;\n      var middle = (low22 + high) * 0.5;\n      var endPointOffset = 0;\n      if (this.options.arrowStrikethrough === true) {\n        if (direction === -1) {\n          endPointOffset = this.options.endPointOffset.from;\n        } else if (direction === 1) {\n          endPointOffset = this.options.endPointOffset.to;\n        }\n      }\n      var iteration = 0;\n      do {\n        middle = (low22 + high) * 0.5;\n        pos = this._pointOnCircle(x, y, radius, middle);\n        var angle = Math.atan2(nearNode.y - pos.y, nearNode.x - pos.x);\n        var distanceToBorder = nearNode.distanceToBorder(ctx, angle) + endPointOffset;\n        var distanceToPoint = Math.sqrt(Math.pow(pos.x - nearNode.x, 2) + Math.pow(pos.y - nearNode.y, 2));\n        var difference = distanceToBorder - distanceToPoint;\n        if (Math.abs(difference) < threshold) {\n          break;\n        } else if (difference > 0) {\n          if (direction > 0) {\n            low22 = middle;\n          } else {\n            high = middle;\n          }\n        } else {\n          if (direction > 0) {\n            high = middle;\n          } else {\n            low22 = middle;\n          }\n        }\n        ++iteration;\n      } while (low22 <= high && iteration < maxIterations);\n      return _objectSpread$1(_objectSpread$1({}, pos), {}, {\n        t: middle\n      });\n    }\n  }, {\n    key: \"getLineWidth\",\n    value: function getLineWidth(selected, hover) {\n      if (selected === true) {\n        return Math.max(this.selectionWidth, 0.3 / this._body.view.scale);\n      } else if (hover === true) {\n        return Math.max(this.hoverWidth, 0.3 / this._body.view.scale);\n      } else {\n        return Math.max(this.options.width, 0.3 / this._body.view.scale);\n      }\n    }\n  }, {\n    key: \"getColor\",\n    value: function getColor(ctx, values32) {\n      if (values32.inheritsColor !== false) {\n        if (values32.inheritsColor === \"both\" && this.from.id !== this.to.id) {\n          var grd = ctx.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);\n          var fromColor = this.from.options.color.highlight.border;\n          var toColor = this.to.options.color.highlight.border;\n          if (this.from.selected === false && this.to.selected === false) {\n            fromColor = overrideOpacity(this.from.options.color.border, values32.opacity);\n            toColor = overrideOpacity(this.to.options.color.border, values32.opacity);\n          } else if (this.from.selected === true && this.to.selected === false) {\n            toColor = this.to.options.color.border;\n          } else if (this.from.selected === false && this.to.selected === true) {\n            fromColor = this.from.options.color.border;\n          }\n          grd.addColorStop(0, fromColor);\n          grd.addColorStop(1, toColor);\n          return grd;\n        }\n        if (values32.inheritsColor === \"to\") {\n          return overrideOpacity(this.to.options.color.border, values32.opacity);\n        } else {\n          return overrideOpacity(this.from.options.color.border, values32.opacity);\n        }\n      } else {\n        return overrideOpacity(values32.color, values32.opacity);\n      }\n    }\n  }, {\n    key: \"_circle\",\n    value: function _circle(ctx, values32, x, y, radius) {\n      this.enableShadow(ctx, values32);\n      var angleFrom = 0;\n      var angleTo = Math.PI * 2;\n      if (!this.options.selfReference.renderBehindTheNode) {\n        var low22 = this.options.selfReference.angle;\n        var high = this.options.selfReference.angle + Math.PI;\n        var pointTFrom = this._findBorderPositionCircle(this.from, ctx, {\n          x,\n          y,\n          low: low22,\n          high,\n          direction: -1\n        });\n        var pointTTo = this._findBorderPositionCircle(this.from, ctx, {\n          x,\n          y,\n          low: low22,\n          high,\n          direction: 1\n        });\n        angleFrom = Math.atan2(pointTFrom.y - y, pointTFrom.x - x);\n        angleTo = Math.atan2(pointTTo.y - y, pointTTo.x - x);\n      }\n      ctx.beginPath();\n      ctx.arc(x, y, radius, angleFrom, angleTo, false);\n      ctx.stroke();\n      this.disableShadow(ctx, values32);\n    }\n  }, {\n    key: \"getDistanceToEdge\",\n    value: function getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      if (this.from != this.to) {\n        return this._getDistanceToEdge(x1, y1, x2, y2, x3, y3);\n      } else {\n        var _this$_getCircleData7 = this._getCircleData(void 0), _this$_getCircleData8 = _slicedToArray2(_this$_getCircleData7, 3), x = _this$_getCircleData8[0], y = _this$_getCircleData8[1], radius = _this$_getCircleData8[2];\n        var dx = x - x3;\n        var dy = y - y3;\n        return Math.abs(Math.sqrt(dx * dx + dy * dy) - radius);\n      }\n    }\n  }, {\n    key: \"_getDistanceToLine\",\n    value: function _getDistanceToLine(x1, y1, x2, y2, x3, y3) {\n      var px = x2 - x1;\n      var py = y2 - y1;\n      var something22 = px * px + py * py;\n      var u = ((x3 - x1) * px + (y3 - y1) * py) / something22;\n      if (u > 1) {\n        u = 1;\n      } else if (u < 0) {\n        u = 0;\n      }\n      var x = x1 + u * px;\n      var y = y1 + u * py;\n      var dx = x - x3;\n      var dy = y - y3;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n  }, {\n    key: \"getArrowData\",\n    value: function getArrowData(ctx, position, viaNode, _selected, _hover, values32) {\n      var angle;\n      var arrowPoint;\n      var node1;\n      var node2;\n      var reversed;\n      var scaleFactor;\n      var type2;\n      var lineWidth = values32.width;\n      if (position === \"from\") {\n        node1 = this.from;\n        node2 = this.to;\n        reversed = values32.fromArrowScale < 0;\n        scaleFactor = Math.abs(values32.fromArrowScale);\n        type2 = values32.fromArrowType;\n      } else if (position === \"to\") {\n        node1 = this.to;\n        node2 = this.from;\n        reversed = values32.toArrowScale < 0;\n        scaleFactor = Math.abs(values32.toArrowScale);\n        type2 = values32.toArrowType;\n      } else {\n        node1 = this.to;\n        node2 = this.from;\n        reversed = values32.middleArrowScale < 0;\n        scaleFactor = Math.abs(values32.middleArrowScale);\n        type2 = values32.middleArrowType;\n      }\n      var length2 = 15 * scaleFactor + 3 * lineWidth;\n      if (node1 != node2) {\n        var approximateEdgeLength = hypot2(node1.x - node2.x, node1.y - node2.y);\n        var relativeLength = length2 / approximateEdgeLength;\n        if (position !== \"middle\") {\n          if (this.options.smooth.enabled === true) {\n            var pointT = this._findBorderPosition(node1, ctx, {\n              via: viaNode\n            });\n            var guidePos = this.getPoint(pointT.t + relativeLength * (position === \"from\" ? 1 : -1), viaNode);\n            angle = Math.atan2(pointT.y - guidePos.y, pointT.x - guidePos.x);\n            arrowPoint = pointT;\n          } else {\n            angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);\n            arrowPoint = this._findBorderPosition(node1, ctx);\n          }\n        } else {\n          var halfLength = (reversed ? -relativeLength : relativeLength) / 2;\n          var guidePos1 = this.getPoint(0.5 + halfLength, viaNode);\n          var guidePos2 = this.getPoint(0.5 - halfLength, viaNode);\n          angle = Math.atan2(guidePos1.y - guidePos2.y, guidePos1.x - guidePos2.x);\n          arrowPoint = this.getPoint(0.5, viaNode);\n        }\n      } else {\n        var _this$_getCircleData9 = this._getCircleData(ctx), _this$_getCircleData10 = _slicedToArray2(_this$_getCircleData9, 3), x = _this$_getCircleData10[0], y = _this$_getCircleData10[1], radius = _this$_getCircleData10[2];\n        if (position === \"from\") {\n          var low22 = this.options.selfReference.angle;\n          var high = this.options.selfReference.angle + Math.PI;\n          var _pointT = this._findBorderPositionCircle(this.from, ctx, {\n            x,\n            y,\n            low: low22,\n            high,\n            direction: -1\n          });\n          angle = _pointT.t * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;\n          arrowPoint = _pointT;\n        } else if (position === \"to\") {\n          var _low = this.options.selfReference.angle;\n          var _high = this.options.selfReference.angle + Math.PI;\n          var _pointT2 = this._findBorderPositionCircle(this.from, ctx, {\n            x,\n            y,\n            low: _low,\n            high: _high,\n            direction: 1\n          });\n          angle = _pointT2.t * -2 * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI;\n          arrowPoint = _pointT2;\n        } else {\n          var pos = this.options.selfReference.angle / (2 * Math.PI);\n          arrowPoint = this._pointOnCircle(x, y, radius, pos);\n          angle = pos * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;\n        }\n      }\n      var xi = arrowPoint.x - length2 * 0.9 * Math.cos(angle);\n      var yi = arrowPoint.y - length2 * 0.9 * Math.sin(angle);\n      var arrowCore = {\n        x: xi,\n        y: yi\n      };\n      return {\n        point: arrowPoint,\n        core: arrowCore,\n        angle,\n        length: length2,\n        type: type2\n      };\n    }\n  }, {\n    key: \"drawArrowHead\",\n    value: function drawArrowHead(ctx, values32, _selected, _hover, arrowData) {\n      ctx.strokeStyle = this.getColor(ctx, values32);\n      ctx.fillStyle = ctx.strokeStyle;\n      ctx.lineWidth = values32.width;\n      var canFill = EndPoints.draw(ctx, arrowData);\n      if (canFill) {\n        this.enableShadow(ctx, values32);\n        fill22(ctx).call(ctx);\n        this.disableShadow(ctx, values32);\n      }\n    }\n  }, {\n    key: \"enableShadow\",\n    value: function enableShadow(ctx, values32) {\n      if (values32.shadow === true) {\n        ctx.shadowColor = values32.shadowColor;\n        ctx.shadowBlur = values32.shadowSize;\n        ctx.shadowOffsetX = values32.shadowX;\n        ctx.shadowOffsetY = values32.shadowY;\n      }\n    }\n  }, {\n    key: \"disableShadow\",\n    value: function disableShadow(ctx, values32) {\n      if (values32.shadow === true) {\n        ctx.shadowColor = \"rgba(0,0,0,0)\";\n        ctx.shadowBlur = 0;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n      }\n    }\n  }, {\n    key: \"drawBackground\",\n    value: function drawBackground(ctx, values32) {\n      if (values32.background !== false) {\n        var origCtxAttr = {\n          strokeStyle: ctx.strokeStyle,\n          lineWidth: ctx.lineWidth,\n          dashes: ctx.dashes\n        };\n        ctx.strokeStyle = values32.backgroundColor;\n        ctx.lineWidth = values32.backgroundSize;\n        this.setStrokeDashed(ctx, values32.backgroundDashes);\n        ctx.stroke();\n        ctx.strokeStyle = origCtxAttr.strokeStyle;\n        ctx.lineWidth = origCtxAttr.lineWidth;\n        ctx.dashes = origCtxAttr.dashes;\n        this.setStrokeDashed(ctx, values32.dashes);\n      }\n    }\n  }, {\n    key: \"setStrokeDashed\",\n    value: function setStrokeDashed(ctx, dashes) {\n      if (dashes !== false) {\n        if (ctx.setLineDash !== void 0) {\n          var pattern2 = isArray$12(dashes) ? dashes : [5, 5];\n          ctx.setLineDash(pattern2);\n        } else {\n          console.warn(\"setLineDash is not supported in this browser. The dashed stroke cannot be used.\");\n        }\n      } else {\n        if (ctx.setLineDash !== void 0) {\n          ctx.setLineDash([]);\n        } else {\n          console.warn(\"setLineDash is not supported in this browser. The dashed stroke cannot be used.\");\n        }\n      }\n    }\n  }]);\n  return EdgeBase2;\n}();\nfunction ownKeys22(object2, enumerableOnly) {\n  var keys$122 = keys32(object2);\n  if (getOwnPropertySymbols32) {\n    var symbols = getOwnPropertySymbols32(object2);\n    enumerableOnly && (symbols = filter22(symbols).call(symbols, function(sym) {\n      return getOwnPropertyDescriptor$32(object2, sym).enumerable;\n    })), keys$122.push.apply(keys$122, symbols);\n  }\n  return keys$122;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var _context, _context2;\n    var source = arguments[i] != null ? arguments[i] : {};\n    i % 2 ? forEach$22(_context = ownKeys22(Object(source), true)).call(_context, function(key) {\n      _defineProperty2(target, key, source[key]);\n    }) : getOwnPropertyDescriptors22 ? defineProperties42(target, getOwnPropertyDescriptors22(source)) : forEach$22(_context2 = ownKeys22(Object(source))).call(_context2, function(key) {\n      defineProperty$62(target, key, getOwnPropertyDescriptor$32(source, key));\n    });\n  }\n  return target;\n}\nfunction _createSuper$9(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$9() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar BezierEdgeBase = /* @__PURE__ */ function(_EdgeBase) {\n  _inherits2(BezierEdgeBase2, _EdgeBase);\n  var _super = _createSuper$9(BezierEdgeBase2);\n  function BezierEdgeBase2(options2, body, labelModule) {\n    _classCallCheck2(this, BezierEdgeBase2);\n    return _super.call(this, options2, body, labelModule);\n  }\n  _createClass2(BezierEdgeBase2, [{\n    key: \"_findBorderPositionBezier\",\n    value: function _findBorderPositionBezier(nearNode, ctx) {\n      var viaNode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this._getViaCoordinates();\n      var maxIterations = 10;\n      var threshold = 0.2;\n      var from32 = false;\n      var high = 1;\n      var low22 = 0;\n      var node = this.to;\n      var pos;\n      var middle;\n      var endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.to : 0;\n      if (nearNode.id === this.from.id) {\n        node = this.from;\n        from32 = true;\n        endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.from : 0;\n      }\n      if (this.options.arrowStrikethrough === false) {\n        endPointOffset = 0;\n      }\n      var iteration = 0;\n      do {\n        middle = (low22 + high) * 0.5;\n        pos = this.getPoint(middle, viaNode);\n        var angle = Math.atan2(node.y - pos.y, node.x - pos.x);\n        var distanceToBorder = node.distanceToBorder(ctx, angle) + endPointOffset;\n        var distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));\n        var difference = distanceToBorder - distanceToPoint;\n        if (Math.abs(difference) < threshold) {\n          break;\n        } else if (difference < 0) {\n          if (from32 === false) {\n            low22 = middle;\n          } else {\n            high = middle;\n          }\n        } else {\n          if (from32 === false) {\n            high = middle;\n          } else {\n            low22 = middle;\n          }\n        }\n        ++iteration;\n      } while (low22 <= high && iteration < maxIterations);\n      return _objectSpread2(_objectSpread2({}, pos), {}, {\n        t: middle\n      });\n    }\n  }, {\n    key: \"_getDistanceToBezierEdge\",\n    value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via) {\n      var minDistance = 1e9;\n      var distance;\n      var i, t, x, y;\n      var lastX = x1;\n      var lastY = y1;\n      for (i = 1; i < 10; i++) {\n        t = 0.1 * i;\n        x = Math.pow(1 - t, 2) * x1 + 2 * t * (1 - t) * via.x + Math.pow(t, 2) * x2;\n        y = Math.pow(1 - t, 2) * y1 + 2 * t * (1 - t) * via.y + Math.pow(t, 2) * y2;\n        if (i > 0) {\n          distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);\n          minDistance = distance < minDistance ? distance : minDistance;\n        }\n        lastX = x;\n        lastY = y;\n      }\n      return minDistance;\n    }\n  }, {\n    key: \"_bezierCurve\",\n    value: function _bezierCurve(ctx, values32, viaNode1, viaNode2) {\n      ctx.beginPath();\n      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);\n      if (viaNode1 != null && viaNode1.x != null) {\n        if (viaNode2 != null && viaNode2.x != null) {\n          ctx.bezierCurveTo(viaNode1.x, viaNode1.y, viaNode2.x, viaNode2.y, this.toPoint.x, this.toPoint.y);\n        } else {\n          ctx.quadraticCurveTo(viaNode1.x, viaNode1.y, this.toPoint.x, this.toPoint.y);\n        }\n      } else {\n        ctx.lineTo(this.toPoint.x, this.toPoint.y);\n      }\n      this.drawBackground(ctx, values32);\n      this.enableShadow(ctx, values32);\n      ctx.stroke();\n      this.disableShadow(ctx, values32);\n    }\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return this._getViaCoordinates();\n    }\n  }]);\n  return BezierEdgeBase2;\n}(EdgeBase);\nfunction _createSuper$8(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$8() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar BezierEdgeDynamic = /* @__PURE__ */ function(_BezierEdgeBase) {\n  _inherits2(BezierEdgeDynamic2, _BezierEdgeBase);\n  var _super = _createSuper$8(BezierEdgeDynamic2);\n  function BezierEdgeDynamic2(options2, body, labelModule) {\n    var _this;\n    _classCallCheck2(this, BezierEdgeDynamic2);\n    _this = _super.call(this, options2, body, labelModule);\n    _this.via = _this.via;\n    _this._boundFunction = function() {\n      _this.positionBezierNode();\n    };\n    _this._body.emitter.on(\"_repositionBezierNodes\", _this._boundFunction);\n    return _this;\n  }\n  _createClass2(BezierEdgeDynamic2, [{\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      _get(_getPrototypeOf2(BezierEdgeDynamic2.prototype), \"setOptions\", this).call(this, options2);\n      var physicsChange = false;\n      if (this.options.physics !== options2.physics) {\n        physicsChange = true;\n      }\n      this.options = options2;\n      this.id = this.options.id;\n      this.from = this._body.nodes[this.options.from];\n      this.to = this._body.nodes[this.options.to];\n      this.setupSupportNode();\n      this.connect();\n      if (physicsChange === true) {\n        this.via.setOptions({\n          physics: this.options.physics\n        });\n        this.positionBezierNode();\n      }\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      this.from = this._body.nodes[this.options.from];\n      this.to = this._body.nodes[this.options.to];\n      if (this.from === void 0 || this.to === void 0 || this.options.physics === false) {\n        this.via.setOptions({\n          physics: false\n        });\n      } else {\n        if (this.from.id === this.to.id) {\n          this.via.setOptions({\n            physics: false\n          });\n        } else {\n          this.via.setOptions({\n            physics: true\n          });\n        }\n      }\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      this._body.emitter.off(\"_repositionBezierNodes\", this._boundFunction);\n      if (this.via !== void 0) {\n        delete this._body.nodes[this.via.id];\n        this.via = void 0;\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"setupSupportNode\",\n    value: function setupSupportNode() {\n      if (this.via === void 0) {\n        var nodeId = \"edgeId:\" + this.id;\n        var node = this._body.functions.createNode({\n          id: nodeId,\n          shape: \"circle\",\n          physics: true,\n          hidden: true\n        });\n        this._body.nodes[nodeId] = node;\n        this.via = node;\n        this.via.parentEdgeId = this.id;\n        this.positionBezierNode();\n      }\n    }\n  }, {\n    key: \"positionBezierNode\",\n    value: function positionBezierNode() {\n      if (this.via !== void 0 && this.from !== void 0 && this.to !== void 0) {\n        this.via.x = 0.5 * (this.from.x + this.to.x);\n        this.via.y = 0.5 * (this.from.y + this.to.y);\n      } else if (this.via !== void 0) {\n        this.via.x = 0;\n        this.via.y = 0;\n      }\n    }\n  }, {\n    key: \"_line\",\n    value: function _line(ctx, values32, viaNode) {\n      this._bezierCurve(ctx, values32, viaNode);\n    }\n  }, {\n    key: \"_getViaCoordinates\",\n    value: function _getViaCoordinates() {\n      return this.via;\n    }\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return this.via;\n    }\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(position) {\n      var viaNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.via;\n      if (this.from === this.to) {\n        var _this$_getCircleData = this._getCircleData(), _this$_getCircleData2 = _slicedToArray2(_this$_getCircleData, 3), cx = _this$_getCircleData2[0], cy = _this$_getCircleData2[1], cr = _this$_getCircleData2[2];\n        var a = 2 * Math.PI * (1 - position);\n        return {\n          x: cx + cr * Math.sin(a),\n          y: cy + cr - cr * (1 - Math.cos(a))\n        };\n      } else {\n        return {\n          x: Math.pow(1 - position, 2) * this.fromPoint.x + 2 * position * (1 - position) * viaNode.x + Math.pow(position, 2) * this.toPoint.x,\n          y: Math.pow(1 - position, 2) * this.fromPoint.y + 2 * position * (1 - position) * viaNode.y + Math.pow(position, 2) * this.toPoint.y\n        };\n      }\n    }\n  }, {\n    key: \"_findBorderPosition\",\n    value: function _findBorderPosition(nearNode, ctx) {\n      return this._findBorderPositionBezier(nearNode, ctx, this.via);\n    }\n  }, {\n    key: \"_getDistanceToEdge\",\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, this.via);\n    }\n  }]);\n  return BezierEdgeDynamic2;\n}(BezierEdgeBase);\nfunction _createSuper$7(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$7() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar BezierEdgeStatic = /* @__PURE__ */ function(_BezierEdgeBase) {\n  _inherits2(BezierEdgeStatic2, _BezierEdgeBase);\n  var _super = _createSuper$7(BezierEdgeStatic2);\n  function BezierEdgeStatic2(options2, body, labelModule) {\n    _classCallCheck2(this, BezierEdgeStatic2);\n    return _super.call(this, options2, body, labelModule);\n  }\n  _createClass2(BezierEdgeStatic2, [{\n    key: \"_line\",\n    value: function _line(ctx, values32, viaNode) {\n      this._bezierCurve(ctx, values32, viaNode);\n    }\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return this._getViaCoordinates();\n    }\n  }, {\n    key: \"_getViaCoordinates\",\n    value: function _getViaCoordinates() {\n      var factor = this.options.smooth.roundness;\n      var type2 = this.options.smooth.type;\n      var dx = Math.abs(this.from.x - this.to.x);\n      var dy = Math.abs(this.from.y - this.to.y);\n      if (type2 === \"discrete\" || type2 === \"diagonalCross\") {\n        var stepX;\n        var stepY;\n        if (dx <= dy) {\n          stepX = stepY = factor * dy;\n        } else {\n          stepX = stepY = factor * dx;\n        }\n        if (this.from.x > this.to.x) {\n          stepX = -stepX;\n        }\n        if (this.from.y >= this.to.y) {\n          stepY = -stepY;\n        }\n        var xVia = this.from.x + stepX;\n        var yVia = this.from.y + stepY;\n        if (type2 === \"discrete\") {\n          if (dx <= dy) {\n            xVia = dx < factor * dy ? this.from.x : xVia;\n          } else {\n            yVia = dy < factor * dx ? this.from.y : yVia;\n          }\n        }\n        return {\n          x: xVia,\n          y: yVia\n        };\n      } else if (type2 === \"straightCross\") {\n        var _stepX = (1 - factor) * dx;\n        var _stepY = (1 - factor) * dy;\n        if (dx <= dy) {\n          _stepX = 0;\n          if (this.from.y < this.to.y) {\n            _stepY = -_stepY;\n          }\n        } else {\n          if (this.from.x < this.to.x) {\n            _stepX = -_stepX;\n          }\n          _stepY = 0;\n        }\n        return {\n          x: this.to.x + _stepX,\n          y: this.to.y + _stepY\n        };\n      } else if (type2 === \"horizontal\") {\n        var _stepX2 = (1 - factor) * dx;\n        if (this.from.x < this.to.x) {\n          _stepX2 = -_stepX2;\n        }\n        return {\n          x: this.to.x + _stepX2,\n          y: this.from.y\n        };\n      } else if (type2 === \"vertical\") {\n        var _stepY2 = (1 - factor) * dy;\n        if (this.from.y < this.to.y) {\n          _stepY2 = -_stepY2;\n        }\n        return {\n          x: this.from.x,\n          y: this.to.y + _stepY2\n        };\n      } else if (type2 === \"curvedCW\") {\n        dx = this.to.x - this.from.x;\n        dy = this.from.y - this.to.y;\n        var radius = Math.sqrt(dx * dx + dy * dy);\n        var pi = Math.PI;\n        var originalAngle = Math.atan2(dy, dx);\n        var myAngle = (originalAngle + (factor * 0.5 + 0.5) * pi) % (2 * pi);\n        return {\n          x: this.from.x + (factor * 0.5 + 0.5) * radius * Math.sin(myAngle),\n          y: this.from.y + (factor * 0.5 + 0.5) * radius * Math.cos(myAngle)\n        };\n      } else if (type2 === \"curvedCCW\") {\n        dx = this.to.x - this.from.x;\n        dy = this.from.y - this.to.y;\n        var _radius = Math.sqrt(dx * dx + dy * dy);\n        var _pi = Math.PI;\n        var _originalAngle = Math.atan2(dy, dx);\n        var _myAngle = (_originalAngle + (-factor * 0.5 + 0.5) * _pi) % (2 * _pi);\n        return {\n          x: this.from.x + (factor * 0.5 + 0.5) * _radius * Math.sin(_myAngle),\n          y: this.from.y + (factor * 0.5 + 0.5) * _radius * Math.cos(_myAngle)\n        };\n      } else {\n        var _stepX3;\n        var _stepY3;\n        if (dx <= dy) {\n          _stepX3 = _stepY3 = factor * dy;\n        } else {\n          _stepX3 = _stepY3 = factor * dx;\n        }\n        if (this.from.x > this.to.x) {\n          _stepX3 = -_stepX3;\n        }\n        if (this.from.y >= this.to.y) {\n          _stepY3 = -_stepY3;\n        }\n        var _xVia = this.from.x + _stepX3;\n        var _yVia = this.from.y + _stepY3;\n        if (dx <= dy) {\n          if (this.from.x <= this.to.x) {\n            _xVia = this.to.x < _xVia ? this.to.x : _xVia;\n          } else {\n            _xVia = this.to.x > _xVia ? this.to.x : _xVia;\n          }\n        } else {\n          if (this.from.y >= this.to.y) {\n            _yVia = this.to.y > _yVia ? this.to.y : _yVia;\n          } else {\n            _yVia = this.to.y < _yVia ? this.to.y : _yVia;\n          }\n        }\n        return {\n          x: _xVia,\n          y: _yVia\n        };\n      }\n    }\n  }, {\n    key: \"_findBorderPosition\",\n    value: function _findBorderPosition(nearNode, ctx) {\n      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n      return this._findBorderPositionBezier(nearNode, ctx, options2.via);\n    }\n  }, {\n    key: \"_getDistanceToEdge\",\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      var viaNode = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this._getViaCoordinates();\n      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, viaNode);\n    }\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(position) {\n      var viaNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getViaCoordinates();\n      var t = position;\n      var x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;\n      var y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;\n      return {\n        x,\n        y\n      };\n    }\n  }]);\n  return BezierEdgeStatic2;\n}(BezierEdgeBase);\nfunction _createSuper$6(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$6() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar CubicBezierEdgeBase = /* @__PURE__ */ function(_BezierEdgeBase) {\n  _inherits2(CubicBezierEdgeBase2, _BezierEdgeBase);\n  var _super = _createSuper$6(CubicBezierEdgeBase2);\n  function CubicBezierEdgeBase2(options2, body, labelModule) {\n    _classCallCheck2(this, CubicBezierEdgeBase2);\n    return _super.call(this, options2, body, labelModule);\n  }\n  _createClass2(CubicBezierEdgeBase2, [{\n    key: \"_getDistanceToBezierEdge2\",\n    value: function _getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2) {\n      var minDistance = 1e9;\n      var lastX = x1;\n      var lastY = y1;\n      var vec = [0, 0, 0, 0];\n      for (var i = 1; i < 10; i++) {\n        var t = 0.1 * i;\n        vec[0] = Math.pow(1 - t, 3);\n        vec[1] = 3 * t * Math.pow(1 - t, 2);\n        vec[2] = 3 * Math.pow(t, 2) * (1 - t);\n        vec[3] = Math.pow(t, 3);\n        var x = vec[0] * x1 + vec[1] * via1.x + vec[2] * via2.x + vec[3] * x2;\n        var y = vec[0] * y1 + vec[1] * via1.y + vec[2] * via2.y + vec[3] * y2;\n        if (i > 0) {\n          var distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);\n          minDistance = distance < minDistance ? distance : minDistance;\n        }\n        lastX = x;\n        lastY = y;\n      }\n      return minDistance;\n    }\n  }]);\n  return CubicBezierEdgeBase2;\n}(BezierEdgeBase);\nfunction _createSuper$5(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$5() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar CubicBezierEdge = /* @__PURE__ */ function(_CubicBezierEdgeBase) {\n  _inherits2(CubicBezierEdge2, _CubicBezierEdgeBase);\n  var _super = _createSuper$5(CubicBezierEdge2);\n  function CubicBezierEdge2(options2, body, labelModule) {\n    _classCallCheck2(this, CubicBezierEdge2);\n    return _super.call(this, options2, body, labelModule);\n  }\n  _createClass2(CubicBezierEdge2, [{\n    key: \"_line\",\n    value: function _line(ctx, values32, viaNodes) {\n      var via1 = viaNodes[0];\n      var via2 = viaNodes[1];\n      this._bezierCurve(ctx, values32, via1, via2);\n    }\n  }, {\n    key: \"_getViaCoordinates\",\n    value: function _getViaCoordinates() {\n      var dx = this.from.x - this.to.x;\n      var dy = this.from.y - this.to.y;\n      var x1;\n      var y1;\n      var x2;\n      var y2;\n      var roundness = this.options.smooth.roundness;\n      if ((Math.abs(dx) > Math.abs(dy) || this.options.smooth.forceDirection === true || this.options.smooth.forceDirection === \"horizontal\") && this.options.smooth.forceDirection !== \"vertical\") {\n        y1 = this.from.y;\n        y2 = this.to.y;\n        x1 = this.from.x - roundness * dx;\n        x2 = this.to.x + roundness * dx;\n      } else {\n        y1 = this.from.y - roundness * dy;\n        y2 = this.to.y + roundness * dy;\n        x1 = this.from.x;\n        x2 = this.to.x;\n      }\n      return [{\n        x: x1,\n        y: y1\n      }, {\n        x: x2,\n        y: y2\n      }];\n    }\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return this._getViaCoordinates();\n    }\n  }, {\n    key: \"_findBorderPosition\",\n    value: function _findBorderPosition(nearNode, ctx) {\n      return this._findBorderPositionBezier(nearNode, ctx);\n    }\n  }, {\n    key: \"_getDistanceToEdge\",\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      var _ref = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this._getViaCoordinates(), _ref2 = _slicedToArray2(_ref, 2), via1 = _ref2[0], via2 = _ref2[1];\n      return this._getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2);\n    }\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(position) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getViaCoordinates(), _ref4 = _slicedToArray2(_ref3, 2), via1 = _ref4[0], via2 = _ref4[1];\n      var t = position;\n      var vec = [Math.pow(1 - t, 3), 3 * t * Math.pow(1 - t, 2), 3 * Math.pow(t, 2) * (1 - t), Math.pow(t, 3)];\n      var x = vec[0] * this.fromPoint.x + vec[1] * via1.x + vec[2] * via2.x + vec[3] * this.toPoint.x;\n      var y = vec[0] * this.fromPoint.y + vec[1] * via1.y + vec[2] * via2.y + vec[3] * this.toPoint.y;\n      return {\n        x,\n        y\n      };\n    }\n  }]);\n  return CubicBezierEdge2;\n}(CubicBezierEdgeBase);\nfunction _createSuper$4(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$4() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar StraightEdge = /* @__PURE__ */ function(_EdgeBase) {\n  _inherits2(StraightEdge2, _EdgeBase);\n  var _super = _createSuper$4(StraightEdge2);\n  function StraightEdge2(options2, body, labelModule) {\n    _classCallCheck2(this, StraightEdge2);\n    return _super.call(this, options2, body, labelModule);\n  }\n  _createClass2(StraightEdge2, [{\n    key: \"_line\",\n    value: function _line(ctx, values32) {\n      ctx.beginPath();\n      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);\n      ctx.lineTo(this.toPoint.x, this.toPoint.y);\n      this.enableShadow(ctx, values32);\n      ctx.stroke();\n      this.disableShadow(ctx, values32);\n    }\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return void 0;\n    }\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(position) {\n      return {\n        x: (1 - position) * this.fromPoint.x + position * this.toPoint.x,\n        y: (1 - position) * this.fromPoint.y + position * this.toPoint.y\n      };\n    }\n  }, {\n    key: \"_findBorderPosition\",\n    value: function _findBorderPosition(nearNode, ctx) {\n      var node1 = this.to;\n      var node2 = this.from;\n      if (nearNode.id === this.from.id) {\n        node1 = this.from;\n        node2 = this.to;\n      }\n      var angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);\n      var dx = node1.x - node2.x;\n      var dy = node1.y - node2.y;\n      var edgeSegmentLength = Math.sqrt(dx * dx + dy * dy);\n      var toBorderDist = nearNode.distanceToBorder(ctx, angle);\n      var toBorderPoint = (edgeSegmentLength - toBorderDist) / edgeSegmentLength;\n      return {\n        x: (1 - toBorderPoint) * node2.x + toBorderPoint * node1.x,\n        y: (1 - toBorderPoint) * node2.y + toBorderPoint * node1.y,\n        t: 0\n      };\n    }\n  }, {\n    key: \"_getDistanceToEdge\",\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      return this._getDistanceToLine(x1, y1, x2, y2, x3, y3);\n    }\n  }]);\n  return StraightEdge2;\n}(EdgeBase);\nvar Edge = /* @__PURE__ */ function() {\n  function Edge2(options2, body, imagelist, globalOptions, defaultOptions) {\n    _classCallCheck2(this, Edge2);\n    if (body === void 0) {\n      throw new Error(\"No body provided\");\n    }\n    this.options = bridgeObject(globalOptions);\n    this.globalOptions = globalOptions;\n    this.defaultOptions = defaultOptions;\n    this.body = body;\n    this.imagelist = imagelist;\n    this.id = void 0;\n    this.fromId = void 0;\n    this.toId = void 0;\n    this.selected = false;\n    this.hover = false;\n    this.labelDirty = true;\n    this.baseWidth = this.options.width;\n    this.baseFontSize = this.options.font.size;\n    this.from = void 0;\n    this.to = void 0;\n    this.edgeType = void 0;\n    this.connected = false;\n    this.labelModule = new Label(this.body, this.options, true);\n    this.setOptions(options2);\n  }\n  _createClass2(Edge2, [{\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      if (!options2) {\n        return;\n      }\n      var affectsLayout = typeof options2.physics !== \"undefined\" && this.options.physics !== options2.physics || typeof options2.hidden !== \"undefined\" && (this.options.hidden || false) !== (options2.hidden || false) || typeof options2.from !== \"undefined\" && this.options.from !== options2.from || typeof options2.to !== \"undefined\" && this.options.to !== options2.to;\n      Edge2.parseOptions(this.options, options2, true, this.globalOptions);\n      if (options2.id !== void 0) {\n        this.id = options2.id;\n      }\n      if (options2.from !== void 0) {\n        this.fromId = options2.from;\n      }\n      if (options2.to !== void 0) {\n        this.toId = options2.to;\n      }\n      if (options2.title !== void 0) {\n        this.title = options2.title;\n      }\n      if (options2.value !== void 0) {\n        options2.value = _parseFloat(options2.value);\n      }\n      var pile = [options2, this.options, this.defaultOptions];\n      this.chooser = choosify(\"edge\", pile);\n      this.updateLabelModule(options2);\n      affectsLayout = this.updateEdgeType() || affectsLayout;\n      this._setInteractionWidths();\n      this.connect();\n      return affectsLayout;\n    }\n  }, {\n    key: \"getFormattingValues\",\n    value: function getFormattingValues() {\n      var toArrow = this.options.arrows.to === true || this.options.arrows.to.enabled === true;\n      var fromArrow = this.options.arrows.from === true || this.options.arrows.from.enabled === true;\n      var middleArrow = this.options.arrows.middle === true || this.options.arrows.middle.enabled === true;\n      var inheritsColor = this.options.color.inherit;\n      var values32 = {\n        toArrow,\n        toArrowScale: this.options.arrows.to.scaleFactor,\n        toArrowType: this.options.arrows.to.type,\n        toArrowSrc: this.options.arrows.to.src,\n        toArrowImageWidth: this.options.arrows.to.imageWidth,\n        toArrowImageHeight: this.options.arrows.to.imageHeight,\n        middleArrow,\n        middleArrowScale: this.options.arrows.middle.scaleFactor,\n        middleArrowType: this.options.arrows.middle.type,\n        middleArrowSrc: this.options.arrows.middle.src,\n        middleArrowImageWidth: this.options.arrows.middle.imageWidth,\n        middleArrowImageHeight: this.options.arrows.middle.imageHeight,\n        fromArrow,\n        fromArrowScale: this.options.arrows.from.scaleFactor,\n        fromArrowType: this.options.arrows.from.type,\n        fromArrowSrc: this.options.arrows.from.src,\n        fromArrowImageWidth: this.options.arrows.from.imageWidth,\n        fromArrowImageHeight: this.options.arrows.from.imageHeight,\n        arrowStrikethrough: this.options.arrowStrikethrough,\n        color: inheritsColor ? void 0 : this.options.color.color,\n        inheritsColor,\n        opacity: this.options.color.opacity,\n        hidden: this.options.hidden,\n        length: this.options.length,\n        shadow: this.options.shadow.enabled,\n        shadowColor: this.options.shadow.color,\n        shadowSize: this.options.shadow.size,\n        shadowX: this.options.shadow.x,\n        shadowY: this.options.shadow.y,\n        dashes: this.options.dashes,\n        width: this.options.width,\n        background: this.options.background.enabled,\n        backgroundColor: this.options.background.color,\n        backgroundSize: this.options.background.size,\n        backgroundDashes: this.options.background.dashes\n      };\n      if (this.selected || this.hover) {\n        if (this.chooser === true) {\n          if (this.selected) {\n            var selectedWidth = this.options.selectionWidth;\n            if (typeof selectedWidth === \"function\") {\n              values32.width = selectedWidth(values32.width);\n            } else if (typeof selectedWidth === \"number\") {\n              values32.width += selectedWidth;\n            }\n            values32.width = Math.max(values32.width, 0.3 / this.body.view.scale);\n            values32.color = this.options.color.highlight;\n            values32.shadow = this.options.shadow.enabled;\n          } else if (this.hover) {\n            var hoverWidth = this.options.hoverWidth;\n            if (typeof hoverWidth === \"function\") {\n              values32.width = hoverWidth(values32.width);\n            } else if (typeof hoverWidth === \"number\") {\n              values32.width += hoverWidth;\n            }\n            values32.width = Math.max(values32.width, 0.3 / this.body.view.scale);\n            values32.color = this.options.color.hover;\n            values32.shadow = this.options.shadow.enabled;\n          }\n        } else if (typeof this.chooser === \"function\") {\n          this.chooser(values32, this.options.id, this.selected, this.hover);\n          if (values32.color !== void 0) {\n            values32.inheritsColor = false;\n          }\n          if (values32.shadow === false) {\n            if (values32.shadowColor !== this.options.shadow.color || values32.shadowSize !== this.options.shadow.size || values32.shadowX !== this.options.shadow.x || values32.shadowY !== this.options.shadow.y) {\n              values32.shadow = true;\n            }\n          }\n        }\n      } else {\n        values32.shadow = this.options.shadow.enabled;\n        values32.width = Math.max(values32.width, 0.3 / this.body.view.scale);\n      }\n      return values32;\n    }\n  }, {\n    key: \"updateLabelModule\",\n    value: function updateLabelModule(options2) {\n      var pile = [\n        options2,\n        this.options,\n        this.globalOptions,\n        this.defaultOptions\n      ];\n      this.labelModule.update(this.options, pile);\n      if (this.labelModule.baseSize !== void 0) {\n        this.baseFontSize = this.labelModule.baseSize;\n      }\n    }\n  }, {\n    key: \"updateEdgeType\",\n    value: function updateEdgeType() {\n      var smooth = this.options.smooth;\n      var dataChanged = false;\n      var changeInType = true;\n      if (this.edgeType !== void 0) {\n        if (this.edgeType instanceof BezierEdgeDynamic && smooth.enabled === true && smooth.type === \"dynamic\" || this.edgeType instanceof CubicBezierEdge && smooth.enabled === true && smooth.type === \"cubicBezier\" || this.edgeType instanceof BezierEdgeStatic && smooth.enabled === true && smooth.type !== \"dynamic\" && smooth.type !== \"cubicBezier\" || this.edgeType instanceof StraightEdge && smooth.type.enabled === false) {\n          changeInType = false;\n        }\n        if (changeInType === true) {\n          dataChanged = this.cleanup();\n        }\n      }\n      if (changeInType === true) {\n        if (smooth.enabled === true) {\n          if (smooth.type === \"dynamic\") {\n            dataChanged = true;\n            this.edgeType = new BezierEdgeDynamic(this.options, this.body, this.labelModule);\n          } else if (smooth.type === \"cubicBezier\") {\n            this.edgeType = new CubicBezierEdge(this.options, this.body, this.labelModule);\n          } else {\n            this.edgeType = new BezierEdgeStatic(this.options, this.body, this.labelModule);\n          }\n        } else {\n          this.edgeType = new StraightEdge(this.options, this.body, this.labelModule);\n        }\n      } else {\n        this.edgeType.setOptions(this.options);\n      }\n      return dataChanged;\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      this.disconnect();\n      this.from = this.body.nodes[this.fromId] || void 0;\n      this.to = this.body.nodes[this.toId] || void 0;\n      this.connected = this.from !== void 0 && this.to !== void 0;\n      if (this.connected === true) {\n        this.from.attachEdge(this);\n        this.to.attachEdge(this);\n      } else {\n        if (this.from) {\n          this.from.detachEdge(this);\n        }\n        if (this.to) {\n          this.to.detachEdge(this);\n        }\n      }\n      this.edgeType.connect();\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (this.from) {\n        this.from.detachEdge(this);\n        this.from = void 0;\n      }\n      if (this.to) {\n        this.to.detachEdge(this);\n        this.to = void 0;\n      }\n      this.connected = false;\n    }\n  }, {\n    key: \"getTitle\",\n    value: function getTitle() {\n      return this.title;\n    }\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return this.selected;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.options.value;\n    }\n  }, {\n    key: \"setValueRange\",\n    value: function setValueRange(min22, max22, total) {\n      if (this.options.value !== void 0) {\n        var scale = this.options.scaling.customScalingFunction(min22, max22, total, this.options.value);\n        var widthDiff = this.options.scaling.max - this.options.scaling.min;\n        if (this.options.scaling.label.enabled === true) {\n          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;\n          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;\n        }\n        this.options.width = this.options.scaling.min + scale * widthDiff;\n      } else {\n        this.options.width = this.baseWidth;\n        this.options.font.size = this.baseFontSize;\n      }\n      this._setInteractionWidths();\n      this.updateLabelModule();\n    }\n  }, {\n    key: \"_setInteractionWidths\",\n    value: function _setInteractionWidths() {\n      if (typeof this.options.hoverWidth === \"function\") {\n        this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width);\n      } else {\n        this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width;\n      }\n      if (typeof this.options.selectionWidth === \"function\") {\n        this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width);\n      } else {\n        this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      var values32 = this.getFormattingValues();\n      if (values32.hidden) {\n        return;\n      }\n      var viaNode = this.edgeType.getViaNode();\n      this.edgeType.drawLine(ctx, values32, this.selected, this.hover, viaNode);\n      this.drawLabel(ctx, viaNode);\n    }\n  }, {\n    key: \"drawArrows\",\n    value: function drawArrows(ctx) {\n      var values32 = this.getFormattingValues();\n      if (values32.hidden) {\n        return;\n      }\n      var viaNode = this.edgeType.getViaNode();\n      var arrowData = {};\n      this.edgeType.fromPoint = this.edgeType.from;\n      this.edgeType.toPoint = this.edgeType.to;\n      if (values32.fromArrow) {\n        arrowData.from = this.edgeType.getArrowData(ctx, \"from\", viaNode, this.selected, this.hover, values32);\n        if (values32.arrowStrikethrough === false)\n          this.edgeType.fromPoint = arrowData.from.core;\n        if (values32.fromArrowSrc) {\n          arrowData.from.image = this.imagelist.load(values32.fromArrowSrc);\n        }\n        if (values32.fromArrowImageWidth) {\n          arrowData.from.imageWidth = values32.fromArrowImageWidth;\n        }\n        if (values32.fromArrowImageHeight) {\n          arrowData.from.imageHeight = values32.fromArrowImageHeight;\n        }\n      }\n      if (values32.toArrow) {\n        arrowData.to = this.edgeType.getArrowData(ctx, \"to\", viaNode, this.selected, this.hover, values32);\n        if (values32.arrowStrikethrough === false)\n          this.edgeType.toPoint = arrowData.to.core;\n        if (values32.toArrowSrc) {\n          arrowData.to.image = this.imagelist.load(values32.toArrowSrc);\n        }\n        if (values32.toArrowImageWidth) {\n          arrowData.to.imageWidth = values32.toArrowImageWidth;\n        }\n        if (values32.toArrowImageHeight) {\n          arrowData.to.imageHeight = values32.toArrowImageHeight;\n        }\n      }\n      if (values32.middleArrow) {\n        arrowData.middle = this.edgeType.getArrowData(ctx, \"middle\", viaNode, this.selected, this.hover, values32);\n        if (values32.middleArrowSrc) {\n          arrowData.middle.image = this.imagelist.load(values32.middleArrowSrc);\n        }\n        if (values32.middleArrowImageWidth) {\n          arrowData.middle.imageWidth = values32.middleArrowImageWidth;\n        }\n        if (values32.middleArrowImageHeight) {\n          arrowData.middle.imageHeight = values32.middleArrowImageHeight;\n        }\n      }\n      if (values32.fromArrow) {\n        this.edgeType.drawArrowHead(ctx, values32, this.selected, this.hover, arrowData.from);\n      }\n      if (values32.middleArrow) {\n        this.edgeType.drawArrowHead(ctx, values32, this.selected, this.hover, arrowData.middle);\n      }\n      if (values32.toArrow) {\n        this.edgeType.drawArrowHead(ctx, values32, this.selected, this.hover, arrowData.to);\n      }\n    }\n  }, {\n    key: \"drawLabel\",\n    value: function drawLabel(ctx, viaNode) {\n      if (this.options.label !== void 0) {\n        var node1 = this.from;\n        var node2 = this.to;\n        if (this.labelModule.differentState(this.selected, this.hover)) {\n          this.labelModule.getTextSize(ctx, this.selected, this.hover);\n        }\n        var point;\n        if (node1.id != node2.id) {\n          this.labelModule.pointToSelf = false;\n          point = this.edgeType.getPoint(0.5, viaNode);\n          ctx.save();\n          var rotationPoint = this._getRotation(ctx);\n          if (rotationPoint.angle != 0) {\n            ctx.translate(rotationPoint.x, rotationPoint.y);\n            ctx.rotate(rotationPoint.angle);\n          }\n          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);\n          ctx.restore();\n        } else {\n          this.labelModule.pointToSelf = true;\n          var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, this.options.selfReference.size, node1);\n          point = this._pointOnCircle(coordinates.x, coordinates.y, this.options.selfReference.size, this.options.selfReference.angle);\n          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);\n        }\n      }\n    }\n  }, {\n    key: \"getItemsOnPoint\",\n    value: function getItemsOnPoint(point) {\n      var ret = [];\n      if (this.labelModule.visible()) {\n        var rotationPoint = this._getRotation();\n        if (pointInRect(this.labelModule.getSize(), point, rotationPoint)) {\n          ret.push({\n            edgeId: this.id,\n            labelId: 0\n          });\n        }\n      }\n      var obj = {\n        left: point.x,\n        top: point.y\n      };\n      if (this.isOverlappingWith(obj)) {\n        ret.push({\n          edgeId: this.id\n        });\n      }\n      return ret;\n    }\n  }, {\n    key: \"isOverlappingWith\",\n    value: function isOverlappingWith(obj) {\n      if (this.connected) {\n        var distMax = 10;\n        var xFrom = this.from.x;\n        var yFrom = this.from.y;\n        var xTo = this.to.x;\n        var yTo = this.to.y;\n        var xObj = obj.left;\n        var yObj = obj.top;\n        var dist = this.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, xObj, yObj);\n        return dist < distMax;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"_getRotation\",\n    value: function _getRotation(ctx) {\n      var viaNode = this.edgeType.getViaNode();\n      var point = this.edgeType.getPoint(0.5, viaNode);\n      if (ctx !== void 0) {\n        this.labelModule.calculateLabelSize(ctx, this.selected, this.hover, point.x, point.y);\n      }\n      var ret = {\n        x: point.x,\n        y: this.labelModule.size.yLine,\n        angle: 0\n      };\n      if (!this.labelModule.visible()) {\n        return ret;\n      }\n      if (this.options.font.align === \"horizontal\") {\n        return ret;\n      }\n      var dy = this.from.y - this.to.y;\n      var dx = this.from.x - this.to.x;\n      var angle = Math.atan2(dy, dx);\n      if (angle < -1 && dx < 0 || angle > 0 && dx < 0) {\n        angle += Math.PI;\n      }\n      ret.angle = angle;\n      return ret;\n    }\n  }, {\n    key: \"_pointOnCircle\",\n    value: function _pointOnCircle(x, y, radius, angle) {\n      return {\n        x: x + radius * Math.cos(angle),\n        y: y - radius * Math.sin(angle)\n      };\n    }\n  }, {\n    key: \"select\",\n    value: function select() {\n      this.selected = true;\n    }\n  }, {\n    key: \"unselect\",\n    value: function unselect() {\n      this.selected = false;\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      return this.edgeType.cleanup();\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      this.cleanup();\n      this.disconnect();\n      delete this.body.edges[this.id];\n    }\n  }, {\n    key: \"endPointsValid\",\n    value: function endPointsValid() {\n      return this.body.nodes[this.fromId] !== void 0 && this.body.nodes[this.toId] !== void 0;\n    }\n  }], [{\n    key: \"parseOptions\",\n    value: function parseOptions(parentOptions, newOptions) {\n      var allowDeletion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n      var globalOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n      var copyFromGlobals = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;\n      var fields = [\"endPointOffset\", \"arrowStrikethrough\", \"id\", \"from\", \"hidden\", \"hoverWidth\", \"labelHighlightBold\", \"length\", \"line\", \"opacity\", \"physics\", \"scaling\", \"selectionWidth\", \"selfReferenceSize\", \"selfReference\", \"to\", \"title\", \"value\", \"width\", \"font\", \"chosen\", \"widthConstraint\"];\n      selectiveDeepExtend(fields, parentOptions, newOptions, allowDeletion);\n      if (newOptions.endPointOffset !== void 0 && newOptions.endPointOffset.from !== void 0) {\n        if (_isFinite(newOptions.endPointOffset.from)) {\n          parentOptions.endPointOffset.from = newOptions.endPointOffset.from;\n        } else {\n          parentOptions.endPointOffset.from = globalOptions.endPointOffset.from !== void 0 ? globalOptions.endPointOffset.from : 0;\n          console.error(\"endPointOffset.from is not a valid number\");\n        }\n      }\n      if (newOptions.endPointOffset !== void 0 && newOptions.endPointOffset.to !== void 0) {\n        if (_isFinite(newOptions.endPointOffset.to)) {\n          parentOptions.endPointOffset.to = newOptions.endPointOffset.to;\n        } else {\n          parentOptions.endPointOffset.to = globalOptions.endPointOffset.to !== void 0 ? globalOptions.endPointOffset.to : 0;\n          console.error(\"endPointOffset.to is not a valid number\");\n        }\n      }\n      if (isValidLabel(newOptions.label)) {\n        parentOptions.label = newOptions.label;\n      } else if (!isValidLabel(parentOptions.label)) {\n        parentOptions.label = void 0;\n      }\n      mergeOptions(parentOptions, newOptions, \"smooth\", globalOptions);\n      mergeOptions(parentOptions, newOptions, \"shadow\", globalOptions);\n      mergeOptions(parentOptions, newOptions, \"background\", globalOptions);\n      if (newOptions.dashes !== void 0 && newOptions.dashes !== null) {\n        parentOptions.dashes = newOptions.dashes;\n      } else if (allowDeletion === true && newOptions.dashes === null) {\n        parentOptions.dashes = create$52(globalOptions.dashes);\n      }\n      if (newOptions.scaling !== void 0 && newOptions.scaling !== null) {\n        if (newOptions.scaling.min !== void 0) {\n          parentOptions.scaling.min = newOptions.scaling.min;\n        }\n        if (newOptions.scaling.max !== void 0) {\n          parentOptions.scaling.max = newOptions.scaling.max;\n        }\n        mergeOptions(parentOptions.scaling, newOptions.scaling, \"label\", globalOptions.scaling);\n      } else if (allowDeletion === true && newOptions.scaling === null) {\n        parentOptions.scaling = create$52(globalOptions.scaling);\n      }\n      if (newOptions.arrows !== void 0 && newOptions.arrows !== null) {\n        if (typeof newOptions.arrows === \"string\") {\n          var arrows = newOptions.arrows.toLowerCase();\n          parentOptions.arrows.to.enabled = indexOf22(arrows).call(arrows, \"to\") != -1;\n          parentOptions.arrows.middle.enabled = indexOf22(arrows).call(arrows, \"middle\") != -1;\n          parentOptions.arrows.from.enabled = indexOf22(arrows).call(arrows, \"from\") != -1;\n        } else if (_typeof2(newOptions.arrows) === \"object\") {\n          mergeOptions(parentOptions.arrows, newOptions.arrows, \"to\", globalOptions.arrows);\n          mergeOptions(parentOptions.arrows, newOptions.arrows, \"middle\", globalOptions.arrows);\n          mergeOptions(parentOptions.arrows, newOptions.arrows, \"from\", globalOptions.arrows);\n        } else {\n          throw new Error(\"The arrow newOptions can only be an object or a string. Refer to the documentation. You used:\" + stringify$12(newOptions.arrows));\n        }\n      } else if (allowDeletion === true && newOptions.arrows === null) {\n        parentOptions.arrows = create$52(globalOptions.arrows);\n      }\n      if (newOptions.color !== void 0 && newOptions.color !== null) {\n        var fromColor = isString(newOptions.color) ? {\n          color: newOptions.color,\n          highlight: newOptions.color,\n          hover: newOptions.color,\n          inherit: false,\n          opacity: 1\n        } : newOptions.color;\n        var toColor = parentOptions.color;\n        if (copyFromGlobals) {\n          deepExtend(toColor, globalOptions.color, false, allowDeletion);\n        } else {\n          for (var i in toColor) {\n            if (Object.prototype.hasOwnProperty.call(toColor, i)) {\n              delete toColor[i];\n            }\n          }\n        }\n        if (isString(toColor)) {\n          toColor.color = toColor;\n          toColor.highlight = toColor;\n          toColor.hover = toColor;\n          toColor.inherit = false;\n          if (fromColor.opacity === void 0) {\n            toColor.opacity = 1;\n          }\n        } else {\n          var colorsDefined = false;\n          if (fromColor.color !== void 0) {\n            toColor.color = fromColor.color;\n            colorsDefined = true;\n          }\n          if (fromColor.highlight !== void 0) {\n            toColor.highlight = fromColor.highlight;\n            colorsDefined = true;\n          }\n          if (fromColor.hover !== void 0) {\n            toColor.hover = fromColor.hover;\n            colorsDefined = true;\n          }\n          if (fromColor.inherit !== void 0) {\n            toColor.inherit = fromColor.inherit;\n          }\n          if (fromColor.opacity !== void 0) {\n            toColor.opacity = Math.min(1, Math.max(0, fromColor.opacity));\n          }\n          if (colorsDefined === true) {\n            toColor.inherit = false;\n          } else {\n            if (toColor.inherit === void 0) {\n              toColor.inherit = \"from\";\n            }\n          }\n        }\n      } else if (allowDeletion === true && newOptions.color === null) {\n        parentOptions.color = bridgeObject(globalOptions.color);\n      }\n      if (allowDeletion === true && newOptions.font === null) {\n        parentOptions.font = bridgeObject(globalOptions.font);\n      }\n      if (Object.prototype.hasOwnProperty.call(newOptions, \"selfReferenceSize\")) {\n        console.warn(\"The selfReferenceSize property has been deprecated. Please use selfReference property instead. The selfReference can be set like thise selfReference:{size:30, angle:Math.PI / 4}\");\n        parentOptions.selfReference.size = newOptions.selfReferenceSize;\n      }\n    }\n  }]);\n  return Edge2;\n}();\nvar EdgesHandler = /* @__PURE__ */ function() {\n  function EdgesHandler2(body, images, groups) {\n    var _context, _this = this;\n    _classCallCheck2(this, EdgesHandler2);\n    this.body = body;\n    this.images = images;\n    this.groups = groups;\n    this.body.functions.createEdge = bind$52(_context = this.create).call(_context, this);\n    this.edgesListeners = {\n      add: function add(event, params) {\n        _this.add(params.items);\n      },\n      update: function update(event, params) {\n        _this.update(params.items);\n      },\n      remove: function remove(event, params) {\n        _this.remove(params.items);\n      }\n    };\n    this.options = {};\n    this.defaultOptions = {\n      arrows: {\n        to: {\n          enabled: false,\n          scaleFactor: 1,\n          type: \"arrow\"\n        },\n        middle: {\n          enabled: false,\n          scaleFactor: 1,\n          type: \"arrow\"\n        },\n        from: {\n          enabled: false,\n          scaleFactor: 1,\n          type: \"arrow\"\n        }\n      },\n      endPointOffset: {\n        from: 0,\n        to: 0\n      },\n      arrowStrikethrough: true,\n      color: {\n        color: \"#848484\",\n        highlight: \"#848484\",\n        hover: \"#848484\",\n        inherit: \"from\",\n        opacity: 1\n      },\n      dashes: false,\n      font: {\n        color: \"#343434\",\n        size: 14,\n        face: \"arial\",\n        background: \"none\",\n        strokeWidth: 2,\n        strokeColor: \"#ffffff\",\n        align: \"horizontal\",\n        multi: false,\n        vadjust: 0,\n        bold: {\n          mod: \"bold\"\n        },\n        boldital: {\n          mod: \"bold italic\"\n        },\n        ital: {\n          mod: \"italic\"\n        },\n        mono: {\n          mod: \"\",\n          size: 15,\n          face: \"courier new\",\n          vadjust: 2\n        }\n      },\n      hidden: false,\n      hoverWidth: 1.5,\n      label: void 0,\n      labelHighlightBold: true,\n      length: void 0,\n      physics: true,\n      scaling: {\n        min: 1,\n        max: 15,\n        label: {\n          enabled: true,\n          min: 14,\n          max: 30,\n          maxVisible: 30,\n          drawThreshold: 5\n        },\n        customScalingFunction: function customScalingFunction(min22, max22, total, value) {\n          if (max22 === min22) {\n            return 0.5;\n          } else {\n            var scale = 1 / (max22 - min22);\n            return Math.max(0, (value - min22) * scale);\n          }\n        }\n      },\n      selectionWidth: 1.5,\n      selfReference: {\n        size: 20,\n        angle: Math.PI / 4,\n        renderBehindTheNode: true\n      },\n      shadow: {\n        enabled: false,\n        color: \"rgba(0,0,0,0.5)\",\n        size: 10,\n        x: 5,\n        y: 5\n      },\n      background: {\n        enabled: false,\n        color: \"rgba(111,111,111,1)\",\n        size: 10,\n        dashes: false\n      },\n      smooth: {\n        enabled: true,\n        type: \"dynamic\",\n        forceDirection: \"none\",\n        roundness: 0.5\n      },\n      title: void 0,\n      width: 1,\n      value: void 0\n    };\n    deepExtend(this.options, this.defaultOptions);\n    this.bindEventListeners();\n  }\n  _createClass2(EdgesHandler2, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this2 = this, _context2, _context3;\n      this.body.emitter.on(\"_forceDisableDynamicCurves\", function(type2) {\n        var emit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        if (type2 === \"dynamic\") {\n          type2 = \"continuous\";\n        }\n        var dataChanged = false;\n        for (var edgeId in _this2.body.edges) {\n          if (Object.prototype.hasOwnProperty.call(_this2.body.edges, edgeId)) {\n            var edge = _this2.body.edges[edgeId];\n            var edgeData = _this2.body.data.edges.get(edgeId);\n            if (edgeData != null) {\n              var smoothOptions = edgeData.smooth;\n              if (smoothOptions !== void 0) {\n                if (smoothOptions.enabled === true && smoothOptions.type === \"dynamic\") {\n                  if (type2 === void 0) {\n                    edge.setOptions({\n                      smooth: false\n                    });\n                  } else {\n                    edge.setOptions({\n                      smooth: {\n                        type: type2\n                      }\n                    });\n                  }\n                  dataChanged = true;\n                }\n              }\n            }\n          }\n        }\n        if (emit === true && dataChanged === true) {\n          _this2.body.emitter.emit(\"_dataChanged\");\n        }\n      });\n      this.body.emitter.on(\"_dataUpdated\", function() {\n        _this2.reconnectEdges();\n      });\n      this.body.emitter.on(\"refreshEdges\", bind$52(_context2 = this.refresh).call(_context2, this));\n      this.body.emitter.on(\"refresh\", bind$52(_context3 = this.refresh).call(_context3, this));\n      this.body.emitter.on(\"destroy\", function() {\n        forEach$12(_this2.edgesListeners, function(callback, event) {\n          if (_this2.body.data.edges)\n            _this2.body.data.edges.off(event, callback);\n        });\n        delete _this2.body.functions.createEdge;\n        delete _this2.edgesListeners.add;\n        delete _this2.edgesListeners.update;\n        delete _this2.edgesListeners.remove;\n        delete _this2.edgesListeners;\n      });\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      if (options2 !== void 0) {\n        Edge.parseOptions(this.options, options2, true, this.defaultOptions, true);\n        var dataChanged = false;\n        if (options2.smooth !== void 0) {\n          for (var edgeId in this.body.edges) {\n            if (Object.prototype.hasOwnProperty.call(this.body.edges, edgeId)) {\n              dataChanged = this.body.edges[edgeId].updateEdgeType() || dataChanged;\n            }\n          }\n        }\n        if (options2.font !== void 0) {\n          for (var _edgeId in this.body.edges) {\n            if (Object.prototype.hasOwnProperty.call(this.body.edges, _edgeId)) {\n              this.body.edges[_edgeId].updateLabelModule();\n            }\n          }\n        }\n        if (options2.hidden !== void 0 || options2.physics !== void 0 || dataChanged === true) {\n          this.body.emitter.emit(\"_dataChanged\");\n        }\n      }\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(edges) {\n      var _this3 = this;\n      var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n      var oldEdgesData = this.body.data.edges;\n      if (isDataViewLike(\"id\", edges)) {\n        this.body.data.edges = edges;\n      } else if (isArray$12(edges)) {\n        this.body.data.edges = new DataSet();\n        this.body.data.edges.add(edges);\n      } else if (!edges) {\n        this.body.data.edges = new DataSet();\n      } else {\n        throw new TypeError(\"Array or DataSet expected\");\n      }\n      if (oldEdgesData) {\n        forEach$12(this.edgesListeners, function(callback, event) {\n          oldEdgesData.off(event, callback);\n        });\n      }\n      this.body.edges = {};\n      if (this.body.data.edges) {\n        forEach$12(this.edgesListeners, function(callback, event) {\n          _this3.body.data.edges.on(event, callback);\n        });\n        var ids = this.body.data.edges.getIds();\n        this.add(ids, true);\n      }\n      this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\");\n      if (doNotEmit === false) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n  }, {\n    key: \"add\",\n    value: function add(ids) {\n      var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n      var edges = this.body.edges;\n      var edgesData = this.body.data.edges;\n      for (var i = 0; i < ids.length; i++) {\n        var id22 = ids[i];\n        var oldEdge = edges[id22];\n        if (oldEdge) {\n          oldEdge.disconnect();\n        }\n        var data22 = edgesData.get(id22, {\n          showInternalIds: true\n        });\n        edges[id22] = this.create(data22);\n      }\n      this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\");\n      if (doNotEmit === false) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(ids) {\n      var edges = this.body.edges;\n      var edgesData = this.body.data.edges;\n      var dataChanged = false;\n      for (var i = 0; i < ids.length; i++) {\n        var id22 = ids[i];\n        var data22 = edgesData.get(id22);\n        var edge = edges[id22];\n        if (edge !== void 0) {\n          edge.disconnect();\n          dataChanged = edge.setOptions(data22) || dataChanged;\n          edge.connect();\n        } else {\n          this.body.edges[id22] = this.create(data22);\n          dataChanged = true;\n        }\n      }\n      if (dataChanged === true) {\n        this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\");\n        this.body.emitter.emit(\"_dataChanged\");\n      } else {\n        this.body.emitter.emit(\"_dataUpdated\");\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(ids) {\n      var emit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n      if (ids.length === 0)\n        return;\n      var edges = this.body.edges;\n      forEach$12(ids, function(id22) {\n        var edge = edges[id22];\n        if (edge !== void 0) {\n          edge.remove();\n        }\n      });\n      if (emit) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var _this4 = this;\n      forEach$12(this.body.edges, function(edge, edgeId) {\n        var data22 = _this4.body.data.edges.get(edgeId);\n        if (data22 !== void 0) {\n          edge.setOptions(data22);\n        }\n      });\n    }\n  }, {\n    key: \"create\",\n    value: function create52(properties) {\n      return new Edge(properties, this.body, this.images, this.options, this.defaultOptions);\n    }\n  }, {\n    key: \"reconnectEdges\",\n    value: function reconnectEdges() {\n      var id22;\n      var nodes = this.body.nodes;\n      var edges = this.body.edges;\n      for (id22 in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, id22)) {\n          nodes[id22].edges = [];\n        }\n      }\n      for (id22 in edges) {\n        if (Object.prototype.hasOwnProperty.call(edges, id22)) {\n          var edge = edges[id22];\n          edge.from = null;\n          edge.to = null;\n          edge.connect();\n        }\n      }\n    }\n  }, {\n    key: \"getConnectedNodes\",\n    value: function getConnectedNodes(edgeId) {\n      var nodeList = [];\n      if (this.body.edges[edgeId] !== void 0) {\n        var edge = this.body.edges[edgeId];\n        if (edge.fromId !== void 0) {\n          nodeList.push(edge.fromId);\n        }\n        if (edge.toId !== void 0) {\n          nodeList.push(edge.toId);\n        }\n      }\n      return nodeList;\n    }\n  }, {\n    key: \"_updateState\",\n    value: function _updateState() {\n      this._addMissingEdges();\n      this._removeInvalidEdges();\n    }\n  }, {\n    key: \"_removeInvalidEdges\",\n    value: function _removeInvalidEdges() {\n      var _this5 = this;\n      var edgesToDelete = [];\n      forEach$12(this.body.edges, function(edge, id22) {\n        var toNode = _this5.body.nodes[edge.toId];\n        var fromNode = _this5.body.nodes[edge.fromId];\n        if (toNode !== void 0 && toNode.isCluster === true || fromNode !== void 0 && fromNode.isCluster === true) {\n          return;\n        }\n        if (toNode === void 0 || fromNode === void 0) {\n          edgesToDelete.push(id22);\n        }\n      });\n      this.remove(edgesToDelete, false);\n    }\n  }, {\n    key: \"_addMissingEdges\",\n    value: function _addMissingEdges() {\n      var edgesData = this.body.data.edges;\n      if (edgesData === void 0 || edgesData === null) {\n        return;\n      }\n      var edges = this.body.edges;\n      var addIds = [];\n      forEach$22(edgesData).call(edgesData, function(edgeData, edgeId) {\n        var edge = edges[edgeId];\n        if (edge === void 0) {\n          addIds.push(edgeId);\n        }\n      });\n      this.add(addIds, true);\n    }\n  }]);\n  return EdgesHandler2;\n}();\nvar BarnesHutSolver = /* @__PURE__ */ function() {\n  function BarnesHutSolver2(body, physicsBody, options2) {\n    _classCallCheck2(this, BarnesHutSolver2);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.barnesHutTree;\n    this.setOptions(options2);\n    this._rng = Alea(\"BARNES HUT SOLVER\");\n  }\n  _createClass2(BarnesHutSolver2, [{\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      this.options = options2;\n      this.thetaInversed = 1 / this.options.theta;\n      this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap));\n    }\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      if (this.options.gravitationalConstant !== 0 && this.physicsBody.physicsNodeIndices.length > 0) {\n        var node;\n        var nodes = this.body.nodes;\n        var nodeIndices = this.physicsBody.physicsNodeIndices;\n        var nodeCount = nodeIndices.length;\n        var barnesHutTree = this._formBarnesHutTree(nodes, nodeIndices);\n        this.barnesHutTree = barnesHutTree;\n        for (var i = 0; i < nodeCount; i++) {\n          node = nodes[nodeIndices[i]];\n          if (node.options.mass > 0) {\n            this._getForceContributions(barnesHutTree.root, node);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_getForceContributions\",\n    value: function _getForceContributions(parentBranch, node) {\n      this._getForceContribution(parentBranch.children.NW, node);\n      this._getForceContribution(parentBranch.children.NE, node);\n      this._getForceContribution(parentBranch.children.SW, node);\n      this._getForceContribution(parentBranch.children.SE, node);\n    }\n  }, {\n    key: \"_getForceContribution\",\n    value: function _getForceContribution(parentBranch, node) {\n      if (parentBranch.childrenCount > 0) {\n        var dx = parentBranch.centerOfMass.x - node.x;\n        var dy = parentBranch.centerOfMass.y - node.y;\n        var distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance * parentBranch.calcSize > this.thetaInversed) {\n          this._calculateForces(distance, dx, dy, node, parentBranch);\n        } else {\n          if (parentBranch.childrenCount === 4) {\n            this._getForceContributions(parentBranch, node);\n          } else {\n            if (parentBranch.children.data.id != node.id) {\n              this._calculateForces(distance, dx, dy, node, parentBranch);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_calculateForces\",\n    value: function _calculateForces(distance, dx, dy, node, parentBranch) {\n      if (distance === 0) {\n        distance = 0.1;\n        dx = distance;\n      }\n      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {\n        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);\n      }\n      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass / Math.pow(distance, 3);\n      var fx = dx * gravityForce;\n      var fy = dy * gravityForce;\n      this.physicsBody.forces[node.id].x += fx;\n      this.physicsBody.forces[node.id].y += fy;\n    }\n  }, {\n    key: \"_formBarnesHutTree\",\n    value: function _formBarnesHutTree(nodes, nodeIndices) {\n      var node;\n      var nodeCount = nodeIndices.length;\n      var minX = nodes[nodeIndices[0]].x;\n      var minY = nodes[nodeIndices[0]].y;\n      var maxX = nodes[nodeIndices[0]].x;\n      var maxY = nodes[nodeIndices[0]].y;\n      for (var i = 1; i < nodeCount; i++) {\n        var _node = nodes[nodeIndices[i]];\n        var x = _node.x;\n        var y = _node.y;\n        if (_node.options.mass > 0) {\n          if (x < minX) {\n            minX = x;\n          }\n          if (x > maxX) {\n            maxX = x;\n          }\n          if (y < minY) {\n            minY = y;\n          }\n          if (y > maxY) {\n            maxY = y;\n          }\n        }\n      }\n      var sizeDiff = Math.abs(maxX - minX) - Math.abs(maxY - minY);\n      if (sizeDiff > 0) {\n        minY -= 0.5 * sizeDiff;\n        maxY += 0.5 * sizeDiff;\n      } else {\n        minX += 0.5 * sizeDiff;\n        maxX -= 0.5 * sizeDiff;\n      }\n      var minimumTreeSize = 1e-5;\n      var rootSize = Math.max(minimumTreeSize, Math.abs(maxX - minX));\n      var halfRootSize = 0.5 * rootSize;\n      var centerX = 0.5 * (minX + maxX), centerY = 0.5 * (minY + maxY);\n      var barnesHutTree = {\n        root: {\n          centerOfMass: {\n            x: 0,\n            y: 0\n          },\n          mass: 0,\n          range: {\n            minX: centerX - halfRootSize,\n            maxX: centerX + halfRootSize,\n            minY: centerY - halfRootSize,\n            maxY: centerY + halfRootSize\n          },\n          size: rootSize,\n          calcSize: 1 / rootSize,\n          children: {\n            data: null\n          },\n          maxWidth: 0,\n          level: 0,\n          childrenCount: 4\n        }\n      };\n      this._splitBranch(barnesHutTree.root);\n      for (var _i = 0; _i < nodeCount; _i++) {\n        node = nodes[nodeIndices[_i]];\n        if (node.options.mass > 0) {\n          this._placeInTree(barnesHutTree.root, node);\n        }\n      }\n      return barnesHutTree;\n    }\n  }, {\n    key: \"_updateBranchMass\",\n    value: function _updateBranchMass(parentBranch, node) {\n      var centerOfMass = parentBranch.centerOfMass;\n      var totalMass = parentBranch.mass + node.options.mass;\n      var totalMassInv = 1 / totalMass;\n      centerOfMass.x = centerOfMass.x * parentBranch.mass + node.x * node.options.mass;\n      centerOfMass.x *= totalMassInv;\n      centerOfMass.y = centerOfMass.y * parentBranch.mass + node.y * node.options.mass;\n      centerOfMass.y *= totalMassInv;\n      parentBranch.mass = totalMass;\n      var biggestSize = Math.max(Math.max(node.height, node.radius), node.width);\n      parentBranch.maxWidth = parentBranch.maxWidth < biggestSize ? biggestSize : parentBranch.maxWidth;\n    }\n  }, {\n    key: \"_placeInTree\",\n    value: function _placeInTree(parentBranch, node, skipMassUpdate) {\n      if (skipMassUpdate != true || skipMassUpdate === void 0) {\n        this._updateBranchMass(parentBranch, node);\n      }\n      var range = parentBranch.children.NW.range;\n      var region;\n      if (range.maxX > node.x) {\n        if (range.maxY > node.y) {\n          region = \"NW\";\n        } else {\n          region = \"SW\";\n        }\n      } else {\n        if (range.maxY > node.y) {\n          region = \"NE\";\n        } else {\n          region = \"SE\";\n        }\n      }\n      this._placeInRegion(parentBranch, node, region);\n    }\n  }, {\n    key: \"_placeInRegion\",\n    value: function _placeInRegion(parentBranch, node, region) {\n      var children = parentBranch.children[region];\n      switch (children.childrenCount) {\n        case 0:\n          children.children.data = node;\n          children.childrenCount = 1;\n          this._updateBranchMass(children, node);\n          break;\n        case 1:\n          if (children.children.data.x === node.x && children.children.data.y === node.y) {\n            node.x += this._rng();\n            node.y += this._rng();\n          } else {\n            this._splitBranch(children);\n            this._placeInTree(children, node);\n          }\n          break;\n        case 4:\n          this._placeInTree(children, node);\n          break;\n      }\n    }\n  }, {\n    key: \"_splitBranch\",\n    value: function _splitBranch(parentBranch) {\n      var containedNode = null;\n      if (parentBranch.childrenCount === 1) {\n        containedNode = parentBranch.children.data;\n        parentBranch.mass = 0;\n        parentBranch.centerOfMass.x = 0;\n        parentBranch.centerOfMass.y = 0;\n      }\n      parentBranch.childrenCount = 4;\n      parentBranch.children.data = null;\n      this._insertRegion(parentBranch, \"NW\");\n      this._insertRegion(parentBranch, \"NE\");\n      this._insertRegion(parentBranch, \"SW\");\n      this._insertRegion(parentBranch, \"SE\");\n      if (containedNode != null) {\n        this._placeInTree(parentBranch, containedNode);\n      }\n    }\n  }, {\n    key: \"_insertRegion\",\n    value: function _insertRegion(parentBranch, region) {\n      var minX, maxX, minY, maxY;\n      var childSize = 0.5 * parentBranch.size;\n      switch (region) {\n        case \"NW\":\n          minX = parentBranch.range.minX;\n          maxX = parentBranch.range.minX + childSize;\n          minY = parentBranch.range.minY;\n          maxY = parentBranch.range.minY + childSize;\n          break;\n        case \"NE\":\n          minX = parentBranch.range.minX + childSize;\n          maxX = parentBranch.range.maxX;\n          minY = parentBranch.range.minY;\n          maxY = parentBranch.range.minY + childSize;\n          break;\n        case \"SW\":\n          minX = parentBranch.range.minX;\n          maxX = parentBranch.range.minX + childSize;\n          minY = parentBranch.range.minY + childSize;\n          maxY = parentBranch.range.maxY;\n          break;\n        case \"SE\":\n          minX = parentBranch.range.minX + childSize;\n          maxX = parentBranch.range.maxX;\n          minY = parentBranch.range.minY + childSize;\n          maxY = parentBranch.range.maxY;\n          break;\n      }\n      parentBranch.children[region] = {\n        centerOfMass: {\n          x: 0,\n          y: 0\n        },\n        mass: 0,\n        range: {\n          minX,\n          maxX,\n          minY,\n          maxY\n        },\n        size: 0.5 * parentBranch.size,\n        calcSize: 2 * parentBranch.calcSize,\n        children: {\n          data: null\n        },\n        maxWidth: 0,\n        level: parentBranch.level + 1,\n        childrenCount: 0\n      };\n    }\n  }, {\n    key: \"_debug\",\n    value: function _debug(ctx, color) {\n      if (this.barnesHutTree !== void 0) {\n        ctx.lineWidth = 1;\n        this._drawBranch(this.barnesHutTree.root, ctx, color);\n      }\n    }\n  }, {\n    key: \"_drawBranch\",\n    value: function _drawBranch(branch, ctx, color) {\n      if (color === void 0) {\n        color = \"#FF0000\";\n      }\n      if (branch.childrenCount === 4) {\n        this._drawBranch(branch.children.NW, ctx);\n        this._drawBranch(branch.children.NE, ctx);\n        this._drawBranch(branch.children.SE, ctx);\n        this._drawBranch(branch.children.SW, ctx);\n      }\n      ctx.strokeStyle = color;\n      ctx.beginPath();\n      ctx.moveTo(branch.range.minX, branch.range.minY);\n      ctx.lineTo(branch.range.maxX, branch.range.minY);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(branch.range.maxX, branch.range.minY);\n      ctx.lineTo(branch.range.maxX, branch.range.maxY);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(branch.range.maxX, branch.range.maxY);\n      ctx.lineTo(branch.range.minX, branch.range.maxY);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(branch.range.minX, branch.range.maxY);\n      ctx.lineTo(branch.range.minX, branch.range.minY);\n      ctx.stroke();\n    }\n  }]);\n  return BarnesHutSolver2;\n}();\nvar RepulsionSolver = /* @__PURE__ */ function() {\n  function RepulsionSolver2(body, physicsBody, options2) {\n    _classCallCheck2(this, RepulsionSolver2);\n    this._rng = Alea(\"REPULSION SOLVER\");\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options2);\n  }\n  _createClass2(RepulsionSolver2, [{\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      this.options = options2;\n    }\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var dx, dy, distance, fx, fy, repulsingForce, node1, node2;\n      var nodes = this.body.nodes;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces;\n      var nodeDistance = this.options.nodeDistance;\n      var a = -2 / 3 / nodeDistance;\n      var b = 4 / 3;\n      for (var i = 0; i < nodeIndices.length - 1; i++) {\n        node1 = nodes[nodeIndices[i]];\n        for (var j = i + 1; j < nodeIndices.length; j++) {\n          node2 = nodes[nodeIndices[j]];\n          dx = node2.x - node1.x;\n          dy = node2.y - node1.y;\n          distance = Math.sqrt(dx * dx + dy * dy);\n          if (distance === 0) {\n            distance = 0.1 * this._rng();\n            dx = distance;\n          }\n          if (distance < 2 * nodeDistance) {\n            if (distance < 0.5 * nodeDistance) {\n              repulsingForce = 1;\n            } else {\n              repulsingForce = a * distance + b;\n            }\n            repulsingForce = repulsingForce / distance;\n            fx = dx * repulsingForce;\n            fy = dy * repulsingForce;\n            forces[node1.id].x -= fx;\n            forces[node1.id].y -= fy;\n            forces[node2.id].x += fx;\n            forces[node2.id].y += fy;\n          }\n        }\n      }\n    }\n  }]);\n  return RepulsionSolver2;\n}();\nvar HierarchicalRepulsionSolver = /* @__PURE__ */ function() {\n  function HierarchicalRepulsionSolver2(body, physicsBody, options2) {\n    _classCallCheck2(this, HierarchicalRepulsionSolver2);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options2);\n  }\n  _createClass2(HierarchicalRepulsionSolver2, [{\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      this.options = options2;\n      this.overlapAvoidanceFactor = Math.max(0, Math.min(1, this.options.avoidOverlap || 0));\n    }\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var nodes = this.body.nodes;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces;\n      var nodeDistance = this.options.nodeDistance;\n      for (var i = 0; i < nodeIndices.length - 1; i++) {\n        var node1 = nodes[nodeIndices[i]];\n        for (var j = i + 1; j < nodeIndices.length; j++) {\n          var node2 = nodes[nodeIndices[j]];\n          if (node1.level === node2.level) {\n            var theseNodesDistance = nodeDistance + this.overlapAvoidanceFactor * ((node1.shape.radius || 0) / 2 + (node2.shape.radius || 0) / 2);\n            var dx = node2.x - node1.x;\n            var dy = node2.y - node1.y;\n            var distance = Math.sqrt(dx * dx + dy * dy);\n            var steepness = 0.05;\n            var repulsingForce = void 0;\n            if (distance < theseNodesDistance) {\n              repulsingForce = -Math.pow(steepness * distance, 2) + Math.pow(steepness * theseNodesDistance, 2);\n            } else {\n              repulsingForce = 0;\n            }\n            if (distance !== 0) {\n              repulsingForce = repulsingForce / distance;\n            }\n            var fx = dx * repulsingForce;\n            var fy = dy * repulsingForce;\n            forces[node1.id].x -= fx;\n            forces[node1.id].y -= fy;\n            forces[node2.id].x += fx;\n            forces[node2.id].y += fy;\n          }\n        }\n      }\n    }\n  }]);\n  return HierarchicalRepulsionSolver2;\n}();\nvar SpringSolver = /* @__PURE__ */ function() {\n  function SpringSolver2(body, physicsBody, options2) {\n    _classCallCheck2(this, SpringSolver2);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options2);\n  }\n  _createClass2(SpringSolver2, [{\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      this.options = options2;\n    }\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var edgeLength, edge;\n      var edgeIndices = this.physicsBody.physicsEdgeIndices;\n      var edges = this.body.edges;\n      var node1, node2, node3;\n      for (var i = 0; i < edgeIndices.length; i++) {\n        edge = edges[edgeIndices[i]];\n        if (edge.connected === true && edge.toId !== edge.fromId) {\n          if (this.body.nodes[edge.toId] !== void 0 && this.body.nodes[edge.fromId] !== void 0) {\n            if (edge.edgeType.via !== void 0) {\n              edgeLength = edge.options.length === void 0 ? this.options.springLength : edge.options.length;\n              node1 = edge.to;\n              node2 = edge.edgeType.via;\n              node3 = edge.from;\n              this._calculateSpringForce(node1, node2, 0.5 * edgeLength);\n              this._calculateSpringForce(node2, node3, 0.5 * edgeLength);\n            } else {\n              edgeLength = edge.options.length === void 0 ? this.options.springLength * 1.5 : edge.options.length;\n              this._calculateSpringForce(edge.from, edge.to, edgeLength);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_calculateSpringForce\",\n    value: function _calculateSpringForce(node1, node2, edgeLength) {\n      var dx = node1.x - node2.x;\n      var dy = node1.y - node2.y;\n      var distance = Math.max(Math.sqrt(dx * dx + dy * dy), 0.01);\n      var springForce = this.options.springConstant * (edgeLength - distance) / distance;\n      var fx = dx * springForce;\n      var fy = dy * springForce;\n      if (this.physicsBody.forces[node1.id] !== void 0) {\n        this.physicsBody.forces[node1.id].x += fx;\n        this.physicsBody.forces[node1.id].y += fy;\n      }\n      if (this.physicsBody.forces[node2.id] !== void 0) {\n        this.physicsBody.forces[node2.id].x -= fx;\n        this.physicsBody.forces[node2.id].y -= fy;\n      }\n    }\n  }]);\n  return SpringSolver2;\n}();\nvar HierarchicalSpringSolver = /* @__PURE__ */ function() {\n  function HierarchicalSpringSolver2(body, physicsBody, options2) {\n    _classCallCheck2(this, HierarchicalSpringSolver2);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options2);\n  }\n  _createClass2(HierarchicalSpringSolver2, [{\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      this.options = options2;\n    }\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var edgeLength, edge;\n      var dx, dy, fx, fy, springForce, distance;\n      var edges = this.body.edges;\n      var factor = 0.5;\n      var edgeIndices = this.physicsBody.physicsEdgeIndices;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces;\n      for (var i = 0; i < nodeIndices.length; i++) {\n        var nodeId = nodeIndices[i];\n        forces[nodeId].springFx = 0;\n        forces[nodeId].springFy = 0;\n      }\n      for (var _i = 0; _i < edgeIndices.length; _i++) {\n        edge = edges[edgeIndices[_i]];\n        if (edge.connected === true) {\n          edgeLength = edge.options.length === void 0 ? this.options.springLength : edge.options.length;\n          dx = edge.from.x - edge.to.x;\n          dy = edge.from.y - edge.to.y;\n          distance = Math.sqrt(dx * dx + dy * dy);\n          distance = distance === 0 ? 0.01 : distance;\n          springForce = this.options.springConstant * (edgeLength - distance) / distance;\n          fx = dx * springForce;\n          fy = dy * springForce;\n          if (edge.to.level != edge.from.level) {\n            if (forces[edge.toId] !== void 0) {\n              forces[edge.toId].springFx -= fx;\n              forces[edge.toId].springFy -= fy;\n            }\n            if (forces[edge.fromId] !== void 0) {\n              forces[edge.fromId].springFx += fx;\n              forces[edge.fromId].springFy += fy;\n            }\n          } else {\n            if (forces[edge.toId] !== void 0) {\n              forces[edge.toId].x -= factor * fx;\n              forces[edge.toId].y -= factor * fy;\n            }\n            if (forces[edge.fromId] !== void 0) {\n              forces[edge.fromId].x += factor * fx;\n              forces[edge.fromId].y += factor * fy;\n            }\n          }\n        }\n      }\n      springForce = 1;\n      var springFx, springFy;\n      for (var _i2 = 0; _i2 < nodeIndices.length; _i2++) {\n        var _nodeId = nodeIndices[_i2];\n        springFx = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFx));\n        springFy = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFy));\n        forces[_nodeId].x += springFx;\n        forces[_nodeId].y += springFy;\n      }\n      var totalFx = 0;\n      var totalFy = 0;\n      for (var _i3 = 0; _i3 < nodeIndices.length; _i3++) {\n        var _nodeId2 = nodeIndices[_i3];\n        totalFx += forces[_nodeId2].x;\n        totalFy += forces[_nodeId2].y;\n      }\n      var correctionFx = totalFx / nodeIndices.length;\n      var correctionFy = totalFy / nodeIndices.length;\n      for (var _i4 = 0; _i4 < nodeIndices.length; _i4++) {\n        var _nodeId3 = nodeIndices[_i4];\n        forces[_nodeId3].x -= correctionFx;\n        forces[_nodeId3].y -= correctionFy;\n      }\n    }\n  }]);\n  return HierarchicalSpringSolver2;\n}();\nvar CentralGravitySolver = /* @__PURE__ */ function() {\n  function CentralGravitySolver2(body, physicsBody, options2) {\n    _classCallCheck2(this, CentralGravitySolver2);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options2);\n  }\n  _createClass2(CentralGravitySolver2, [{\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      this.options = options2;\n    }\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var dx, dy, distance, node;\n      var nodes = this.body.nodes;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces;\n      for (var i = 0; i < nodeIndices.length; i++) {\n        var nodeId = nodeIndices[i];\n        node = nodes[nodeId];\n        dx = -node.x;\n        dy = -node.y;\n        distance = Math.sqrt(dx * dx + dy * dy);\n        this._calculateForces(distance, dx, dy, forces, node);\n      }\n    }\n  }, {\n    key: \"_calculateForces\",\n    value: function _calculateForces(distance, dx, dy, forces, node) {\n      var gravityForce = distance === 0 ? 0 : this.options.centralGravity / distance;\n      forces[node.id].x = dx * gravityForce;\n      forces[node.id].y = dy * gravityForce;\n    }\n  }]);\n  return CentralGravitySolver2;\n}();\nfunction _createSuper$3(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$3() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar ForceAtlas2BasedRepulsionSolver = /* @__PURE__ */ function(_BarnesHutSolver) {\n  _inherits2(ForceAtlas2BasedRepulsionSolver2, _BarnesHutSolver);\n  var _super = _createSuper$3(ForceAtlas2BasedRepulsionSolver2);\n  function ForceAtlas2BasedRepulsionSolver2(body, physicsBody, options2) {\n    var _this;\n    _classCallCheck2(this, ForceAtlas2BasedRepulsionSolver2);\n    _this = _super.call(this, body, physicsBody, options2);\n    _this._rng = Alea(\"FORCE ATLAS 2 BASED REPULSION SOLVER\");\n    return _this;\n  }\n  _createClass2(ForceAtlas2BasedRepulsionSolver2, [{\n    key: \"_calculateForces\",\n    value: function _calculateForces(distance, dx, dy, node, parentBranch) {\n      if (distance === 0) {\n        distance = 0.1 * this._rng();\n        dx = distance;\n      }\n      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {\n        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);\n      }\n      var degree = node.edges.length + 1;\n      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass * degree / Math.pow(distance, 2);\n      var fx = dx * gravityForce;\n      var fy = dy * gravityForce;\n      this.physicsBody.forces[node.id].x += fx;\n      this.physicsBody.forces[node.id].y += fy;\n    }\n  }]);\n  return ForceAtlas2BasedRepulsionSolver2;\n}(BarnesHutSolver);\nfunction _createSuper$2(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$2() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar ForceAtlas2BasedCentralGravitySolver = /* @__PURE__ */ function(_CentralGravitySolver) {\n  _inherits2(ForceAtlas2BasedCentralGravitySolver2, _CentralGravitySolver);\n  var _super = _createSuper$2(ForceAtlas2BasedCentralGravitySolver2);\n  function ForceAtlas2BasedCentralGravitySolver2(body, physicsBody, options2) {\n    _classCallCheck2(this, ForceAtlas2BasedCentralGravitySolver2);\n    return _super.call(this, body, physicsBody, options2);\n  }\n  _createClass2(ForceAtlas2BasedCentralGravitySolver2, [{\n    key: \"_calculateForces\",\n    value: function _calculateForces(distance, dx, dy, forces, node) {\n      if (distance > 0) {\n        var degree = node.edges.length + 1;\n        var gravityForce = this.options.centralGravity * degree * node.options.mass;\n        forces[node.id].x = dx * gravityForce;\n        forces[node.id].y = dy * gravityForce;\n      }\n    }\n  }]);\n  return ForceAtlas2BasedCentralGravitySolver2;\n}(CentralGravitySolver);\nvar PhysicsEngine = /* @__PURE__ */ function() {\n  function PhysicsEngine2(body) {\n    _classCallCheck2(this, PhysicsEngine2);\n    this.body = body;\n    this.physicsBody = {\n      physicsNodeIndices: [],\n      physicsEdgeIndices: [],\n      forces: {},\n      velocities: {}\n    };\n    this.physicsEnabled = true;\n    this.simulationInterval = 1e3 / 60;\n    this.requiresTimeout = true;\n    this.previousStates = {};\n    this.referenceState = {};\n    this.freezeCache = {};\n    this.renderTimer = void 0;\n    this.adaptiveTimestep = false;\n    this.adaptiveTimestepEnabled = false;\n    this.adaptiveCounter = 0;\n    this.adaptiveInterval = 3;\n    this.stabilized = false;\n    this.startedStabilization = false;\n    this.stabilizationIterations = 0;\n    this.ready = false;\n    this.options = {};\n    this.defaultOptions = {\n      enabled: true,\n      barnesHut: {\n        theta: 0.5,\n        gravitationalConstant: -2e3,\n        centralGravity: 0.3,\n        springLength: 95,\n        springConstant: 0.04,\n        damping: 0.09,\n        avoidOverlap: 0\n      },\n      forceAtlas2Based: {\n        theta: 0.5,\n        gravitationalConstant: -50,\n        centralGravity: 0.01,\n        springConstant: 0.08,\n        springLength: 100,\n        damping: 0.4,\n        avoidOverlap: 0\n      },\n      repulsion: {\n        centralGravity: 0.2,\n        springLength: 200,\n        springConstant: 0.05,\n        nodeDistance: 100,\n        damping: 0.09,\n        avoidOverlap: 0\n      },\n      hierarchicalRepulsion: {\n        centralGravity: 0,\n        springLength: 100,\n        springConstant: 0.01,\n        nodeDistance: 120,\n        damping: 0.09\n      },\n      maxVelocity: 50,\n      minVelocity: 0.75,\n      solver: \"barnesHut\",\n      stabilization: {\n        enabled: true,\n        iterations: 1e3,\n        updateInterval: 50,\n        onlyDynamicEdges: false,\n        fit: true\n      },\n      timestep: 0.5,\n      adaptiveTimestep: true,\n      wind: {\n        x: 0,\n        y: 0\n      }\n    };\n    assign$22(this.options, this.defaultOptions);\n    this.timestep = 0.5;\n    this.layoutFailed = false;\n    this.bindEventListeners();\n  }\n  _createClass2(PhysicsEngine2, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this = this;\n      this.body.emitter.on(\"initPhysics\", function() {\n        _this.initPhysics();\n      });\n      this.body.emitter.on(\"_layoutFailed\", function() {\n        _this.layoutFailed = true;\n      });\n      this.body.emitter.on(\"resetPhysics\", function() {\n        _this.stopSimulation();\n        _this.ready = false;\n      });\n      this.body.emitter.on(\"disablePhysics\", function() {\n        _this.physicsEnabled = false;\n        _this.stopSimulation();\n      });\n      this.body.emitter.on(\"restorePhysics\", function() {\n        _this.setOptions(_this.options);\n        if (_this.ready === true) {\n          _this.startSimulation();\n        }\n      });\n      this.body.emitter.on(\"startSimulation\", function() {\n        if (_this.ready === true) {\n          _this.startSimulation();\n        }\n      });\n      this.body.emitter.on(\"stopSimulation\", function() {\n        _this.stopSimulation();\n      });\n      this.body.emitter.on(\"destroy\", function() {\n        _this.stopSimulation(false);\n        _this.body.emitter.off();\n      });\n      this.body.emitter.on(\"_dataChanged\", function() {\n        _this.updatePhysicsData();\n      });\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      if (options2 !== void 0) {\n        if (options2 === false) {\n          this.options.enabled = false;\n          this.physicsEnabled = false;\n          this.stopSimulation();\n        } else if (options2 === true) {\n          this.options.enabled = true;\n          this.physicsEnabled = true;\n          this.startSimulation();\n        } else {\n          this.physicsEnabled = true;\n          selectiveNotDeepExtend([\"stabilization\"], this.options, options2);\n          mergeOptions(this.options, options2, \"stabilization\");\n          if (options2.enabled === void 0) {\n            this.options.enabled = true;\n          }\n          if (this.options.enabled === false) {\n            this.physicsEnabled = false;\n            this.stopSimulation();\n          }\n          var wind = this.options.wind;\n          if (wind) {\n            if (typeof wind.x !== \"number\" || isNan(wind.x)) {\n              wind.x = 0;\n            }\n            if (typeof wind.y !== \"number\" || isNan(wind.y)) {\n              wind.y = 0;\n            }\n          }\n          this.timestep = this.options.timestep;\n        }\n      }\n      this.init();\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      var options2;\n      if (this.options.solver === \"forceAtlas2Based\") {\n        options2 = this.options.forceAtlas2Based;\n        this.nodesSolver = new ForceAtlas2BasedRepulsionSolver(this.body, this.physicsBody, options2);\n        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options2);\n        this.gravitySolver = new ForceAtlas2BasedCentralGravitySolver(this.body, this.physicsBody, options2);\n      } else if (this.options.solver === \"repulsion\") {\n        options2 = this.options.repulsion;\n        this.nodesSolver = new RepulsionSolver(this.body, this.physicsBody, options2);\n        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options2);\n        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options2);\n      } else if (this.options.solver === \"hierarchicalRepulsion\") {\n        options2 = this.options.hierarchicalRepulsion;\n        this.nodesSolver = new HierarchicalRepulsionSolver(this.body, this.physicsBody, options2);\n        this.edgesSolver = new HierarchicalSpringSolver(this.body, this.physicsBody, options2);\n        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options2);\n      } else {\n        options2 = this.options.barnesHut;\n        this.nodesSolver = new BarnesHutSolver(this.body, this.physicsBody, options2);\n        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options2);\n        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options2);\n      }\n      this.modelOptions = options2;\n    }\n  }, {\n    key: \"initPhysics\",\n    value: function initPhysics() {\n      if (this.physicsEnabled === true && this.options.enabled === true) {\n        if (this.options.stabilization.enabled === true) {\n          this.stabilize();\n        } else {\n          this.stabilized = false;\n          this.ready = true;\n          this.body.emitter.emit(\"fit\", {}, this.layoutFailed);\n          this.startSimulation();\n        }\n      } else {\n        this.ready = true;\n        this.body.emitter.emit(\"fit\");\n      }\n    }\n  }, {\n    key: \"startSimulation\",\n    value: function startSimulation() {\n      if (this.physicsEnabled === true && this.options.enabled === true) {\n        this.stabilized = false;\n        this.adaptiveTimestep = false;\n        this.body.emitter.emit(\"_resizeNodes\");\n        if (this.viewFunction === void 0) {\n          var _context;\n          this.viewFunction = bind$52(_context = this.simulationStep).call(_context, this);\n          this.body.emitter.on(\"initRedraw\", this.viewFunction);\n          this.body.emitter.emit(\"_startRendering\");\n        }\n      } else {\n        this.body.emitter.emit(\"_redraw\");\n      }\n    }\n  }, {\n    key: \"stopSimulation\",\n    value: function stopSimulation() {\n      var emit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n      this.stabilized = true;\n      if (emit === true) {\n        this._emitStabilized();\n      }\n      if (this.viewFunction !== void 0) {\n        this.body.emitter.off(\"initRedraw\", this.viewFunction);\n        this.viewFunction = void 0;\n        if (emit === true) {\n          this.body.emitter.emit(\"_stopRendering\");\n        }\n      }\n    }\n  }, {\n    key: \"simulationStep\",\n    value: function simulationStep() {\n      var startTime = now$1();\n      this.physicsTick();\n      var physicsTime = now$1() - startTime;\n      if ((physicsTime < 0.4 * this.simulationInterval || this.runDoubleSpeed === true) && this.stabilized === false) {\n        this.physicsTick();\n        this.runDoubleSpeed = true;\n      }\n      if (this.stabilized === true) {\n        this.stopSimulation();\n      }\n    }\n  }, {\n    key: \"_emitStabilized\",\n    value: function _emitStabilized() {\n      var _this2 = this;\n      var amountOfIterations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.stabilizationIterations;\n      if (this.stabilizationIterations > 1 || this.startedStabilization === true) {\n        setTimeout$12(function() {\n          _this2.body.emitter.emit(\"stabilized\", {\n            iterations: amountOfIterations\n          });\n          _this2.startedStabilization = false;\n          _this2.stabilizationIterations = 0;\n        }, 0);\n      }\n    }\n  }, {\n    key: \"physicsStep\",\n    value: function physicsStep() {\n      this.gravitySolver.solve();\n      this.nodesSolver.solve();\n      this.edgesSolver.solve();\n      this.moveNodes();\n    }\n  }, {\n    key: \"adjustTimeStep\",\n    value: function adjustTimeStep() {\n      var factor = 1.2;\n      if (this._evaluateStepQuality() === true) {\n        this.timestep = factor * this.timestep;\n      } else {\n        if (this.timestep / factor < this.options.timestep) {\n          this.timestep = this.options.timestep;\n        } else {\n          this.adaptiveCounter = -1;\n          this.timestep = Math.max(this.options.timestep, this.timestep / factor);\n        }\n      }\n    }\n  }, {\n    key: \"physicsTick\",\n    value: function physicsTick() {\n      this._startStabilizing();\n      if (this.stabilized === true)\n        return;\n      if (this.adaptiveTimestep === true && this.adaptiveTimestepEnabled === true) {\n        var doAdaptive = this.adaptiveCounter % this.adaptiveInterval === 0;\n        if (doAdaptive) {\n          this.timestep = 2 * this.timestep;\n          this.physicsStep();\n          this.revert();\n          this.timestep = 0.5 * this.timestep;\n          this.physicsStep();\n          this.physicsStep();\n          this.adjustTimeStep();\n        } else {\n          this.physicsStep();\n        }\n        this.adaptiveCounter += 1;\n      } else {\n        this.timestep = this.options.timestep;\n        this.physicsStep();\n      }\n      if (this.stabilized === true)\n        this.revert();\n      this.stabilizationIterations++;\n    }\n  }, {\n    key: \"updatePhysicsData\",\n    value: function updatePhysicsData() {\n      this.physicsBody.forces = {};\n      this.physicsBody.physicsNodeIndices = [];\n      this.physicsBody.physicsEdgeIndices = [];\n      var nodes = this.body.nodes;\n      var edges = this.body.edges;\n      for (var nodeId in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n          if (nodes[nodeId].options.physics === true) {\n            this.physicsBody.physicsNodeIndices.push(nodes[nodeId].id);\n          }\n        }\n      }\n      for (var edgeId in edges) {\n        if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {\n          if (edges[edgeId].options.physics === true) {\n            this.physicsBody.physicsEdgeIndices.push(edges[edgeId].id);\n          }\n        }\n      }\n      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {\n        var _nodeId = this.physicsBody.physicsNodeIndices[i];\n        this.physicsBody.forces[_nodeId] = {\n          x: 0,\n          y: 0\n        };\n        if (this.physicsBody.velocities[_nodeId] === void 0) {\n          this.physicsBody.velocities[_nodeId] = {\n            x: 0,\n            y: 0\n          };\n        }\n      }\n      for (var _nodeId2 in this.physicsBody.velocities) {\n        if (nodes[_nodeId2] === void 0) {\n          delete this.physicsBody.velocities[_nodeId2];\n        }\n      }\n    }\n  }, {\n    key: \"revert\",\n    value: function revert() {\n      var nodeIds = keys32(this.previousStates);\n      var nodes = this.body.nodes;\n      var velocities = this.physicsBody.velocities;\n      this.referenceState = {};\n      for (var i = 0; i < nodeIds.length; i++) {\n        var nodeId = nodeIds[i];\n        if (nodes[nodeId] !== void 0) {\n          if (nodes[nodeId].options.physics === true) {\n            this.referenceState[nodeId] = {\n              positions: {\n                x: nodes[nodeId].x,\n                y: nodes[nodeId].y\n              }\n            };\n            velocities[nodeId].x = this.previousStates[nodeId].vx;\n            velocities[nodeId].y = this.previousStates[nodeId].vy;\n            nodes[nodeId].x = this.previousStates[nodeId].x;\n            nodes[nodeId].y = this.previousStates[nodeId].y;\n          }\n        } else {\n          delete this.previousStates[nodeId];\n        }\n      }\n    }\n  }, {\n    key: \"_evaluateStepQuality\",\n    value: function _evaluateStepQuality() {\n      var dx, dy, dpos;\n      var nodes = this.body.nodes;\n      var reference = this.referenceState;\n      var posThreshold = 0.3;\n      for (var nodeId in this.referenceState) {\n        if (Object.prototype.hasOwnProperty.call(this.referenceState, nodeId) && nodes[nodeId] !== void 0) {\n          dx = nodes[nodeId].x - reference[nodeId].positions.x;\n          dy = nodes[nodeId].y - reference[nodeId].positions.y;\n          dpos = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          if (dpos > posThreshold) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"moveNodes\",\n    value: function moveNodes() {\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var maxNodeVelocity = 0;\n      var averageNodeVelocity = 0;\n      var velocityAdaptiveThreshold = 5;\n      for (var i = 0; i < nodeIndices.length; i++) {\n        var nodeId = nodeIndices[i];\n        var nodeVelocity = this._performStep(nodeId);\n        maxNodeVelocity = Math.max(maxNodeVelocity, nodeVelocity);\n        averageNodeVelocity += nodeVelocity;\n      }\n      this.adaptiveTimestepEnabled = averageNodeVelocity / nodeIndices.length < velocityAdaptiveThreshold;\n      this.stabilized = maxNodeVelocity < this.options.minVelocity;\n    }\n  }, {\n    key: \"calculateComponentVelocity\",\n    value: function calculateComponentVelocity(v, f, m) {\n      var df = this.modelOptions.damping * v;\n      var a = (f - df) / m;\n      v += a * this.timestep;\n      var maxV = this.options.maxVelocity || 1e9;\n      if (Math.abs(v) > maxV) {\n        v = v > 0 ? maxV : -maxV;\n      }\n      return v;\n    }\n  }, {\n    key: \"_performStep\",\n    value: function _performStep(nodeId) {\n      var node = this.body.nodes[nodeId];\n      var force = this.physicsBody.forces[nodeId];\n      if (this.options.wind) {\n        force.x += this.options.wind.x;\n        force.y += this.options.wind.y;\n      }\n      var velocity = this.physicsBody.velocities[nodeId];\n      this.previousStates[nodeId] = {\n        x: node.x,\n        y: node.y,\n        vx: velocity.x,\n        vy: velocity.y\n      };\n      if (node.options.fixed.x === false) {\n        velocity.x = this.calculateComponentVelocity(velocity.x, force.x, node.options.mass);\n        node.x += velocity.x * this.timestep;\n      } else {\n        force.x = 0;\n        velocity.x = 0;\n      }\n      if (node.options.fixed.y === false) {\n        velocity.y = this.calculateComponentVelocity(velocity.y, force.y, node.options.mass);\n        node.y += velocity.y * this.timestep;\n      } else {\n        force.y = 0;\n        velocity.y = 0;\n      }\n      var totalVelocity = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2));\n      return totalVelocity;\n    }\n  }, {\n    key: \"_freezeNodes\",\n    value: function _freezeNodes() {\n      var nodes = this.body.nodes;\n      for (var id22 in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, id22)) {\n          if (nodes[id22].x && nodes[id22].y) {\n            var fixed = nodes[id22].options.fixed;\n            this.freezeCache[id22] = {\n              x: fixed.x,\n              y: fixed.y\n            };\n            fixed.x = true;\n            fixed.y = true;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_restoreFrozenNodes\",\n    value: function _restoreFrozenNodes() {\n      var nodes = this.body.nodes;\n      for (var id22 in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, id22)) {\n          if (this.freezeCache[id22] !== void 0) {\n            nodes[id22].options.fixed.x = this.freezeCache[id22].x;\n            nodes[id22].options.fixed.y = this.freezeCache[id22].y;\n          }\n        }\n      }\n      this.freezeCache = {};\n    }\n  }, {\n    key: \"stabilize\",\n    value: function stabilize() {\n      var _this3 = this;\n      var iterations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.stabilization.iterations;\n      if (typeof iterations !== \"number\") {\n        iterations = this.options.stabilization.iterations;\n        console.error(\"The stabilize method needs a numeric amount of iterations. Switching to default: \", iterations);\n      }\n      if (this.physicsBody.physicsNodeIndices.length === 0) {\n        this.ready = true;\n        return;\n      }\n      this.adaptiveTimestep = this.options.adaptiveTimestep;\n      this.body.emitter.emit(\"_resizeNodes\");\n      this.stopSimulation();\n      this.stabilized = false;\n      this.body.emitter.emit(\"_blockRedraw\");\n      this.targetIterations = iterations;\n      if (this.options.stabilization.onlyDynamicEdges === true) {\n        this._freezeNodes();\n      }\n      this.stabilizationIterations = 0;\n      setTimeout$12(function() {\n        return _this3._stabilizationBatch();\n      }, 0);\n    }\n  }, {\n    key: \"_startStabilizing\",\n    value: function _startStabilizing() {\n      if (this.startedStabilization === true)\n        return false;\n      this.body.emitter.emit(\"startStabilizing\");\n      this.startedStabilization = true;\n      return true;\n    }\n  }, {\n    key: \"_stabilizationBatch\",\n    value: function _stabilizationBatch() {\n      var _this4 = this;\n      var running = function running2() {\n        return _this4.stabilized === false && _this4.stabilizationIterations < _this4.targetIterations;\n      };\n      var sendProgress = function sendProgress2() {\n        _this4.body.emitter.emit(\"stabilizationProgress\", {\n          iterations: _this4.stabilizationIterations,\n          total: _this4.targetIterations\n        });\n      };\n      if (this._startStabilizing()) {\n        sendProgress();\n      }\n      var count = 0;\n      while (running() && count < this.options.stabilization.updateInterval) {\n        this.physicsTick();\n        count++;\n      }\n      sendProgress();\n      if (running()) {\n        var _context2;\n        setTimeout$12(bind$52(_context2 = this._stabilizationBatch).call(_context2, this), 0);\n      } else {\n        this._finalizeStabilization();\n      }\n    }\n  }, {\n    key: \"_finalizeStabilization\",\n    value: function _finalizeStabilization() {\n      this.body.emitter.emit(\"_allowRedraw\");\n      if (this.options.stabilization.fit === true) {\n        this.body.emitter.emit(\"fit\");\n      }\n      if (this.options.stabilization.onlyDynamicEdges === true) {\n        this._restoreFrozenNodes();\n      }\n      this.body.emitter.emit(\"stabilizationIterationsDone\");\n      this.body.emitter.emit(\"_requestRedraw\");\n      if (this.stabilized === true) {\n        this._emitStabilized();\n      } else {\n        this.startSimulation();\n      }\n      this.ready = true;\n    }\n  }, {\n    key: \"_drawForces\",\n    value: function _drawForces(ctx) {\n      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {\n        var index2 = this.physicsBody.physicsNodeIndices[i];\n        var node = this.body.nodes[index2];\n        var force = this.physicsBody.forces[index2];\n        var factor = 20;\n        var colorFactor = 0.03;\n        var forceSize = Math.sqrt(Math.pow(force.x, 2) + Math.pow(force.x, 2));\n        var size = Math.min(Math.max(5, forceSize), 15);\n        var arrowSize = 3 * size;\n        var color = HSVToHex((180 - Math.min(1, Math.max(0, colorFactor * forceSize)) * 180) / 360, 1, 1);\n        var point = {\n          x: node.x + factor * force.x,\n          y: node.y + factor * force.y\n        };\n        ctx.lineWidth = size;\n        ctx.strokeStyle = color;\n        ctx.beginPath();\n        ctx.moveTo(node.x, node.y);\n        ctx.lineTo(point.x, point.y);\n        ctx.stroke();\n        var angle = Math.atan2(force.y, force.x);\n        ctx.fillStyle = color;\n        EndPoints.draw(ctx, {\n          type: \"arrow\",\n          point,\n          angle,\n          length: arrowSize\n        });\n        fill22(ctx).call(ctx);\n      }\n    }\n  }]);\n  return PhysicsEngine2;\n}();\nvar getRandomValues2;\nvar rnds82 = new Uint8Array(16);\nfunction rng2() {\n  if (!getRandomValues2) {\n    getRandomValues2 = typeof crypto !== \"undefined\" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== \"undefined\" && typeof msCrypto.getRandomValues === \"function\" && msCrypto.getRandomValues.bind(msCrypto);\n    if (!getRandomValues2) {\n      throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n    }\n  }\n  return getRandomValues2(rnds82);\n}\nvar REGEX2 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nfunction validate2(uuid) {\n  return typeof uuid === \"string\" && REGEX2.test(uuid);\n}\nvar byteToHex2 = [];\nfor (i = 0; i < 256; ++i) {\n  byteToHex2.push((i + 256).toString(16).substr(1));\n}\nvar i;\nfunction stringify22(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n  var uuid = (byteToHex2[arr[offset + 0]] + byteToHex2[arr[offset + 1]] + byteToHex2[arr[offset + 2]] + byteToHex2[arr[offset + 3]] + \"-\" + byteToHex2[arr[offset + 4]] + byteToHex2[arr[offset + 5]] + \"-\" + byteToHex2[arr[offset + 6]] + byteToHex2[arr[offset + 7]] + \"-\" + byteToHex2[arr[offset + 8]] + byteToHex2[arr[offset + 9]] + \"-\" + byteToHex2[arr[offset + 10]] + byteToHex2[arr[offset + 11]] + byteToHex2[arr[offset + 12]] + byteToHex2[arr[offset + 13]] + byteToHex2[arr[offset + 14]] + byteToHex2[arr[offset + 15]]).toLowerCase();\n  if (!validate2(uuid)) {\n    throw TypeError(\"Stringified UUID is invalid\");\n  }\n  return uuid;\n}\nfunction v42(options2, buf, offset) {\n  options2 = options2 || {};\n  var rnds = options2.random || (options2.rng || rng2)();\n  rnds[6] = rnds[6] & 15 | 64;\n  rnds[8] = rnds[8] & 63 | 128;\n  if (buf) {\n    offset = offset || 0;\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return stringify22(rnds);\n}\nvar NetworkUtil = /* @__PURE__ */ function() {\n  function NetworkUtil2() {\n    _classCallCheck2(this, NetworkUtil2);\n  }\n  _createClass2(NetworkUtil2, null, [{\n    key: \"getRange\",\n    value: function getRange(allNodes) {\n      var specificNodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n      var minY = 1e9, maxY = -1e9, minX = 1e9, maxX = -1e9, node;\n      if (specificNodes.length > 0) {\n        for (var i = 0; i < specificNodes.length; i++) {\n          node = allNodes[specificNodes[i]];\n          if (minX > node.shape.boundingBox.left) {\n            minX = node.shape.boundingBox.left;\n          }\n          if (maxX < node.shape.boundingBox.right) {\n            maxX = node.shape.boundingBox.right;\n          }\n          if (minY > node.shape.boundingBox.top) {\n            minY = node.shape.boundingBox.top;\n          }\n          if (maxY < node.shape.boundingBox.bottom) {\n            maxY = node.shape.boundingBox.bottom;\n          }\n        }\n      }\n      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {\n        minY = 0, maxY = 0, minX = 0, maxX = 0;\n      }\n      return {\n        minX,\n        maxX,\n        minY,\n        maxY\n      };\n    }\n  }, {\n    key: \"getRangeCore\",\n    value: function getRangeCore(allNodes) {\n      var specificNodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n      var minY = 1e9, maxY = -1e9, minX = 1e9, maxX = -1e9, node;\n      if (specificNodes.length > 0) {\n        for (var i = 0; i < specificNodes.length; i++) {\n          node = allNodes[specificNodes[i]];\n          if (minX > node.x) {\n            minX = node.x;\n          }\n          if (maxX < node.x) {\n            maxX = node.x;\n          }\n          if (minY > node.y) {\n            minY = node.y;\n          }\n          if (maxY < node.y) {\n            maxY = node.y;\n          }\n        }\n      }\n      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {\n        minY = 0, maxY = 0, minX = 0, maxX = 0;\n      }\n      return {\n        minX,\n        maxX,\n        minY,\n        maxY\n      };\n    }\n  }, {\n    key: \"findCenter\",\n    value: function findCenter(range) {\n      return {\n        x: 0.5 * (range.maxX + range.minX),\n        y: 0.5 * (range.maxY + range.minY)\n      };\n    }\n  }, {\n    key: \"cloneOptions\",\n    value: function cloneOptions(item, type2) {\n      var clonedOptions = {};\n      if (type2 === void 0 || type2 === \"node\") {\n        deepExtend(clonedOptions, item.options, true);\n        clonedOptions.x = item.x;\n        clonedOptions.y = item.y;\n        clonedOptions.amountOfConnections = item.edges.length;\n      } else {\n        deepExtend(clonedOptions, item.options, true);\n      }\n      return clonedOptions;\n    }\n  }]);\n  return NetworkUtil2;\n}();\nfunction _createSuper$12(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$12();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct$12() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Cluster = /* @__PURE__ */ function(_Node) {\n  _inherits2(Cluster2, _Node);\n  var _super = _createSuper$12(Cluster2);\n  function Cluster2(options2, body, imagelist, grouplist, globalOptions, defaultOptions) {\n    var _this;\n    _classCallCheck2(this, Cluster2);\n    _this = _super.call(this, options2, body, imagelist, grouplist, globalOptions, defaultOptions);\n    _this.isCluster = true;\n    _this.containedNodes = {};\n    _this.containedEdges = {};\n    return _this;\n  }\n  _createClass2(Cluster2, [{\n    key: \"_openChildCluster\",\n    value: function _openChildCluster(childClusterId) {\n      var _this2 = this;\n      var childCluster = this.body.nodes[childClusterId];\n      if (this.containedNodes[childClusterId] === void 0) {\n        throw new Error(\"node with id: \" + childClusterId + \" not in current cluster\");\n      }\n      if (!childCluster.isCluster) {\n        throw new Error(\"node with id: \" + childClusterId + \" is not a cluster\");\n      }\n      delete this.containedNodes[childClusterId];\n      forEach$12(childCluster.edges, function(edge) {\n        delete _this2.containedEdges[edge.id];\n      });\n      forEach$12(childCluster.containedNodes, function(node, nodeId) {\n        _this2.containedNodes[nodeId] = node;\n      });\n      childCluster.containedNodes = {};\n      forEach$12(childCluster.containedEdges, function(edge, edgeId) {\n        _this2.containedEdges[edgeId] = edge;\n      });\n      childCluster.containedEdges = {};\n      forEach$12(childCluster.edges, function(clusterEdge) {\n        forEach$12(_this2.edges, function(parentClusterEdge) {\n          var _context, _context2;\n          var index2 = indexOf22(_context = parentClusterEdge.clusteringEdgeReplacingIds).call(_context, clusterEdge.id);\n          if (index2 === -1)\n            return;\n          forEach$12(clusterEdge.clusteringEdgeReplacingIds, function(srcId) {\n            parentClusterEdge.clusteringEdgeReplacingIds.push(srcId);\n            _this2.body.edges[srcId].edgeReplacedById = parentClusterEdge.id;\n          });\n          splice$12(_context2 = parentClusterEdge.clusteringEdgeReplacingIds).call(_context2, index2, 1);\n        });\n      });\n      childCluster.edges = [];\n    }\n  }]);\n  return Cluster2;\n}(Node);\nvar ClusterEngine = /* @__PURE__ */ function() {\n  function ClusterEngine2(body) {\n    var _this = this;\n    _classCallCheck2(this, ClusterEngine2);\n    this.body = body;\n    this.clusteredNodes = {};\n    this.clusteredEdges = {};\n    this.options = {};\n    this.defaultOptions = {};\n    assign$22(this.options, this.defaultOptions);\n    this.body.emitter.on(\"_resetData\", function() {\n      _this.clusteredNodes = {};\n      _this.clusteredEdges = {};\n    });\n  }\n  _createClass2(ClusterEngine2, [{\n    key: \"clusterByHubsize\",\n    value: function clusterByHubsize(hubsize, options2) {\n      if (hubsize === void 0) {\n        hubsize = this._getHubSize();\n      } else if (_typeof2(hubsize) === \"object\") {\n        options2 = this._checkOptions(hubsize);\n        hubsize = this._getHubSize();\n      }\n      var nodesToCluster = [];\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var node = this.body.nodes[this.body.nodeIndices[i]];\n        if (node.edges.length >= hubsize) {\n          nodesToCluster.push(node.id);\n        }\n      }\n      for (var _i = 0; _i < nodesToCluster.length; _i++) {\n        this.clusterByConnection(nodesToCluster[_i], options2, true);\n      }\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n  }, {\n    key: \"cluster\",\n    value: function cluster() {\n      var _this2 = this;\n      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n      var refreshData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n      if (options2.joinCondition === void 0) {\n        throw new Error(\"Cannot call clusterByNodeData without a joinCondition function in the options.\");\n      }\n      options2 = this._checkOptions(options2);\n      var childNodesObj = {};\n      var childEdgesObj = {};\n      forEach$12(this.body.nodes, function(node, nodeId) {\n        if (node.options && options2.joinCondition(node.options) === true) {\n          childNodesObj[nodeId] = node;\n          forEach$12(node.edges, function(edge) {\n            if (_this2.clusteredEdges[edge.id] === void 0) {\n              childEdgesObj[edge.id] = edge;\n            }\n          });\n        }\n      });\n      this._cluster(childNodesObj, childEdgesObj, options2, refreshData);\n    }\n  }, {\n    key: \"clusterByEdgeCount\",\n    value: function clusterByEdgeCount(edgeCount, options2) {\n      var _this3 = this;\n      var refreshData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n      options2 = this._checkOptions(options2);\n      var clusters = [];\n      var usedNodes = {};\n      var edge, edges, relevantEdgeCount;\n      var _loop = function _loop2(i2) {\n        var childNodesObj = {};\n        var childEdgesObj = {};\n        var nodeId = _this3.body.nodeIndices[i2];\n        var node = _this3.body.nodes[nodeId];\n        if (usedNodes[nodeId] === void 0) {\n          relevantEdgeCount = 0;\n          edges = [];\n          for (var j = 0; j < node.edges.length; j++) {\n            edge = node.edges[j];\n            if (_this3.clusteredEdges[edge.id] === void 0) {\n              if (edge.toId !== edge.fromId) {\n                relevantEdgeCount++;\n              }\n              edges.push(edge);\n            }\n          }\n          if (relevantEdgeCount === edgeCount) {\n            var checkJoinCondition = function checkJoinCondition2(node2) {\n              if (options2.joinCondition === void 0 || options2.joinCondition === null) {\n                return true;\n              }\n              var clonedOptions = NetworkUtil.cloneOptions(node2);\n              return options2.joinCondition(clonedOptions);\n            };\n            var gatheringSuccessful = true;\n            for (var _j = 0; _j < edges.length; _j++) {\n              edge = edges[_j];\n              var childNodeId = _this3._getConnectedId(edge, nodeId);\n              if (checkJoinCondition(node)) {\n                childEdgesObj[edge.id] = edge;\n                childNodesObj[nodeId] = node;\n                childNodesObj[childNodeId] = _this3.body.nodes[childNodeId];\n                usedNodes[nodeId] = true;\n              } else {\n                gatheringSuccessful = false;\n                break;\n              }\n            }\n            if (keys32(childNodesObj).length > 0 && keys32(childEdgesObj).length > 0 && gatheringSuccessful === true) {\n              var findClusterData = function findClusterData2() {\n                for (var n = 0; n < clusters.length; ++n) {\n                  for (var m2 in childNodesObj) {\n                    if (clusters[n].nodes[m2] !== void 0) {\n                      return clusters[n];\n                    }\n                  }\n                }\n                return void 0;\n              };\n              var foundCluster = findClusterData();\n              if (foundCluster !== void 0) {\n                for (var m in childNodesObj) {\n                  if (foundCluster.nodes[m] === void 0) {\n                    foundCluster.nodes[m] = childNodesObj[m];\n                  }\n                }\n                for (var _m in childEdgesObj) {\n                  if (foundCluster.edges[_m] === void 0) {\n                    foundCluster.edges[_m] = childEdgesObj[_m];\n                  }\n                }\n              } else {\n                clusters.push({\n                  nodes: childNodesObj,\n                  edges: childEdgesObj\n                });\n              }\n            }\n          }\n        }\n      };\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        _loop(i);\n      }\n      for (var _i2 = 0; _i2 < clusters.length; _i2++) {\n        this._cluster(clusters[_i2].nodes, clusters[_i2].edges, options2, false);\n      }\n      if (refreshData === true) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n  }, {\n    key: \"clusterOutliers\",\n    value: function clusterOutliers(options2) {\n      var refreshData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n      this.clusterByEdgeCount(1, options2, refreshData);\n    }\n  }, {\n    key: \"clusterBridges\",\n    value: function clusterBridges(options2) {\n      var refreshData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n      this.clusterByEdgeCount(2, options2, refreshData);\n    }\n  }, {\n    key: \"clusterByConnection\",\n    value: function clusterByConnection(nodeId, options2) {\n      var _context;\n      var refreshData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n      if (nodeId === void 0) {\n        throw new Error(\"No nodeId supplied to clusterByConnection!\");\n      }\n      if (this.body.nodes[nodeId] === void 0) {\n        throw new Error(\"The nodeId given to clusterByConnection does not exist!\");\n      }\n      var node = this.body.nodes[nodeId];\n      options2 = this._checkOptions(options2, node);\n      if (options2.clusterNodeProperties.x === void 0) {\n        options2.clusterNodeProperties.x = node.x;\n      }\n      if (options2.clusterNodeProperties.y === void 0) {\n        options2.clusterNodeProperties.y = node.y;\n      }\n      if (options2.clusterNodeProperties.fixed === void 0) {\n        options2.clusterNodeProperties.fixed = {};\n        options2.clusterNodeProperties.fixed.x = node.options.fixed.x;\n        options2.clusterNodeProperties.fixed.y = node.options.fixed.y;\n      }\n      var childNodesObj = {};\n      var childEdgesObj = {};\n      var parentNodeId = node.id;\n      var parentClonedOptions = NetworkUtil.cloneOptions(node);\n      childNodesObj[parentNodeId] = node;\n      for (var i = 0; i < node.edges.length; i++) {\n        var edge = node.edges[i];\n        if (this.clusteredEdges[edge.id] === void 0) {\n          var childNodeId = this._getConnectedId(edge, parentNodeId);\n          if (this.clusteredNodes[childNodeId] === void 0) {\n            if (childNodeId !== parentNodeId) {\n              if (options2.joinCondition === void 0) {\n                childEdgesObj[edge.id] = edge;\n                childNodesObj[childNodeId] = this.body.nodes[childNodeId];\n              } else {\n                var childClonedOptions = NetworkUtil.cloneOptions(this.body.nodes[childNodeId]);\n                if (options2.joinCondition(parentClonedOptions, childClonedOptions) === true) {\n                  childEdgesObj[edge.id] = edge;\n                  childNodesObj[childNodeId] = this.body.nodes[childNodeId];\n                }\n              }\n            } else {\n              childEdgesObj[edge.id] = edge;\n            }\n          }\n        }\n      }\n      var childNodeIDs = map$32(_context = keys32(childNodesObj)).call(_context, function(childNode2) {\n        return childNodesObj[childNode2].id;\n      });\n      for (var childNodeKey in childNodesObj) {\n        if (!Object.prototype.hasOwnProperty.call(childNodesObj, childNodeKey))\n          continue;\n        var childNode = childNodesObj[childNodeKey];\n        for (var y = 0; y < childNode.edges.length; y++) {\n          var childEdge = childNode.edges[y];\n          if (indexOf22(childNodeIDs).call(childNodeIDs, this._getConnectedId(childEdge, childNode.id)) > -1) {\n            childEdgesObj[childEdge.id] = childEdge;\n          }\n        }\n      }\n      this._cluster(childNodesObj, childEdgesObj, options2, refreshData);\n    }\n  }, {\n    key: \"_createClusterEdges\",\n    value: function _createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, clusterEdgeProperties) {\n      var edge, childNodeId, childNode, toId, fromId, otherNodeId;\n      var childKeys = keys32(childNodesObj);\n      var createEdges = [];\n      for (var i = 0; i < childKeys.length; i++) {\n        childNodeId = childKeys[i];\n        childNode = childNodesObj[childNodeId];\n        for (var j = 0; j < childNode.edges.length; j++) {\n          edge = childNode.edges[j];\n          if (this.clusteredEdges[edge.id] === void 0) {\n            if (edge.toId == edge.fromId) {\n              childEdgesObj[edge.id] = edge;\n            } else {\n              if (edge.toId == childNodeId) {\n                toId = clusterNodeProperties.id;\n                fromId = edge.fromId;\n                otherNodeId = fromId;\n              } else {\n                toId = edge.toId;\n                fromId = clusterNodeProperties.id;\n                otherNodeId = toId;\n              }\n            }\n            if (childNodesObj[otherNodeId] === void 0) {\n              createEdges.push({\n                edge,\n                fromId,\n                toId\n              });\n            }\n          }\n        }\n      }\n      var newEdges = [];\n      var getNewEdge = function getNewEdge2(createdEdge2) {\n        for (var _j2 = 0; _j2 < newEdges.length; _j2++) {\n          var newEdge2 = newEdges[_j2];\n          var matchToDirection = createdEdge2.fromId === newEdge2.fromId && createdEdge2.toId === newEdge2.toId;\n          var matchFromDirection = createdEdge2.fromId === newEdge2.toId && createdEdge2.toId === newEdge2.fromId;\n          if (matchToDirection || matchFromDirection) {\n            return newEdge2;\n          }\n        }\n        return null;\n      };\n      for (var _j3 = 0; _j3 < createEdges.length; _j3++) {\n        var createdEdge = createEdges[_j3];\n        var _edge = createdEdge.edge;\n        var newEdge = getNewEdge(createdEdge);\n        if (newEdge === null) {\n          newEdge = this._createClusteredEdge(createdEdge.fromId, createdEdge.toId, _edge, clusterEdgeProperties);\n          newEdges.push(newEdge);\n        } else {\n          newEdge.clusteringEdgeReplacingIds.push(_edge.id);\n        }\n        this.body.edges[_edge.id].edgeReplacedById = newEdge.id;\n        this._backupEdgeOptions(_edge);\n        _edge.setOptions({\n          physics: false\n        });\n      }\n    }\n  }, {\n    key: \"_checkOptions\",\n    value: function _checkOptions() {\n      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n      if (options2.clusterEdgeProperties === void 0) {\n        options2.clusterEdgeProperties = {};\n      }\n      if (options2.clusterNodeProperties === void 0) {\n        options2.clusterNodeProperties = {};\n      }\n      return options2;\n    }\n  }, {\n    key: \"_cluster\",\n    value: function _cluster(childNodesObj, childEdgesObj, options2) {\n      var refreshData = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;\n      var tmpNodesToRemove = [];\n      for (var nodeId in childNodesObj) {\n        if (Object.prototype.hasOwnProperty.call(childNodesObj, nodeId)) {\n          if (this.clusteredNodes[nodeId] !== void 0) {\n            tmpNodesToRemove.push(nodeId);\n          }\n        }\n      }\n      for (var n = 0; n < tmpNodesToRemove.length; ++n) {\n        delete childNodesObj[tmpNodesToRemove[n]];\n      }\n      if (keys32(childNodesObj).length == 0) {\n        return;\n      }\n      if (keys32(childNodesObj).length == 1 && options2.clusterNodeProperties.allowSingleNodeCluster != true) {\n        return;\n      }\n      var clusterNodeProperties = deepExtend({}, options2.clusterNodeProperties);\n      if (options2.processProperties !== void 0) {\n        var childNodesOptions = [];\n        for (var _nodeId in childNodesObj) {\n          if (Object.prototype.hasOwnProperty.call(childNodesObj, _nodeId)) {\n            var clonedOptions = NetworkUtil.cloneOptions(childNodesObj[_nodeId]);\n            childNodesOptions.push(clonedOptions);\n          }\n        }\n        var childEdgesOptions = [];\n        for (var edgeId in childEdgesObj) {\n          if (Object.prototype.hasOwnProperty.call(childEdgesObj, edgeId)) {\n            if (edgeId.substr(0, 12) !== \"clusterEdge:\") {\n              var _clonedOptions = NetworkUtil.cloneOptions(childEdgesObj[edgeId], \"edge\");\n              childEdgesOptions.push(_clonedOptions);\n            }\n          }\n        }\n        clusterNodeProperties = options2.processProperties(clusterNodeProperties, childNodesOptions, childEdgesOptions);\n        if (!clusterNodeProperties) {\n          throw new Error(\"The processProperties function does not return properties!\");\n        }\n      }\n      if (clusterNodeProperties.id === void 0) {\n        clusterNodeProperties.id = \"cluster:\" + v42();\n      }\n      var clusterId = clusterNodeProperties.id;\n      if (clusterNodeProperties.label === void 0) {\n        clusterNodeProperties.label = \"cluster\";\n      }\n      var pos = void 0;\n      if (clusterNodeProperties.x === void 0) {\n        pos = this._getClusterPosition(childNodesObj);\n        clusterNodeProperties.x = pos.x;\n      }\n      if (clusterNodeProperties.y === void 0) {\n        if (pos === void 0) {\n          pos = this._getClusterPosition(childNodesObj);\n        }\n        clusterNodeProperties.y = pos.y;\n      }\n      clusterNodeProperties.id = clusterId;\n      var clusterNode = this.body.functions.createNode(clusterNodeProperties, Cluster);\n      clusterNode.containedNodes = childNodesObj;\n      clusterNode.containedEdges = childEdgesObj;\n      clusterNode.clusterEdgeProperties = options2.clusterEdgeProperties;\n      this.body.nodes[clusterNodeProperties.id] = clusterNode;\n      this._clusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, options2.clusterEdgeProperties);\n      clusterNodeProperties.id = void 0;\n      if (refreshData === true) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n  }, {\n    key: \"_backupEdgeOptions\",\n    value: function _backupEdgeOptions(edge) {\n      if (this.clusteredEdges[edge.id] === void 0) {\n        this.clusteredEdges[edge.id] = {\n          physics: edge.options.physics\n        };\n      }\n    }\n  }, {\n    key: \"_restoreEdge\",\n    value: function _restoreEdge(edge) {\n      var originalOptions = this.clusteredEdges[edge.id];\n      if (originalOptions !== void 0) {\n        edge.setOptions({\n          physics: originalOptions.physics\n        });\n        delete this.clusteredEdges[edge.id];\n      }\n    }\n  }, {\n    key: \"isCluster\",\n    value: function isCluster(nodeId) {\n      if (this.body.nodes[nodeId] !== void 0) {\n        return this.body.nodes[nodeId].isCluster === true;\n      } else {\n        console.error(\"Node does not exist.\");\n        return false;\n      }\n    }\n  }, {\n    key: \"_getClusterPosition\",\n    value: function _getClusterPosition(childNodesObj) {\n      var childKeys = keys32(childNodesObj);\n      var minX = childNodesObj[childKeys[0]].x;\n      var maxX = childNodesObj[childKeys[0]].x;\n      var minY = childNodesObj[childKeys[0]].y;\n      var maxY = childNodesObj[childKeys[0]].y;\n      var node;\n      for (var i = 1; i < childKeys.length; i++) {\n        node = childNodesObj[childKeys[i]];\n        minX = node.x < minX ? node.x : minX;\n        maxX = node.x > maxX ? node.x : maxX;\n        minY = node.y < minY ? node.y : minY;\n        maxY = node.y > maxY ? node.y : maxY;\n      }\n      return {\n        x: 0.5 * (minX + maxX),\n        y: 0.5 * (minY + maxY)\n      };\n    }\n  }, {\n    key: \"openCluster\",\n    value: function openCluster(clusterNodeId, options2) {\n      var refreshData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n      if (clusterNodeId === void 0) {\n        throw new Error(\"No clusterNodeId supplied to openCluster.\");\n      }\n      var clusterNode = this.body.nodes[clusterNodeId];\n      if (clusterNode === void 0) {\n        throw new Error(\"The clusterNodeId supplied to openCluster does not exist.\");\n      }\n      if (clusterNode.isCluster !== true || clusterNode.containedNodes === void 0 || clusterNode.containedEdges === void 0) {\n        throw new Error(\"The node:\" + clusterNodeId + \" is not a valid cluster.\");\n      }\n      var stack = this.findNode(clusterNodeId);\n      var parentIndex = indexOf22(stack).call(stack, clusterNodeId) - 1;\n      if (parentIndex >= 0) {\n        var parentClusterNodeId = stack[parentIndex];\n        var parentClusterNode = this.body.nodes[parentClusterNodeId];\n        parentClusterNode._openChildCluster(clusterNodeId);\n        delete this.body.nodes[clusterNodeId];\n        if (refreshData === true) {\n          this.body.emitter.emit(\"_dataChanged\");\n        }\n        return;\n      }\n      var containedNodes = clusterNode.containedNodes;\n      var containedEdges = clusterNode.containedEdges;\n      if (options2 !== void 0 && options2.releaseFunction !== void 0 && typeof options2.releaseFunction === \"function\") {\n        var positions = {};\n        var clusterPosition = {\n          x: clusterNode.x,\n          y: clusterNode.y\n        };\n        for (var nodeId in containedNodes) {\n          if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {\n            var containedNode = this.body.nodes[nodeId];\n            positions[nodeId] = {\n              x: containedNode.x,\n              y: containedNode.y\n            };\n          }\n        }\n        var newPositions = options2.releaseFunction(clusterPosition, positions);\n        for (var _nodeId2 in containedNodes) {\n          if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId2)) {\n            var _containedNode = this.body.nodes[_nodeId2];\n            if (newPositions[_nodeId2] !== void 0) {\n              _containedNode.x = newPositions[_nodeId2].x === void 0 ? clusterNode.x : newPositions[_nodeId2].x;\n              _containedNode.y = newPositions[_nodeId2].y === void 0 ? clusterNode.y : newPositions[_nodeId2].y;\n            }\n          }\n        }\n      } else {\n        forEach$12(containedNodes, function(containedNode2) {\n          if (containedNode2.options.fixed.x === false) {\n            containedNode2.x = clusterNode.x;\n          }\n          if (containedNode2.options.fixed.y === false) {\n            containedNode2.y = clusterNode.y;\n          }\n        });\n      }\n      for (var _nodeId3 in containedNodes) {\n        if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId3)) {\n          var _containedNode2 = this.body.nodes[_nodeId3];\n          _containedNode2.vx = clusterNode.vx;\n          _containedNode2.vy = clusterNode.vy;\n          _containedNode2.setOptions({\n            physics: true\n          });\n          delete this.clusteredNodes[_nodeId3];\n        }\n      }\n      var edgesToBeDeleted = [];\n      for (var i = 0; i < clusterNode.edges.length; i++) {\n        edgesToBeDeleted.push(clusterNode.edges[i]);\n      }\n      for (var _i3 = 0; _i3 < edgesToBeDeleted.length; _i3++) {\n        var edge = edgesToBeDeleted[_i3];\n        var otherNodeId = this._getConnectedId(edge, clusterNodeId);\n        var otherNode = this.clusteredNodes[otherNodeId];\n        for (var j = 0; j < edge.clusteringEdgeReplacingIds.length; j++) {\n          var transferId = edge.clusteringEdgeReplacingIds[j];\n          var transferEdge = this.body.edges[transferId];\n          if (transferEdge === void 0)\n            continue;\n          if (otherNode !== void 0) {\n            var otherCluster = this.body.nodes[otherNode.clusterId];\n            otherCluster.containedEdges[transferEdge.id] = transferEdge;\n            delete containedEdges[transferEdge.id];\n            var fromId = transferEdge.fromId;\n            var toId = transferEdge.toId;\n            if (transferEdge.toId == otherNodeId) {\n              toId = otherNode.clusterId;\n            } else {\n              fromId = otherNode.clusterId;\n            }\n            this._createClusteredEdge(fromId, toId, transferEdge, otherCluster.clusterEdgeProperties, {\n              hidden: false,\n              physics: true\n            });\n          } else {\n            this._restoreEdge(transferEdge);\n          }\n        }\n        edge.remove();\n      }\n      for (var edgeId in containedEdges) {\n        if (Object.prototype.hasOwnProperty.call(containedEdges, edgeId)) {\n          this._restoreEdge(containedEdges[edgeId]);\n        }\n      }\n      delete this.body.nodes[clusterNodeId];\n      if (refreshData === true) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n  }, {\n    key: \"getNodesInCluster\",\n    value: function getNodesInCluster(clusterId) {\n      var nodesArray = [];\n      if (this.isCluster(clusterId) === true) {\n        var containedNodes = this.body.nodes[clusterId].containedNodes;\n        for (var nodeId in containedNodes) {\n          if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {\n            nodesArray.push(this.body.nodes[nodeId].id);\n          }\n        }\n      }\n      return nodesArray;\n    }\n  }, {\n    key: \"findNode\",\n    value: function findNode(nodeId) {\n      var stack = [];\n      var max22 = 100;\n      var counter = 0;\n      var node;\n      while (this.clusteredNodes[nodeId] !== void 0 && counter < max22) {\n        node = this.body.nodes[nodeId];\n        if (node === void 0)\n          return [];\n        stack.push(node.id);\n        nodeId = this.clusteredNodes[nodeId].clusterId;\n        counter++;\n      }\n      node = this.body.nodes[nodeId];\n      if (node === void 0)\n        return [];\n      stack.push(node.id);\n      reverse22(stack).call(stack);\n      return stack;\n    }\n  }, {\n    key: \"updateClusteredNode\",\n    value: function updateClusteredNode(clusteredNodeId, newOptions) {\n      if (clusteredNodeId === void 0) {\n        throw new Error(\"No clusteredNodeId supplied to updateClusteredNode.\");\n      }\n      if (newOptions === void 0) {\n        throw new Error(\"No newOptions supplied to updateClusteredNode.\");\n      }\n      if (this.body.nodes[clusteredNodeId] === void 0) {\n        throw new Error(\"The clusteredNodeId supplied to updateClusteredNode does not exist.\");\n      }\n      this.body.nodes[clusteredNodeId].setOptions(newOptions);\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n  }, {\n    key: \"updateEdge\",\n    value: function updateEdge(startEdgeId, newOptions) {\n      if (startEdgeId === void 0) {\n        throw new Error(\"No startEdgeId supplied to updateEdge.\");\n      }\n      if (newOptions === void 0) {\n        throw new Error(\"No newOptions supplied to updateEdge.\");\n      }\n      if (this.body.edges[startEdgeId] === void 0) {\n        throw new Error(\"The startEdgeId supplied to updateEdge does not exist.\");\n      }\n      var allEdgeIds = this.getClusteredEdges(startEdgeId);\n      for (var i = 0; i < allEdgeIds.length; i++) {\n        var edge = this.body.edges[allEdgeIds[i]];\n        edge.setOptions(newOptions);\n      }\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n  }, {\n    key: \"getClusteredEdges\",\n    value: function getClusteredEdges(edgeId) {\n      var stack = [];\n      var max22 = 100;\n      var counter = 0;\n      while (edgeId !== void 0 && this.body.edges[edgeId] !== void 0 && counter < max22) {\n        stack.push(this.body.edges[edgeId].id);\n        edgeId = this.body.edges[edgeId].edgeReplacedById;\n        counter++;\n      }\n      reverse22(stack).call(stack);\n      return stack;\n    }\n  }, {\n    key: \"getBaseEdge\",\n    value: function getBaseEdge(clusteredEdgeId) {\n      return this.getBaseEdges(clusteredEdgeId)[0];\n    }\n  }, {\n    key: \"getBaseEdges\",\n    value: function getBaseEdges(clusteredEdgeId) {\n      var IdsToHandle = [clusteredEdgeId];\n      var doneIds = [];\n      var foundIds = [];\n      var max22 = 100;\n      var counter = 0;\n      while (IdsToHandle.length > 0 && counter < max22) {\n        var nextId = IdsToHandle.pop();\n        if (nextId === void 0)\n          continue;\n        var nextEdge = this.body.edges[nextId];\n        if (nextEdge === void 0)\n          continue;\n        counter++;\n        var replacingIds = nextEdge.clusteringEdgeReplacingIds;\n        if (replacingIds === void 0) {\n          foundIds.push(nextId);\n        } else {\n          for (var i = 0; i < replacingIds.length; ++i) {\n            var replacingId = replacingIds[i];\n            if (indexOf22(IdsToHandle).call(IdsToHandle, replacingIds) !== -1 || indexOf22(doneIds).call(doneIds, replacingIds) !== -1) {\n              continue;\n            }\n            IdsToHandle.push(replacingId);\n          }\n        }\n        doneIds.push(nextId);\n      }\n      return foundIds;\n    }\n  }, {\n    key: \"_getConnectedId\",\n    value: function _getConnectedId(edge, nodeId) {\n      if (edge.toId != nodeId) {\n        return edge.toId;\n      } else if (edge.fromId != nodeId) {\n        return edge.fromId;\n      } else {\n        return edge.fromId;\n      }\n    }\n  }, {\n    key: \"_getHubSize\",\n    value: function _getHubSize() {\n      var average = 0;\n      var averageSquared = 0;\n      var hubCounter = 0;\n      var largestHub = 0;\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var node = this.body.nodes[this.body.nodeIndices[i]];\n        if (node.edges.length > largestHub) {\n          largestHub = node.edges.length;\n        }\n        average += node.edges.length;\n        averageSquared += Math.pow(node.edges.length, 2);\n        hubCounter += 1;\n      }\n      average = average / hubCounter;\n      averageSquared = averageSquared / hubCounter;\n      var variance = averageSquared - Math.pow(average, 2);\n      var standardDeviation = Math.sqrt(variance);\n      var hubThreshold = Math.floor(average + 2 * standardDeviation);\n      if (hubThreshold > largestHub) {\n        hubThreshold = largestHub;\n      }\n      return hubThreshold;\n    }\n  }, {\n    key: \"_createClusteredEdge\",\n    value: function _createClusteredEdge(fromId, toId, baseEdge, clusterEdgeProperties, extraOptions) {\n      var clonedOptions = NetworkUtil.cloneOptions(baseEdge, \"edge\");\n      deepExtend(clonedOptions, clusterEdgeProperties);\n      clonedOptions.from = fromId;\n      clonedOptions.to = toId;\n      clonedOptions.id = \"clusterEdge:\" + v42();\n      if (extraOptions !== void 0) {\n        deepExtend(clonedOptions, extraOptions);\n      }\n      var newEdge = this.body.functions.createEdge(clonedOptions);\n      newEdge.clusteringEdgeReplacingIds = [baseEdge.id];\n      newEdge.connect();\n      this.body.edges[newEdge.id] = newEdge;\n      return newEdge;\n    }\n  }, {\n    key: \"_clusterEdges\",\n    value: function _clusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties) {\n      if (childEdges instanceof Edge) {\n        var edge = childEdges;\n        var obj = {};\n        obj[edge.id] = edge;\n        childEdges = obj;\n      }\n      if (childNodes instanceof Node) {\n        var node = childNodes;\n        var _obj = {};\n        _obj[node.id] = node;\n        childNodes = _obj;\n      }\n      if (clusterNode === void 0 || clusterNode === null) {\n        throw new Error(\"_clusterEdges: parameter clusterNode required\");\n      }\n      if (clusterEdgeProperties === void 0) {\n        clusterEdgeProperties = clusterNode.clusterEdgeProperties;\n      }\n      this._createClusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties);\n      for (var edgeId in childEdges) {\n        if (Object.prototype.hasOwnProperty.call(childEdges, edgeId)) {\n          if (this.body.edges[edgeId] !== void 0) {\n            var _edge2 = this.body.edges[edgeId];\n            this._backupEdgeOptions(_edge2);\n            _edge2.setOptions({\n              physics: false\n            });\n          }\n        }\n      }\n      for (var nodeId in childNodes) {\n        if (Object.prototype.hasOwnProperty.call(childNodes, nodeId)) {\n          this.clusteredNodes[nodeId] = {\n            clusterId: clusterNode.id,\n            node: this.body.nodes[nodeId]\n          };\n          this.body.nodes[nodeId].setOptions({\n            physics: false\n          });\n        }\n      }\n    }\n  }, {\n    key: \"_getClusterNodeForNode\",\n    value: function _getClusterNodeForNode(nodeId) {\n      if (nodeId === void 0)\n        return void 0;\n      var clusteredNode = this.clusteredNodes[nodeId];\n      if (clusteredNode === void 0)\n        return void 0;\n      var clusterId = clusteredNode.clusterId;\n      if (clusterId === void 0)\n        return void 0;\n      return this.body.nodes[clusterId];\n    }\n  }, {\n    key: \"_filter\",\n    value: function _filter(arr, callback) {\n      var ret = [];\n      forEach$12(arr, function(item) {\n        if (callback(item)) {\n          ret.push(item);\n        }\n      });\n      return ret;\n    }\n  }, {\n    key: \"_updateState\",\n    value: function _updateState() {\n      var _this4 = this;\n      var nodeId;\n      var deletedNodeIds = [];\n      var deletedEdgeIds = {};\n      var eachClusterNode = function eachClusterNode2(callback) {\n        forEach$12(_this4.body.nodes, function(node2) {\n          if (node2.isCluster === true) {\n            callback(node2);\n          }\n        });\n      };\n      for (nodeId in this.clusteredNodes) {\n        if (!Object.prototype.hasOwnProperty.call(this.clusteredNodes, nodeId))\n          continue;\n        var node = this.body.nodes[nodeId];\n        if (node === void 0) {\n          deletedNodeIds.push(nodeId);\n        }\n      }\n      eachClusterNode(function(clusterNode) {\n        for (var n2 = 0; n2 < deletedNodeIds.length; n2++) {\n          delete clusterNode.containedNodes[deletedNodeIds[n2]];\n        }\n      });\n      for (var n = 0; n < deletedNodeIds.length; n++) {\n        delete this.clusteredNodes[deletedNodeIds[n]];\n      }\n      forEach$12(this.clusteredEdges, function(edgeId) {\n        var edge = _this4.body.edges[edgeId];\n        if (edge === void 0 || !edge.endPointsValid()) {\n          deletedEdgeIds[edgeId] = edgeId;\n        }\n      });\n      eachClusterNode(function(clusterNode) {\n        forEach$12(clusterNode.containedEdges, function(edge, edgeId) {\n          if (!edge.endPointsValid() && !deletedEdgeIds[edgeId]) {\n            deletedEdgeIds[edgeId] = edgeId;\n          }\n        });\n      });\n      forEach$12(this.body.edges, function(edge, edgeId) {\n        var isValid = true;\n        var replacedIds = edge.clusteringEdgeReplacingIds;\n        if (replacedIds !== void 0) {\n          var numValid = 0;\n          forEach$12(replacedIds, function(containedEdgeId) {\n            var containedEdge = _this4.body.edges[containedEdgeId];\n            if (containedEdge !== void 0 && containedEdge.endPointsValid()) {\n              numValid += 1;\n            }\n          });\n          isValid = numValid > 0;\n        }\n        if (!edge.endPointsValid() || !isValid) {\n          deletedEdgeIds[edgeId] = edgeId;\n        }\n      });\n      eachClusterNode(function(clusterNode) {\n        forEach$12(deletedEdgeIds, function(deletedEdgeId) {\n          delete clusterNode.containedEdges[deletedEdgeId];\n          forEach$12(clusterNode.edges, function(edge, m) {\n            if (edge.id === deletedEdgeId) {\n              clusterNode.edges[m] = null;\n              return;\n            }\n            edge.clusteringEdgeReplacingIds = _this4._filter(edge.clusteringEdgeReplacingIds, function(id22) {\n              return !deletedEdgeIds[id22];\n            });\n          });\n          clusterNode.edges = _this4._filter(clusterNode.edges, function(item) {\n            return item !== null;\n          });\n        });\n      });\n      forEach$12(deletedEdgeIds, function(edgeId) {\n        delete _this4.clusteredEdges[edgeId];\n      });\n      forEach$12(deletedEdgeIds, function(edgeId) {\n        delete _this4.body.edges[edgeId];\n      });\n      var ids = keys32(this.body.edges);\n      forEach$12(ids, function(edgeId) {\n        var edge = _this4.body.edges[edgeId];\n        var shouldBeClustered = _this4._isClusteredNode(edge.fromId) || _this4._isClusteredNode(edge.toId);\n        if (shouldBeClustered === _this4._isClusteredEdge(edge.id)) {\n          return;\n        }\n        if (shouldBeClustered) {\n          var clusterFrom = _this4._getClusterNodeForNode(edge.fromId);\n          if (clusterFrom !== void 0) {\n            _this4._clusterEdges(_this4.body.nodes[edge.fromId], edge, clusterFrom);\n          }\n          var clusterTo = _this4._getClusterNodeForNode(edge.toId);\n          if (clusterTo !== void 0) {\n            _this4._clusterEdges(_this4.body.nodes[edge.toId], edge, clusterTo);\n          }\n        } else {\n          delete _this4._clusterEdges[edgeId];\n          _this4._restoreEdge(edge);\n        }\n      });\n      var changed = false;\n      var continueLoop = true;\n      var _loop2 = function _loop22() {\n        var clustersToOpen = [];\n        eachClusterNode(function(clusterNode) {\n          var numNodes = keys32(clusterNode.containedNodes).length;\n          var allowSingle = clusterNode.options.allowSingleNodeCluster === true;\n          if (allowSingle && numNodes < 1 || !allowSingle && numNodes < 2) {\n            clustersToOpen.push(clusterNode.id);\n          }\n        });\n        for (var _n = 0; _n < clustersToOpen.length; ++_n) {\n          _this4.openCluster(clustersToOpen[_n], {}, false);\n        }\n        continueLoop = clustersToOpen.length > 0;\n        changed = changed || continueLoop;\n      };\n      while (continueLoop) {\n        _loop2();\n      }\n      if (changed) {\n        this._updateState();\n      }\n    }\n  }, {\n    key: \"_isClusteredNode\",\n    value: function _isClusteredNode(nodeId) {\n      return this.clusteredNodes[nodeId] !== void 0;\n    }\n  }, {\n    key: \"_isClusteredEdge\",\n    value: function _isClusteredEdge(edgeId) {\n      return this.clusteredEdges[edgeId] !== void 0;\n    }\n  }]);\n  return ClusterEngine2;\n}();\nfunction _createForOfIteratorHelper$5(o, allowArrayLike) {\n  var it2 = typeof symbol2 !== \"undefined\" && getIteratorMethod$12(o) || o[\"@@iterator\"];\n  if (!it2) {\n    if (isArray$12(o) || (it2 = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it2)\n        o = it2;\n      var i = 0;\n      var F2 = function F22() {\n      };\n      return { s: F2, n: function n() {\n        if (i >= o.length)\n          return { done: true };\n        return { done: false, value: o[i++] };\n      }, e: function e(_e3) {\n        throw _e3;\n      }, f: F2 };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true, didErr = false, err;\n  return { s: function s() {\n    it2 = it2.call(o);\n  }, n: function n() {\n    var step = it2.next();\n    normalCompletion = step.done;\n    return step;\n  }, e: function e(_e22) {\n    didErr = true;\n    err = _e22;\n  }, f: function f() {\n    try {\n      if (!normalCompletion && it2.return != null)\n        it2.return();\n    } finally {\n      if (didErr)\n        throw err;\n    }\n  } };\n}\nfunction _unsupportedIterableToArray$5(o, minLen) {\n  var _context4;\n  if (!o)\n    return;\n  if (typeof o === \"string\")\n    return _arrayLikeToArray$5(o, minLen);\n  var n = slice22(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1);\n  if (n === \"Object\" && o.constructor)\n    n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\")\n    return from$32(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray$5(o, minLen);\n}\nfunction _arrayLikeToArray$5(arr, len) {\n  if (len == null || len > arr.length)\n    len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _initRequestAnimationFrame() {\n  var func;\n  if (window !== void 0) {\n    func = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n  }\n  if (func === void 0) {\n    window.requestAnimationFrame = function(callback) {\n      callback();\n    };\n  } else {\n    window.requestAnimationFrame = func;\n  }\n}\nvar CanvasRenderer = /* @__PURE__ */ function() {\n  function CanvasRenderer2(body, canvas) {\n    _classCallCheck2(this, CanvasRenderer2);\n    _initRequestAnimationFrame();\n    this.body = body;\n    this.canvas = canvas;\n    this.redrawRequested = false;\n    this.renderTimer = void 0;\n    this.requiresTimeout = true;\n    this.renderingActive = false;\n    this.renderRequests = 0;\n    this.allowRedraw = true;\n    this.dragging = false;\n    this.zooming = false;\n    this.options = {};\n    this.defaultOptions = {\n      hideEdgesOnDrag: false,\n      hideEdgesOnZoom: false,\n      hideNodesOnDrag: false\n    };\n    assign$22(this.options, this.defaultOptions);\n    this._determineBrowserMethod();\n    this.bindEventListeners();\n  }\n  _createClass2(CanvasRenderer2, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this = this, _context2;\n      this.body.emitter.on(\"dragStart\", function() {\n        _this.dragging = true;\n      });\n      this.body.emitter.on(\"dragEnd\", function() {\n        _this.dragging = false;\n      });\n      this.body.emitter.on(\"zoom\", function() {\n        _this.zooming = true;\n        window.clearTimeout(_this.zoomTimeoutId);\n        _this.zoomTimeoutId = setTimeout$12(function() {\n          var _context;\n          _this.zooming = false;\n          bind$52(_context = _this._requestRedraw).call(_context, _this)();\n        }, 250);\n      });\n      this.body.emitter.on(\"_resizeNodes\", function() {\n        _this._resizeNodes();\n      });\n      this.body.emitter.on(\"_redraw\", function() {\n        if (_this.renderingActive === false) {\n          _this._redraw();\n        }\n      });\n      this.body.emitter.on(\"_blockRedraw\", function() {\n        _this.allowRedraw = false;\n      });\n      this.body.emitter.on(\"_allowRedraw\", function() {\n        _this.allowRedraw = true;\n        _this.redrawRequested = false;\n      });\n      this.body.emitter.on(\"_requestRedraw\", bind$52(_context2 = this._requestRedraw).call(_context2, this));\n      this.body.emitter.on(\"_startRendering\", function() {\n        _this.renderRequests += 1;\n        _this.renderingActive = true;\n        _this._startRendering();\n      });\n      this.body.emitter.on(\"_stopRendering\", function() {\n        _this.renderRequests -= 1;\n        _this.renderingActive = _this.renderRequests > 0;\n        _this.renderTimer = void 0;\n      });\n      this.body.emitter.on(\"destroy\", function() {\n        _this.renderRequests = 0;\n        _this.allowRedraw = false;\n        _this.renderingActive = false;\n        if (_this.requiresTimeout === true) {\n          clearTimeout(_this.renderTimer);\n        } else {\n          window.cancelAnimationFrame(_this.renderTimer);\n        }\n        _this.body.emitter.off();\n      });\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      if (options2 !== void 0) {\n        var fields = [\"hideEdgesOnDrag\", \"hideEdgesOnZoom\", \"hideNodesOnDrag\"];\n        selectiveDeepExtend(fields, this.options, options2);\n      }\n    }\n  }, {\n    key: \"_requestNextFrame\",\n    value: function _requestNextFrame(callback, delay) {\n      if (typeof window === \"undefined\")\n        return;\n      var timer;\n      var myWindow = window;\n      if (this.requiresTimeout === true) {\n        timer = setTimeout$12(callback, delay);\n      } else {\n        if (myWindow.requestAnimationFrame) {\n          timer = myWindow.requestAnimationFrame(callback);\n        }\n      }\n      return timer;\n    }\n  }, {\n    key: \"_startRendering\",\n    value: function _startRendering() {\n      if (this.renderingActive === true) {\n        if (this.renderTimer === void 0) {\n          var _context3;\n          this.renderTimer = this._requestNextFrame(bind$52(_context3 = this._renderStep).call(_context3, this), this.simulationInterval);\n        }\n      }\n    }\n  }, {\n    key: \"_renderStep\",\n    value: function _renderStep() {\n      if (this.renderingActive === true) {\n        this.renderTimer = void 0;\n        if (this.requiresTimeout === true) {\n          this._startRendering();\n        }\n        this._redraw();\n        if (this.requiresTimeout === false) {\n          this._startRendering();\n        }\n      }\n    }\n  }, {\n    key: \"redraw\",\n    value: function redraw() {\n      this.body.emitter.emit(\"setSize\");\n      this._redraw();\n    }\n  }, {\n    key: \"_requestRedraw\",\n    value: function _requestRedraw() {\n      var _this2 = this;\n      if (this.redrawRequested !== true && this.renderingActive === false && this.allowRedraw === true) {\n        this.redrawRequested = true;\n        this._requestNextFrame(function() {\n          _this2._redraw(false);\n        }, 0);\n      }\n    }\n  }, {\n    key: \"_redraw\",\n    value: function _redraw() {\n      var hidden = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n      if (this.allowRedraw === true) {\n        this.body.emitter.emit(\"initRedraw\");\n        this.redrawRequested = false;\n        var drawLater = {\n          drawExternalLabels: null\n        };\n        if (this.canvas.frame.canvas.width === 0 || this.canvas.frame.canvas.height === 0) {\n          this.canvas.setSize();\n        }\n        this.canvas.setTransform();\n        var ctx = this.canvas.getContext();\n        var w = this.canvas.frame.canvas.clientWidth;\n        var h = this.canvas.frame.canvas.clientHeight;\n        ctx.clearRect(0, 0, w, h);\n        if (this.canvas.frame.clientWidth === 0) {\n          return;\n        }\n        ctx.save();\n        ctx.translate(this.body.view.translation.x, this.body.view.translation.y);\n        ctx.scale(this.body.view.scale, this.body.view.scale);\n        ctx.beginPath();\n        this.body.emitter.emit(\"beforeDrawing\", ctx);\n        ctx.closePath();\n        if (hidden === false) {\n          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {\n            this._drawEdges(ctx);\n          }\n        }\n        if (this.dragging === false || this.dragging === true && this.options.hideNodesOnDrag === false) {\n          var _this$_drawNodes = this._drawNodes(ctx, hidden), drawExternalLabels = _this$_drawNodes.drawExternalLabels;\n          drawLater.drawExternalLabels = drawExternalLabels;\n        }\n        if (hidden === false) {\n          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {\n            this._drawArrows(ctx);\n          }\n        }\n        if (drawLater.drawExternalLabels != null) {\n          drawLater.drawExternalLabels();\n        }\n        if (hidden === false) {\n          this._drawSelectionBox(ctx);\n        }\n        ctx.beginPath();\n        this.body.emitter.emit(\"afterDrawing\", ctx);\n        ctx.closePath();\n        ctx.restore();\n        if (hidden === true) {\n          ctx.clearRect(0, 0, w, h);\n        }\n      }\n    }\n  }, {\n    key: \"_resizeNodes\",\n    value: function _resizeNodes() {\n      this.canvas.setTransform();\n      var ctx = this.canvas.getContext();\n      ctx.save();\n      ctx.translate(this.body.view.translation.x, this.body.view.translation.y);\n      ctx.scale(this.body.view.scale, this.body.view.scale);\n      var nodes = this.body.nodes;\n      var node;\n      for (var nodeId in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n          node = nodes[nodeId];\n          node.resize(ctx);\n          node.updateBoundingBox(ctx, node.selected);\n        }\n      }\n      ctx.restore();\n    }\n  }, {\n    key: \"_drawNodes\",\n    value: function _drawNodes(ctx) {\n      var alwaysShow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n      var nodes = this.body.nodes;\n      var nodeIndices = this.body.nodeIndices;\n      var node;\n      var selected = [];\n      var hovered = [];\n      var margin = 20;\n      var topLeft = this.canvas.DOMtoCanvas({\n        x: -margin,\n        y: -margin\n      });\n      var bottomRight = this.canvas.DOMtoCanvas({\n        x: this.canvas.frame.canvas.clientWidth + margin,\n        y: this.canvas.frame.canvas.clientHeight + margin\n      });\n      var viewableArea = {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x\n      };\n      var _drawExternalLabels = [];\n      for (var _i = 0; _i < nodeIndices.length; _i++) {\n        node = nodes[nodeIndices[_i]];\n        if (node.hover) {\n          hovered.push(nodeIndices[_i]);\n        } else if (node.isSelected()) {\n          selected.push(nodeIndices[_i]);\n        } else {\n          if (alwaysShow === true) {\n            var drawLater = node.draw(ctx);\n            if (drawLater.drawExternalLabel != null) {\n              _drawExternalLabels.push(drawLater.drawExternalLabel);\n            }\n          } else if (node.isBoundingBoxOverlappingWith(viewableArea) === true) {\n            var _drawLater = node.draw(ctx);\n            if (_drawLater.drawExternalLabel != null) {\n              _drawExternalLabels.push(_drawLater.drawExternalLabel);\n            }\n          } else {\n            node.updateBoundingBox(ctx, node.selected);\n          }\n        }\n      }\n      var i;\n      var selectedLength = selected.length;\n      var hoveredLength = hovered.length;\n      for (i = 0; i < selectedLength; i++) {\n        node = nodes[selected[i]];\n        var _drawLater2 = node.draw(ctx);\n        if (_drawLater2.drawExternalLabel != null) {\n          _drawExternalLabels.push(_drawLater2.drawExternalLabel);\n        }\n      }\n      for (i = 0; i < hoveredLength; i++) {\n        node = nodes[hovered[i]];\n        var _drawLater3 = node.draw(ctx);\n        if (_drawLater3.drawExternalLabel != null) {\n          _drawExternalLabels.push(_drawLater3.drawExternalLabel);\n        }\n      }\n      return {\n        drawExternalLabels: function drawExternalLabels() {\n          var _iterator = _createForOfIteratorHelper$5(_drawExternalLabels), _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done; ) {\n              var draw = _step.value;\n              draw();\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      };\n    }\n  }, {\n    key: \"_drawEdges\",\n    value: function _drawEdges(ctx) {\n      var edges = this.body.edges;\n      var edgeIndices = this.body.edgeIndices;\n      for (var i = 0; i < edgeIndices.length; i++) {\n        var edge = edges[edgeIndices[i]];\n        if (edge.connected === true) {\n          edge.draw(ctx);\n        }\n      }\n    }\n  }, {\n    key: \"_drawArrows\",\n    value: function _drawArrows(ctx) {\n      var edges = this.body.edges;\n      var edgeIndices = this.body.edgeIndices;\n      for (var i = 0; i < edgeIndices.length; i++) {\n        var edge = edges[edgeIndices[i]];\n        if (edge.connected === true) {\n          edge.drawArrows(ctx);\n        }\n      }\n    }\n  }, {\n    key: \"_determineBrowserMethod\",\n    value: function _determineBrowserMethod() {\n      if (typeof window !== \"undefined\") {\n        var browserType = navigator.userAgent.toLowerCase();\n        this.requiresTimeout = false;\n        if (indexOf22(browserType).call(browserType, \"msie 9.0\") != -1) {\n          this.requiresTimeout = true;\n        } else if (indexOf22(browserType).call(browserType, \"safari\") != -1) {\n          if (indexOf22(browserType).call(browserType, \"chrome\") <= -1) {\n            this.requiresTimeout = true;\n          }\n        }\n      } else {\n        this.requiresTimeout = true;\n      }\n    }\n  }, {\n    key: \"_drawSelectionBox\",\n    value: function _drawSelectionBox(ctx) {\n      if (this.body.selectionBox.show) {\n        ctx.beginPath();\n        var width = this.body.selectionBox.position.end.x - this.body.selectionBox.position.start.x;\n        var height = this.body.selectionBox.position.end.y - this.body.selectionBox.position.start.y;\n        ctx.rect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);\n        ctx.fillStyle = \"rgba(151, 194, 252, 0.2)\";\n        ctx.fillRect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);\n        ctx.strokeStyle = \"rgba(151, 194, 252, 1)\";\n        ctx.stroke();\n      } else {\n        ctx.closePath();\n      }\n    }\n  }]);\n  return CanvasRenderer2;\n}();\nvar path$22 = path$y;\nvar setInterval$1 = path$22.setInterval;\nvar setInterval = setInterval$1;\nfunction onTouch(hammer, callback) {\n  callback.inputHandler = function(event) {\n    if (event.isFirst) {\n      callback(event);\n    }\n  };\n  hammer.on(\"hammer.input\", callback.inputHandler);\n}\nfunction onRelease(hammer, callback) {\n  callback.inputHandler = function(event) {\n    if (event.isFinal) {\n      callback(event);\n    }\n  };\n  return hammer.on(\"hammer.input\", callback.inputHandler);\n}\nvar Canvas = /* @__PURE__ */ function() {\n  function Canvas2(body) {\n    _classCallCheck2(this, Canvas2);\n    this.body = body;\n    this.pixelRatio = 1;\n    this.cameraState = {};\n    this.initialized = false;\n    this.canvasViewCenter = {};\n    this._cleanupCallbacks = [];\n    this.options = {};\n    this.defaultOptions = {\n      autoResize: true,\n      height: \"100%\",\n      width: \"100%\"\n    };\n    assign$22(this.options, this.defaultOptions);\n    this.bindEventListeners();\n  }\n  _createClass2(Canvas2, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this = this, _context;\n      this.body.emitter.once(\"resize\", function(obj) {\n        if (obj.width !== 0) {\n          _this.body.view.translation.x = obj.width * 0.5;\n        }\n        if (obj.height !== 0) {\n          _this.body.view.translation.y = obj.height * 0.5;\n        }\n      });\n      this.body.emitter.on(\"setSize\", bind$52(_context = this.setSize).call(_context, this));\n      this.body.emitter.on(\"destroy\", function() {\n        _this.hammerFrame.destroy();\n        _this.hammer.destroy();\n        _this._cleanUp();\n      });\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      var _this2 = this;\n      if (options2 !== void 0) {\n        var fields = [\"width\", \"height\", \"autoResize\"];\n        selectiveDeepExtend(fields, this.options, options2);\n      }\n      this._cleanUp();\n      if (this.options.autoResize === true) {\n        var _context2;\n        if (window.ResizeObserver) {\n          var observer = new ResizeObserver(function() {\n            var changed = _this2.setSize();\n            if (changed === true) {\n              _this2.body.emitter.emit(\"_requestRedraw\");\n            }\n          });\n          var frame = this.frame;\n          observer.observe(frame);\n          this._cleanupCallbacks.push(function() {\n            observer.unobserve(frame);\n          });\n        } else {\n          var resizeTimer = setInterval(function() {\n            var changed = _this2.setSize();\n            if (changed === true) {\n              _this2.body.emitter.emit(\"_requestRedraw\");\n            }\n          }, 1e3);\n          this._cleanupCallbacks.push(function() {\n            clearInterval(resizeTimer);\n          });\n        }\n        var resizeFunction = bind$52(_context2 = this._onResize).call(_context2, this);\n        addEventListener(window, \"resize\", resizeFunction);\n        this._cleanupCallbacks.push(function() {\n          removeEventListener(window, \"resize\", resizeFunction);\n        });\n      }\n    }\n  }, {\n    key: \"_cleanUp\",\n    value: function _cleanUp() {\n      var _context3, _context4, _context5;\n      forEach$22(_context3 = reverse22(_context4 = splice$12(_context5 = this._cleanupCallbacks).call(_context5, 0)).call(_context4)).call(_context3, function(callback) {\n        try {\n          callback();\n        } catch (error) {\n          console.error(error);\n        }\n      });\n    }\n  }, {\n    key: \"_onResize\",\n    value: function _onResize() {\n      this.setSize();\n      this.body.emitter.emit(\"_redraw\");\n    }\n  }, {\n    key: \"_getCameraState\",\n    value: function _getCameraState() {\n      var pixelRatio = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.pixelRatio;\n      if (this.initialized === true) {\n        this.cameraState.previousWidth = this.frame.canvas.width / pixelRatio;\n        this.cameraState.previousHeight = this.frame.canvas.height / pixelRatio;\n        this.cameraState.scale = this.body.view.scale;\n        this.cameraState.position = this.DOMtoCanvas({\n          x: 0.5 * this.frame.canvas.width / pixelRatio,\n          y: 0.5 * this.frame.canvas.height / pixelRatio\n        });\n      }\n    }\n  }, {\n    key: \"_setCameraState\",\n    value: function _setCameraState() {\n      if (this.cameraState.scale !== void 0 && this.frame.canvas.clientWidth !== 0 && this.frame.canvas.clientHeight !== 0 && this.pixelRatio !== 0 && this.cameraState.previousWidth > 0 && this.cameraState.previousHeight > 0) {\n        var widthRatio = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth;\n        var heightRatio = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight;\n        var newScale = this.cameraState.scale;\n        if (widthRatio != 1 && heightRatio != 1) {\n          newScale = this.cameraState.scale * 0.5 * (widthRatio + heightRatio);\n        } else if (widthRatio != 1) {\n          newScale = this.cameraState.scale * widthRatio;\n        } else if (heightRatio != 1) {\n          newScale = this.cameraState.scale * heightRatio;\n        }\n        this.body.view.scale = newScale;\n        var currentViewCenter = this.DOMtoCanvas({\n          x: 0.5 * this.frame.canvas.clientWidth,\n          y: 0.5 * this.frame.canvas.clientHeight\n        });\n        var distanceFromCenter = {\n          x: currentViewCenter.x - this.cameraState.position.x,\n          y: currentViewCenter.y - this.cameraState.position.y\n        };\n        this.body.view.translation.x += distanceFromCenter.x * this.body.view.scale;\n        this.body.view.translation.y += distanceFromCenter.y * this.body.view.scale;\n      }\n    }\n  }, {\n    key: \"_prepareValue\",\n    value: function _prepareValue(value) {\n      if (typeof value === \"number\") {\n        return value + \"px\";\n      } else if (typeof value === \"string\") {\n        if (indexOf22(value).call(value, \"%\") !== -1 || indexOf22(value).call(value, \"px\") !== -1) {\n          return value;\n        } else if (indexOf22(value).call(value, \"%\") === -1) {\n          return value + \"px\";\n        }\n      }\n      throw new Error(\"Could not use the value supplied for width or height:\" + value);\n    }\n  }, {\n    key: \"_create\",\n    value: function _create() {\n      while (this.body.container.hasChildNodes()) {\n        this.body.container.removeChild(this.body.container.firstChild);\n      }\n      this.frame = document.createElement(\"div\");\n      this.frame.className = \"vis-network\";\n      this.frame.style.position = \"relative\";\n      this.frame.style.overflow = \"hidden\";\n      this.frame.tabIndex = 0;\n      this.frame.canvas = document.createElement(\"canvas\");\n      this.frame.canvas.style.position = \"relative\";\n      this.frame.appendChild(this.frame.canvas);\n      if (!this.frame.canvas.getContext) {\n        var noCanvas = document.createElement(\"DIV\");\n        noCanvas.style.color = \"red\";\n        noCanvas.style.fontWeight = \"bold\";\n        noCanvas.style.padding = \"10px\";\n        noCanvas.innerText = \"Error: your browser does not support HTML canvas\";\n        this.frame.canvas.appendChild(noCanvas);\n      } else {\n        this._setPixelRatio();\n        this.setTransform();\n      }\n      this.body.container.appendChild(this.frame);\n      this.body.view.scale = 1;\n      this.body.view.translation = {\n        x: 0.5 * this.frame.canvas.clientWidth,\n        y: 0.5 * this.frame.canvas.clientHeight\n      };\n      this._bindHammer();\n    }\n  }, {\n    key: \"_bindHammer\",\n    value: function _bindHammer() {\n      var _this3 = this;\n      if (this.hammer !== void 0) {\n        this.hammer.destroy();\n      }\n      this.drag = {};\n      this.pinch = {};\n      this.hammer = new Hammer2(this.frame.canvas);\n      this.hammer.get(\"pinch\").set({\n        enable: true\n      });\n      this.hammer.get(\"pan\").set({\n        threshold: 5,\n        direction: Hammer2.DIRECTION_ALL\n      });\n      onTouch(this.hammer, function(event) {\n        _this3.body.eventListeners.onTouch(event);\n      });\n      this.hammer.on(\"tap\", function(event) {\n        _this3.body.eventListeners.onTap(event);\n      });\n      this.hammer.on(\"doubletap\", function(event) {\n        _this3.body.eventListeners.onDoubleTap(event);\n      });\n      this.hammer.on(\"press\", function(event) {\n        _this3.body.eventListeners.onHold(event);\n      });\n      this.hammer.on(\"panstart\", function(event) {\n        _this3.body.eventListeners.onDragStart(event);\n      });\n      this.hammer.on(\"panmove\", function(event) {\n        _this3.body.eventListeners.onDrag(event);\n      });\n      this.hammer.on(\"panend\", function(event) {\n        _this3.body.eventListeners.onDragEnd(event);\n      });\n      this.hammer.on(\"pinch\", function(event) {\n        _this3.body.eventListeners.onPinch(event);\n      });\n      this.frame.canvas.addEventListener(\"wheel\", function(event) {\n        _this3.body.eventListeners.onMouseWheel(event);\n      });\n      this.frame.canvas.addEventListener(\"mousemove\", function(event) {\n        _this3.body.eventListeners.onMouseMove(event);\n      });\n      this.frame.canvas.addEventListener(\"contextmenu\", function(event) {\n        _this3.body.eventListeners.onContext(event);\n      });\n      this.hammerFrame = new Hammer2(this.frame);\n      onRelease(this.hammerFrame, function(event) {\n        _this3.body.eventListeners.onRelease(event);\n      });\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize() {\n      var width = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.width;\n      var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.height;\n      width = this._prepareValue(width);\n      height = this._prepareValue(height);\n      var emitEvent = false;\n      var oldWidth = this.frame.canvas.width;\n      var oldHeight = this.frame.canvas.height;\n      var previousRatio = this.pixelRatio;\n      this._setPixelRatio();\n      if (width != this.options.width || height != this.options.height || this.frame.style.width != width || this.frame.style.height != height) {\n        this._getCameraState(previousRatio);\n        this.frame.style.width = width;\n        this.frame.style.height = height;\n        this.frame.canvas.style.width = \"100%\";\n        this.frame.canvas.style.height = \"100%\";\n        this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);\n        this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);\n        this.options.width = width;\n        this.options.height = height;\n        this.canvasViewCenter = {\n          x: 0.5 * this.frame.clientWidth,\n          y: 0.5 * this.frame.clientHeight\n        };\n        emitEvent = true;\n      } else {\n        var newWidth = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);\n        var newHeight = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);\n        if (this.frame.canvas.width !== newWidth || this.frame.canvas.height !== newHeight) {\n          this._getCameraState(previousRatio);\n        }\n        if (this.frame.canvas.width !== newWidth) {\n          this.frame.canvas.width = newWidth;\n          emitEvent = true;\n        }\n        if (this.frame.canvas.height !== newHeight) {\n          this.frame.canvas.height = newHeight;\n          emitEvent = true;\n        }\n      }\n      if (emitEvent === true) {\n        this.body.emitter.emit(\"resize\", {\n          width: Math.round(this.frame.canvas.width / this.pixelRatio),\n          height: Math.round(this.frame.canvas.height / this.pixelRatio),\n          oldWidth: Math.round(oldWidth / this.pixelRatio),\n          oldHeight: Math.round(oldHeight / this.pixelRatio)\n        });\n        this._setCameraState();\n      }\n      this.initialized = true;\n      return emitEvent;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.frame.canvas.getContext(\"2d\");\n    }\n  }, {\n    key: \"_determinePixelRatio\",\n    value: function _determinePixelRatio() {\n      var ctx = this.getContext();\n      if (ctx === void 0) {\n        throw new Error(\"Could not get canvax context\");\n      }\n      var numerator = 1;\n      if (typeof window !== \"undefined\") {\n        numerator = window.devicePixelRatio || 1;\n      }\n      var denominator = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\n      return numerator / denominator;\n    }\n  }, {\n    key: \"_setPixelRatio\",\n    value: function _setPixelRatio() {\n      this.pixelRatio = this._determinePixelRatio();\n    }\n  }, {\n    key: \"setTransform\",\n    value: function setTransform() {\n      var ctx = this.getContext();\n      if (ctx === void 0) {\n        throw new Error(\"Could not get canvax context\");\n      }\n      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n    }\n  }, {\n    key: \"_XconvertDOMtoCanvas\",\n    value: function _XconvertDOMtoCanvas(x) {\n      return (x - this.body.view.translation.x) / this.body.view.scale;\n    }\n  }, {\n    key: \"_XconvertCanvasToDOM\",\n    value: function _XconvertCanvasToDOM(x) {\n      return x * this.body.view.scale + this.body.view.translation.x;\n    }\n  }, {\n    key: \"_YconvertDOMtoCanvas\",\n    value: function _YconvertDOMtoCanvas(y) {\n      return (y - this.body.view.translation.y) / this.body.view.scale;\n    }\n  }, {\n    key: \"_YconvertCanvasToDOM\",\n    value: function _YconvertCanvasToDOM(y) {\n      return y * this.body.view.scale + this.body.view.translation.y;\n    }\n  }, {\n    key: \"canvasToDOM\",\n    value: function canvasToDOM(pos) {\n      return {\n        x: this._XconvertCanvasToDOM(pos.x),\n        y: this._YconvertCanvasToDOM(pos.y)\n      };\n    }\n  }, {\n    key: \"DOMtoCanvas\",\n    value: function DOMtoCanvas(pos) {\n      return {\n        x: this._XconvertDOMtoCanvas(pos.x),\n        y: this._YconvertDOMtoCanvas(pos.y)\n      };\n    }\n  }]);\n  return Canvas2;\n}();\nfunction normalizeFitOptions(rawOptions, allNodeIds) {\n  var options2 = assign$22({\n    nodes: allNodeIds,\n    minZoomLevel: Number.MIN_VALUE,\n    maxZoomLevel: 1\n  }, rawOptions !== null && rawOptions !== void 0 ? rawOptions : {});\n  if (!isArray$12(options2.nodes)) {\n    throw new TypeError(\"Nodes has to be an array of ids.\");\n  }\n  if (options2.nodes.length === 0) {\n    options2.nodes = allNodeIds;\n  }\n  if (!(typeof options2.minZoomLevel === \"number\" && options2.minZoomLevel > 0)) {\n    throw new TypeError(\"Min zoom level has to be a number higher than zero.\");\n  }\n  if (!(typeof options2.maxZoomLevel === \"number\" && options2.minZoomLevel <= options2.maxZoomLevel)) {\n    throw new TypeError(\"Max zoom level has to be a number higher than min zoom level.\");\n  }\n  return options2;\n}\nvar View = /* @__PURE__ */ function() {\n  function View2(body, canvas) {\n    var _context, _this = this, _context2;\n    _classCallCheck2(this, View2);\n    this.body = body;\n    this.canvas = canvas;\n    this.animationSpeed = 1 / this.renderRefreshRate;\n    this.animationEasingFunction = \"easeInOutQuint\";\n    this.easingTime = 0;\n    this.sourceScale = 0;\n    this.targetScale = 0;\n    this.sourceTranslation = 0;\n    this.targetTranslation = 0;\n    this.lockedOnNodeId = void 0;\n    this.lockedOnNodeOffset = void 0;\n    this.touchTime = 0;\n    this.viewFunction = void 0;\n    this.body.emitter.on(\"fit\", bind$52(_context = this.fit).call(_context, this));\n    this.body.emitter.on(\"animationFinished\", function() {\n      _this.body.emitter.emit(\"_stopRendering\");\n    });\n    this.body.emitter.on(\"unlockNode\", bind$52(_context2 = this.releaseNode).call(_context2, this));\n  }\n  _createClass2(View2, [{\n    key: \"setOptions\",\n    value: function setOptions() {\n      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n      this.options = options2;\n    }\n  }, {\n    key: \"fit\",\n    value: function fit(options2) {\n      var initialZoom = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n      options2 = normalizeFitOptions(options2, this.body.nodeIndices);\n      var canvasWidth = this.canvas.frame.canvas.clientWidth;\n      var canvasHeight = this.canvas.frame.canvas.clientHeight;\n      var range;\n      var zoomLevel;\n      if (canvasWidth === 0 || canvasHeight === 0) {\n        zoomLevel = 1;\n        range = NetworkUtil.getRange(this.body.nodes, options2.nodes);\n      } else if (initialZoom === true) {\n        var positionDefined = 0;\n        for (var nodeId in this.body.nodes) {\n          if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {\n            var node = this.body.nodes[nodeId];\n            if (node.predefinedPosition === true) {\n              positionDefined += 1;\n            }\n          }\n        }\n        if (positionDefined > 0.5 * this.body.nodeIndices.length) {\n          this.fit(options2, false);\n          return;\n        }\n        range = NetworkUtil.getRange(this.body.nodes, options2.nodes);\n        var numberOfNodes = this.body.nodeIndices.length;\n        zoomLevel = 12.662 / (numberOfNodes + 7.4147) + 0.0964822;\n        var factor = Math.min(canvasWidth / 600, canvasHeight / 600);\n        zoomLevel *= factor;\n      } else {\n        this.body.emitter.emit(\"_resizeNodes\");\n        range = NetworkUtil.getRange(this.body.nodes, options2.nodes);\n        var xDistance = Math.abs(range.maxX - range.minX) * 1.1;\n        var yDistance = Math.abs(range.maxY - range.minY) * 1.1;\n        var xZoomLevel = canvasWidth / xDistance;\n        var yZoomLevel = canvasHeight / yDistance;\n        zoomLevel = xZoomLevel <= yZoomLevel ? xZoomLevel : yZoomLevel;\n      }\n      if (zoomLevel > options2.maxZoomLevel) {\n        zoomLevel = options2.maxZoomLevel;\n      } else if (zoomLevel < options2.minZoomLevel) {\n        zoomLevel = options2.minZoomLevel;\n      }\n      var center = NetworkUtil.findCenter(range);\n      var animationOptions = {\n        position: center,\n        scale: zoomLevel,\n        animation: options2.animation\n      };\n      this.moveTo(animationOptions);\n    }\n  }, {\n    key: \"focus\",\n    value: function focus(nodeId) {\n      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n      if (this.body.nodes[nodeId] !== void 0) {\n        var nodePosition = {\n          x: this.body.nodes[nodeId].x,\n          y: this.body.nodes[nodeId].y\n        };\n        options2.position = nodePosition;\n        options2.lockedOnNode = nodeId;\n        this.moveTo(options2);\n      } else {\n        console.error(\"Node: \" + nodeId + \" cannot be found.\");\n      }\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(options2) {\n      if (options2 === void 0) {\n        options2 = {};\n        return;\n      }\n      if (options2.offset != null) {\n        if (options2.offset.x != null) {\n          options2.offset.x = +options2.offset.x;\n          if (!_isFinite(options2.offset.x)) {\n            throw new TypeError('The option \"offset.x\" has to be a finite number.');\n          }\n        } else {\n          options2.offset.x = 0;\n        }\n        if (options2.offset.y != null) {\n          options2.offset.y = +options2.offset.y;\n          if (!_isFinite(options2.offset.y)) {\n            throw new TypeError('The option \"offset.y\" has to be a finite number.');\n          }\n        } else {\n          options2.offset.x = 0;\n        }\n      } else {\n        options2.offset = {\n          x: 0,\n          y: 0\n        };\n      }\n      if (options2.position != null) {\n        if (options2.position.x != null) {\n          options2.position.x = +options2.position.x;\n          if (!_isFinite(options2.position.x)) {\n            throw new TypeError('The option \"position.x\" has to be a finite number.');\n          }\n        } else {\n          options2.position.x = 0;\n        }\n        if (options2.position.y != null) {\n          options2.position.y = +options2.position.y;\n          if (!_isFinite(options2.position.y)) {\n            throw new TypeError('The option \"position.y\" has to be a finite number.');\n          }\n        } else {\n          options2.position.x = 0;\n        }\n      } else {\n        options2.position = this.getViewPosition();\n      }\n      if (options2.scale != null) {\n        options2.scale = +options2.scale;\n        if (!(options2.scale > 0)) {\n          throw new TypeError('The option \"scale\" has to be a number greater than zero.');\n        }\n      } else {\n        options2.scale = this.body.view.scale;\n      }\n      if (options2.animation === void 0) {\n        options2.animation = {\n          duration: 0\n        };\n      }\n      if (options2.animation === false) {\n        options2.animation = {\n          duration: 0\n        };\n      }\n      if (options2.animation === true) {\n        options2.animation = {};\n      }\n      if (options2.animation.duration === void 0) {\n        options2.animation.duration = 1e3;\n      }\n      if (options2.animation.easingFunction === void 0) {\n        options2.animation.easingFunction = \"easeInOutQuad\";\n      }\n      this.animateView(options2);\n    }\n  }, {\n    key: \"animateView\",\n    value: function animateView(options2) {\n      if (options2 === void 0) {\n        return;\n      }\n      this.animationEasingFunction = options2.animation.easingFunction;\n      this.releaseNode();\n      if (options2.locked === true) {\n        this.lockedOnNodeId = options2.lockedOnNode;\n        this.lockedOnNodeOffset = options2.offset;\n      }\n      if (this.easingTime != 0) {\n        this._transitionRedraw(true);\n      }\n      this.sourceScale = this.body.view.scale;\n      this.sourceTranslation = this.body.view.translation;\n      this.targetScale = options2.scale;\n      this.body.view.scale = this.targetScale;\n      var viewCenter = this.canvas.DOMtoCanvas({\n        x: 0.5 * this.canvas.frame.canvas.clientWidth,\n        y: 0.5 * this.canvas.frame.canvas.clientHeight\n      });\n      var distanceFromCenter = {\n        x: viewCenter.x - options2.position.x,\n        y: viewCenter.y - options2.position.y\n      };\n      this.targetTranslation = {\n        x: this.sourceTranslation.x + distanceFromCenter.x * this.targetScale + options2.offset.x,\n        y: this.sourceTranslation.y + distanceFromCenter.y * this.targetScale + options2.offset.y\n      };\n      if (options2.animation.duration === 0) {\n        if (this.lockedOnNodeId != void 0) {\n          var _context3;\n          this.viewFunction = bind$52(_context3 = this._lockedRedraw).call(_context3, this);\n          this.body.emitter.on(\"initRedraw\", this.viewFunction);\n        } else {\n          this.body.view.scale = this.targetScale;\n          this.body.view.translation = this.targetTranslation;\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n      } else {\n        var _context4;\n        this.animationSpeed = 1 / (60 * options2.animation.duration * 1e-3) || 1 / 60;\n        this.animationEasingFunction = options2.animation.easingFunction;\n        this.viewFunction = bind$52(_context4 = this._transitionRedraw).call(_context4, this);\n        this.body.emitter.on(\"initRedraw\", this.viewFunction);\n        this.body.emitter.emit(\"_startRendering\");\n      }\n    }\n  }, {\n    key: \"_lockedRedraw\",\n    value: function _lockedRedraw() {\n      var nodePosition = {\n        x: this.body.nodes[this.lockedOnNodeId].x,\n        y: this.body.nodes[this.lockedOnNodeId].y\n      };\n      var viewCenter = this.canvas.DOMtoCanvas({\n        x: 0.5 * this.canvas.frame.canvas.clientWidth,\n        y: 0.5 * this.canvas.frame.canvas.clientHeight\n      });\n      var distanceFromCenter = {\n        x: viewCenter.x - nodePosition.x,\n        y: viewCenter.y - nodePosition.y\n      };\n      var sourceTranslation = this.body.view.translation;\n      var targetTranslation = {\n        x: sourceTranslation.x + distanceFromCenter.x * this.body.view.scale + this.lockedOnNodeOffset.x,\n        y: sourceTranslation.y + distanceFromCenter.y * this.body.view.scale + this.lockedOnNodeOffset.y\n      };\n      this.body.view.translation = targetTranslation;\n    }\n  }, {\n    key: \"releaseNode\",\n    value: function releaseNode() {\n      if (this.lockedOnNodeId !== void 0 && this.viewFunction !== void 0) {\n        this.body.emitter.off(\"initRedraw\", this.viewFunction);\n        this.lockedOnNodeId = void 0;\n        this.lockedOnNodeOffset = void 0;\n      }\n    }\n  }, {\n    key: \"_transitionRedraw\",\n    value: function _transitionRedraw() {\n      var finished = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n      this.easingTime += this.animationSpeed;\n      this.easingTime = finished === true ? 1 : this.easingTime;\n      var progress = easingFunctions[this.animationEasingFunction](this.easingTime);\n      this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * progress;\n      this.body.view.translation = {\n        x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * progress,\n        y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * progress\n      };\n      if (this.easingTime >= 1) {\n        this.body.emitter.off(\"initRedraw\", this.viewFunction);\n        this.easingTime = 0;\n        if (this.lockedOnNodeId != void 0) {\n          var _context5;\n          this.viewFunction = bind$52(_context5 = this._lockedRedraw).call(_context5, this);\n          this.body.emitter.on(\"initRedraw\", this.viewFunction);\n        }\n        this.body.emitter.emit(\"animationFinished\");\n      }\n    }\n  }, {\n    key: \"getScale\",\n    value: function getScale22() {\n      return this.body.view.scale;\n    }\n  }, {\n    key: \"getViewPosition\",\n    value: function getViewPosition() {\n      return this.canvas.DOMtoCanvas({\n        x: 0.5 * this.canvas.frame.canvas.clientWidth,\n        y: 0.5 * this.canvas.frame.canvas.clientHeight\n      });\n    }\n  }]);\n  return View2;\n}();\nfunction keycharm(options2) {\n  var preventDefault = options2 && options2.preventDefault || false;\n  var container = options2 && options2.container || window;\n  var _exportFunctions = {};\n  var _bound = {\n    keydown: {},\n    keyup: {}\n  };\n  var _keys = {};\n  var i;\n  for (i = 97; i <= 122; i++) {\n    _keys[String.fromCharCode(i)] = {\n      code: 65 + (i - 97),\n      shift: false\n    };\n  }\n  for (i = 65; i <= 90; i++) {\n    _keys[String.fromCharCode(i)] = {\n      code: i,\n      shift: true\n    };\n  }\n  for (i = 0; i <= 9; i++) {\n    _keys[\"\" + i] = {\n      code: 48 + i,\n      shift: false\n    };\n  }\n  for (i = 1; i <= 12; i++) {\n    _keys[\"F\" + i] = {\n      code: 111 + i,\n      shift: false\n    };\n  }\n  for (i = 0; i <= 9; i++) {\n    _keys[\"num\" + i] = {\n      code: 96 + i,\n      shift: false\n    };\n  }\n  _keys[\"num*\"] = {\n    code: 106,\n    shift: false\n  };\n  _keys[\"num+\"] = {\n    code: 107,\n    shift: false\n  };\n  _keys[\"num-\"] = {\n    code: 109,\n    shift: false\n  };\n  _keys[\"num/\"] = {\n    code: 111,\n    shift: false\n  };\n  _keys[\"num.\"] = {\n    code: 110,\n    shift: false\n  };\n  _keys[\"left\"] = {\n    code: 37,\n    shift: false\n  };\n  _keys[\"up\"] = {\n    code: 38,\n    shift: false\n  };\n  _keys[\"right\"] = {\n    code: 39,\n    shift: false\n  };\n  _keys[\"down\"] = {\n    code: 40,\n    shift: false\n  };\n  _keys[\"space\"] = {\n    code: 32,\n    shift: false\n  };\n  _keys[\"enter\"] = {\n    code: 13,\n    shift: false\n  };\n  _keys[\"shift\"] = {\n    code: 16,\n    shift: void 0\n  };\n  _keys[\"esc\"] = {\n    code: 27,\n    shift: false\n  };\n  _keys[\"backspace\"] = {\n    code: 8,\n    shift: false\n  };\n  _keys[\"tab\"] = {\n    code: 9,\n    shift: false\n  };\n  _keys[\"ctrl\"] = {\n    code: 17,\n    shift: false\n  };\n  _keys[\"alt\"] = {\n    code: 18,\n    shift: false\n  };\n  _keys[\"delete\"] = {\n    code: 46,\n    shift: false\n  };\n  _keys[\"pageup\"] = {\n    code: 33,\n    shift: false\n  };\n  _keys[\"pagedown\"] = {\n    code: 34,\n    shift: false\n  };\n  _keys[\"=\"] = {\n    code: 187,\n    shift: false\n  };\n  _keys[\"-\"] = {\n    code: 189,\n    shift: false\n  };\n  _keys[\"]\"] = {\n    code: 221,\n    shift: false\n  };\n  _keys[\"[\"] = {\n    code: 219,\n    shift: false\n  };\n  var down = function(event) {\n    handleEvent(event, \"keydown\");\n  };\n  var up = function(event) {\n    handleEvent(event, \"keyup\");\n  };\n  var handleEvent = function(event, type2) {\n    if (_bound[type2][event.keyCode] !== void 0) {\n      var bound = _bound[type2][event.keyCode];\n      for (var i2 = 0; i2 < bound.length; i2++) {\n        if (bound[i2].shift === void 0) {\n          bound[i2].fn(event);\n        } else if (bound[i2].shift == true && event.shiftKey == true) {\n          bound[i2].fn(event);\n        } else if (bound[i2].shift == false && event.shiftKey == false) {\n          bound[i2].fn(event);\n        }\n      }\n      if (preventDefault == true) {\n        event.preventDefault();\n      }\n    }\n  };\n  _exportFunctions.bind = function(key, callback, type2) {\n    if (type2 === void 0) {\n      type2 = \"keydown\";\n    }\n    if (_keys[key] === void 0) {\n      throw new Error(\"unsupported key: \" + key);\n    }\n    if (_bound[type2][_keys[key].code] === void 0) {\n      _bound[type2][_keys[key].code] = [];\n    }\n    _bound[type2][_keys[key].code].push({\n      fn: callback,\n      shift: _keys[key].shift\n    });\n  };\n  _exportFunctions.bindAll = function(callback, type2) {\n    if (type2 === void 0) {\n      type2 = \"keydown\";\n    }\n    for (var key in _keys) {\n      if (_keys.hasOwnProperty(key)) {\n        _exportFunctions.bind(key, callback, type2);\n      }\n    }\n  };\n  _exportFunctions.getKey = function(event) {\n    for (var key in _keys) {\n      if (_keys.hasOwnProperty(key)) {\n        if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {\n          return key;\n        } else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {\n          return key;\n        } else if (event.keyCode == _keys[key].code && key == \"shift\") {\n          return key;\n        }\n      }\n    }\n    return \"unknown key, currently not supported\";\n  };\n  _exportFunctions.unbind = function(key, callback, type2) {\n    if (type2 === void 0) {\n      type2 = \"keydown\";\n    }\n    if (_keys[key] === void 0) {\n      throw new Error(\"unsupported key: \" + key);\n    }\n    if (callback !== void 0) {\n      var newBindings = [];\n      var bound = _bound[type2][_keys[key].code];\n      if (bound !== void 0) {\n        for (var i2 = 0; i2 < bound.length; i2++) {\n          if (!(bound[i2].fn == callback && bound[i2].shift == _keys[key].shift)) {\n            newBindings.push(_bound[type2][_keys[key].code][i2]);\n          }\n        }\n      }\n      _bound[type2][_keys[key].code] = newBindings;\n    } else {\n      _bound[type2][_keys[key].code] = [];\n    }\n  };\n  _exportFunctions.reset = function() {\n    _bound = {\n      keydown: {},\n      keyup: {}\n    };\n  };\n  _exportFunctions.destroy = function() {\n    _bound = {\n      keydown: {},\n      keyup: {}\n    };\n    container.removeEventListener(\"keydown\", down, true);\n    container.removeEventListener(\"keyup\", up, true);\n  };\n  container.addEventListener(\"keydown\", down, true);\n  container.addEventListener(\"keyup\", up, true);\n  return _exportFunctions;\n}\nvar NavigationHandler = /* @__PURE__ */ function() {\n  function NavigationHandler2(body, canvas) {\n    var _this = this;\n    _classCallCheck2(this, NavigationHandler2);\n    this.body = body;\n    this.canvas = canvas;\n    this.iconsCreated = false;\n    this.navigationHammers = [];\n    this.boundFunctions = {};\n    this.touchTime = 0;\n    this.activated = false;\n    this.body.emitter.on(\"activate\", function() {\n      _this.activated = true;\n      _this.configureKeyboardBindings();\n    });\n    this.body.emitter.on(\"deactivate\", function() {\n      _this.activated = false;\n      _this.configureKeyboardBindings();\n    });\n    this.body.emitter.on(\"destroy\", function() {\n      if (_this.keycharm !== void 0) {\n        _this.keycharm.destroy();\n      }\n    });\n    this.options = {};\n  }\n  _createClass2(NavigationHandler2, [{\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      if (options2 !== void 0) {\n        this.options = options2;\n        this.create();\n      }\n    }\n  }, {\n    key: \"create\",\n    value: function create52() {\n      if (this.options.navigationButtons === true) {\n        if (this.iconsCreated === false) {\n          this.loadNavigationElements();\n        }\n      } else if (this.iconsCreated === true) {\n        this.cleanNavigation();\n      }\n      this.configureKeyboardBindings();\n    }\n  }, {\n    key: \"cleanNavigation\",\n    value: function cleanNavigation() {\n      if (this.navigationHammers.length != 0) {\n        for (var i = 0; i < this.navigationHammers.length; i++) {\n          this.navigationHammers[i].destroy();\n        }\n        this.navigationHammers = [];\n      }\n      if (this.navigationDOM && this.navigationDOM[\"wrapper\"] && this.navigationDOM[\"wrapper\"].parentNode) {\n        this.navigationDOM[\"wrapper\"].parentNode.removeChild(this.navigationDOM[\"wrapper\"]);\n      }\n      this.iconsCreated = false;\n    }\n  }, {\n    key: \"loadNavigationElements\",\n    value: function loadNavigationElements() {\n      var _this2 = this;\n      this.cleanNavigation();\n      this.navigationDOM = {};\n      var navigationDivs = [\"up\", \"down\", \"left\", \"right\", \"zoomIn\", \"zoomOut\", \"zoomExtends\"];\n      var navigationDivActions = [\"_moveUp\", \"_moveDown\", \"_moveLeft\", \"_moveRight\", \"_zoomIn\", \"_zoomOut\", \"_fit\"];\n      this.navigationDOM[\"wrapper\"] = document.createElement(\"div\");\n      this.navigationDOM[\"wrapper\"].className = \"vis-navigation\";\n      this.canvas.frame.appendChild(this.navigationDOM[\"wrapper\"]);\n      for (var i = 0; i < navigationDivs.length; i++) {\n        this.navigationDOM[navigationDivs[i]] = document.createElement(\"div\");\n        this.navigationDOM[navigationDivs[i]].className = \"vis-button vis-\" + navigationDivs[i];\n        this.navigationDOM[\"wrapper\"].appendChild(this.navigationDOM[navigationDivs[i]]);\n        var hammer = new Hammer2(this.navigationDOM[navigationDivs[i]]);\n        if (navigationDivActions[i] === \"_fit\") {\n          var _context;\n          onTouch(hammer, bind$52(_context = this._fit).call(_context, this));\n        } else {\n          var _context2;\n          onTouch(hammer, bind$52(_context2 = this.bindToRedraw).call(_context2, this, navigationDivActions[i]));\n        }\n        this.navigationHammers.push(hammer);\n      }\n      var hammerFrame = new Hammer2(this.canvas.frame);\n      onRelease(hammerFrame, function() {\n        _this2._stopMovement();\n      });\n      this.navigationHammers.push(hammerFrame);\n      this.iconsCreated = true;\n    }\n  }, {\n    key: \"bindToRedraw\",\n    value: function bindToRedraw(action) {\n      if (this.boundFunctions[action] === void 0) {\n        var _context3;\n        this.boundFunctions[action] = bind$52(_context3 = this[action]).call(_context3, this);\n        this.body.emitter.on(\"initRedraw\", this.boundFunctions[action]);\n        this.body.emitter.emit(\"_startRendering\");\n      }\n    }\n  }, {\n    key: \"unbindFromRedraw\",\n    value: function unbindFromRedraw(action) {\n      if (this.boundFunctions[action] !== void 0) {\n        this.body.emitter.off(\"initRedraw\", this.boundFunctions[action]);\n        this.body.emitter.emit(\"_stopRendering\");\n        delete this.boundFunctions[action];\n      }\n    }\n  }, {\n    key: \"_fit\",\n    value: function _fit() {\n      if (new Date().valueOf() - this.touchTime > 700) {\n        this.body.emitter.emit(\"fit\", {\n          duration: 700\n        });\n        this.touchTime = new Date().valueOf();\n      }\n    }\n  }, {\n    key: \"_stopMovement\",\n    value: function _stopMovement() {\n      for (var boundAction in this.boundFunctions) {\n        if (Object.prototype.hasOwnProperty.call(this.boundFunctions, boundAction)) {\n          this.body.emitter.off(\"initRedraw\", this.boundFunctions[boundAction]);\n          this.body.emitter.emit(\"_stopRendering\");\n        }\n      }\n      this.boundFunctions = {};\n    }\n  }, {\n    key: \"_moveUp\",\n    value: function _moveUp() {\n      this.body.view.translation.y += this.options.keyboard.speed.y;\n    }\n  }, {\n    key: \"_moveDown\",\n    value: function _moveDown() {\n      this.body.view.translation.y -= this.options.keyboard.speed.y;\n    }\n  }, {\n    key: \"_moveLeft\",\n    value: function _moveLeft() {\n      this.body.view.translation.x += this.options.keyboard.speed.x;\n    }\n  }, {\n    key: \"_moveRight\",\n    value: function _moveRight() {\n      this.body.view.translation.x -= this.options.keyboard.speed.x;\n    }\n  }, {\n    key: \"_zoomIn\",\n    value: function _zoomIn() {\n      var scaleOld = this.body.view.scale;\n      var scale = this.body.view.scale * (1 + this.options.keyboard.speed.zoom);\n      var translation = this.body.view.translation;\n      var scaleFrac = scale / scaleOld;\n      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;\n      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;\n      this.body.view.scale = scale;\n      this.body.view.translation = {\n        x: tx,\n        y: ty\n      };\n      this.body.emitter.emit(\"zoom\", {\n        direction: \"+\",\n        scale: this.body.view.scale,\n        pointer: null\n      });\n    }\n  }, {\n    key: \"_zoomOut\",\n    value: function _zoomOut() {\n      var scaleOld = this.body.view.scale;\n      var scale = this.body.view.scale / (1 + this.options.keyboard.speed.zoom);\n      var translation = this.body.view.translation;\n      var scaleFrac = scale / scaleOld;\n      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;\n      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;\n      this.body.view.scale = scale;\n      this.body.view.translation = {\n        x: tx,\n        y: ty\n      };\n      this.body.emitter.emit(\"zoom\", {\n        direction: \"-\",\n        scale: this.body.view.scale,\n        pointer: null\n      });\n    }\n  }, {\n    key: \"configureKeyboardBindings\",\n    value: function configureKeyboardBindings() {\n      var _this3 = this;\n      if (this.keycharm !== void 0) {\n        this.keycharm.destroy();\n      }\n      if (this.options.keyboard.enabled === true) {\n        if (this.options.keyboard.bindToWindow === true) {\n          this.keycharm = keycharm({\n            container: window,\n            preventDefault: true\n          });\n        } else {\n          this.keycharm = keycharm({\n            container: this.canvas.frame,\n            preventDefault: true\n          });\n        }\n        this.keycharm.reset();\n        if (this.activated === true) {\n          var _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13, _context14, _context15, _context16, _context17, _context18, _context19, _context20, _context21, _context22, _context23, _context24, _context25, _context26, _context27;\n          bind$52(_context4 = this.keycharm).call(_context4, \"up\", function() {\n            _this3.bindToRedraw(\"_moveUp\");\n          }, \"keydown\");\n          bind$52(_context5 = this.keycharm).call(_context5, \"down\", function() {\n            _this3.bindToRedraw(\"_moveDown\");\n          }, \"keydown\");\n          bind$52(_context6 = this.keycharm).call(_context6, \"left\", function() {\n            _this3.bindToRedraw(\"_moveLeft\");\n          }, \"keydown\");\n          bind$52(_context7 = this.keycharm).call(_context7, \"right\", function() {\n            _this3.bindToRedraw(\"_moveRight\");\n          }, \"keydown\");\n          bind$52(_context8 = this.keycharm).call(_context8, \"=\", function() {\n            _this3.bindToRedraw(\"_zoomIn\");\n          }, \"keydown\");\n          bind$52(_context9 = this.keycharm).call(_context9, \"num+\", function() {\n            _this3.bindToRedraw(\"_zoomIn\");\n          }, \"keydown\");\n          bind$52(_context10 = this.keycharm).call(_context10, \"num-\", function() {\n            _this3.bindToRedraw(\"_zoomOut\");\n          }, \"keydown\");\n          bind$52(_context11 = this.keycharm).call(_context11, \"-\", function() {\n            _this3.bindToRedraw(\"_zoomOut\");\n          }, \"keydown\");\n          bind$52(_context12 = this.keycharm).call(_context12, \"[\", function() {\n            _this3.bindToRedraw(\"_zoomOut\");\n          }, \"keydown\");\n          bind$52(_context13 = this.keycharm).call(_context13, \"]\", function() {\n            _this3.bindToRedraw(\"_zoomIn\");\n          }, \"keydown\");\n          bind$52(_context14 = this.keycharm).call(_context14, \"pageup\", function() {\n            _this3.bindToRedraw(\"_zoomIn\");\n          }, \"keydown\");\n          bind$52(_context15 = this.keycharm).call(_context15, \"pagedown\", function() {\n            _this3.bindToRedraw(\"_zoomOut\");\n          }, \"keydown\");\n          bind$52(_context16 = this.keycharm).call(_context16, \"up\", function() {\n            _this3.unbindFromRedraw(\"_moveUp\");\n          }, \"keyup\");\n          bind$52(_context17 = this.keycharm).call(_context17, \"down\", function() {\n            _this3.unbindFromRedraw(\"_moveDown\");\n          }, \"keyup\");\n          bind$52(_context18 = this.keycharm).call(_context18, \"left\", function() {\n            _this3.unbindFromRedraw(\"_moveLeft\");\n          }, \"keyup\");\n          bind$52(_context19 = this.keycharm).call(_context19, \"right\", function() {\n            _this3.unbindFromRedraw(\"_moveRight\");\n          }, \"keyup\");\n          bind$52(_context20 = this.keycharm).call(_context20, \"=\", function() {\n            _this3.unbindFromRedraw(\"_zoomIn\");\n          }, \"keyup\");\n          bind$52(_context21 = this.keycharm).call(_context21, \"num+\", function() {\n            _this3.unbindFromRedraw(\"_zoomIn\");\n          }, \"keyup\");\n          bind$52(_context22 = this.keycharm).call(_context22, \"num-\", function() {\n            _this3.unbindFromRedraw(\"_zoomOut\");\n          }, \"keyup\");\n          bind$52(_context23 = this.keycharm).call(_context23, \"-\", function() {\n            _this3.unbindFromRedraw(\"_zoomOut\");\n          }, \"keyup\");\n          bind$52(_context24 = this.keycharm).call(_context24, \"[\", function() {\n            _this3.unbindFromRedraw(\"_zoomOut\");\n          }, \"keyup\");\n          bind$52(_context25 = this.keycharm).call(_context25, \"]\", function() {\n            _this3.unbindFromRedraw(\"_zoomIn\");\n          }, \"keyup\");\n          bind$52(_context26 = this.keycharm).call(_context26, \"pageup\", function() {\n            _this3.unbindFromRedraw(\"_zoomIn\");\n          }, \"keyup\");\n          bind$52(_context27 = this.keycharm).call(_context27, \"pagedown\", function() {\n            _this3.unbindFromRedraw(\"_zoomOut\");\n          }, \"keyup\");\n        }\n      }\n    }\n  }]);\n  return NavigationHandler2;\n}();\nfunction _createForOfIteratorHelper$4(o, allowArrayLike) {\n  var it2 = typeof symbol2 !== \"undefined\" && getIteratorMethod$12(o) || o[\"@@iterator\"];\n  if (!it2) {\n    if (isArray$12(o) || (it2 = _unsupportedIterableToArray$42(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it2)\n        o = it2;\n      var i = 0;\n      var F2 = function F22() {\n      };\n      return { s: F2, n: function n() {\n        if (i >= o.length)\n          return { done: true };\n        return { done: false, value: o[i++] };\n      }, e: function e(_e3) {\n        throw _e3;\n      }, f: F2 };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true, didErr = false, err;\n  return { s: function s() {\n    it2 = it2.call(o);\n  }, n: function n() {\n    var step = it2.next();\n    normalCompletion = step.done;\n    return step;\n  }, e: function e(_e22) {\n    didErr = true;\n    err = _e22;\n  }, f: function f() {\n    try {\n      if (!normalCompletion && it2.return != null)\n        it2.return();\n    } finally {\n      if (didErr)\n        throw err;\n    }\n  } };\n}\nfunction _unsupportedIterableToArray$42(o, minLen) {\n  var _context15;\n  if (!o)\n    return;\n  if (typeof o === \"string\")\n    return _arrayLikeToArray$42(o, minLen);\n  var n = slice22(_context15 = Object.prototype.toString.call(o)).call(_context15, 8, -1);\n  if (n === \"Object\" && o.constructor)\n    n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\")\n    return from$32(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray$42(o, minLen);\n}\nfunction _arrayLikeToArray$42(arr, len) {\n  if (len == null || len > arr.length)\n    len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar InteractionHandler = /* @__PURE__ */ function() {\n  function InteractionHandler2(body, canvas, selectionHandler) {\n    var _context, _context2, _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13;\n    _classCallCheck2(this, InteractionHandler2);\n    this.body = body;\n    this.canvas = canvas;\n    this.selectionHandler = selectionHandler;\n    this.navigationHandler = new NavigationHandler(body, canvas);\n    this.body.eventListeners.onTap = bind$52(_context = this.onTap).call(_context, this);\n    this.body.eventListeners.onTouch = bind$52(_context2 = this.onTouch).call(_context2, this);\n    this.body.eventListeners.onDoubleTap = bind$52(_context3 = this.onDoubleTap).call(_context3, this);\n    this.body.eventListeners.onHold = bind$52(_context4 = this.onHold).call(_context4, this);\n    this.body.eventListeners.onDragStart = bind$52(_context5 = this.onDragStart).call(_context5, this);\n    this.body.eventListeners.onDrag = bind$52(_context6 = this.onDrag).call(_context6, this);\n    this.body.eventListeners.onDragEnd = bind$52(_context7 = this.onDragEnd).call(_context7, this);\n    this.body.eventListeners.onMouseWheel = bind$52(_context8 = this.onMouseWheel).call(_context8, this);\n    this.body.eventListeners.onPinch = bind$52(_context9 = this.onPinch).call(_context9, this);\n    this.body.eventListeners.onMouseMove = bind$52(_context10 = this.onMouseMove).call(_context10, this);\n    this.body.eventListeners.onRelease = bind$52(_context11 = this.onRelease).call(_context11, this);\n    this.body.eventListeners.onContext = bind$52(_context12 = this.onContext).call(_context12, this);\n    this.touchTime = 0;\n    this.drag = {};\n    this.pinch = {};\n    this.popup = void 0;\n    this.popupObj = void 0;\n    this.popupTimer = void 0;\n    this.body.functions.getPointer = bind$52(_context13 = this.getPointer).call(_context13, this);\n    this.options = {};\n    this.defaultOptions = {\n      dragNodes: true,\n      dragView: true,\n      hover: false,\n      keyboard: {\n        enabled: false,\n        speed: {\n          x: 10,\n          y: 10,\n          zoom: 0.02\n        },\n        bindToWindow: true,\n        autoFocus: true\n      },\n      navigationButtons: false,\n      tooltipDelay: 300,\n      zoomView: true,\n      zoomSpeed: 1\n    };\n    assign$22(this.options, this.defaultOptions);\n    this.bindEventListeners();\n  }\n  _createClass2(InteractionHandler2, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this = this;\n      this.body.emitter.on(\"destroy\", function() {\n        clearTimeout(_this.popupTimer);\n        delete _this.body.functions.getPointer;\n      });\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      if (options2 !== void 0) {\n        var fields = [\"hideEdgesOnDrag\", \"hideEdgesOnZoom\", \"hideNodesOnDrag\", \"keyboard\", \"multiselect\", \"selectable\", \"selectConnectedEdges\"];\n        selectiveNotDeepExtend(fields, this.options, options2);\n        mergeOptions(this.options, options2, \"keyboard\");\n        if (options2.tooltip) {\n          assign$22(this.options.tooltip, options2.tooltip);\n          if (options2.tooltip.color) {\n            this.options.tooltip.color = parseColor(options2.tooltip.color);\n          }\n        }\n      }\n      this.navigationHandler.setOptions(this.options);\n    }\n  }, {\n    key: \"getPointer\",\n    value: function getPointer(touch) {\n      return {\n        x: touch.x - getAbsoluteLeft(this.canvas.frame.canvas),\n        y: touch.y - getAbsoluteTop(this.canvas.frame.canvas)\n      };\n    }\n  }, {\n    key: \"onTouch\",\n    value: function onTouch2(event) {\n      if (new Date().valueOf() - this.touchTime > 50) {\n        this.drag.pointer = this.getPointer(event.center);\n        this.drag.pinched = false;\n        this.pinch.scale = this.body.view.scale;\n        this.touchTime = new Date().valueOf();\n      }\n    }\n  }, {\n    key: \"onTap\",\n    value: function onTap(event) {\n      var pointer = this.getPointer(event.center);\n      var multiselect = this.selectionHandler.options.multiselect && (event.changedPointers[0].ctrlKey || event.changedPointers[0].metaKey);\n      this.checkSelectionChanges(pointer, multiselect);\n      this.selectionHandler.commitAndEmit(pointer, event);\n      this.selectionHandler.generateClickEvent(\"click\", event, pointer);\n    }\n  }, {\n    key: \"onDoubleTap\",\n    value: function onDoubleTap(event) {\n      var pointer = this.getPointer(event.center);\n      this.selectionHandler.generateClickEvent(\"doubleClick\", event, pointer);\n    }\n  }, {\n    key: \"onHold\",\n    value: function onHold(event) {\n      var pointer = this.getPointer(event.center);\n      var multiselect = this.selectionHandler.options.multiselect;\n      this.checkSelectionChanges(pointer, multiselect);\n      this.selectionHandler.commitAndEmit(pointer, event);\n      this.selectionHandler.generateClickEvent(\"click\", event, pointer);\n      this.selectionHandler.generateClickEvent(\"hold\", event, pointer);\n    }\n  }, {\n    key: \"onRelease\",\n    value: function onRelease2(event) {\n      if (new Date().valueOf() - this.touchTime > 10) {\n        var pointer = this.getPointer(event.center);\n        this.selectionHandler.generateClickEvent(\"release\", event, pointer);\n        this.touchTime = new Date().valueOf();\n      }\n    }\n  }, {\n    key: \"onContext\",\n    value: function onContext(event) {\n      var pointer = this.getPointer({\n        x: event.clientX,\n        y: event.clientY\n      });\n      this.selectionHandler.generateClickEvent(\"oncontext\", event, pointer);\n    }\n  }, {\n    key: \"checkSelectionChanges\",\n    value: function checkSelectionChanges(pointer) {\n      var add = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n      if (add === true) {\n        this.selectionHandler.selectAdditionalOnPoint(pointer);\n      } else {\n        this.selectionHandler.selectOnPoint(pointer);\n      }\n    }\n  }, {\n    key: \"_determineDifference\",\n    value: function _determineDifference(firstSet, secondSet) {\n      var arrayDiff = function arrayDiff2(firstArr, secondArr) {\n        var result2 = [];\n        for (var i = 0; i < firstArr.length; i++) {\n          var value = firstArr[i];\n          if (indexOf22(secondArr).call(secondArr, value) === -1) {\n            result2.push(value);\n          }\n        }\n        return result2;\n      };\n      return {\n        nodes: arrayDiff(firstSet.nodes, secondSet.nodes),\n        edges: arrayDiff(firstSet.edges, secondSet.edges)\n      };\n    }\n  }, {\n    key: \"onDragStart\",\n    value: function onDragStart(event) {\n      if (this.drag.dragging) {\n        return;\n      }\n      if (this.drag.pointer === void 0) {\n        this.onTouch(event);\n      }\n      var node = this.selectionHandler.getNodeAt(this.drag.pointer);\n      this.drag.dragging = true;\n      this.drag.selection = [];\n      this.drag.translation = assign$22({}, this.body.view.translation);\n      this.drag.nodeId = void 0;\n      if (event.srcEvent.shiftKey) {\n        this.body.selectionBox.show = true;\n        var pointer = this.getPointer(event.center);\n        this.body.selectionBox.position.start = {\n          x: this.canvas._XconvertDOMtoCanvas(pointer.x),\n          y: this.canvas._YconvertDOMtoCanvas(pointer.y)\n        };\n        this.body.selectionBox.position.end = {\n          x: this.canvas._XconvertDOMtoCanvas(pointer.x),\n          y: this.canvas._YconvertDOMtoCanvas(pointer.y)\n        };\n      }\n      if (node !== void 0 && this.options.dragNodes === true) {\n        this.drag.nodeId = node.id;\n        if (node.isSelected() === false) {\n          this.selectionHandler.setSelection({\n            nodes: [node.id]\n          });\n        }\n        this.selectionHandler.generateClickEvent(\"dragStart\", event, this.drag.pointer);\n        var _iterator = _createForOfIteratorHelper$4(this.selectionHandler.getSelectedNodes()), _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done; ) {\n            var _node = _step.value;\n            var s = {\n              id: _node.id,\n              node: _node,\n              x: _node.x,\n              y: _node.y,\n              xFixed: _node.options.fixed.x,\n              yFixed: _node.options.fixed.y\n            };\n            _node.options.fixed.x = true;\n            _node.options.fixed.y = true;\n            this.drag.selection.push(s);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        this.selectionHandler.generateClickEvent(\"dragStart\", event, this.drag.pointer, void 0, true);\n      }\n    }\n  }, {\n    key: \"onDrag\",\n    value: function onDrag(event) {\n      var _this2 = this;\n      if (this.drag.pinched === true) {\n        return;\n      }\n      this.body.emitter.emit(\"unlockNode\");\n      var pointer = this.getPointer(event.center);\n      var selection = this.drag.selection;\n      if (selection && selection.length && this.options.dragNodes === true) {\n        this.selectionHandler.generateClickEvent(\"dragging\", event, pointer);\n        var deltaX = pointer.x - this.drag.pointer.x;\n        var deltaY = pointer.y - this.drag.pointer.y;\n        forEach$22(selection).call(selection, function(selection2) {\n          var node = selection2.node;\n          if (selection2.xFixed === false) {\n            node.x = _this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(selection2.x) + deltaX);\n          }\n          if (selection2.yFixed === false) {\n            node.y = _this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(selection2.y) + deltaY);\n          }\n        });\n        this.body.emitter.emit(\"startSimulation\");\n      } else {\n        if (event.srcEvent.shiftKey) {\n          this.selectionHandler.generateClickEvent(\"dragging\", event, pointer, void 0, true);\n          if (this.drag.pointer === void 0) {\n            this.onDragStart(event);\n            return;\n          }\n          this.body.selectionBox.position.end = {\n            x: this.canvas._XconvertDOMtoCanvas(pointer.x),\n            y: this.canvas._YconvertDOMtoCanvas(pointer.y)\n          };\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n        if (this.options.dragView === true && !event.srcEvent.shiftKey) {\n          this.selectionHandler.generateClickEvent(\"dragging\", event, pointer, void 0, true);\n          if (this.drag.pointer === void 0) {\n            this.onDragStart(event);\n            return;\n          }\n          var diffX = pointer.x - this.drag.pointer.x;\n          var diffY = pointer.y - this.drag.pointer.y;\n          this.body.view.translation = {\n            x: this.drag.translation.x + diffX,\n            y: this.drag.translation.y + diffY\n          };\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n      }\n    }\n  }, {\n    key: \"onDragEnd\",\n    value: function onDragEnd(event) {\n      var _this3 = this;\n      this.drag.dragging = false;\n      if (this.body.selectionBox.show) {\n        var _context14;\n        this.body.selectionBox.show = false;\n        var selectionBoxPosition = this.body.selectionBox.position;\n        var selectionBoxPositionMinMax = {\n          minX: Math.min(selectionBoxPosition.start.x, selectionBoxPosition.end.x),\n          minY: Math.min(selectionBoxPosition.start.y, selectionBoxPosition.end.y),\n          maxX: Math.max(selectionBoxPosition.start.x, selectionBoxPosition.end.x),\n          maxY: Math.max(selectionBoxPosition.start.y, selectionBoxPosition.end.y)\n        };\n        var toBeSelectedNodes = filter22(_context14 = this.body.nodeIndices).call(_context14, function(nodeId) {\n          var node = _this3.body.nodes[nodeId];\n          return node.x >= selectionBoxPositionMinMax.minX && node.x <= selectionBoxPositionMinMax.maxX && node.y >= selectionBoxPositionMinMax.minY && node.y <= selectionBoxPositionMinMax.maxY;\n        });\n        forEach$22(toBeSelectedNodes).call(toBeSelectedNodes, function(nodeId) {\n          return _this3.selectionHandler.selectObject(_this3.body.nodes[nodeId]);\n        });\n        var pointer = this.getPointer(event.center);\n        this.selectionHandler.commitAndEmit(pointer, event);\n        this.selectionHandler.generateClickEvent(\"dragEnd\", event, this.getPointer(event.center), void 0, true);\n        this.body.emitter.emit(\"_requestRedraw\");\n      } else {\n        var selection = this.drag.selection;\n        if (selection && selection.length) {\n          forEach$22(selection).call(selection, function(s) {\n            s.node.options.fixed.x = s.xFixed;\n            s.node.options.fixed.y = s.yFixed;\n          });\n          this.selectionHandler.generateClickEvent(\"dragEnd\", event, this.getPointer(event.center));\n          this.body.emitter.emit(\"startSimulation\");\n        } else {\n          this.selectionHandler.generateClickEvent(\"dragEnd\", event, this.getPointer(event.center), void 0, true);\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n      }\n    }\n  }, {\n    key: \"onPinch\",\n    value: function onPinch(event) {\n      var pointer = this.getPointer(event.center);\n      this.drag.pinched = true;\n      if (this.pinch[\"scale\"] === void 0) {\n        this.pinch.scale = 1;\n      }\n      var scale = this.pinch.scale * event.scale;\n      this.zoom(scale, pointer);\n    }\n  }, {\n    key: \"zoom\",\n    value: function zoom(scale, pointer) {\n      if (this.options.zoomView === true) {\n        var scaleOld = this.body.view.scale;\n        if (scale < 1e-5) {\n          scale = 1e-5;\n        }\n        if (scale > 10) {\n          scale = 10;\n        }\n        var preScaleDragPointer = void 0;\n        if (this.drag !== void 0) {\n          if (this.drag.dragging === true) {\n            preScaleDragPointer = this.canvas.DOMtoCanvas(this.drag.pointer);\n          }\n        }\n        var translation = this.body.view.translation;\n        var scaleFrac = scale / scaleOld;\n        var tx = (1 - scaleFrac) * pointer.x + translation.x * scaleFrac;\n        var ty = (1 - scaleFrac) * pointer.y + translation.y * scaleFrac;\n        this.body.view.scale = scale;\n        this.body.view.translation = {\n          x: tx,\n          y: ty\n        };\n        if (preScaleDragPointer != void 0) {\n          var postScaleDragPointer = this.canvas.canvasToDOM(preScaleDragPointer);\n          this.drag.pointer.x = postScaleDragPointer.x;\n          this.drag.pointer.y = postScaleDragPointer.y;\n        }\n        this.body.emitter.emit(\"_requestRedraw\");\n        if (scaleOld < scale) {\n          this.body.emitter.emit(\"zoom\", {\n            direction: \"+\",\n            scale: this.body.view.scale,\n            pointer\n          });\n        } else {\n          this.body.emitter.emit(\"zoom\", {\n            direction: \"-\",\n            scale: this.body.view.scale,\n            pointer\n          });\n        }\n      }\n    }\n  }, {\n    key: \"onMouseWheel\",\n    value: function onMouseWheel(event) {\n      if (this.options.zoomView === true) {\n        if (event.deltaY !== 0) {\n          var scale = this.body.view.scale;\n          scale *= 1 + (event.deltaY < 0 ? 1 : -1) * (this.options.zoomSpeed * 0.1);\n          var pointer = this.getPointer({\n            x: event.clientX,\n            y: event.clientY\n          });\n          this.zoom(scale, pointer);\n        }\n        event.preventDefault();\n      }\n    }\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(event) {\n      var _this4 = this;\n      var pointer = this.getPointer({\n        x: event.clientX,\n        y: event.clientY\n      });\n      var popupVisible = false;\n      if (this.popup !== void 0) {\n        if (this.popup.hidden === false) {\n          this._checkHidePopup(pointer);\n        }\n        if (this.popup.hidden === false) {\n          popupVisible = true;\n          this.popup.setPosition(pointer.x + 3, pointer.y - 5);\n          this.popup.show();\n        }\n      }\n      if (this.options.keyboard.autoFocus && this.options.keyboard.bindToWindow === false && this.options.keyboard.enabled === true) {\n        this.canvas.frame.focus();\n      }\n      if (popupVisible === false) {\n        if (this.popupTimer !== void 0) {\n          clearInterval(this.popupTimer);\n          this.popupTimer = void 0;\n        }\n        if (!this.drag.dragging) {\n          this.popupTimer = setTimeout$12(function() {\n            return _this4._checkShowPopup(pointer);\n          }, this.options.tooltipDelay);\n        }\n      }\n      if (this.options.hover === true) {\n        this.selectionHandler.hoverObject(event, pointer);\n      }\n    }\n  }, {\n    key: \"_checkShowPopup\",\n    value: function _checkShowPopup(pointer) {\n      var x = this.canvas._XconvertDOMtoCanvas(pointer.x);\n      var y = this.canvas._YconvertDOMtoCanvas(pointer.y);\n      var pointerObj = {\n        left: x,\n        top: y,\n        right: x,\n        bottom: y\n      };\n      var previousPopupObjId = this.popupObj === void 0 ? void 0 : this.popupObj.id;\n      var nodeUnderCursor = false;\n      var popupType = \"node\";\n      if (this.popupObj === void 0) {\n        var nodeIndices = this.body.nodeIndices;\n        var nodes = this.body.nodes;\n        var node;\n        var overlappingNodes = [];\n        for (var i = 0; i < nodeIndices.length; i++) {\n          node = nodes[nodeIndices[i]];\n          if (node.isOverlappingWith(pointerObj) === true) {\n            nodeUnderCursor = true;\n            if (node.getTitle() !== void 0) {\n              overlappingNodes.push(nodeIndices[i]);\n            }\n          }\n        }\n        if (overlappingNodes.length > 0) {\n          this.popupObj = nodes[overlappingNodes[overlappingNodes.length - 1]];\n          nodeUnderCursor = true;\n        }\n      }\n      if (this.popupObj === void 0 && nodeUnderCursor === false) {\n        var edgeIndices = this.body.edgeIndices;\n        var edges = this.body.edges;\n        var edge;\n        var overlappingEdges = [];\n        for (var _i = 0; _i < edgeIndices.length; _i++) {\n          edge = edges[edgeIndices[_i]];\n          if (edge.isOverlappingWith(pointerObj) === true) {\n            if (edge.connected === true && edge.getTitle() !== void 0) {\n              overlappingEdges.push(edgeIndices[_i]);\n            }\n          }\n        }\n        if (overlappingEdges.length > 0) {\n          this.popupObj = edges[overlappingEdges[overlappingEdges.length - 1]];\n          popupType = \"edge\";\n        }\n      }\n      if (this.popupObj !== void 0) {\n        if (this.popupObj.id !== previousPopupObjId) {\n          if (this.popup === void 0) {\n            this.popup = new Popup(this.canvas.frame);\n          }\n          this.popup.popupTargetType = popupType;\n          this.popup.popupTargetId = this.popupObj.id;\n          this.popup.setPosition(pointer.x + 3, pointer.y - 5);\n          this.popup.setText(this.popupObj.getTitle());\n          this.popup.show();\n          this.body.emitter.emit(\"showPopup\", this.popupObj.id);\n        }\n      } else {\n        if (this.popup !== void 0) {\n          this.popup.hide();\n          this.body.emitter.emit(\"hidePopup\");\n        }\n      }\n    }\n  }, {\n    key: \"_checkHidePopup\",\n    value: function _checkHidePopup(pointer) {\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n      var stillOnObj = false;\n      if (this.popup.popupTargetType === \"node\") {\n        if (this.body.nodes[this.popup.popupTargetId] !== void 0) {\n          stillOnObj = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj);\n          if (stillOnObj === true) {\n            var overNode = this.selectionHandler.getNodeAt(pointer);\n            stillOnObj = overNode === void 0 ? false : overNode.id === this.popup.popupTargetId;\n          }\n        }\n      } else {\n        if (this.selectionHandler.getNodeAt(pointer) === void 0) {\n          if (this.body.edges[this.popup.popupTargetId] !== void 0) {\n            stillOnObj = this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);\n          }\n        }\n      }\n      if (stillOnObj === false) {\n        this.popupObj = void 0;\n        this.popup.hide();\n        this.body.emitter.emit(\"hidePopup\");\n      }\n    }\n  }]);\n  return InteractionHandler2;\n}();\nvar collection$12 = collection$3;\nvar collectionStrong2 = collectionStrong$22;\ncollection$12(\"Set\", function(init) {\n  return function Set2() {\n    return init(this, arguments.length ? arguments[0] : void 0);\n  };\n}, collectionStrong2);\nvar path$12 = path$y;\nvar set$22 = path$12.Set;\nvar parent$42 = set$22;\nvar set$12 = parent$42;\nvar set3 = set$12;\nvar uncurryThis$22 = functionUncurryThis2;\nvar redefineAll$12 = redefineAll$3;\nvar getWeakData2 = internalMetadata2.exports.getWeakData;\nvar anObject2 = anObject$d;\nvar isObject$12 = isObject$j;\nvar anInstance2 = anInstance$3;\nvar iterate2 = iterate$3;\nvar ArrayIterationModule = arrayIteration2;\nvar hasOwn22 = hasOwnProperty_12;\nvar InternalStateModule2 = internalState2;\nvar setInternalState2 = InternalStateModule2.set;\nvar internalStateGetterFor2 = InternalStateModule2.getterFor;\nvar find = ArrayIterationModule.find;\nvar findIndex = ArrayIterationModule.findIndex;\nvar splice22 = uncurryThis$22([].splice);\nvar id2 = 0;\nvar uncaughtFrozenStore = function(store) {\n  return store.frozen || (store.frozen = new UncaughtFrozenStore());\n};\nvar UncaughtFrozenStore = function() {\n  this.entries = [];\n};\nvar findUncaughtFrozen = function(store, key) {\n  return find(store.entries, function(it2) {\n    return it2[0] === key;\n  });\n};\nUncaughtFrozenStore.prototype = {\n  get: function(key) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry)\n      return entry[1];\n  },\n  has: function(key) {\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function(key, value) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry)\n      entry[1] = value;\n    else\n      this.entries.push([key, value]);\n  },\n  delete: function(key) {\n    var index2 = findIndex(this.entries, function(it2) {\n      return it2[0] === key;\n    });\n    if (~index2)\n      splice22(this.entries, index2, 1);\n    return !!~index2;\n  }\n};\nvar collectionWeak$1 = {\n  getConstructor: function(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n    var Constructor = wrapper2(function(that, iterable) {\n      anInstance2(that, Prototype);\n      setInternalState2(that, {\n        type: CONSTRUCTOR_NAME,\n        id: id2++,\n        frozen: void 0\n      });\n      if (iterable != void 0)\n        iterate2(iterable, that[ADDER], {\n          that,\n          AS_ENTRIES: IS_MAP\n        });\n    });\n    var Prototype = Constructor.prototype;\n    var getInternalState22 = internalStateGetterFor2(CONSTRUCTOR_NAME);\n    var define = function(that, key, value) {\n      var state = getInternalState22(that);\n      var data22 = getWeakData2(anObject2(key), true);\n      if (data22 === true)\n        uncaughtFrozenStore(state).set(key, value);\n      else\n        data22[state.id] = value;\n      return that;\n    };\n    redefineAll$12(Prototype, {\n      delete: function(key) {\n        var state = getInternalState22(this);\n        if (!isObject$12(key))\n          return false;\n        var data22 = getWeakData2(key);\n        if (data22 === true)\n          return uncaughtFrozenStore(state)[\"delete\"](key);\n        return data22 && hasOwn22(data22, state.id) && delete data22[state.id];\n      },\n      has: function has22(key) {\n        var state = getInternalState22(this);\n        if (!isObject$12(key))\n          return false;\n        var data22 = getWeakData2(key);\n        if (data22 === true)\n          return uncaughtFrozenStore(state).has(key);\n        return data22 && hasOwn22(data22, state.id);\n      }\n    });\n    redefineAll$12(Prototype, IS_MAP ? {\n      get: function get22(key) {\n        var state = getInternalState22(this);\n        if (isObject$12(key)) {\n          var data22 = getWeakData2(key);\n          if (data22 === true)\n            return uncaughtFrozenStore(state).get(key);\n          return data22 ? data22[state.id] : void 0;\n        }\n      },\n      set: function set22(key, value) {\n        return define(this, key, value);\n      }\n    } : {\n      add: function add(value) {\n        return define(this, value, true);\n      }\n    });\n    return Constructor;\n  }\n};\nvar global$32 = global$O;\nvar uncurryThis$12 = functionUncurryThis2;\nvar redefineAll2 = redefineAll$3;\nvar InternalMetadataModule2 = internalMetadata2.exports;\nvar collection2 = collection$3;\nvar collectionWeak = collectionWeak$1;\nvar isObject2 = isObject$j;\nvar isExtensible22 = objectIsExtensible2;\nvar enforceInternalState = internalState2.enforce;\nvar NATIVE_WEAK_MAP2 = nativeWeakMap2;\nvar IS_IE11 = !global$32.ActiveXObject && \"ActiveXObject\" in global$32;\nvar InternalWeakMap;\nvar wrapper = function(init) {\n  return function WeakMap22() {\n    return init(this, arguments.length ? arguments[0] : void 0);\n  };\n};\nvar $WeakMap = collection2(\"WeakMap\", wrapper, collectionWeak);\nif (NATIVE_WEAK_MAP2 && IS_IE11) {\n  InternalWeakMap = collectionWeak.getConstructor(wrapper, \"WeakMap\", true);\n  InternalMetadataModule2.enable();\n  WeakMapPrototype = $WeakMap.prototype;\n  nativeDelete = uncurryThis$12(WeakMapPrototype[\"delete\"]);\n  nativeHas = uncurryThis$12(WeakMapPrototype.has);\n  nativeGet = uncurryThis$12(WeakMapPrototype.get);\n  nativeSet = uncurryThis$12(WeakMapPrototype.set);\n  redefineAll2(WeakMapPrototype, {\n    delete: function(key) {\n      if (isObject2(key) && !isExtensible22(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen)\n          state.frozen = new InternalWeakMap();\n        return nativeDelete(this, key) || state.frozen[\"delete\"](key);\n      }\n      return nativeDelete(this, key);\n    },\n    has: function has22(key) {\n      if (isObject2(key) && !isExtensible22(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen)\n          state.frozen = new InternalWeakMap();\n        return nativeHas(this, key) || state.frozen.has(key);\n      }\n      return nativeHas(this, key);\n    },\n    get: function get22(key) {\n      if (isObject2(key) && !isExtensible22(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen)\n          state.frozen = new InternalWeakMap();\n        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);\n      }\n      return nativeGet(this, key);\n    },\n    set: function set22(key, value) {\n      if (isObject2(key) && !isExtensible22(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen)\n          state.frozen = new InternalWeakMap();\n        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);\n      } else\n        nativeSet(this, key, value);\n      return this;\n    }\n  });\n}\nvar WeakMapPrototype;\nvar nativeDelete;\nvar nativeHas;\nvar nativeGet;\nvar nativeSet;\nvar path2 = path$y;\nvar weakMap$2 = path2.WeakMap;\nvar parent$32 = weakMap$2;\nvar weakMap$1 = parent$32;\nvar weakMap = weakMap$1;\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f)\n    throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver))\n    throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\")\n    throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f)\n    throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver))\n    throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n}\nfunction _createForOfIteratorHelper$32(o, allowArrayLike) {\n  var it2 = typeof symbol2 !== \"undefined\" && getIteratorMethod$12(o) || o[\"@@iterator\"];\n  if (!it2) {\n    if (isArray$12(o) || (it2 = _unsupportedIterableToArray$32(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it2)\n        o = it2;\n      var i = 0;\n      var F2 = function F22() {\n      };\n      return { s: F2, n: function n() {\n        if (i >= o.length)\n          return { done: true };\n        return { done: false, value: o[i++] };\n      }, e: function e(_e3) {\n        throw _e3;\n      }, f: F2 };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true, didErr = false, err;\n  return { s: function s() {\n    it2 = it2.call(o);\n  }, n: function n() {\n    var step = it2.next();\n    normalCompletion = step.done;\n    return step;\n  }, e: function e(_e22) {\n    didErr = true;\n    err = _e22;\n  }, f: function f() {\n    try {\n      if (!normalCompletion && it2.return != null)\n        it2.return();\n    } finally {\n      if (didErr)\n        throw err;\n    }\n  } };\n}\nfunction _unsupportedIterableToArray$32(o, minLen) {\n  var _context2;\n  if (!o)\n    return;\n  if (typeof o === \"string\")\n    return _arrayLikeToArray$32(o, minLen);\n  var n = slice22(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1);\n  if (n === \"Object\" && o.constructor)\n    n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\")\n    return from$32(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray$32(o, minLen);\n}\nfunction _arrayLikeToArray$32(arr, len) {\n  if (len == null || len > arr.length)\n    len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar _SingleTypeSelectionAccumulator_previousSelection;\nvar _SingleTypeSelectionAccumulator_selection;\nvar _SelectionAccumulator_nodes;\nvar _SelectionAccumulator_edges;\nvar _SelectionAccumulator_commitHandler;\nfunction diffSets(prev, next3) {\n  var diff = new set3();\n  var _iterator = _createForOfIteratorHelper$32(next3), _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done; ) {\n      var item = _step.value;\n      if (!prev.has(item)) {\n        diff.add(item);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return diff;\n}\nvar SingleTypeSelectionAccumulator = /* @__PURE__ */ function() {\n  function SingleTypeSelectionAccumulator2() {\n    _classCallCheck2(this, SingleTypeSelectionAccumulator2);\n    _SingleTypeSelectionAccumulator_previousSelection.set(this, new set3());\n    _SingleTypeSelectionAccumulator_selection.set(this, new set3());\n  }\n  _createClass2(SingleTypeSelectionAccumulator2, [{\n    key: \"size\",\n    get: function get22() {\n      return __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\").size;\n    }\n  }, {\n    key: \"add\",\n    value: function add() {\n      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n        items[_key] = arguments[_key];\n      }\n      for (var _i = 0, _items = items; _i < _items.length; _i++) {\n        var item = _items[_i];\n        __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\").add(item);\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        items[_key2] = arguments[_key2];\n      }\n      for (var _i2 = 0, _items2 = items; _i2 < _items2.length; _i2++) {\n        var item = _items2[_i2];\n        __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\").delete(item);\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\").clear();\n    }\n  }, {\n    key: \"getSelection\",\n    value: function getSelection() {\n      return _toConsumableArray2(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\"));\n    }\n  }, {\n    key: \"getChanges\",\n    value: function getChanges() {\n      return {\n        added: _toConsumableArray2(diffSets(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, \"f\"), __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\"))),\n        deleted: _toConsumableArray2(diffSets(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\"), __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, \"f\"))),\n        previous: _toConsumableArray2(new set3(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, \"f\"))),\n        current: _toConsumableArray2(new set3(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\")))\n      };\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      var changes = this.getChanges();\n      __classPrivateFieldSet(this, _SingleTypeSelectionAccumulator_previousSelection, __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\"), \"f\");\n      __classPrivateFieldSet(this, _SingleTypeSelectionAccumulator_selection, new set3(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, \"f\")), \"f\");\n      var _iterator2 = _createForOfIteratorHelper$32(changes.added), _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {\n          var item = _step2.value;\n          item.select();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var _iterator3 = _createForOfIteratorHelper$32(changes.deleted), _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {\n          var _item = _step3.value;\n          _item.unselect();\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return changes;\n    }\n  }]);\n  return SingleTypeSelectionAccumulator2;\n}();\n_SingleTypeSelectionAccumulator_previousSelection = new weakMap(), _SingleTypeSelectionAccumulator_selection = new weakMap();\nvar SelectionAccumulator = /* @__PURE__ */ function() {\n  function SelectionAccumulator2() {\n    var commitHandler = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {\n    };\n    _classCallCheck2(this, SelectionAccumulator2);\n    _SelectionAccumulator_nodes.set(this, new SingleTypeSelectionAccumulator());\n    _SelectionAccumulator_edges.set(this, new SingleTypeSelectionAccumulator());\n    _SelectionAccumulator_commitHandler.set(this, void 0);\n    __classPrivateFieldSet(this, _SelectionAccumulator_commitHandler, commitHandler, \"f\");\n  }\n  _createClass2(SelectionAccumulator2, [{\n    key: \"sizeNodes\",\n    get: function get22() {\n      return __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\").size;\n    }\n  }, {\n    key: \"sizeEdges\",\n    get: function get22() {\n      return __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\").size;\n    }\n  }, {\n    key: \"getNodes\",\n    value: function getNodes() {\n      return __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\").getSelection();\n    }\n  }, {\n    key: \"getEdges\",\n    value: function getEdges() {\n      return __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\").getSelection();\n    }\n  }, {\n    key: \"addNodes\",\n    value: function addNodes() {\n      var _classPrivateFieldGe;\n      (_classPrivateFieldGe = __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\")).add.apply(_classPrivateFieldGe, arguments);\n    }\n  }, {\n    key: \"addEdges\",\n    value: function addEdges() {\n      var _classPrivateFieldGe2;\n      (_classPrivateFieldGe2 = __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\")).add.apply(_classPrivateFieldGe2, arguments);\n    }\n  }, {\n    key: \"deleteNodes\",\n    value: function deleteNodes(node) {\n      __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\").delete(node);\n    }\n  }, {\n    key: \"deleteEdges\",\n    value: function deleteEdges(edge) {\n      __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\").delete(edge);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\").clear();\n      __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\").clear();\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      var _classPrivateFieldGe3, _context;\n      var summary = {\n        nodes: __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\").commit(),\n        edges: __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\").commit()\n      };\n      for (var _len3 = arguments.length, rest = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        rest[_key3] = arguments[_key3];\n      }\n      (_classPrivateFieldGe3 = __classPrivateFieldGet(this, _SelectionAccumulator_commitHandler, \"f\")).call.apply(_classPrivateFieldGe3, concat22(_context = [this, summary]).call(_context, rest));\n      return summary;\n    }\n  }]);\n  return SelectionAccumulator2;\n}();\n_SelectionAccumulator_nodes = new weakMap(), _SelectionAccumulator_edges = new weakMap(), _SelectionAccumulator_commitHandler = new weakMap();\nfunction _createForOfIteratorHelper$22(o, allowArrayLike) {\n  var it2 = typeof symbol2 !== \"undefined\" && getIteratorMethod$12(o) || o[\"@@iterator\"];\n  if (!it2) {\n    if (isArray$12(o) || (it2 = _unsupportedIterableToArray$22(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it2)\n        o = it2;\n      var i = 0;\n      var F2 = function F22() {\n      };\n      return { s: F2, n: function n() {\n        if (i >= o.length)\n          return { done: true };\n        return { done: false, value: o[i++] };\n      }, e: function e(_e3) {\n        throw _e3;\n      }, f: F2 };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true, didErr = false, err;\n  return { s: function s() {\n    it2 = it2.call(o);\n  }, n: function n() {\n    var step = it2.next();\n    normalCompletion = step.done;\n    return step;\n  }, e: function e(_e22) {\n    didErr = true;\n    err = _e22;\n  }, f: function f() {\n    try {\n      if (!normalCompletion && it2.return != null)\n        it2.return();\n    } finally {\n      if (didErr)\n        throw err;\n    }\n  } };\n}\nfunction _unsupportedIterableToArray$22(o, minLen) {\n  var _context3;\n  if (!o)\n    return;\n  if (typeof o === \"string\")\n    return _arrayLikeToArray$22(o, minLen);\n  var n = slice22(_context3 = Object.prototype.toString.call(o)).call(_context3, 8, -1);\n  if (n === \"Object\" && o.constructor)\n    n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\")\n    return from$32(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray$22(o, minLen);\n}\nfunction _arrayLikeToArray$22(arr, len) {\n  if (len == null || len > arr.length)\n    len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar SelectionHandler = /* @__PURE__ */ function() {\n  function SelectionHandler2(body, canvas) {\n    var _this = this;\n    _classCallCheck2(this, SelectionHandler2);\n    this.body = body;\n    this.canvas = canvas;\n    this._selectionAccumulator = new SelectionAccumulator();\n    this.hoverObj = {\n      nodes: {},\n      edges: {}\n    };\n    this.options = {};\n    this.defaultOptions = {\n      multiselect: false,\n      selectable: true,\n      selectConnectedEdges: true,\n      hoverConnectedEdges: true\n    };\n    assign$22(this.options, this.defaultOptions);\n    this.body.emitter.on(\"_dataChanged\", function() {\n      _this.updateSelection();\n    });\n  }\n  _createClass2(SelectionHandler2, [{\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      if (options2 !== void 0) {\n        var fields = [\"multiselect\", \"hoverConnectedEdges\", \"selectable\", \"selectConnectedEdges\"];\n        selectiveDeepExtend(fields, this.options, options2);\n      }\n    }\n  }, {\n    key: \"selectOnPoint\",\n    value: function selectOnPoint(pointer) {\n      var selected = false;\n      if (this.options.selectable === true) {\n        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);\n        this.unselectAll();\n        if (obj !== void 0) {\n          selected = this.selectObject(obj);\n        }\n        this.body.emitter.emit(\"_requestRedraw\");\n      }\n      return selected;\n    }\n  }, {\n    key: \"selectAdditionalOnPoint\",\n    value: function selectAdditionalOnPoint(pointer) {\n      var selectionChanged = false;\n      if (this.options.selectable === true) {\n        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);\n        if (obj !== void 0) {\n          selectionChanged = true;\n          if (obj.isSelected() === true) {\n            this.deselectObject(obj);\n          } else {\n            this.selectObject(obj);\n          }\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n      }\n      return selectionChanged;\n    }\n  }, {\n    key: \"_initBaseEvent\",\n    value: function _initBaseEvent(event, pointer) {\n      var properties = {};\n      properties[\"pointer\"] = {\n        DOM: {\n          x: pointer.x,\n          y: pointer.y\n        },\n        canvas: this.canvas.DOMtoCanvas(pointer)\n      };\n      properties[\"event\"] = event;\n      return properties;\n    }\n  }, {\n    key: \"generateClickEvent\",\n    value: function generateClickEvent(eventType, event, pointer, oldSelection) {\n      var emptySelection = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;\n      var properties = this._initBaseEvent(event, pointer);\n      if (emptySelection === true) {\n        properties.nodes = [];\n        properties.edges = [];\n      } else {\n        var tmp = this.getSelection();\n        properties.nodes = tmp.nodes;\n        properties.edges = tmp.edges;\n      }\n      if (oldSelection !== void 0) {\n        properties[\"previousSelection\"] = oldSelection;\n      }\n      if (eventType == \"click\") {\n        properties.items = this.getClickedItems(pointer);\n      }\n      if (event.controlEdge !== void 0) {\n        properties.controlEdge = event.controlEdge;\n      }\n      this.body.emitter.emit(eventType, properties);\n    }\n  }, {\n    key: \"selectObject\",\n    value: function selectObject(obj) {\n      var highlightEdges = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.selectConnectedEdges;\n      if (obj !== void 0) {\n        if (obj instanceof Node) {\n          if (highlightEdges === true) {\n            var _this$_selectionAccum;\n            (_this$_selectionAccum = this._selectionAccumulator).addEdges.apply(_this$_selectionAccum, _toConsumableArray2(obj.edges));\n          }\n          this._selectionAccumulator.addNodes(obj);\n        } else {\n          this._selectionAccumulator.addEdges(obj);\n        }\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"deselectObject\",\n    value: function deselectObject(obj) {\n      if (obj.isSelected() === true) {\n        obj.selected = false;\n        this._removeFromSelection(obj);\n      }\n    }\n  }, {\n    key: \"_getAllNodesOverlappingWith\",\n    value: function _getAllNodesOverlappingWith(object2) {\n      var overlappingNodes = [];\n      var nodes = this.body.nodes;\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var nodeId = this.body.nodeIndices[i];\n        if (nodes[nodeId].isOverlappingWith(object2)) {\n          overlappingNodes.push(nodeId);\n        }\n      }\n      return overlappingNodes;\n    }\n  }, {\n    key: \"_pointerToPositionObject\",\n    value: function _pointerToPositionObject(pointer) {\n      var canvasPos = this.canvas.DOMtoCanvas(pointer);\n      return {\n        left: canvasPos.x - 1,\n        top: canvasPos.y + 1,\n        right: canvasPos.x + 1,\n        bottom: canvasPos.y - 1\n      };\n    }\n  }, {\n    key: \"getNodeAt\",\n    value: function getNodeAt(pointer) {\n      var returnNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n      var positionObject = this._pointerToPositionObject(pointer);\n      var overlappingNodes = this._getAllNodesOverlappingWith(positionObject);\n      if (overlappingNodes.length > 0) {\n        if (returnNode === true) {\n          return this.body.nodes[overlappingNodes[overlappingNodes.length - 1]];\n        } else {\n          return overlappingNodes[overlappingNodes.length - 1];\n        }\n      } else {\n        return void 0;\n      }\n    }\n  }, {\n    key: \"_getEdgesOverlappingWith\",\n    value: function _getEdgesOverlappingWith(object2, overlappingEdges) {\n      var edges = this.body.edges;\n      for (var i = 0; i < this.body.edgeIndices.length; i++) {\n        var edgeId = this.body.edgeIndices[i];\n        if (edges[edgeId].isOverlappingWith(object2)) {\n          overlappingEdges.push(edgeId);\n        }\n      }\n    }\n  }, {\n    key: \"_getAllEdgesOverlappingWith\",\n    value: function _getAllEdgesOverlappingWith(object2) {\n      var overlappingEdges = [];\n      this._getEdgesOverlappingWith(object2, overlappingEdges);\n      return overlappingEdges;\n    }\n  }, {\n    key: \"getEdgeAt\",\n    value: function getEdgeAt(pointer) {\n      var returnEdge = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n      var canvasPos = this.canvas.DOMtoCanvas(pointer);\n      var mindist = 10;\n      var overlappingEdge = null;\n      var edges = this.body.edges;\n      for (var i = 0; i < this.body.edgeIndices.length; i++) {\n        var edgeId = this.body.edgeIndices[i];\n        var edge = edges[edgeId];\n        if (edge.connected) {\n          var xFrom = edge.from.x;\n          var yFrom = edge.from.y;\n          var xTo = edge.to.x;\n          var yTo = edge.to.y;\n          var dist = edge.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, canvasPos.x, canvasPos.y);\n          if (dist < mindist) {\n            overlappingEdge = edgeId;\n            mindist = dist;\n          }\n        }\n      }\n      if (overlappingEdge !== null) {\n        if (returnEdge === true) {\n          return this.body.edges[overlappingEdge];\n        } else {\n          return overlappingEdge;\n        }\n      } else {\n        return void 0;\n      }\n    }\n  }, {\n    key: \"_addToHover\",\n    value: function _addToHover(obj) {\n      if (obj instanceof Node) {\n        this.hoverObj.nodes[obj.id] = obj;\n      } else {\n        this.hoverObj.edges[obj.id] = obj;\n      }\n    }\n  }, {\n    key: \"_removeFromSelection\",\n    value: function _removeFromSelection(obj) {\n      if (obj instanceof Node) {\n        var _this$_selectionAccum2;\n        this._selectionAccumulator.deleteNodes(obj);\n        (_this$_selectionAccum2 = this._selectionAccumulator).deleteEdges.apply(_this$_selectionAccum2, _toConsumableArray2(obj.edges));\n      } else {\n        this._selectionAccumulator.deleteEdges(obj);\n      }\n    }\n  }, {\n    key: \"unselectAll\",\n    value: function unselectAll() {\n      this._selectionAccumulator.clear();\n    }\n  }, {\n    key: \"getSelectedNodeCount\",\n    value: function getSelectedNodeCount() {\n      return this._selectionAccumulator.sizeNodes;\n    }\n  }, {\n    key: \"getSelectedEdgeCount\",\n    value: function getSelectedEdgeCount() {\n      return this._selectionAccumulator.sizeEdges;\n    }\n  }, {\n    key: \"_hoverConnectedEdges\",\n    value: function _hoverConnectedEdges(node) {\n      for (var i = 0; i < node.edges.length; i++) {\n        var edge = node.edges[i];\n        edge.hover = true;\n        this._addToHover(edge);\n      }\n    }\n  }, {\n    key: \"emitBlurEvent\",\n    value: function emitBlurEvent(event, pointer, object2) {\n      var properties = this._initBaseEvent(event, pointer);\n      if (object2.hover === true) {\n        object2.hover = false;\n        if (object2 instanceof Node) {\n          properties.node = object2.id;\n          this.body.emitter.emit(\"blurNode\", properties);\n        } else {\n          properties.edge = object2.id;\n          this.body.emitter.emit(\"blurEdge\", properties);\n        }\n      }\n    }\n  }, {\n    key: \"emitHoverEvent\",\n    value: function emitHoverEvent(event, pointer, object2) {\n      var properties = this._initBaseEvent(event, pointer);\n      var hoverChanged = false;\n      if (object2.hover === false) {\n        object2.hover = true;\n        this._addToHover(object2);\n        hoverChanged = true;\n        if (object2 instanceof Node) {\n          properties.node = object2.id;\n          this.body.emitter.emit(\"hoverNode\", properties);\n        } else {\n          properties.edge = object2.id;\n          this.body.emitter.emit(\"hoverEdge\", properties);\n        }\n      }\n      return hoverChanged;\n    }\n  }, {\n    key: \"hoverObject\",\n    value: function hoverObject(event, pointer) {\n      var object2 = this.getNodeAt(pointer);\n      if (object2 === void 0) {\n        object2 = this.getEdgeAt(pointer);\n      }\n      var hoverChanged = false;\n      for (var nodeId in this.hoverObj.nodes) {\n        if (Object.prototype.hasOwnProperty.call(this.hoverObj.nodes, nodeId)) {\n          if (object2 === void 0 || object2 instanceof Node && object2.id != nodeId || object2 instanceof Edge) {\n            this.emitBlurEvent(event, pointer, this.hoverObj.nodes[nodeId]);\n            delete this.hoverObj.nodes[nodeId];\n            hoverChanged = true;\n          }\n        }\n      }\n      for (var edgeId in this.hoverObj.edges) {\n        if (Object.prototype.hasOwnProperty.call(this.hoverObj.edges, edgeId)) {\n          if (hoverChanged === true) {\n            this.hoverObj.edges[edgeId].hover = false;\n            delete this.hoverObj.edges[edgeId];\n          } else if (object2 === void 0 || object2 instanceof Edge && object2.id != edgeId || object2 instanceof Node && !object2.hover) {\n            this.emitBlurEvent(event, pointer, this.hoverObj.edges[edgeId]);\n            delete this.hoverObj.edges[edgeId];\n            hoverChanged = true;\n          }\n        }\n      }\n      if (object2 !== void 0) {\n        var hoveredEdgesCount = keys32(this.hoverObj.edges).length;\n        var hoveredNodesCount = keys32(this.hoverObj.nodes).length;\n        var newOnlyHoveredEdge = object2 instanceof Edge && hoveredEdgesCount === 0 && hoveredNodesCount === 0;\n        var newOnlyHoveredNode = object2 instanceof Node && hoveredEdgesCount === 0 && hoveredNodesCount === 0;\n        if (hoverChanged || newOnlyHoveredEdge || newOnlyHoveredNode) {\n          hoverChanged = this.emitHoverEvent(event, pointer, object2);\n        }\n        if (object2 instanceof Node && this.options.hoverConnectedEdges === true) {\n          this._hoverConnectedEdges(object2);\n        }\n      }\n      if (hoverChanged === true) {\n        this.body.emitter.emit(\"_requestRedraw\");\n      }\n    }\n  }, {\n    key: \"commitWithoutEmitting\",\n    value: function commitWithoutEmitting() {\n      this._selectionAccumulator.commit();\n    }\n  }, {\n    key: \"commitAndEmit\",\n    value: function commitAndEmit(pointer, event) {\n      var selected = false;\n      var selectionChanges = this._selectionAccumulator.commit();\n      var previousSelection = {\n        nodes: selectionChanges.nodes.previous,\n        edges: selectionChanges.edges.previous\n      };\n      if (selectionChanges.edges.deleted.length > 0) {\n        this.generateClickEvent(\"deselectEdge\", event, pointer, previousSelection);\n        selected = true;\n      }\n      if (selectionChanges.nodes.deleted.length > 0) {\n        this.generateClickEvent(\"deselectNode\", event, pointer, previousSelection);\n        selected = true;\n      }\n      if (selectionChanges.nodes.added.length > 0) {\n        this.generateClickEvent(\"selectNode\", event, pointer);\n        selected = true;\n      }\n      if (selectionChanges.edges.added.length > 0) {\n        this.generateClickEvent(\"selectEdge\", event, pointer);\n        selected = true;\n      }\n      if (selected === true) {\n        this.generateClickEvent(\"select\", event, pointer);\n      }\n    }\n  }, {\n    key: \"getSelection\",\n    value: function getSelection() {\n      return {\n        nodes: this.getSelectedNodeIds(),\n        edges: this.getSelectedEdgeIds()\n      };\n    }\n  }, {\n    key: \"getSelectedNodes\",\n    value: function getSelectedNodes() {\n      return this._selectionAccumulator.getNodes();\n    }\n  }, {\n    key: \"getSelectedEdges\",\n    value: function getSelectedEdges() {\n      return this._selectionAccumulator.getEdges();\n    }\n  }, {\n    key: \"getSelectedNodeIds\",\n    value: function getSelectedNodeIds() {\n      var _context;\n      return map$32(_context = this._selectionAccumulator.getNodes()).call(_context, function(node) {\n        return node.id;\n      });\n    }\n  }, {\n    key: \"getSelectedEdgeIds\",\n    value: function getSelectedEdgeIds() {\n      var _context2;\n      return map$32(_context2 = this._selectionAccumulator.getEdges()).call(_context2, function(edge) {\n        return edge.id;\n      });\n    }\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(selection) {\n      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n      if (!selection || !selection.nodes && !selection.edges) {\n        throw new TypeError(\"Selection must be an object with nodes and/or edges properties\");\n      }\n      if (options2.unselectAll || options2.unselectAll === void 0) {\n        this.unselectAll();\n      }\n      if (selection.nodes) {\n        var _iterator = _createForOfIteratorHelper$22(selection.nodes), _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done; ) {\n            var id22 = _step.value;\n            var node = this.body.nodes[id22];\n            if (!node) {\n              throw new RangeError('Node with id \"' + id22 + '\" not found');\n            }\n            this.selectObject(node, options2.highlightEdges);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      if (selection.edges) {\n        var _iterator2 = _createForOfIteratorHelper$22(selection.edges), _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {\n            var _id = _step2.value;\n            var edge = this.body.edges[_id];\n            if (!edge) {\n              throw new RangeError('Edge with id \"' + _id + '\" not found');\n            }\n            this.selectObject(edge);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      this.body.emitter.emit(\"_requestRedraw\");\n      this._selectionAccumulator.commit();\n    }\n  }, {\n    key: \"selectNodes\",\n    value: function selectNodes(selection) {\n      var highlightEdges = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n      if (!selection || selection.length === void 0)\n        throw \"Selection must be an array with ids\";\n      this.setSelection({\n        nodes: selection\n      }, {\n        highlightEdges\n      });\n    }\n  }, {\n    key: \"selectEdges\",\n    value: function selectEdges(selection) {\n      if (!selection || selection.length === void 0)\n        throw \"Selection must be an array with ids\";\n      this.setSelection({\n        edges: selection\n      });\n    }\n  }, {\n    key: \"updateSelection\",\n    value: function updateSelection() {\n      for (var node in this._selectionAccumulator.getNodes()) {\n        if (!Object.prototype.hasOwnProperty.call(this.body.nodes, node.id)) {\n          this._selectionAccumulator.deleteNodes(node);\n        }\n      }\n      for (var edge in this._selectionAccumulator.getEdges()) {\n        if (!Object.prototype.hasOwnProperty.call(this.body.edges, edge.id)) {\n          this._selectionAccumulator.deleteEdges(edge);\n        }\n      }\n    }\n  }, {\n    key: \"getClickedItems\",\n    value: function getClickedItems(pointer) {\n      var point = this.canvas.DOMtoCanvas(pointer);\n      var items = [];\n      var nodeIndices = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      for (var i = nodeIndices.length - 1; i >= 0; i--) {\n        var node = nodes[nodeIndices[i]];\n        var ret = node.getItemsOnPoint(point);\n        items.push.apply(items, ret);\n      }\n      var edgeIndices = this.body.edgeIndices;\n      var edges = this.body.edges;\n      for (var _i = edgeIndices.length - 1; _i >= 0; _i--) {\n        var edge = edges[edgeIndices[_i]];\n        var _ret = edge.getItemsOnPoint(point);\n        items.push.apply(items, _ret);\n      }\n      return items;\n    }\n  }]);\n  return SelectionHandler2;\n}();\nvar arraySlice2 = arraySliceSimple2;\nvar floor2 = Math.floor;\nvar mergeSort2 = function(array2, comparefn) {\n  var length2 = array2.length;\n  var middle = floor2(length2 / 2);\n  return length2 < 8 ? insertionSort2(array2, comparefn) : merge2(array2, mergeSort2(arraySlice2(array2, 0, middle), comparefn), mergeSort2(arraySlice2(array2, middle), comparefn), comparefn);\n};\nvar insertionSort2 = function(array2, comparefn) {\n  var length2 = array2.length;\n  var i = 1;\n  var element, j;\n  while (i < length2) {\n    j = i;\n    element = array2[i];\n    while (j && comparefn(array2[j - 1], element) > 0) {\n      array2[j] = array2[--j];\n    }\n    if (j !== i++)\n      array2[j] = element;\n  }\n  return array2;\n};\nvar merge2 = function(array2, left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n  while (lindex < llength || rindex < rlength) {\n    array2[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];\n  }\n  return array2;\n};\nvar arraySort2 = mergeSort2;\nvar userAgent$12 = engineUserAgent2;\nvar firefox2 = userAgent$12.match(/firefox\\/(\\d+)/i);\nvar engineFfVersion2 = !!firefox2 && +firefox2[1];\nvar UA2 = engineUserAgent2;\nvar engineIsIeOrEdge2 = /MSIE|Trident/.test(UA2);\nvar userAgent2 = engineUserAgent2;\nvar webkit2 = userAgent2.match(/AppleWebKit\\/(\\d+)\\./);\nvar engineWebkitVersion2 = !!webkit2 && +webkit2[1];\nvar $$22 = _export2;\nvar uncurryThis2 = functionUncurryThis2;\nvar aCallable$12 = aCallable$62;\nvar toObject$12 = toObject$d2;\nvar lengthOfArrayLike$12 = lengthOfArrayLike$b2;\nvar toString22 = toString$82;\nvar fails2 = fails$t;\nvar internalSort2 = arraySort2;\nvar arrayMethodIsStrict$22 = arrayMethodIsStrict$6;\nvar FF2 = engineFfVersion2;\nvar IE_OR_EDGE2 = engineIsIeOrEdge2;\nvar V82 = engineV8Version2;\nvar WEBKIT2 = engineWebkitVersion2;\nvar test2 = [];\nvar un$Sort2 = uncurryThis2(test2.sort);\nvar push2 = uncurryThis2(test2.push);\nvar FAILS_ON_UNDEFINED2 = fails2(function() {\n  test2.sort(void 0);\n});\nvar FAILS_ON_NULL2 = fails2(function() {\n  test2.sort(null);\n});\nvar STRICT_METHOD$22 = arrayMethodIsStrict$22(\"sort\");\nvar STABLE_SORT2 = !fails2(function() {\n  if (V82)\n    return V82 < 70;\n  if (FF2 && FF2 > 3)\n    return;\n  if (IE_OR_EDGE2)\n    return true;\n  if (WEBKIT2)\n    return WEBKIT2 < 603;\n  var result2 = \"\";\n  var code, chr, value, index2;\n  for (code = 65; code < 76; code++) {\n    chr = String.fromCharCode(code);\n    switch (code) {\n      case 66:\n      case 69:\n      case 70:\n      case 72:\n        value = 3;\n        break;\n      case 68:\n      case 71:\n        value = 4;\n        break;\n      default:\n        value = 2;\n    }\n    for (index2 = 0; index2 < 47; index2++) {\n      test2.push({\n        k: chr + index2,\n        v: value\n      });\n    }\n  }\n  test2.sort(function(a, b) {\n    return b.v - a.v;\n  });\n  for (index2 = 0; index2 < test2.length; index2++) {\n    chr = test2[index2].k.charAt(0);\n    if (result2.charAt(result2.length - 1) !== chr)\n      result2 += chr;\n  }\n  return result2 !== \"DGBEFHACIJK\";\n});\nvar FORCED2 = FAILS_ON_UNDEFINED2 || !FAILS_ON_NULL2 || !STRICT_METHOD$22 || !STABLE_SORT2;\nvar getSortCompare2 = function(comparefn) {\n  return function(x, y) {\n    if (y === void 0)\n      return -1;\n    if (x === void 0)\n      return 1;\n    if (comparefn !== void 0)\n      return +comparefn(x, y) || 0;\n    return toString22(x) > toString22(y) ? 1 : -1;\n  };\n};\n$$22({\n  target: \"Array\",\n  proto: true,\n  forced: FORCED2\n}, {\n  sort: function sort3(comparefn) {\n    if (comparefn !== void 0)\n      aCallable$12(comparefn);\n    var array2 = toObject$12(this);\n    if (STABLE_SORT2)\n      return comparefn === void 0 ? un$Sort2(array2) : un$Sort2(array2, comparefn);\n    var items = [];\n    var arrayLength = lengthOfArrayLike$12(array2);\n    var itemsLength, index2;\n    for (index2 = 0; index2 < arrayLength; index2++) {\n      if (index2 in array2)\n        push2(items, array2[index2]);\n    }\n    internalSort2(items, getSortCompare2(comparefn));\n    itemsLength = items.length;\n    index2 = 0;\n    while (index2 < itemsLength)\n      array2[index2] = items[index2++];\n    while (index2 < arrayLength)\n      delete array2[index2++];\n    return array2;\n  }\n});\nvar entryVirtual$22 = entryVirtual$i2;\nvar sort$32 = entryVirtual$22(\"Array\").sort;\nvar isPrototypeOf$22 = objectIsPrototypeOf2;\nvar method$22 = sort$32;\nvar ArrayPrototype$22 = Array.prototype;\nvar sort$22 = function(it2) {\n  var own = it2.sort;\n  return it2 === ArrayPrototype$22 || isPrototypeOf$22(ArrayPrototype$22, it2) && own === ArrayPrototype$22.sort ? method$22 : own;\n};\nvar parent$22 = sort$22;\nvar sort$12 = parent$22;\nvar sort22 = sort$12;\nvar global$22 = global$O;\nvar aCallable2 = aCallable$62;\nvar toObject2 = toObject$d2;\nvar IndexedObject2 = indexedObject2;\nvar lengthOfArrayLike2 = lengthOfArrayLike$b2;\nvar TypeError$12 = global$22.TypeError;\nvar createMethod2 = function(IS_RIGHT) {\n  return function(that, callbackfn, argumentsLength, memo) {\n    aCallable2(callbackfn);\n    var O = toObject2(that);\n    var self2 = IndexedObject2(O);\n    var length2 = lengthOfArrayLike2(O);\n    var index2 = IS_RIGHT ? length2 - 1 : 0;\n    var i = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2)\n      while (true) {\n        if (index2 in self2) {\n          memo = self2[index2];\n          index2 += i;\n          break;\n        }\n        index2 += i;\n        if (IS_RIGHT ? index2 < 0 : length2 <= index2) {\n          throw TypeError$12(\"Reduce of empty array with no initial value\");\n        }\n      }\n    for (; IS_RIGHT ? index2 >= 0 : length2 > index2; index2 += i)\n      if (index2 in self2) {\n        memo = callbackfn(memo, self2[index2], index2, O);\n      }\n    return memo;\n  };\n};\nvar arrayReduce2 = {\n  left: createMethod2(false),\n  right: createMethod2(true)\n};\nvar classof2 = classofRaw$12;\nvar global$1$12 = global$O;\nvar engineIsNode2 = classof2(global$1$12.process) == \"process\";\nvar $$12 = _export2;\nvar $reduce2 = arrayReduce2.left;\nvar arrayMethodIsStrict$12 = arrayMethodIsStrict$6;\nvar CHROME_VERSION2 = engineV8Version2;\nvar IS_NODE2 = engineIsNode2;\nvar STRICT_METHOD$12 = arrayMethodIsStrict$12(\"reduce\");\nvar CHROME_BUG2 = !IS_NODE2 && CHROME_VERSION2 > 79 && CHROME_VERSION2 < 83;\n$$12({\n  target: \"Array\",\n  proto: true,\n  forced: !STRICT_METHOD$12 || CHROME_BUG2\n}, {\n  reduce: function reduce3(callbackfn) {\n    var length2 = arguments.length;\n    return $reduce2(this, callbackfn, length2, length2 > 1 ? arguments[1] : void 0);\n  }\n});\nvar entryVirtual$12 = entryVirtual$i2;\nvar reduce$32 = entryVirtual$12(\"Array\").reduce;\nvar isPrototypeOf$12 = objectIsPrototypeOf2;\nvar method$12 = reduce$32;\nvar ArrayPrototype$12 = Array.prototype;\nvar reduce$22 = function(it2) {\n  var own = it2.reduce;\n  return it2 === ArrayPrototype$12 || isPrototypeOf$12(ArrayPrototype$12, it2) && own === ArrayPrototype$12.reduce ? method$12 : own;\n};\nvar parent$14 = reduce$22;\nvar reduce$12 = parent$14;\nvar reduce22 = reduce$12;\nvar timsort$1 = {};\n(function(exports) {\n  (function(global2, factory) {\n    {\n      factory(exports);\n    }\n  })(commonjsGlobal2, function(exports2) {\n    exports2.__esModule = true;\n    exports2.sort = sort32;\n    function _classCallCheck22(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    var DEFAULT_MIN_MERGE = 32;\n    var DEFAULT_MIN_GALLOPING = 7;\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n    var POWERS_OF_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];\n    function log10(x) {\n      if (x < 1e5) {\n        if (x < 100) {\n          return x < 10 ? 0 : 1;\n        }\n        if (x < 1e4) {\n          return x < 1e3 ? 2 : 3;\n        }\n        return 4;\n      }\n      if (x < 1e7) {\n        return x < 1e6 ? 5 : 6;\n      }\n      if (x < 1e9) {\n        return x < 1e8 ? 7 : 8;\n      }\n      return 9;\n    }\n    function alphabeticalCompare(a, b) {\n      if (a === b) {\n        return 0;\n      }\n      if (~~a === a && ~~b === b) {\n        if (a === 0 || b === 0) {\n          return a < b ? -1 : 1;\n        }\n        if (a < 0 || b < 0) {\n          if (b >= 0) {\n            return -1;\n          }\n          if (a >= 0) {\n            return 1;\n          }\n          a = -a;\n          b = -b;\n        }\n        var al = log10(a);\n        var bl = log10(b);\n        var t = 0;\n        if (al < bl) {\n          a *= POWERS_OF_TEN[bl - al - 1];\n          b /= 10;\n          t = -1;\n        } else if (al > bl) {\n          b *= POWERS_OF_TEN[al - bl - 1];\n          a /= 10;\n          t = 1;\n        }\n        if (a === b) {\n          return t;\n        }\n        return a < b ? -1 : 1;\n      }\n      var aStr = String(a);\n      var bStr = String(b);\n      if (aStr === bStr) {\n        return 0;\n      }\n      return aStr < bStr ? -1 : 1;\n    }\n    function minRunLength(n) {\n      var r = 0;\n      while (n >= DEFAULT_MIN_MERGE) {\n        r |= n & 1;\n        n >>= 1;\n      }\n      return n + r;\n    }\n    function makeAscendingRun(array2, lo, hi22, compare) {\n      var runHi = lo + 1;\n      if (runHi === hi22) {\n        return 1;\n      }\n      if (compare(array2[runHi++], array2[lo]) < 0) {\n        while (runHi < hi22 && compare(array2[runHi], array2[runHi - 1]) < 0) {\n          runHi++;\n        }\n        reverseRun(array2, lo, runHi);\n      } else {\n        while (runHi < hi22 && compare(array2[runHi], array2[runHi - 1]) >= 0) {\n          runHi++;\n        }\n      }\n      return runHi - lo;\n    }\n    function reverseRun(array2, lo, hi22) {\n      hi22--;\n      while (lo < hi22) {\n        var t = array2[lo];\n        array2[lo++] = array2[hi22];\n        array2[hi22--] = t;\n      }\n    }\n    function binaryInsertionSort(array2, lo, hi22, start, compare) {\n      if (start === lo) {\n        start++;\n      }\n      for (; start < hi22; start++) {\n        var pivot = array2[start];\n        var left = lo;\n        var right = start;\n        while (left < right) {\n          var mid = left + right >>> 1;\n          if (compare(pivot, array2[mid]) < 0) {\n            right = mid;\n          } else {\n            left = mid + 1;\n          }\n        }\n        var n = start - left;\n        switch (n) {\n          case 3:\n            array2[left + 3] = array2[left + 2];\n          case 2:\n            array2[left + 2] = array2[left + 1];\n          case 1:\n            array2[left + 1] = array2[left];\n            break;\n          default:\n            while (n > 0) {\n              array2[left + n] = array2[left + n - 1];\n              n--;\n            }\n        }\n        array2[left] = pivot;\n      }\n    }\n    function gallopLeft(value, array2, start, length2, hint, compare) {\n      var lastOffset = 0;\n      var maxOffset = 0;\n      var offset = 1;\n      if (compare(value, array2[start + hint]) > 0) {\n        maxOffset = length2 - hint;\n        while (offset < maxOffset && compare(value, array2[start + hint + offset]) > 0) {\n          lastOffset = offset;\n          offset = (offset << 1) + 1;\n          if (offset <= 0) {\n            offset = maxOffset;\n          }\n        }\n        if (offset > maxOffset) {\n          offset = maxOffset;\n        }\n        lastOffset += hint;\n        offset += hint;\n      } else {\n        maxOffset = hint + 1;\n        while (offset < maxOffset && compare(value, array2[start + hint - offset]) <= 0) {\n          lastOffset = offset;\n          offset = (offset << 1) + 1;\n          if (offset <= 0) {\n            offset = maxOffset;\n          }\n        }\n        if (offset > maxOffset) {\n          offset = maxOffset;\n        }\n        var tmp = lastOffset;\n        lastOffset = hint - offset;\n        offset = hint - tmp;\n      }\n      lastOffset++;\n      while (lastOffset < offset) {\n        var m = lastOffset + (offset - lastOffset >>> 1);\n        if (compare(value, array2[start + m]) > 0) {\n          lastOffset = m + 1;\n        } else {\n          offset = m;\n        }\n      }\n      return offset;\n    }\n    function gallopRight(value, array2, start, length2, hint, compare) {\n      var lastOffset = 0;\n      var maxOffset = 0;\n      var offset = 1;\n      if (compare(value, array2[start + hint]) < 0) {\n        maxOffset = hint + 1;\n        while (offset < maxOffset && compare(value, array2[start + hint - offset]) < 0) {\n          lastOffset = offset;\n          offset = (offset << 1) + 1;\n          if (offset <= 0) {\n            offset = maxOffset;\n          }\n        }\n        if (offset > maxOffset) {\n          offset = maxOffset;\n        }\n        var tmp = lastOffset;\n        lastOffset = hint - offset;\n        offset = hint - tmp;\n      } else {\n        maxOffset = length2 - hint;\n        while (offset < maxOffset && compare(value, array2[start + hint + offset]) >= 0) {\n          lastOffset = offset;\n          offset = (offset << 1) + 1;\n          if (offset <= 0) {\n            offset = maxOffset;\n          }\n        }\n        if (offset > maxOffset) {\n          offset = maxOffset;\n        }\n        lastOffset += hint;\n        offset += hint;\n      }\n      lastOffset++;\n      while (lastOffset < offset) {\n        var m = lastOffset + (offset - lastOffset >>> 1);\n        if (compare(value, array2[start + m]) < 0) {\n          offset = m;\n        } else {\n          lastOffset = m + 1;\n        }\n      }\n      return offset;\n    }\n    var TimSort = function() {\n      function TimSort2(array2, compare) {\n        _classCallCheck22(this, TimSort2);\n        this.array = null;\n        this.compare = null;\n        this.minGallop = DEFAULT_MIN_GALLOPING;\n        this.length = 0;\n        this.tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        this.stackLength = 0;\n        this.runStart = null;\n        this.runLength = null;\n        this.stackSize = 0;\n        this.array = array2;\n        this.compare = compare;\n        this.length = array2.length;\n        if (this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n          this.tmpStorageLength = this.length >>> 1;\n        }\n        this.tmp = new Array(this.tmpStorageLength);\n        this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40;\n        this.runStart = new Array(this.stackLength);\n        this.runLength = new Array(this.stackLength);\n      }\n      TimSort2.prototype.pushRun = function pushRun(runStart, runLength) {\n        this.runStart[this.stackSize] = runStart;\n        this.runLength[this.stackSize] = runLength;\n        this.stackSize += 1;\n      };\n      TimSort2.prototype.mergeRuns = function mergeRuns() {\n        while (this.stackSize > 1) {\n          var n = this.stackSize - 2;\n          if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {\n            if (this.runLength[n - 1] < this.runLength[n + 1]) {\n              n--;\n            }\n          } else if (this.runLength[n] > this.runLength[n + 1]) {\n            break;\n          }\n          this.mergeAt(n);\n        }\n      };\n      TimSort2.prototype.forceMergeRuns = function forceMergeRuns() {\n        while (this.stackSize > 1) {\n          var n = this.stackSize - 2;\n          if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {\n            n--;\n          }\n          this.mergeAt(n);\n        }\n      };\n      TimSort2.prototype.mergeAt = function mergeAt(i) {\n        var compare = this.compare;\n        var array2 = this.array;\n        var start1 = this.runStart[i];\n        var length1 = this.runLength[i];\n        var start2 = this.runStart[i + 1];\n        var length2 = this.runLength[i + 1];\n        this.runLength[i] = length1 + length2;\n        if (i === this.stackSize - 3) {\n          this.runStart[i + 1] = this.runStart[i + 2];\n          this.runLength[i + 1] = this.runLength[i + 2];\n        }\n        this.stackSize--;\n        var k2 = gallopRight(array2[start2], array2, start1, length1, 0, compare);\n        start1 += k2;\n        length1 -= k2;\n        if (length1 === 0) {\n          return;\n        }\n        length2 = gallopLeft(array2[start1 + length1 - 1], array2, start2, length2, length2 - 1, compare);\n        if (length2 === 0) {\n          return;\n        }\n        if (length1 <= length2) {\n          this.mergeLow(start1, length1, start2, length2);\n        } else {\n          this.mergeHigh(start1, length1, start2, length2);\n        }\n      };\n      TimSort2.prototype.mergeLow = function mergeLow(start1, length1, start2, length2) {\n        var compare = this.compare;\n        var array2 = this.array;\n        var tmp = this.tmp;\n        var i = 0;\n        for (i = 0; i < length1; i++) {\n          tmp[i] = array2[start1 + i];\n        }\n        var cursor1 = 0;\n        var cursor2 = start2;\n        var dest = start1;\n        array2[dest++] = array2[cursor2++];\n        if (--length2 === 0) {\n          for (i = 0; i < length1; i++) {\n            array2[dest + i] = tmp[cursor1 + i];\n          }\n          return;\n        }\n        if (length1 === 1) {\n          for (i = 0; i < length2; i++) {\n            array2[dest + i] = array2[cursor2 + i];\n          }\n          array2[dest + length2] = tmp[cursor1];\n          return;\n        }\n        var minGallop = this.minGallop;\n        while (true) {\n          var count1 = 0;\n          var count2 = 0;\n          var exit = false;\n          do {\n            if (compare(array2[cursor2], tmp[cursor1]) < 0) {\n              array2[dest++] = array2[cursor2++];\n              count2++;\n              count1 = 0;\n              if (--length2 === 0) {\n                exit = true;\n                break;\n              }\n            } else {\n              array2[dest++] = tmp[cursor1++];\n              count1++;\n              count2 = 0;\n              if (--length1 === 1) {\n                exit = true;\n                break;\n              }\n            }\n          } while ((count1 | count2) < minGallop);\n          if (exit) {\n            break;\n          }\n          do {\n            count1 = gallopRight(array2[cursor2], tmp, cursor1, length1, 0, compare);\n            if (count1 !== 0) {\n              for (i = 0; i < count1; i++) {\n                array2[dest + i] = tmp[cursor1 + i];\n              }\n              dest += count1;\n              cursor1 += count1;\n              length1 -= count1;\n              if (length1 <= 1) {\n                exit = true;\n                break;\n              }\n            }\n            array2[dest++] = array2[cursor2++];\n            if (--length2 === 0) {\n              exit = true;\n              break;\n            }\n            count2 = gallopLeft(tmp[cursor1], array2, cursor2, length2, 0, compare);\n            if (count2 !== 0) {\n              for (i = 0; i < count2; i++) {\n                array2[dest + i] = array2[cursor2 + i];\n              }\n              dest += count2;\n              cursor2 += count2;\n              length2 -= count2;\n              if (length2 === 0) {\n                exit = true;\n                break;\n              }\n            }\n            array2[dest++] = tmp[cursor1++];\n            if (--length1 === 1) {\n              exit = true;\n              break;\n            }\n            minGallop--;\n          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n          if (exit) {\n            break;\n          }\n          if (minGallop < 0) {\n            minGallop = 0;\n          }\n          minGallop += 2;\n        }\n        this.minGallop = minGallop;\n        if (minGallop < 1) {\n          this.minGallop = 1;\n        }\n        if (length1 === 1) {\n          for (i = 0; i < length2; i++) {\n            array2[dest + i] = array2[cursor2 + i];\n          }\n          array2[dest + length2] = tmp[cursor1];\n        } else if (length1 === 0) {\n          throw new Error(\"mergeLow preconditions were not respected\");\n        } else {\n          for (i = 0; i < length1; i++) {\n            array2[dest + i] = tmp[cursor1 + i];\n          }\n        }\n      };\n      TimSort2.prototype.mergeHigh = function mergeHigh(start1, length1, start2, length2) {\n        var compare = this.compare;\n        var array2 = this.array;\n        var tmp = this.tmp;\n        var i = 0;\n        for (i = 0; i < length2; i++) {\n          tmp[i] = array2[start2 + i];\n        }\n        var cursor1 = start1 + length1 - 1;\n        var cursor2 = length2 - 1;\n        var dest = start2 + length2 - 1;\n        var customCursor = 0;\n        var customDest = 0;\n        array2[dest--] = array2[cursor1--];\n        if (--length1 === 0) {\n          customCursor = dest - (length2 - 1);\n          for (i = 0; i < length2; i++) {\n            array2[customCursor + i] = tmp[i];\n          }\n          return;\n        }\n        if (length2 === 1) {\n          dest -= length1;\n          cursor1 -= length1;\n          customDest = dest + 1;\n          customCursor = cursor1 + 1;\n          for (i = length1 - 1; i >= 0; i--) {\n            array2[customDest + i] = array2[customCursor + i];\n          }\n          array2[dest] = tmp[cursor2];\n          return;\n        }\n        var minGallop = this.minGallop;\n        while (true) {\n          var count1 = 0;\n          var count2 = 0;\n          var exit = false;\n          do {\n            if (compare(tmp[cursor2], array2[cursor1]) < 0) {\n              array2[dest--] = array2[cursor1--];\n              count1++;\n              count2 = 0;\n              if (--length1 === 0) {\n                exit = true;\n                break;\n              }\n            } else {\n              array2[dest--] = tmp[cursor2--];\n              count2++;\n              count1 = 0;\n              if (--length2 === 1) {\n                exit = true;\n                break;\n              }\n            }\n          } while ((count1 | count2) < minGallop);\n          if (exit) {\n            break;\n          }\n          do {\n            count1 = length1 - gallopRight(tmp[cursor2], array2, start1, length1, length1 - 1, compare);\n            if (count1 !== 0) {\n              dest -= count1;\n              cursor1 -= count1;\n              length1 -= count1;\n              customDest = dest + 1;\n              customCursor = cursor1 + 1;\n              for (i = count1 - 1; i >= 0; i--) {\n                array2[customDest + i] = array2[customCursor + i];\n              }\n              if (length1 === 0) {\n                exit = true;\n                break;\n              }\n            }\n            array2[dest--] = tmp[cursor2--];\n            if (--length2 === 1) {\n              exit = true;\n              break;\n            }\n            count2 = length2 - gallopLeft(array2[cursor1], tmp, 0, length2, length2 - 1, compare);\n            if (count2 !== 0) {\n              dest -= count2;\n              cursor2 -= count2;\n              length2 -= count2;\n              customDest = dest + 1;\n              customCursor = cursor2 + 1;\n              for (i = 0; i < count2; i++) {\n                array2[customDest + i] = tmp[customCursor + i];\n              }\n              if (length2 <= 1) {\n                exit = true;\n                break;\n              }\n            }\n            array2[dest--] = array2[cursor1--];\n            if (--length1 === 0) {\n              exit = true;\n              break;\n            }\n            minGallop--;\n          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n          if (exit) {\n            break;\n          }\n          if (minGallop < 0) {\n            minGallop = 0;\n          }\n          minGallop += 2;\n        }\n        this.minGallop = minGallop;\n        if (minGallop < 1) {\n          this.minGallop = 1;\n        }\n        if (length2 === 1) {\n          dest -= length1;\n          cursor1 -= length1;\n          customDest = dest + 1;\n          customCursor = cursor1 + 1;\n          for (i = length1 - 1; i >= 0; i--) {\n            array2[customDest + i] = array2[customCursor + i];\n          }\n          array2[dest] = tmp[cursor2];\n        } else if (length2 === 0) {\n          throw new Error(\"mergeHigh preconditions were not respected\");\n        } else {\n          customCursor = dest - (length2 - 1);\n          for (i = 0; i < length2; i++) {\n            array2[customCursor + i] = tmp[i];\n          }\n        }\n      };\n      return TimSort2;\n    }();\n    function sort32(array2, compare, lo, hi22) {\n      if (!Array.isArray(array2)) {\n        throw new TypeError(\"Can only sort arrays\");\n      }\n      if (!compare) {\n        compare = alphabeticalCompare;\n      } else if (typeof compare !== \"function\") {\n        hi22 = lo;\n        lo = compare;\n        compare = alphabeticalCompare;\n      }\n      if (!lo) {\n        lo = 0;\n      }\n      if (!hi22) {\n        hi22 = array2.length;\n      }\n      var remaining = hi22 - lo;\n      if (remaining < 2) {\n        return;\n      }\n      var runLength = 0;\n      if (remaining < DEFAULT_MIN_MERGE) {\n        runLength = makeAscendingRun(array2, lo, hi22, compare);\n        binaryInsertionSort(array2, lo, hi22, lo + runLength, compare);\n        return;\n      }\n      var ts = new TimSort(array2, compare);\n      var minRun = minRunLength(remaining);\n      do {\n        runLength = makeAscendingRun(array2, lo, hi22, compare);\n        if (runLength < minRun) {\n          var force = remaining;\n          if (force > minRun) {\n            force = minRun;\n          }\n          binaryInsertionSort(array2, lo, lo + force, lo + runLength, compare);\n          runLength = force;\n        }\n        ts.pushRun(lo, runLength);\n        ts.mergeRuns();\n        remaining -= runLength;\n        lo += runLength;\n      } while (remaining !== 0);\n      ts.forceMergeRuns();\n    }\n  });\n})(timsort$1);\nvar timsort = timsort$1;\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf2(Derived), result2;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf2(this).constructor;\n      result2 = construct22(Super, arguments, NewTarget);\n    } else {\n      result2 = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn2(this, result2);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !construct22)\n    return false;\n  if (construct22.sham)\n    return false;\n  if (typeof Proxy === \"function\")\n    return true;\n  try {\n    Boolean.prototype.valueOf.call(construct22(Boolean, [], function() {\n    }));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar DirectionInterface = /* @__PURE__ */ function() {\n  function DirectionInterface2() {\n    _classCallCheck2(this, DirectionInterface2);\n  }\n  _createClass2(DirectionInterface2, [{\n    key: \"abstract\",\n    value: function abstract() {\n      throw new Error(\"Can't instantiate abstract class!\");\n    }\n  }, {\n    key: \"fake_use\",\n    value: function fake_use() {\n    }\n  }, {\n    key: \"curveType\",\n    value: function curveType() {\n      return this.abstract();\n    }\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(node) {\n      this.fake_use(node);\n      return this.abstract();\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(node, position) {\n      var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;\n      this.fake_use(node, position, level);\n      this.abstract();\n    }\n  }, {\n    key: \"getTreeSize\",\n    value: function getTreeSize(index2) {\n      this.fake_use(index2);\n      return this.abstract();\n    }\n  }, {\n    key: \"sort\",\n    value: function sort32(nodeArray) {\n      this.fake_use(nodeArray);\n      this.abstract();\n    }\n  }, {\n    key: \"fix\",\n    value: function fix22(node, level) {\n      this.fake_use(node, level);\n      this.abstract();\n    }\n  }, {\n    key: \"shift\",\n    value: function shift(nodeId, diff) {\n      this.fake_use(nodeId, diff);\n      this.abstract();\n    }\n  }]);\n  return DirectionInterface2;\n}();\nvar VerticalStrategy = /* @__PURE__ */ function(_DirectionInterface) {\n  _inherits2(VerticalStrategy2, _DirectionInterface);\n  var _super = _createSuper(VerticalStrategy2);\n  function VerticalStrategy2(layout) {\n    var _this;\n    _classCallCheck2(this, VerticalStrategy2);\n    _this = _super.call(this);\n    _this.layout = layout;\n    return _this;\n  }\n  _createClass2(VerticalStrategy2, [{\n    key: \"curveType\",\n    value: function curveType() {\n      return \"horizontal\";\n    }\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(node) {\n      return node.x;\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(node, position) {\n      var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;\n      if (level !== void 0) {\n        this.layout.hierarchical.addToOrdering(node, level);\n      }\n      node.x = position;\n    }\n  }, {\n    key: \"getTreeSize\",\n    value: function getTreeSize(index2) {\n      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index2);\n      return {\n        min: res.min_x,\n        max: res.max_x\n      };\n    }\n  }, {\n    key: \"sort\",\n    value: function sort32(nodeArray) {\n      timsort.sort(nodeArray, function(a, b) {\n        return a.x - b.x;\n      });\n    }\n  }, {\n    key: \"fix\",\n    value: function fix22(node, level) {\n      node.y = this.layout.options.hierarchical.levelSeparation * level;\n      node.options.fixed.y = true;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift(nodeId, diff) {\n      this.layout.body.nodes[nodeId].x += diff;\n    }\n  }]);\n  return VerticalStrategy2;\n}(DirectionInterface);\nvar HorizontalStrategy = /* @__PURE__ */ function(_DirectionInterface2) {\n  _inherits2(HorizontalStrategy2, _DirectionInterface2);\n  var _super2 = _createSuper(HorizontalStrategy2);\n  function HorizontalStrategy2(layout) {\n    var _this2;\n    _classCallCheck2(this, HorizontalStrategy2);\n    _this2 = _super2.call(this);\n    _this2.layout = layout;\n    return _this2;\n  }\n  _createClass2(HorizontalStrategy2, [{\n    key: \"curveType\",\n    value: function curveType() {\n      return \"vertical\";\n    }\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(node) {\n      return node.y;\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(node, position) {\n      var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;\n      if (level !== void 0) {\n        this.layout.hierarchical.addToOrdering(node, level);\n      }\n      node.y = position;\n    }\n  }, {\n    key: \"getTreeSize\",\n    value: function getTreeSize(index2) {\n      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index2);\n      return {\n        min: res.min_y,\n        max: res.max_y\n      };\n    }\n  }, {\n    key: \"sort\",\n    value: function sort32(nodeArray) {\n      timsort.sort(nodeArray, function(a, b) {\n        return a.y - b.y;\n      });\n    }\n  }, {\n    key: \"fix\",\n    value: function fix22(node, level) {\n      node.x = this.layout.options.hierarchical.levelSeparation * level;\n      node.options.fixed.x = true;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift(nodeId, diff) {\n      this.layout.body.nodes[nodeId].y += diff;\n    }\n  }]);\n  return HorizontalStrategy2;\n}(DirectionInterface);\nvar $3 = _export2;\nvar $every = arrayIteration2.every;\nvar arrayMethodIsStrict2 = arrayMethodIsStrict$6;\nvar STRICT_METHOD2 = arrayMethodIsStrict2(\"every\");\n$3({\n  target: \"Array\",\n  proto: true,\n  forced: !STRICT_METHOD2\n}, {\n  every: function every(callbackfn) {\n    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);\n  }\n});\nvar entryVirtual2 = entryVirtual$i2;\nvar every$3 = entryVirtual2(\"Array\").every;\nvar isPrototypeOf2 = objectIsPrototypeOf2;\nvar method2 = every$3;\nvar ArrayPrototype2 = Array.prototype;\nvar every$2 = function(it2) {\n  var own = it2.every;\n  return it2 === ArrayPrototype2 || isPrototypeOf2(ArrayPrototype2, it2) && own === ArrayPrototype2.every ? method2 : own;\n};\nvar parent2 = every$2;\nvar every$1 = parent2;\nvar every2 = every$1;\nfunction _createForOfIteratorHelper$12(o, allowArrayLike) {\n  var it2 = typeof symbol2 !== \"undefined\" && getIteratorMethod$12(o) || o[\"@@iterator\"];\n  if (!it2) {\n    if (isArray$12(o) || (it2 = _unsupportedIterableToArray$12(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it2)\n        o = it2;\n      var i = 0;\n      var F2 = function F22() {\n      };\n      return { s: F2, n: function n() {\n        if (i >= o.length)\n          return { done: true };\n        return { done: false, value: o[i++] };\n      }, e: function e(_e3) {\n        throw _e3;\n      }, f: F2 };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true, didErr = false, err;\n  return { s: function s() {\n    it2 = it2.call(o);\n  }, n: function n() {\n    var step = it2.next();\n    normalCompletion = step.done;\n    return step;\n  }, e: function e(_e22) {\n    didErr = true;\n    err = _e22;\n  }, f: function f() {\n    try {\n      if (!normalCompletion && it2.return != null)\n        it2.return();\n    } finally {\n      if (didErr)\n        throw err;\n    }\n  } };\n}\nfunction _unsupportedIterableToArray$12(o, minLen) {\n  var _context9;\n  if (!o)\n    return;\n  if (typeof o === \"string\")\n    return _arrayLikeToArray$12(o, minLen);\n  var n = slice22(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1);\n  if (n === \"Object\" && o.constructor)\n    n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\")\n    return from$32(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray$12(o, minLen);\n}\nfunction _arrayLikeToArray$12(arr, len) {\n  if (len == null || len > arr.length)\n    len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction fillLevelsByDirectionCyclic(nodes, levels) {\n  var edges = new set3();\n  forEach$22(nodes).call(nodes, function(node) {\n    var _context;\n    forEach$22(_context = node.edges).call(_context, function(edge) {\n      if (edge.connected) {\n        edges.add(edge);\n      }\n    });\n  });\n  forEach$22(edges).call(edges, function(edge) {\n    var fromId = edge.from.id;\n    var toId = edge.to.id;\n    if (levels[fromId] == null) {\n      levels[fromId] = 0;\n    }\n    if (levels[toId] == null || levels[fromId] >= levels[toId]) {\n      levels[toId] = levels[fromId] + 1;\n    }\n  });\n  return levels;\n}\nfunction fillLevelsByDirectionLeaves(nodes) {\n  return fillLevelsByDirection(function(node) {\n    var _context2, _context3;\n    return every2(_context2 = filter22(_context3 = node.edges).call(_context3, function(edge) {\n      return nodes.has(edge.toId);\n    })).call(_context2, function(edge) {\n      return edge.to === node;\n    });\n  }, function(newLevel, oldLevel) {\n    return oldLevel > newLevel;\n  }, \"from\", nodes);\n}\nfunction fillLevelsByDirectionRoots(nodes) {\n  return fillLevelsByDirection(function(node) {\n    var _context4, _context5;\n    return every2(_context4 = filter22(_context5 = node.edges).call(_context5, function(edge) {\n      return nodes.has(edge.toId);\n    })).call(_context4, function(edge) {\n      return edge.from === node;\n    });\n  }, function(newLevel, oldLevel) {\n    return oldLevel < newLevel;\n  }, \"to\", nodes);\n}\nfunction fillLevelsByDirection(isEntryNode, shouldLevelBeReplaced, direction, nodes) {\n  var _context6;\n  var levels = create$52(null);\n  var limit = reduce22(_context6 = _toConsumableArray2(values22(nodes).call(nodes))).call(_context6, function(acc, node) {\n    return acc + 1 + node.edges.length;\n  }, 0);\n  var edgeIdProp = direction + \"Id\";\n  var newLevelDiff = direction === \"to\" ? 1 : -1;\n  var _iterator = _createForOfIteratorHelper$12(nodes), _step;\n  try {\n    var _loop = function _loop2() {\n      var _step$value = _slicedToArray2(_step.value, 2), entryNodeId = _step$value[0], entryNode = _step$value[1];\n      if (!nodes.has(entryNodeId) || !isEntryNode(entryNode)) {\n        return \"continue\";\n      }\n      levels[entryNodeId] = 0;\n      var stack = [entryNode];\n      var done = 0;\n      var node = void 0;\n      var _loop22 = function _loop23() {\n        var _context7, _context8;\n        if (!nodes.has(entryNodeId)) {\n          return \"continue\";\n        }\n        var newLevel = levels[node.id] + newLevelDiff;\n        forEach$22(_context7 = filter22(_context8 = node.edges).call(_context8, function(edge) {\n          return edge.connected && edge.to !== edge.from && edge[direction] !== node && nodes.has(edge.toId) && nodes.has(edge.fromId);\n        })).call(_context7, function(edge) {\n          var targetNodeId = edge[edgeIdProp];\n          var oldLevel = levels[targetNodeId];\n          if (oldLevel == null || shouldLevelBeReplaced(newLevel, oldLevel)) {\n            levels[targetNodeId] = newLevel;\n            stack.push(edge[direction]);\n          }\n        });\n        if (done > limit) {\n          return {\n            v: {\n              v: fillLevelsByDirectionCyclic(nodes, levels)\n            }\n          };\n        } else {\n          ++done;\n        }\n      };\n      while (node = stack.pop()) {\n        var _ret2 = _loop22();\n        if (_ret2 === \"continue\")\n          continue;\n        if (_typeof2(_ret2) === \"object\")\n          return _ret2.v;\n      }\n    };\n    for (_iterator.s(); !(_step = _iterator.n()).done; ) {\n      var _ret = _loop();\n      if (_ret === \"continue\")\n        continue;\n      if (_typeof2(_ret) === \"object\")\n        return _ret.v;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return levels;\n}\nvar HierarchicalStatus = /* @__PURE__ */ function() {\n  function HierarchicalStatus2() {\n    _classCallCheck2(this, HierarchicalStatus2);\n    this.childrenReference = {};\n    this.parentReference = {};\n    this.trees = {};\n    this.distributionOrdering = {};\n    this.levels = {};\n    this.distributionIndex = {};\n    this.isTree = false;\n    this.treeIndex = -1;\n  }\n  _createClass2(HierarchicalStatus2, [{\n    key: \"addRelation\",\n    value: function addRelation(parentNodeId, childNodeId) {\n      if (this.childrenReference[parentNodeId] === void 0) {\n        this.childrenReference[parentNodeId] = [];\n      }\n      this.childrenReference[parentNodeId].push(childNodeId);\n      if (this.parentReference[childNodeId] === void 0) {\n        this.parentReference[childNodeId] = [];\n      }\n      this.parentReference[childNodeId].push(parentNodeId);\n    }\n  }, {\n    key: \"checkIfTree\",\n    value: function checkIfTree() {\n      for (var i in this.parentReference) {\n        if (this.parentReference[i].length > 1) {\n          this.isTree = false;\n          return;\n        }\n      }\n      this.isTree = true;\n    }\n  }, {\n    key: \"numTrees\",\n    value: function numTrees() {\n      return this.treeIndex + 1;\n    }\n  }, {\n    key: \"setTreeIndex\",\n    value: function setTreeIndex(node, treeId) {\n      if (treeId === void 0)\n        return;\n      if (this.trees[node.id] === void 0) {\n        this.trees[node.id] = treeId;\n        this.treeIndex = Math.max(treeId, this.treeIndex);\n      }\n    }\n  }, {\n    key: \"ensureLevel\",\n    value: function ensureLevel(nodeId) {\n      if (this.levels[nodeId] === void 0) {\n        this.levels[nodeId] = 0;\n      }\n    }\n  }, {\n    key: \"getMaxLevel\",\n    value: function getMaxLevel(nodeId) {\n      var _this = this;\n      var accumulator = {};\n      var _getMaxLevel = function _getMaxLevel2(nodeId2) {\n        if (accumulator[nodeId2] !== void 0) {\n          return accumulator[nodeId2];\n        }\n        var level = _this.levels[nodeId2];\n        if (_this.childrenReference[nodeId2]) {\n          var children = _this.childrenReference[nodeId2];\n          if (children.length > 0) {\n            for (var i = 0; i < children.length; i++) {\n              level = Math.max(level, _getMaxLevel2(children[i]));\n            }\n          }\n        }\n        accumulator[nodeId2] = level;\n        return level;\n      };\n      return _getMaxLevel(nodeId);\n    }\n  }, {\n    key: \"levelDownstream\",\n    value: function levelDownstream(nodeA, nodeB) {\n      if (this.levels[nodeB.id] === void 0) {\n        if (this.levels[nodeA.id] === void 0) {\n          this.levels[nodeA.id] = 0;\n        }\n        this.levels[nodeB.id] = this.levels[nodeA.id] + 1;\n      }\n    }\n  }, {\n    key: \"setMinLevelToZero\",\n    value: function setMinLevelToZero(nodes) {\n      var minLevel = 1e9;\n      for (var nodeId in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n          if (this.levels[nodeId] !== void 0) {\n            minLevel = Math.min(this.levels[nodeId], minLevel);\n          }\n        }\n      }\n      for (var _nodeId in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, _nodeId)) {\n          if (this.levels[_nodeId] !== void 0) {\n            this.levels[_nodeId] -= minLevel;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"getTreeSize\",\n    value: function getTreeSize(nodes, index2) {\n      var min_x = 1e9;\n      var max_x = -1e9;\n      var min_y = 1e9;\n      var max_y = -1e9;\n      for (var nodeId in this.trees) {\n        if (Object.prototype.hasOwnProperty.call(this.trees, nodeId)) {\n          if (this.trees[nodeId] === index2) {\n            var node = nodes[nodeId];\n            min_x = Math.min(node.x, min_x);\n            max_x = Math.max(node.x, max_x);\n            min_y = Math.min(node.y, min_y);\n            max_y = Math.max(node.y, max_y);\n          }\n        }\n      }\n      return {\n        min_x,\n        max_x,\n        min_y,\n        max_y\n      };\n    }\n  }, {\n    key: \"hasSameParent\",\n    value: function hasSameParent(node1, node2) {\n      var parents1 = this.parentReference[node1.id];\n      var parents2 = this.parentReference[node2.id];\n      if (parents1 === void 0 || parents2 === void 0) {\n        return false;\n      }\n      for (var i = 0; i < parents1.length; i++) {\n        for (var j = 0; j < parents2.length; j++) {\n          if (parents1[i] == parents2[j]) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"inSameSubNetwork\",\n    value: function inSameSubNetwork(node1, node2) {\n      return this.trees[node1.id] === this.trees[node2.id];\n    }\n  }, {\n    key: \"getLevels\",\n    value: function getLevels() {\n      return keys32(this.distributionOrdering);\n    }\n  }, {\n    key: \"addToOrdering\",\n    value: function addToOrdering(node, level) {\n      if (this.distributionOrdering[level] === void 0) {\n        this.distributionOrdering[level] = [];\n      }\n      var isPresent = false;\n      var curLevel = this.distributionOrdering[level];\n      for (var n in curLevel) {\n        if (curLevel[n] === node) {\n          isPresent = true;\n          break;\n        }\n      }\n      if (!isPresent) {\n        this.distributionOrdering[level].push(node);\n        this.distributionIndex[node.id] = this.distributionOrdering[level].length - 1;\n      }\n    }\n  }]);\n  return HierarchicalStatus2;\n}();\nvar LayoutEngine = /* @__PURE__ */ function() {\n  function LayoutEngine2(body) {\n    _classCallCheck2(this, LayoutEngine2);\n    this.body = body;\n    this._resetRNG(Math.random() + \":\" + now$1());\n    this.setPhysics = false;\n    this.options = {};\n    this.optionsBackup = {\n      physics: {}\n    };\n    this.defaultOptions = {\n      randomSeed: void 0,\n      improvedLayout: true,\n      clusterThreshold: 150,\n      hierarchical: {\n        enabled: false,\n        levelSeparation: 150,\n        nodeSpacing: 100,\n        treeSpacing: 200,\n        blockShifting: true,\n        edgeMinimization: true,\n        parentCentralization: true,\n        direction: \"UD\",\n        sortMethod: \"hubsize\"\n      }\n    };\n    assign$22(this.options, this.defaultOptions);\n    this.bindEventListeners();\n  }\n  _createClass2(LayoutEngine2, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this2 = this;\n      this.body.emitter.on(\"_dataChanged\", function() {\n        _this2.setupHierarchicalLayout();\n      });\n      this.body.emitter.on(\"_dataLoaded\", function() {\n        _this2.layoutNetwork();\n      });\n      this.body.emitter.on(\"_resetHierarchicalLayout\", function() {\n        _this2.setupHierarchicalLayout();\n      });\n      this.body.emitter.on(\"_adjustEdgesForHierarchicalLayout\", function() {\n        if (_this2.options.hierarchical.enabled !== true) {\n          return;\n        }\n        var type2 = _this2.direction.curveType();\n        _this2.body.emitter.emit(\"_forceDisableDynamicCurves\", type2, false);\n      });\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options2, allOptions2) {\n      if (options2 !== void 0) {\n        var hierarchical = this.options.hierarchical;\n        var prevHierarchicalState = hierarchical.enabled;\n        selectiveDeepExtend([\"randomSeed\", \"improvedLayout\", \"clusterThreshold\"], this.options, options2);\n        mergeOptions(this.options, options2, \"hierarchical\");\n        if (options2.randomSeed !== void 0) {\n          this._resetRNG(options2.randomSeed);\n        }\n        if (hierarchical.enabled === true) {\n          if (prevHierarchicalState === true) {\n            this.body.emitter.emit(\"refresh\", true);\n          }\n          if (hierarchical.direction === \"RL\" || hierarchical.direction === \"DU\") {\n            if (hierarchical.levelSeparation > 0) {\n              hierarchical.levelSeparation *= -1;\n            }\n          } else {\n            if (hierarchical.levelSeparation < 0) {\n              hierarchical.levelSeparation *= -1;\n            }\n          }\n          this.setDirectionStrategy();\n          this.body.emitter.emit(\"_resetHierarchicalLayout\");\n          return this.adaptAllOptionsForHierarchicalLayout(allOptions2);\n        } else {\n          if (prevHierarchicalState === true) {\n            this.body.emitter.emit(\"refresh\");\n            return deepExtend(allOptions2, this.optionsBackup);\n          }\n        }\n      }\n      return allOptions2;\n    }\n  }, {\n    key: \"_resetRNG\",\n    value: function _resetRNG(seed) {\n      this.initialRandomSeed = seed;\n      this._rng = Alea(this.initialRandomSeed);\n    }\n  }, {\n    key: \"adaptAllOptionsForHierarchicalLayout\",\n    value: function adaptAllOptionsForHierarchicalLayout(allOptions2) {\n      if (this.options.hierarchical.enabled === true) {\n        var backupPhysics = this.optionsBackup.physics;\n        if (allOptions2.physics === void 0 || allOptions2.physics === true) {\n          allOptions2.physics = {\n            enabled: backupPhysics.enabled === void 0 ? true : backupPhysics.enabled,\n            solver: \"hierarchicalRepulsion\"\n          };\n          backupPhysics.enabled = backupPhysics.enabled === void 0 ? true : backupPhysics.enabled;\n          backupPhysics.solver = backupPhysics.solver || \"barnesHut\";\n        } else if (_typeof2(allOptions2.physics) === \"object\") {\n          backupPhysics.enabled = allOptions2.physics.enabled === void 0 ? true : allOptions2.physics.enabled;\n          backupPhysics.solver = allOptions2.physics.solver || \"barnesHut\";\n          allOptions2.physics.solver = \"hierarchicalRepulsion\";\n        } else if (allOptions2.physics !== false) {\n          backupPhysics.solver = \"barnesHut\";\n          allOptions2.physics = {\n            solver: \"hierarchicalRepulsion\"\n          };\n        }\n        var type2 = this.direction.curveType();\n        if (allOptions2.edges === void 0) {\n          this.optionsBackup.edges = {\n            smooth: {\n              enabled: true,\n              type: \"dynamic\"\n            }\n          };\n          allOptions2.edges = {\n            smooth: false\n          };\n        } else if (allOptions2.edges.smooth === void 0) {\n          this.optionsBackup.edges = {\n            smooth: {\n              enabled: true,\n              type: \"dynamic\"\n            }\n          };\n          allOptions2.edges.smooth = false;\n        } else {\n          if (typeof allOptions2.edges.smooth === \"boolean\") {\n            this.optionsBackup.edges = {\n              smooth: allOptions2.edges.smooth\n            };\n            allOptions2.edges.smooth = {\n              enabled: allOptions2.edges.smooth,\n              type: type2\n            };\n          } else {\n            var smooth = allOptions2.edges.smooth;\n            if (smooth.type !== void 0 && smooth.type !== \"dynamic\") {\n              type2 = smooth.type;\n            }\n            this.optionsBackup.edges = {\n              smooth: {\n                enabled: smooth.enabled === void 0 ? true : smooth.enabled,\n                type: smooth.type === void 0 ? \"dynamic\" : smooth.type,\n                roundness: smooth.roundness === void 0 ? 0.5 : smooth.roundness,\n                forceDirection: smooth.forceDirection === void 0 ? false : smooth.forceDirection\n              }\n            };\n            allOptions2.edges.smooth = {\n              enabled: smooth.enabled === void 0 ? true : smooth.enabled,\n              type: type2,\n              roundness: smooth.roundness === void 0 ? 0.5 : smooth.roundness,\n              forceDirection: smooth.forceDirection === void 0 ? false : smooth.forceDirection\n            };\n          }\n        }\n        this.body.emitter.emit(\"_forceDisableDynamicCurves\", type2);\n      }\n      return allOptions2;\n    }\n  }, {\n    key: \"positionInitially\",\n    value: function positionInitially(nodesArray) {\n      if (this.options.hierarchical.enabled !== true) {\n        this._resetRNG(this.initialRandomSeed);\n        var radius = nodesArray.length + 50;\n        for (var i = 0; i < nodesArray.length; i++) {\n          var node = nodesArray[i];\n          var angle = 2 * Math.PI * this._rng();\n          if (node.x === void 0) {\n            node.x = radius * Math.cos(angle);\n          }\n          if (node.y === void 0) {\n            node.y = radius * Math.sin(angle);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"layoutNetwork\",\n    value: function layoutNetwork() {\n      if (this.options.hierarchical.enabled !== true && this.options.improvedLayout === true) {\n        var indices = this.body.nodeIndices;\n        var positionDefined = 0;\n        for (var i = 0; i < indices.length; i++) {\n          var node = this.body.nodes[indices[i]];\n          if (node.predefinedPosition === true) {\n            positionDefined += 1;\n          }\n        }\n        if (positionDefined < 0.5 * indices.length) {\n          var MAX_LEVELS = 10;\n          var level = 0;\n          var clusterThreshold = this.options.clusterThreshold;\n          var clusterOptions = {\n            clusterNodeProperties: {\n              shape: \"ellipse\",\n              label: \"\",\n              group: \"\",\n              font: {\n                multi: false\n              }\n            },\n            clusterEdgeProperties: {\n              label: \"\",\n              font: {\n                multi: false\n              },\n              smooth: {\n                enabled: false\n              }\n            }\n          };\n          if (indices.length > clusterThreshold) {\n            var startLength = indices.length;\n            while (indices.length > clusterThreshold && level <= MAX_LEVELS) {\n              level += 1;\n              var before = indices.length;\n              if (level % 3 === 0) {\n                this.body.modules.clustering.clusterBridges(clusterOptions);\n              } else {\n                this.body.modules.clustering.clusterOutliers(clusterOptions);\n              }\n              var after = indices.length;\n              if (before == after && level % 3 !== 0) {\n                this._declusterAll();\n                this.body.emitter.emit(\"_layoutFailed\");\n                console.info(\"This network could not be positioned by this version of the improved layout algorithm. Please disable improvedLayout for better performance.\");\n                return;\n              }\n            }\n            this.body.modules.kamadaKawai.setOptions({\n              springLength: Math.max(150, 2 * startLength)\n            });\n          }\n          if (level > MAX_LEVELS) {\n            console.info(\"The clustering didn't succeed within the amount of interations allowed, progressing with partial result.\");\n          }\n          this.body.modules.kamadaKawai.solve(indices, this.body.edgeIndices, true);\n          this._shiftToCenter();\n          var offset = 70;\n          for (var _i = 0; _i < indices.length; _i++) {\n            var _node = this.body.nodes[indices[_i]];\n            if (_node.predefinedPosition === false) {\n              _node.x += (0.5 - this._rng()) * offset;\n              _node.y += (0.5 - this._rng()) * offset;\n            }\n          }\n          this._declusterAll();\n          this.body.emitter.emit(\"_repositionBezierNodes\");\n        }\n      }\n    }\n  }, {\n    key: \"_shiftToCenter\",\n    value: function _shiftToCenter() {\n      var range = NetworkUtil.getRangeCore(this.body.nodes, this.body.nodeIndices);\n      var center = NetworkUtil.findCenter(range);\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var node = this.body.nodes[this.body.nodeIndices[i]];\n        node.x -= center.x;\n        node.y -= center.y;\n      }\n    }\n  }, {\n    key: \"_declusterAll\",\n    value: function _declusterAll() {\n      var clustersPresent = true;\n      while (clustersPresent === true) {\n        clustersPresent = false;\n        for (var i = 0; i < this.body.nodeIndices.length; i++) {\n          if (this.body.nodes[this.body.nodeIndices[i]].isCluster === true) {\n            clustersPresent = true;\n            this.body.modules.clustering.openCluster(this.body.nodeIndices[i], {}, false);\n          }\n        }\n        if (clustersPresent === true) {\n          this.body.emitter.emit(\"_dataChanged\");\n        }\n      }\n    }\n  }, {\n    key: \"getSeed\",\n    value: function getSeed() {\n      return this.initialRandomSeed;\n    }\n  }, {\n    key: \"setupHierarchicalLayout\",\n    value: function setupHierarchicalLayout() {\n      if (this.options.hierarchical.enabled === true && this.body.nodeIndices.length > 0) {\n        var node, nodeId;\n        var definedLevel = false;\n        var undefinedLevel = false;\n        this.lastNodeOnLevel = {};\n        this.hierarchical = new HierarchicalStatus();\n        for (nodeId in this.body.nodes) {\n          if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {\n            node = this.body.nodes[nodeId];\n            if (node.options.level !== void 0) {\n              definedLevel = true;\n              this.hierarchical.levels[nodeId] = node.options.level;\n            } else {\n              undefinedLevel = true;\n            }\n          }\n        }\n        if (undefinedLevel === true && definedLevel === true) {\n          throw new Error(\"To use the hierarchical layout, nodes require either no predefined levels or levels have to be defined for all nodes.\");\n        } else {\n          if (undefinedLevel === true) {\n            var sortMethod = this.options.hierarchical.sortMethod;\n            if (sortMethod === \"hubsize\") {\n              this._determineLevelsByHubsize();\n            } else if (sortMethod === \"directed\") {\n              this._determineLevelsDirected();\n            } else if (sortMethod === \"custom\") {\n              this._determineLevelsCustomCallback();\n            }\n          }\n          for (var _nodeId2 in this.body.nodes) {\n            if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {\n              this.hierarchical.ensureLevel(_nodeId2);\n            }\n          }\n          var distribution = this._getDistribution();\n          this._generateMap();\n          this._placeNodesByHierarchy(distribution);\n          this._condenseHierarchy();\n          this._shiftToCenter();\n        }\n      }\n    }\n  }, {\n    key: \"_condenseHierarchy\",\n    value: function _condenseHierarchy() {\n      var _this3 = this;\n      var stillShifting = false;\n      var branches = {};\n      var shiftTrees = function shiftTrees2() {\n        var treeSizes = getTreeSizes();\n        var shiftBy = 0;\n        for (var i = 0; i < treeSizes.length - 1; i++) {\n          var diff = treeSizes[i].max - treeSizes[i + 1].min;\n          shiftBy += diff + _this3.options.hierarchical.treeSpacing;\n          shiftTree(i + 1, shiftBy);\n        }\n      };\n      var shiftTree = function shiftTree2(index2, offset) {\n        var trees = _this3.hierarchical.trees;\n        for (var nodeId in trees) {\n          if (Object.prototype.hasOwnProperty.call(trees, nodeId)) {\n            if (trees[nodeId] === index2) {\n              _this3.direction.shift(nodeId, offset);\n            }\n          }\n        }\n      };\n      var getTreeSizes = function getTreeSizes2() {\n        var treeWidths = [];\n        for (var i = 0; i < _this3.hierarchical.numTrees(); i++) {\n          treeWidths.push(_this3.direction.getTreeSize(i));\n        }\n        return treeWidths;\n      };\n      var getBranchNodes = function getBranchNodes2(source, map32) {\n        if (map32[source.id]) {\n          return;\n        }\n        map32[source.id] = true;\n        if (_this3.hierarchical.childrenReference[source.id]) {\n          var children = _this3.hierarchical.childrenReference[source.id];\n          if (children.length > 0) {\n            for (var i = 0; i < children.length; i++) {\n              getBranchNodes2(_this3.body.nodes[children[i]], map32);\n            }\n          }\n        }\n      };\n      var getBranchBoundary = function getBranchBoundary2(branchMap) {\n        var maxLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e9;\n        var minSpace = 1e9;\n        var maxSpace = 1e9;\n        var min22 = 1e9;\n        var max22 = -1e9;\n        for (var branchNode in branchMap) {\n          if (Object.prototype.hasOwnProperty.call(branchMap, branchNode)) {\n            var node = _this3.body.nodes[branchNode];\n            var level = _this3.hierarchical.levels[node.id];\n            var position = _this3.direction.getPosition(node);\n            var _this3$_getSpaceAroun = _this3._getSpaceAroundNode(node, branchMap), _this3$_getSpaceAroun2 = _slicedToArray2(_this3$_getSpaceAroun, 2), minSpaceNode = _this3$_getSpaceAroun2[0], maxSpaceNode = _this3$_getSpaceAroun2[1];\n            minSpace = Math.min(minSpaceNode, minSpace);\n            maxSpace = Math.min(maxSpaceNode, maxSpace);\n            if (level <= maxLevel) {\n              min22 = Math.min(position, min22);\n              max22 = Math.max(position, max22);\n            }\n          }\n        }\n        return [min22, max22, minSpace, maxSpace];\n      };\n      var getCollisionLevel = function getCollisionLevel2(node1, node2) {\n        var maxLevel1 = _this3.hierarchical.getMaxLevel(node1.id);\n        var maxLevel2 = _this3.hierarchical.getMaxLevel(node2.id);\n        return Math.min(maxLevel1, maxLevel2);\n      };\n      var shiftElementsCloser = function shiftElementsCloser2(callback, levels, centerParents) {\n        var hier = _this3.hierarchical;\n        for (var i = 0; i < levels.length; i++) {\n          var level = levels[i];\n          var levelNodes = hier.distributionOrdering[level];\n          if (levelNodes.length > 1) {\n            for (var j = 0; j < levelNodes.length - 1; j++) {\n              var node1 = levelNodes[j];\n              var node2 = levelNodes[j + 1];\n              if (hier.hasSameParent(node1, node2) && hier.inSameSubNetwork(node1, node2)) {\n                callback(node1, node2, centerParents);\n              }\n            }\n          }\n        }\n      };\n      var branchShiftCallback = function branchShiftCallback2(node1, node2) {\n        var centerParent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        var pos1 = _this3.direction.getPosition(node1);\n        var pos2 = _this3.direction.getPosition(node2);\n        var diffAbs = Math.abs(pos2 - pos1);\n        var nodeSpacing = _this3.options.hierarchical.nodeSpacing;\n        if (diffAbs > nodeSpacing) {\n          var branchNodes1 = {};\n          var branchNodes2 = {};\n          getBranchNodes(node1, branchNodes1);\n          getBranchNodes(node2, branchNodes2);\n          var maxLevel = getCollisionLevel(node1, node2);\n          var branchNodeBoundary1 = getBranchBoundary(branchNodes1, maxLevel);\n          var branchNodeBoundary2 = getBranchBoundary(branchNodes2, maxLevel);\n          var max1 = branchNodeBoundary1[1];\n          var min22 = branchNodeBoundary2[0];\n          var minSpace2 = branchNodeBoundary2[2];\n          var diffBranch = Math.abs(max1 - min22);\n          if (diffBranch > nodeSpacing) {\n            var offset = max1 - min22 + nodeSpacing;\n            if (offset < -minSpace2 + nodeSpacing) {\n              offset = -minSpace2 + nodeSpacing;\n            }\n            if (offset < 0) {\n              _this3._shiftBlock(node2.id, offset);\n              stillShifting = true;\n              if (centerParent === true)\n                _this3._centerParent(node2);\n            }\n          }\n        }\n      };\n      var minimizeEdgeLength = function minimizeEdgeLength2(iterations, node) {\n        var nodeId = node.id;\n        var allEdges = node.edges;\n        var nodeLevel = _this3.hierarchical.levels[node.id];\n        var C22 = _this3.options.hierarchical.levelSeparation * _this3.options.hierarchical.levelSeparation;\n        var referenceNodes = {};\n        var aboveEdges = [];\n        for (var i = 0; i < allEdges.length; i++) {\n          var edge = allEdges[i];\n          if (edge.toId != edge.fromId) {\n            var otherNode = edge.toId == nodeId ? edge.from : edge.to;\n            referenceNodes[allEdges[i].id] = otherNode;\n            if (_this3.hierarchical.levels[otherNode.id] < nodeLevel) {\n              aboveEdges.push(edge);\n            }\n          }\n        }\n        var getFx = function getFx2(point, edges) {\n          var sum = 0;\n          for (var _i2 = 0; _i2 < edges.length; _i2++) {\n            if (referenceNodes[edges[_i2].id] !== void 0) {\n              var a = _this3.direction.getPosition(referenceNodes[edges[_i2].id]) - point;\n              sum += a / Math.sqrt(a * a + C22);\n            }\n          }\n          return sum;\n        };\n        var getDFx = function getDFx2(point, edges) {\n          var sum = 0;\n          for (var _i3 = 0; _i3 < edges.length; _i3++) {\n            if (referenceNodes[edges[_i3].id] !== void 0) {\n              var a = _this3.direction.getPosition(referenceNodes[edges[_i3].id]) - point;\n              sum -= C22 * Math.pow(a * a + C22, -1.5);\n            }\n          }\n          return sum;\n        };\n        var getGuess = function getGuess2(iterations2, edges) {\n          var guess2 = _this3.direction.getPosition(node);\n          var guessMap = {};\n          for (var _i4 = 0; _i4 < iterations2; _i4++) {\n            var fx = getFx(guess2, edges);\n            var dfx = getDFx(guess2, edges);\n            var limit = 40;\n            var ratio = Math.max(-limit, Math.min(limit, Math.round(fx / dfx)));\n            guess2 = guess2 - ratio;\n            if (guessMap[guess2] !== void 0) {\n              break;\n            }\n            guessMap[guess2] = _i4;\n          }\n          return guess2;\n        };\n        var moveBranch = function moveBranch2(guess2) {\n          var nodePosition = _this3.direction.getPosition(node);\n          if (branches[node.id] === void 0) {\n            var branchNodes = {};\n            getBranchNodes(node, branchNodes);\n            branches[node.id] = branchNodes;\n          }\n          var branchBoundary = getBranchBoundary(branches[node.id]);\n          var minSpaceBranch = branchBoundary[2];\n          var maxSpaceBranch = branchBoundary[3];\n          var diff = guess2 - nodePosition;\n          var branchOffset = 0;\n          if (diff > 0) {\n            branchOffset = Math.min(diff, maxSpaceBranch - _this3.options.hierarchical.nodeSpacing);\n          } else if (diff < 0) {\n            branchOffset = -Math.min(-diff, minSpaceBranch - _this3.options.hierarchical.nodeSpacing);\n          }\n          if (branchOffset != 0) {\n            _this3._shiftBlock(node.id, branchOffset);\n            stillShifting = true;\n          }\n        };\n        var moveNode = function moveNode2(guess2) {\n          var nodePosition = _this3.direction.getPosition(node);\n          var _this3$_getSpaceAroun3 = _this3._getSpaceAroundNode(node), _this3$_getSpaceAroun4 = _slicedToArray2(_this3$_getSpaceAroun3, 2), minSpace = _this3$_getSpaceAroun4[0], maxSpace = _this3$_getSpaceAroun4[1];\n          var diff = guess2 - nodePosition;\n          var newPosition = nodePosition;\n          if (diff > 0) {\n            newPosition = Math.min(nodePosition + (maxSpace - _this3.options.hierarchical.nodeSpacing), guess2);\n          } else if (diff < 0) {\n            newPosition = Math.max(nodePosition - (minSpace - _this3.options.hierarchical.nodeSpacing), guess2);\n          }\n          if (newPosition !== nodePosition) {\n            _this3.direction.setPosition(node, newPosition);\n            stillShifting = true;\n          }\n        };\n        var guess = getGuess(iterations, aboveEdges);\n        moveBranch(guess);\n        guess = getGuess(iterations, allEdges);\n        moveNode(guess);\n      };\n      var minimizeEdgeLengthBottomUp = function minimizeEdgeLengthBottomUp2(iterations) {\n        var levels = _this3.hierarchical.getLevels();\n        levels = reverse22(levels).call(levels);\n        for (var i = 0; i < iterations; i++) {\n          stillShifting = false;\n          for (var j = 0; j < levels.length; j++) {\n            var level = levels[j];\n            var levelNodes = _this3.hierarchical.distributionOrdering[level];\n            for (var k2 = 0; k2 < levelNodes.length; k2++) {\n              minimizeEdgeLength(1e3, levelNodes[k2]);\n            }\n          }\n          if (stillShifting !== true) {\n            break;\n          }\n        }\n      };\n      var shiftBranchesCloserBottomUp = function shiftBranchesCloserBottomUp2(iterations) {\n        var levels = _this3.hierarchical.getLevels();\n        levels = reverse22(levels).call(levels);\n        for (var i = 0; i < iterations; i++) {\n          stillShifting = false;\n          shiftElementsCloser(branchShiftCallback, levels, true);\n          if (stillShifting !== true) {\n            break;\n          }\n        }\n      };\n      var centerAllParents = function centerAllParents2() {\n        for (var nodeId in _this3.body.nodes) {\n          if (Object.prototype.hasOwnProperty.call(_this3.body.nodes, nodeId))\n            _this3._centerParent(_this3.body.nodes[nodeId]);\n        }\n      };\n      var centerAllParentsBottomUp = function centerAllParentsBottomUp2() {\n        var levels = _this3.hierarchical.getLevels();\n        levels = reverse22(levels).call(levels);\n        for (var i = 0; i < levels.length; i++) {\n          var level = levels[i];\n          var levelNodes = _this3.hierarchical.distributionOrdering[level];\n          for (var j = 0; j < levelNodes.length; j++) {\n            _this3._centerParent(levelNodes[j]);\n          }\n        }\n      };\n      if (this.options.hierarchical.blockShifting === true) {\n        shiftBranchesCloserBottomUp(5);\n        centerAllParents();\n      }\n      if (this.options.hierarchical.edgeMinimization === true) {\n        minimizeEdgeLengthBottomUp(20);\n      }\n      if (this.options.hierarchical.parentCentralization === true) {\n        centerAllParentsBottomUp();\n      }\n      shiftTrees();\n    }\n  }, {\n    key: \"_getSpaceAroundNode\",\n    value: function _getSpaceAroundNode(node, map32) {\n      var useMap = true;\n      if (map32 === void 0) {\n        useMap = false;\n      }\n      var level = this.hierarchical.levels[node.id];\n      if (level !== void 0) {\n        var index2 = this.hierarchical.distributionIndex[node.id];\n        var position = this.direction.getPosition(node);\n        var ordering = this.hierarchical.distributionOrdering[level];\n        var minSpace = 1e9;\n        var maxSpace = 1e9;\n        if (index2 !== 0) {\n          var prevNode = ordering[index2 - 1];\n          if (useMap === true && map32[prevNode.id] === void 0 || useMap === false) {\n            var prevPos = this.direction.getPosition(prevNode);\n            minSpace = position - prevPos;\n          }\n        }\n        if (index2 != ordering.length - 1) {\n          var nextNode = ordering[index2 + 1];\n          if (useMap === true && map32[nextNode.id] === void 0 || useMap === false) {\n            var nextPos = this.direction.getPosition(nextNode);\n            maxSpace = Math.min(maxSpace, nextPos - position);\n          }\n        }\n        return [minSpace, maxSpace];\n      } else {\n        return [0, 0];\n      }\n    }\n  }, {\n    key: \"_centerParent\",\n    value: function _centerParent(node) {\n      if (this.hierarchical.parentReference[node.id]) {\n        var parents = this.hierarchical.parentReference[node.id];\n        for (var i = 0; i < parents.length; i++) {\n          var parentId = parents[i];\n          var parentNode = this.body.nodes[parentId];\n          var children = this.hierarchical.childrenReference[parentId];\n          if (children !== void 0) {\n            var newPosition = this._getCenterPosition(children);\n            var position = this.direction.getPosition(parentNode);\n            var _this$_getSpaceAround = this._getSpaceAroundNode(parentNode), _this$_getSpaceAround2 = _slicedToArray2(_this$_getSpaceAround, 2), minSpace = _this$_getSpaceAround2[0], maxSpace = _this$_getSpaceAround2[1];\n            var diff = position - newPosition;\n            if (diff < 0 && Math.abs(diff) < maxSpace - this.options.hierarchical.nodeSpacing || diff > 0 && Math.abs(diff) < minSpace - this.options.hierarchical.nodeSpacing) {\n              this.direction.setPosition(parentNode, newPosition);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_placeNodesByHierarchy\",\n    value: function _placeNodesByHierarchy(distribution) {\n      this.positionedNodes = {};\n      for (var level in distribution) {\n        if (Object.prototype.hasOwnProperty.call(distribution, level)) {\n          var _context;\n          var nodeArray = keys32(distribution[level]);\n          nodeArray = this._indexArrayToNodes(nodeArray);\n          sort22(_context = this.direction).call(_context, nodeArray);\n          var handledNodeCount = 0;\n          for (var i = 0; i < nodeArray.length; i++) {\n            var node = nodeArray[i];\n            if (this.positionedNodes[node.id] === void 0) {\n              var spacing = this.options.hierarchical.nodeSpacing;\n              var pos = spacing * handledNodeCount;\n              if (handledNodeCount > 0) {\n                pos = this.direction.getPosition(nodeArray[i - 1]) + spacing;\n              }\n              this.direction.setPosition(node, pos, level);\n              this._validatePositionAndContinue(node, level, pos);\n              handledNodeCount++;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_placeBranchNodes\",\n    value: function _placeBranchNodes(parentId, parentLevel) {\n      var _context2;\n      var childRef = this.hierarchical.childrenReference[parentId];\n      if (childRef === void 0) {\n        return;\n      }\n      var childNodes = [];\n      for (var i = 0; i < childRef.length; i++) {\n        childNodes.push(this.body.nodes[childRef[i]]);\n      }\n      sort22(_context2 = this.direction).call(_context2, childNodes);\n      for (var _i5 = 0; _i5 < childNodes.length; _i5++) {\n        var childNode = childNodes[_i5];\n        var childNodeLevel = this.hierarchical.levels[childNode.id];\n        if (childNodeLevel > parentLevel && this.positionedNodes[childNode.id] === void 0) {\n          var spacing = this.options.hierarchical.nodeSpacing;\n          var pos = void 0;\n          if (_i5 === 0) {\n            pos = this.direction.getPosition(this.body.nodes[parentId]);\n          } else {\n            pos = this.direction.getPosition(childNodes[_i5 - 1]) + spacing;\n          }\n          this.direction.setPosition(childNode, pos, childNodeLevel);\n          this._validatePositionAndContinue(childNode, childNodeLevel, pos);\n        } else {\n          return;\n        }\n      }\n      var center = this._getCenterPosition(childNodes);\n      this.direction.setPosition(this.body.nodes[parentId], center, parentLevel);\n    }\n  }, {\n    key: \"_validatePositionAndContinue\",\n    value: function _validatePositionAndContinue(node, level, pos) {\n      if (!this.hierarchical.isTree)\n        return;\n      if (this.lastNodeOnLevel[level] !== void 0) {\n        var previousPos = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[level]]);\n        if (pos - previousPos < this.options.hierarchical.nodeSpacing) {\n          var diff = previousPos + this.options.hierarchical.nodeSpacing - pos;\n          var sharedParent = this._findCommonParent(this.lastNodeOnLevel[level], node.id);\n          this._shiftBlock(sharedParent.withChild, diff);\n        }\n      }\n      this.lastNodeOnLevel[level] = node.id;\n      this.positionedNodes[node.id] = true;\n      this._placeBranchNodes(node.id, level);\n    }\n  }, {\n    key: \"_indexArrayToNodes\",\n    value: function _indexArrayToNodes(idArray) {\n      var array2 = [];\n      for (var i = 0; i < idArray.length; i++) {\n        array2.push(this.body.nodes[idArray[i]]);\n      }\n      return array2;\n    }\n  }, {\n    key: \"_getDistribution\",\n    value: function _getDistribution() {\n      var distribution = {};\n      var nodeId, node;\n      for (nodeId in this.body.nodes) {\n        if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {\n          node = this.body.nodes[nodeId];\n          var level = this.hierarchical.levels[nodeId] === void 0 ? 0 : this.hierarchical.levels[nodeId];\n          this.direction.fix(node, level);\n          if (distribution[level] === void 0) {\n            distribution[level] = {};\n          }\n          distribution[level][nodeId] = node;\n        }\n      }\n      return distribution;\n    }\n  }, {\n    key: \"_getActiveEdges\",\n    value: function _getActiveEdges(node) {\n      var _this4 = this;\n      var result2 = [];\n      forEach$12(node.edges, function(edge) {\n        var _context3;\n        if (indexOf22(_context3 = _this4.body.edgeIndices).call(_context3, edge.id) !== -1) {\n          result2.push(edge);\n        }\n      });\n      return result2;\n    }\n  }, {\n    key: \"_getHubSizes\",\n    value: function _getHubSizes() {\n      var _this5 = this;\n      var hubSizes = {};\n      var nodeIds = this.body.nodeIndices;\n      forEach$12(nodeIds, function(nodeId) {\n        var node = _this5.body.nodes[nodeId];\n        var hubSize = _this5._getActiveEdges(node).length;\n        hubSizes[hubSize] = true;\n      });\n      var result2 = [];\n      forEach$12(hubSizes, function(size) {\n        result2.push(Number(size));\n      });\n      sort22(timsort).call(timsort, result2, function(a, b) {\n        return b - a;\n      });\n      return result2;\n    }\n  }, {\n    key: \"_determineLevelsByHubsize\",\n    value: function _determineLevelsByHubsize() {\n      var _this6 = this;\n      var levelDownstream = function levelDownstream2(nodeA, nodeB) {\n        _this6.hierarchical.levelDownstream(nodeA, nodeB);\n      };\n      var hubSizes = this._getHubSizes();\n      var _loop = function _loop2(i2) {\n        var hubSize = hubSizes[i2];\n        if (hubSize === 0)\n          return \"break\";\n        forEach$12(_this6.body.nodeIndices, function(nodeId) {\n          var node = _this6.body.nodes[nodeId];\n          if (hubSize === _this6._getActiveEdges(node).length) {\n            _this6._crawlNetwork(levelDownstream, nodeId);\n          }\n        });\n      };\n      for (var i = 0; i < hubSizes.length; ++i) {\n        var _ret = _loop(i);\n        if (_ret === \"break\")\n          break;\n      }\n    }\n  }, {\n    key: \"_determineLevelsCustomCallback\",\n    value: function _determineLevelsCustomCallback() {\n      var _this7 = this;\n      var minLevel = 1e5;\n      var customCallback = function customCallback2(nodeA, nodeB, edge) {\n      };\n      var levelByDirection = function levelByDirection2(nodeA, nodeB, edge) {\n        var levelA = _this7.hierarchical.levels[nodeA.id];\n        if (levelA === void 0) {\n          levelA = _this7.hierarchical.levels[nodeA.id] = minLevel;\n        }\n        var diff = customCallback(NetworkUtil.cloneOptions(nodeA, \"node\"), NetworkUtil.cloneOptions(nodeB, \"node\"), NetworkUtil.cloneOptions(edge, \"edge\"));\n        _this7.hierarchical.levels[nodeB.id] = levelA + diff;\n      };\n      this._crawlNetwork(levelByDirection);\n      this.hierarchical.setMinLevelToZero(this.body.nodes);\n    }\n  }, {\n    key: \"_determineLevelsDirected\",\n    value: function _determineLevelsDirected() {\n      var _context4, _this8 = this;\n      var nodes = reduce22(_context4 = this.body.nodeIndices).call(_context4, function(acc, id22) {\n        acc.set(id22, _this8.body.nodes[id22]);\n        return acc;\n      }, new map23());\n      if (this.options.hierarchical.shakeTowards === \"roots\") {\n        this.hierarchical.levels = fillLevelsByDirectionRoots(nodes);\n      } else {\n        this.hierarchical.levels = fillLevelsByDirectionLeaves(nodes);\n      }\n      this.hierarchical.setMinLevelToZero(this.body.nodes);\n    }\n  }, {\n    key: \"_generateMap\",\n    value: function _generateMap() {\n      var _this9 = this;\n      var fillInRelations = function fillInRelations2(parentNode, childNode) {\n        if (_this9.hierarchical.levels[childNode.id] > _this9.hierarchical.levels[parentNode.id]) {\n          _this9.hierarchical.addRelation(parentNode.id, childNode.id);\n        }\n      };\n      this._crawlNetwork(fillInRelations);\n      this.hierarchical.checkIfTree();\n    }\n  }, {\n    key: \"_crawlNetwork\",\n    value: function _crawlNetwork() {\n      var _this10 = this;\n      var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {\n      };\n      var startingNodeId = arguments.length > 1 ? arguments[1] : void 0;\n      var progress = {};\n      var crawler = function crawler2(node2, tree) {\n        if (progress[node2.id] === void 0) {\n          _this10.hierarchical.setTreeIndex(node2, tree);\n          progress[node2.id] = true;\n          var childNode;\n          var edges = _this10._getActiveEdges(node2);\n          for (var i2 = 0; i2 < edges.length; i2++) {\n            var edge = edges[i2];\n            if (edge.connected === true) {\n              if (edge.toId == node2.id) {\n                childNode = edge.from;\n              } else {\n                childNode = edge.to;\n              }\n              if (node2.id != childNode.id) {\n                callback(node2, childNode, edge);\n                crawler2(childNode, tree);\n              }\n            }\n          }\n        }\n      };\n      if (startingNodeId === void 0) {\n        var treeIndex = 0;\n        for (var i = 0; i < this.body.nodeIndices.length; i++) {\n          var nodeId = this.body.nodeIndices[i];\n          if (progress[nodeId] === void 0) {\n            var node = this.body.nodes[nodeId];\n            crawler(node, treeIndex);\n            treeIndex += 1;\n          }\n        }\n      } else {\n        var _node2 = this.body.nodes[startingNodeId];\n        if (_node2 === void 0) {\n          console.error(\"Node not found:\", startingNodeId);\n          return;\n        }\n        crawler(_node2);\n      }\n    }\n  }, {\n    key: \"_shiftBlock\",\n    value: function _shiftBlock(parentId, diff) {\n      var _this11 = this;\n      var progress = {};\n      var shifter = function shifter2(parentId2) {\n        if (progress[parentId2]) {\n          return;\n        }\n        progress[parentId2] = true;\n        _this11.direction.shift(parentId2, diff);\n        var childRef = _this11.hierarchical.childrenReference[parentId2];\n        if (childRef !== void 0) {\n          for (var i = 0; i < childRef.length; i++) {\n            shifter2(childRef[i]);\n          }\n        }\n      };\n      shifter(parentId);\n    }\n  }, {\n    key: \"_findCommonParent\",\n    value: function _findCommonParent(childA, childB) {\n      var _this12 = this;\n      var parents = {};\n      var iterateParents = function iterateParents2(parents2, child) {\n        var parentRef = _this12.hierarchical.parentReference[child];\n        if (parentRef !== void 0) {\n          for (var i = 0; i < parentRef.length; i++) {\n            var parent22 = parentRef[i];\n            parents2[parent22] = true;\n            iterateParents2(parents2, parent22);\n          }\n        }\n      };\n      var findParent = function findParent2(parents2, child) {\n        var parentRef = _this12.hierarchical.parentReference[child];\n        if (parentRef !== void 0) {\n          for (var i = 0; i < parentRef.length; i++) {\n            var parent22 = parentRef[i];\n            if (parents2[parent22] !== void 0) {\n              return {\n                foundParent: parent22,\n                withChild: child\n              };\n            }\n            var branch = findParent2(parents2, parent22);\n            if (branch.foundParent !== null) {\n              return branch;\n            }\n          }\n        }\n        return {\n          foundParent: null,\n          withChild: child\n        };\n      };\n      iterateParents(parents, childA);\n      return findParent(parents, childB);\n    }\n  }, {\n    key: \"setDirectionStrategy\",\n    value: function setDirectionStrategy() {\n      var isVertical = this.options.hierarchical.direction === \"UD\" || this.options.hierarchical.direction === \"DU\";\n      if (isVertical) {\n        this.direction = new VerticalStrategy(this);\n      } else {\n        this.direction = new HorizontalStrategy(this);\n      }\n    }\n  }, {\n    key: \"_getCenterPosition\",\n    value: function _getCenterPosition(childNodes) {\n      var minPos = 1e9;\n      var maxPos = -1e9;\n      for (var i = 0; i < childNodes.length; i++) {\n        var childNode = void 0;\n        if (childNodes[i].id !== void 0) {\n          childNode = childNodes[i];\n        } else {\n          var childNodeId = childNodes[i];\n          childNode = this.body.nodes[childNodeId];\n        }\n        var position = this.direction.getPosition(childNode);\n        minPos = Math.min(minPos, position);\n        maxPos = Math.max(maxPos, position);\n      }\n      return 0.5 * (minPos + maxPos);\n    }\n  }]);\n  return LayoutEngine2;\n}();\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it2 = typeof symbol2 !== \"undefined\" && getIteratorMethod$12(o) || o[\"@@iterator\"];\n  if (!it2) {\n    if (isArray$12(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it2)\n        o = it2;\n      var i = 0;\n      var F2 = function F22() {\n      };\n      return { s: F2, n: function n() {\n        if (i >= o.length)\n          return { done: true };\n        return { done: false, value: o[i++] };\n      }, e: function e(_e3) {\n        throw _e3;\n      }, f: F2 };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true, didErr = false, err;\n  return { s: function s() {\n    it2 = it2.call(o);\n  }, n: function n() {\n    var step = it2.next();\n    normalCompletion = step.done;\n    return step;\n  }, e: function e(_e22) {\n    didErr = true;\n    err = _e22;\n  }, f: function f() {\n    try {\n      if (!normalCompletion && it2.return != null)\n        it2.return();\n    } finally {\n      if (didErr)\n        throw err;\n    }\n  } };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  var _context32;\n  if (!o)\n    return;\n  if (typeof o === \"string\")\n    return _arrayLikeToArray(o, minLen);\n  var n = slice22(_context32 = Object.prototype.toString.call(o)).call(_context32, 8, -1);\n  if (n === \"Object\" && o.constructor)\n    n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\")\n    return from$32(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length)\n    len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar ManipulationSystem = /* @__PURE__ */ function() {\n  function ManipulationSystem2(body, canvas, selectionHandler, interactionHandler) {\n    var _this = this, _context, _context2;\n    _classCallCheck2(this, ManipulationSystem2);\n    this.body = body;\n    this.canvas = canvas;\n    this.selectionHandler = selectionHandler;\n    this.interactionHandler = interactionHandler;\n    this.editMode = false;\n    this.manipulationDiv = void 0;\n    this.editModeDiv = void 0;\n    this.closeDiv = void 0;\n    this._domEventListenerCleanupQueue = [];\n    this.temporaryUIFunctions = {};\n    this.temporaryEventFunctions = [];\n    this.touchTime = 0;\n    this.temporaryIds = {\n      nodes: [],\n      edges: []\n    };\n    this.guiEnabled = false;\n    this.inMode = false;\n    this.selectedControlNode = void 0;\n    this.options = {};\n    this.defaultOptions = {\n      enabled: false,\n      initiallyActive: false,\n      addNode: true,\n      addEdge: true,\n      editNode: void 0,\n      editEdge: true,\n      deleteNode: true,\n      deleteEdge: true,\n      controlNodeStyle: {\n        shape: \"dot\",\n        size: 6,\n        color: {\n          background: \"#ff0000\",\n          border: \"#3c3c3c\",\n          highlight: {\n            background: \"#07f968\",\n            border: \"#3c3c3c\"\n          }\n        },\n        borderWidth: 2,\n        borderWidthSelected: 2\n      }\n    };\n    assign$22(this.options, this.defaultOptions);\n    this.body.emitter.on(\"destroy\", function() {\n      _this._clean();\n    });\n    this.body.emitter.on(\"_dataChanged\", bind$52(_context = this._restore).call(_context, this));\n    this.body.emitter.on(\"_resetData\", bind$52(_context2 = this._restore).call(_context2, this));\n  }\n  _createClass2(ManipulationSystem2, [{\n    key: \"_restore\",\n    value: function _restore() {\n      if (this.inMode !== false) {\n        if (this.options.initiallyActive === true) {\n          this.enableEditMode();\n        } else {\n          this.disableEditMode();\n        }\n      }\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options2, allOptions2, globalOptions) {\n      if (allOptions2 !== void 0) {\n        if (allOptions2.locale !== void 0) {\n          this.options.locale = allOptions2.locale;\n        } else {\n          this.options.locale = globalOptions.locale;\n        }\n        if (allOptions2.locales !== void 0) {\n          this.options.locales = allOptions2.locales;\n        } else {\n          this.options.locales = globalOptions.locales;\n        }\n      }\n      if (options2 !== void 0) {\n        if (typeof options2 === \"boolean\") {\n          this.options.enabled = options2;\n        } else {\n          this.options.enabled = true;\n          deepExtend(this.options, options2);\n        }\n        if (this.options.initiallyActive === true) {\n          this.editMode = true;\n        }\n        this._setup();\n      }\n    }\n  }, {\n    key: \"toggleEditMode\",\n    value: function toggleEditMode() {\n      if (this.editMode === true) {\n        this.disableEditMode();\n      } else {\n        this.enableEditMode();\n      }\n    }\n  }, {\n    key: \"enableEditMode\",\n    value: function enableEditMode() {\n      this.editMode = true;\n      this._clean();\n      if (this.guiEnabled === true) {\n        this.manipulationDiv.style.display = \"block\";\n        this.closeDiv.style.display = \"block\";\n        this.editModeDiv.style.display = \"none\";\n        this.showManipulatorToolbar();\n      }\n    }\n  }, {\n    key: \"disableEditMode\",\n    value: function disableEditMode() {\n      this.editMode = false;\n      this._clean();\n      if (this.guiEnabled === true) {\n        this.manipulationDiv.style.display = \"none\";\n        this.closeDiv.style.display = \"none\";\n        this.editModeDiv.style.display = \"block\";\n        this._createEditButton();\n      }\n    }\n  }, {\n    key: \"showManipulatorToolbar\",\n    value: function showManipulatorToolbar() {\n      this._clean();\n      this.manipulationDOM = {};\n      if (this.guiEnabled === true) {\n        var _context3, _context4;\n        this.editMode = true;\n        this.manipulationDiv.style.display = \"block\";\n        this.closeDiv.style.display = \"block\";\n        var selectedNodeCount = this.selectionHandler.getSelectedNodeCount();\n        var selectedEdgeCount = this.selectionHandler.getSelectedEdgeCount();\n        var selectedTotalCount = selectedNodeCount + selectedEdgeCount;\n        var locale = this.options.locales[this.options.locale];\n        var needSeperator = false;\n        if (this.options.addNode !== false) {\n          this._createAddNodeButton(locale);\n          needSeperator = true;\n        }\n        if (this.options.addEdge !== false) {\n          if (needSeperator === true) {\n            this._createSeperator(1);\n          } else {\n            needSeperator = true;\n          }\n          this._createAddEdgeButton(locale);\n        }\n        if (selectedNodeCount === 1 && typeof this.options.editNode === \"function\") {\n          if (needSeperator === true) {\n            this._createSeperator(2);\n          } else {\n            needSeperator = true;\n          }\n          this._createEditNodeButton(locale);\n        } else if (selectedEdgeCount === 1 && selectedNodeCount === 0 && this.options.editEdge !== false) {\n          if (needSeperator === true) {\n            this._createSeperator(3);\n          } else {\n            needSeperator = true;\n          }\n          this._createEditEdgeButton(locale);\n        }\n        if (selectedTotalCount !== 0) {\n          if (selectedNodeCount > 0 && this.options.deleteNode !== false) {\n            if (needSeperator === true) {\n              this._createSeperator(4);\n            }\n            this._createDeleteButton(locale);\n          } else if (selectedNodeCount === 0 && this.options.deleteEdge !== false) {\n            if (needSeperator === true) {\n              this._createSeperator(4);\n            }\n            this._createDeleteButton(locale);\n          }\n        }\n        this._bindElementEvents(this.closeDiv, bind$52(_context3 = this.toggleEditMode).call(_context3, this));\n        this._temporaryBindEvent(\"select\", bind$52(_context4 = this.showManipulatorToolbar).call(_context4, this));\n      }\n      this.body.emitter.emit(\"_redraw\");\n    }\n  }, {\n    key: \"addNodeMode\",\n    value: function addNodeMode() {\n      var _context6;\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n      this._clean();\n      this.inMode = \"addNode\";\n      if (this.guiEnabled === true) {\n        var _context5;\n        var locale = this.options.locales[this.options.locale];\n        this.manipulationDOM = {};\n        this._createBackButton(locale);\n        this._createSeperator();\n        this._createDescription(locale[\"addDescription\"] || this.options.locales[\"en\"][\"addDescription\"]);\n        this._bindElementEvents(this.closeDiv, bind$52(_context5 = this.toggleEditMode).call(_context5, this));\n      }\n      this._temporaryBindEvent(\"click\", bind$52(_context6 = this._performAddNode).call(_context6, this));\n    }\n  }, {\n    key: \"editNode\",\n    value: function editNode() {\n      var _this2 = this;\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n      this._clean();\n      var node = this.selectionHandler.getSelectedNodes()[0];\n      if (node !== void 0) {\n        this.inMode = \"editNode\";\n        if (typeof this.options.editNode === \"function\") {\n          if (node.isCluster !== true) {\n            var data22 = deepExtend({}, node.options, false);\n            data22.x = node.x;\n            data22.y = node.y;\n            if (this.options.editNode.length === 2) {\n              this.options.editNode(data22, function(finalizedData) {\n                if (finalizedData !== null && finalizedData !== void 0 && _this2.inMode === \"editNode\") {\n                  _this2.body.data.nodes.getDataSet().update(finalizedData);\n                }\n                _this2.showManipulatorToolbar();\n              });\n            } else {\n              throw new Error(\"The function for edit does not support two arguments (data, callback)\");\n            }\n          } else {\n            alert(this.options.locales[this.options.locale][\"editClusterError\"] || this.options.locales[\"en\"][\"editClusterError\"]);\n          }\n        } else {\n          throw new Error(\"No function has been configured to handle the editing of nodes.\");\n        }\n      } else {\n        this.showManipulatorToolbar();\n      }\n    }\n  }, {\n    key: \"addEdgeMode\",\n    value: function addEdgeMode() {\n      var _context8, _context9, _context10, _context11, _context12;\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n      this._clean();\n      this.inMode = \"addEdge\";\n      if (this.guiEnabled === true) {\n        var _context7;\n        var locale = this.options.locales[this.options.locale];\n        this.manipulationDOM = {};\n        this._createBackButton(locale);\n        this._createSeperator();\n        this._createDescription(locale[\"edgeDescription\"] || this.options.locales[\"en\"][\"edgeDescription\"]);\n        this._bindElementEvents(this.closeDiv, bind$52(_context7 = this.toggleEditMode).call(_context7, this));\n      }\n      this._temporaryBindUI(\"onTouch\", bind$52(_context8 = this._handleConnect).call(_context8, this));\n      this._temporaryBindUI(\"onDragEnd\", bind$52(_context9 = this._finishConnect).call(_context9, this));\n      this._temporaryBindUI(\"onDrag\", bind$52(_context10 = this._dragControlNode).call(_context10, this));\n      this._temporaryBindUI(\"onRelease\", bind$52(_context11 = this._finishConnect).call(_context11, this));\n      this._temporaryBindUI(\"onDragStart\", bind$52(_context12 = this._dragStartEdge).call(_context12, this));\n      this._temporaryBindUI(\"onHold\", function() {\n      });\n    }\n  }, {\n    key: \"editEdgeMode\",\n    value: function editEdgeMode() {\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n      this._clean();\n      this.inMode = \"editEdge\";\n      if (_typeof2(this.options.editEdge) === \"object\" && typeof this.options.editEdge.editWithoutDrag === \"function\") {\n        this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0];\n        if (this.edgeBeingEditedId !== void 0) {\n          var edge = this.body.edges[this.edgeBeingEditedId];\n          this._performEditEdge(edge.from.id, edge.to.id);\n          return;\n        }\n      }\n      if (this.guiEnabled === true) {\n        var _context13;\n        var locale = this.options.locales[this.options.locale];\n        this.manipulationDOM = {};\n        this._createBackButton(locale);\n        this._createSeperator();\n        this._createDescription(locale[\"editEdgeDescription\"] || this.options.locales[\"en\"][\"editEdgeDescription\"]);\n        this._bindElementEvents(this.closeDiv, bind$52(_context13 = this.toggleEditMode).call(_context13, this));\n      }\n      this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0];\n      if (this.edgeBeingEditedId !== void 0) {\n        var _context14, _context15, _context16, _context17;\n        var _edge = this.body.edges[this.edgeBeingEditedId];\n        var controlNodeFrom = this._getNewTargetNode(_edge.from.x, _edge.from.y);\n        var controlNodeTo = this._getNewTargetNode(_edge.to.x, _edge.to.y);\n        this.temporaryIds.nodes.push(controlNodeFrom.id);\n        this.temporaryIds.nodes.push(controlNodeTo.id);\n        this.body.nodes[controlNodeFrom.id] = controlNodeFrom;\n        this.body.nodeIndices.push(controlNodeFrom.id);\n        this.body.nodes[controlNodeTo.id] = controlNodeTo;\n        this.body.nodeIndices.push(controlNodeTo.id);\n        this._temporaryBindUI(\"onTouch\", bind$52(_context14 = this._controlNodeTouch).call(_context14, this));\n        this._temporaryBindUI(\"onTap\", function() {\n        });\n        this._temporaryBindUI(\"onHold\", function() {\n        });\n        this._temporaryBindUI(\"onDragStart\", bind$52(_context15 = this._controlNodeDragStart).call(_context15, this));\n        this._temporaryBindUI(\"onDrag\", bind$52(_context16 = this._controlNodeDrag).call(_context16, this));\n        this._temporaryBindUI(\"onDragEnd\", bind$52(_context17 = this._controlNodeDragEnd).call(_context17, this));\n        this._temporaryBindUI(\"onMouseMove\", function() {\n        });\n        this._temporaryBindEvent(\"beforeDrawing\", function(ctx) {\n          var positions = _edge.edgeType.findBorderPositions(ctx);\n          if (controlNodeFrom.selected === false) {\n            controlNodeFrom.x = positions.from.x;\n            controlNodeFrom.y = positions.from.y;\n          }\n          if (controlNodeTo.selected === false) {\n            controlNodeTo.x = positions.to.x;\n            controlNodeTo.y = positions.to.y;\n          }\n        });\n        this.body.emitter.emit(\"_redraw\");\n      } else {\n        this.showManipulatorToolbar();\n      }\n    }\n  }, {\n    key: \"deleteSelected\",\n    value: function deleteSelected() {\n      var _this3 = this;\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n      this._clean();\n      this.inMode = \"delete\";\n      var selectedNodes = this.selectionHandler.getSelectedNodeIds();\n      var selectedEdges = this.selectionHandler.getSelectedEdgeIds();\n      var deleteFunction = void 0;\n      if (selectedNodes.length > 0) {\n        for (var i = 0; i < selectedNodes.length; i++) {\n          if (this.body.nodes[selectedNodes[i]].isCluster === true) {\n            alert(this.options.locales[this.options.locale][\"deleteClusterError\"] || this.options.locales[\"en\"][\"deleteClusterError\"]);\n            return;\n          }\n        }\n        if (typeof this.options.deleteNode === \"function\") {\n          deleteFunction = this.options.deleteNode;\n        }\n      } else if (selectedEdges.length > 0) {\n        if (typeof this.options.deleteEdge === \"function\") {\n          deleteFunction = this.options.deleteEdge;\n        }\n      }\n      if (typeof deleteFunction === \"function\") {\n        var data22 = {\n          nodes: selectedNodes,\n          edges: selectedEdges\n        };\n        if (deleteFunction.length === 2) {\n          deleteFunction(data22, function(finalizedData) {\n            if (finalizedData !== null && finalizedData !== void 0 && _this3.inMode === \"delete\") {\n              _this3.body.data.edges.getDataSet().remove(finalizedData.edges);\n              _this3.body.data.nodes.getDataSet().remove(finalizedData.nodes);\n              _this3.body.emitter.emit(\"startSimulation\");\n              _this3.showManipulatorToolbar();\n            } else {\n              _this3.body.emitter.emit(\"startSimulation\");\n              _this3.showManipulatorToolbar();\n            }\n          });\n        } else {\n          throw new Error(\"The function for delete does not support two arguments (data, callback)\");\n        }\n      } else {\n        this.body.data.edges.getDataSet().remove(selectedEdges);\n        this.body.data.nodes.getDataSet().remove(selectedNodes);\n        this.body.emitter.emit(\"startSimulation\");\n        this.showManipulatorToolbar();\n      }\n    }\n  }, {\n    key: \"_setup\",\n    value: function _setup() {\n      if (this.options.enabled === true) {\n        this.guiEnabled = true;\n        this._createWrappers();\n        if (this.editMode === false) {\n          this._createEditButton();\n        } else {\n          this.showManipulatorToolbar();\n        }\n      } else {\n        this._removeManipulationDOM();\n        this.guiEnabled = false;\n      }\n    }\n  }, {\n    key: \"_createWrappers\",\n    value: function _createWrappers() {\n      if (this.manipulationDiv === void 0) {\n        this.manipulationDiv = document.createElement(\"div\");\n        this.manipulationDiv.className = \"vis-manipulation\";\n        if (this.editMode === true) {\n          this.manipulationDiv.style.display = \"block\";\n        } else {\n          this.manipulationDiv.style.display = \"none\";\n        }\n        this.canvas.frame.appendChild(this.manipulationDiv);\n      }\n      if (this.editModeDiv === void 0) {\n        this.editModeDiv = document.createElement(\"div\");\n        this.editModeDiv.className = \"vis-edit-mode\";\n        if (this.editMode === true) {\n          this.editModeDiv.style.display = \"none\";\n        } else {\n          this.editModeDiv.style.display = \"block\";\n        }\n        this.canvas.frame.appendChild(this.editModeDiv);\n      }\n      if (this.closeDiv === void 0) {\n        var _this$options$locales, _this$options$locales2;\n        this.closeDiv = document.createElement(\"button\");\n        this.closeDiv.className = \"vis-close\";\n        this.closeDiv.setAttribute(\"aria-label\", (_this$options$locales = (_this$options$locales2 = this.options.locales[this.options.locale]) === null || _this$options$locales2 === void 0 ? void 0 : _this$options$locales2[\"close\"]) !== null && _this$options$locales !== void 0 ? _this$options$locales : this.options.locales[\"en\"][\"close\"]);\n        this.closeDiv.style.display = this.manipulationDiv.style.display;\n        this.canvas.frame.appendChild(this.closeDiv);\n      }\n    }\n  }, {\n    key: \"_getNewTargetNode\",\n    value: function _getNewTargetNode(x, y) {\n      var controlNodeStyle = deepExtend({}, this.options.controlNodeStyle);\n      controlNodeStyle.id = \"targetNode\" + v42();\n      controlNodeStyle.hidden = false;\n      controlNodeStyle.physics = false;\n      controlNodeStyle.x = x;\n      controlNodeStyle.y = y;\n      var node = this.body.functions.createNode(controlNodeStyle);\n      node.shape.boundingBox = {\n        left: x,\n        right: x,\n        top: y,\n        bottom: y\n      };\n      return node;\n    }\n  }, {\n    key: \"_createEditButton\",\n    value: function _createEditButton() {\n      var _context18;\n      this._clean();\n      this.manipulationDOM = {};\n      recursiveDOMDelete(this.editModeDiv);\n      var locale = this.options.locales[this.options.locale];\n      var button = this._createButton(\"editMode\", \"vis-edit vis-edit-mode\", locale[\"edit\"] || this.options.locales[\"en\"][\"edit\"]);\n      this.editModeDiv.appendChild(button);\n      this._bindElementEvents(button, bind$52(_context18 = this.toggleEditMode).call(_context18, this));\n    }\n  }, {\n    key: \"_clean\",\n    value: function _clean() {\n      this.inMode = false;\n      if (this.guiEnabled === true) {\n        recursiveDOMDelete(this.editModeDiv);\n        recursiveDOMDelete(this.manipulationDiv);\n        this._cleanupDOMEventListeners();\n      }\n      this._cleanupTemporaryNodesAndEdges();\n      this._unbindTemporaryUIs();\n      this._unbindTemporaryEvents();\n      this.body.emitter.emit(\"restorePhysics\");\n    }\n  }, {\n    key: \"_cleanupDOMEventListeners\",\n    value: function _cleanupDOMEventListeners() {\n      var _context19;\n      var _iterator = _createForOfIteratorHelper(splice$12(_context19 = this._domEventListenerCleanupQueue).call(_context19, 0)), _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done; ) {\n          var callback = _step.value;\n          callback();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"_removeManipulationDOM\",\n    value: function _removeManipulationDOM() {\n      this._clean();\n      recursiveDOMDelete(this.manipulationDiv);\n      recursiveDOMDelete(this.editModeDiv);\n      recursiveDOMDelete(this.closeDiv);\n      if (this.manipulationDiv) {\n        this.canvas.frame.removeChild(this.manipulationDiv);\n      }\n      if (this.editModeDiv) {\n        this.canvas.frame.removeChild(this.editModeDiv);\n      }\n      if (this.closeDiv) {\n        this.canvas.frame.removeChild(this.closeDiv);\n      }\n      this.manipulationDiv = void 0;\n      this.editModeDiv = void 0;\n      this.closeDiv = void 0;\n    }\n  }, {\n    key: \"_createSeperator\",\n    value: function _createSeperator() {\n      var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;\n      this.manipulationDOM[\"seperatorLineDiv\" + index2] = document.createElement(\"div\");\n      this.manipulationDOM[\"seperatorLineDiv\" + index2].className = \"vis-separator-line\";\n      this.manipulationDiv.appendChild(this.manipulationDOM[\"seperatorLineDiv\" + index2]);\n    }\n  }, {\n    key: \"_createAddNodeButton\",\n    value: function _createAddNodeButton(locale) {\n      var _context20;\n      var button = this._createButton(\"addNode\", \"vis-add\", locale[\"addNode\"] || this.options.locales[\"en\"][\"addNode\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, bind$52(_context20 = this.addNodeMode).call(_context20, this));\n    }\n  }, {\n    key: \"_createAddEdgeButton\",\n    value: function _createAddEdgeButton(locale) {\n      var _context21;\n      var button = this._createButton(\"addEdge\", \"vis-connect\", locale[\"addEdge\"] || this.options.locales[\"en\"][\"addEdge\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, bind$52(_context21 = this.addEdgeMode).call(_context21, this));\n    }\n  }, {\n    key: \"_createEditNodeButton\",\n    value: function _createEditNodeButton(locale) {\n      var _context22;\n      var button = this._createButton(\"editNode\", \"vis-edit\", locale[\"editNode\"] || this.options.locales[\"en\"][\"editNode\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, bind$52(_context22 = this.editNode).call(_context22, this));\n    }\n  }, {\n    key: \"_createEditEdgeButton\",\n    value: function _createEditEdgeButton(locale) {\n      var _context23;\n      var button = this._createButton(\"editEdge\", \"vis-edit\", locale[\"editEdge\"] || this.options.locales[\"en\"][\"editEdge\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, bind$52(_context23 = this.editEdgeMode).call(_context23, this));\n    }\n  }, {\n    key: \"_createDeleteButton\",\n    value: function _createDeleteButton(locale) {\n      var _context24;\n      var deleteBtnClass;\n      if (this.options.rtl) {\n        deleteBtnClass = \"vis-delete-rtl\";\n      } else {\n        deleteBtnClass = \"vis-delete\";\n      }\n      var button = this._createButton(\"delete\", deleteBtnClass, locale[\"del\"] || this.options.locales[\"en\"][\"del\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, bind$52(_context24 = this.deleteSelected).call(_context24, this));\n    }\n  }, {\n    key: \"_createBackButton\",\n    value: function _createBackButton(locale) {\n      var _context25;\n      var button = this._createButton(\"back\", \"vis-back\", locale[\"back\"] || this.options.locales[\"en\"][\"back\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, bind$52(_context25 = this.showManipulatorToolbar).call(_context25, this));\n    }\n  }, {\n    key: \"_createButton\",\n    value: function _createButton(id22, className, label) {\n      var labelClassName = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"vis-label\";\n      this.manipulationDOM[id22 + \"Div\"] = document.createElement(\"button\");\n      this.manipulationDOM[id22 + \"Div\"].className = \"vis-button \" + className;\n      this.manipulationDOM[id22 + \"Label\"] = document.createElement(\"div\");\n      this.manipulationDOM[id22 + \"Label\"].className = labelClassName;\n      this.manipulationDOM[id22 + \"Label\"].innerText = label;\n      this.manipulationDOM[id22 + \"Div\"].appendChild(this.manipulationDOM[id22 + \"Label\"]);\n      return this.manipulationDOM[id22 + \"Div\"];\n    }\n  }, {\n    key: \"_createDescription\",\n    value: function _createDescription(label) {\n      this.manipulationDOM[\"descriptionLabel\"] = document.createElement(\"div\");\n      this.manipulationDOM[\"descriptionLabel\"].className = \"vis-none\";\n      this.manipulationDOM[\"descriptionLabel\"].innerText = label;\n      this.manipulationDiv.appendChild(this.manipulationDOM[\"descriptionLabel\"]);\n    }\n  }, {\n    key: \"_temporaryBindEvent\",\n    value: function _temporaryBindEvent(event, newFunction) {\n      this.temporaryEventFunctions.push({\n        event,\n        boundFunction: newFunction\n      });\n      this.body.emitter.on(event, newFunction);\n    }\n  }, {\n    key: \"_temporaryBindUI\",\n    value: function _temporaryBindUI(UIfunctionName, newFunction) {\n      if (this.body.eventListeners[UIfunctionName] !== void 0) {\n        this.temporaryUIFunctions[UIfunctionName] = this.body.eventListeners[UIfunctionName];\n        this.body.eventListeners[UIfunctionName] = newFunction;\n      } else {\n        throw new Error(\"This UI function does not exist. Typo? You tried: \" + UIfunctionName + \" possible are: \" + stringify$12(keys32(this.body.eventListeners)));\n      }\n    }\n  }, {\n    key: \"_unbindTemporaryUIs\",\n    value: function _unbindTemporaryUIs() {\n      for (var functionName22 in this.temporaryUIFunctions) {\n        if (Object.prototype.hasOwnProperty.call(this.temporaryUIFunctions, functionName22)) {\n          this.body.eventListeners[functionName22] = this.temporaryUIFunctions[functionName22];\n          delete this.temporaryUIFunctions[functionName22];\n        }\n      }\n      this.temporaryUIFunctions = {};\n    }\n  }, {\n    key: \"_unbindTemporaryEvents\",\n    value: function _unbindTemporaryEvents() {\n      for (var i = 0; i < this.temporaryEventFunctions.length; i++) {\n        var eventName = this.temporaryEventFunctions[i].event;\n        var boundFunction = this.temporaryEventFunctions[i].boundFunction;\n        this.body.emitter.off(eventName, boundFunction);\n      }\n      this.temporaryEventFunctions = [];\n    }\n  }, {\n    key: \"_bindElementEvents\",\n    value: function _bindElementEvents(domElement, boundFunction) {\n      var hammer = new Hammer2(domElement, {});\n      onTouch(hammer, boundFunction);\n      this._domEventListenerCleanupQueue.push(function() {\n        hammer.destroy();\n      });\n      var keyupListener = function keyupListener2(_ref) {\n        var keyCode = _ref.keyCode, key = _ref.key;\n        if (key === \"Enter\" || key === \" \" || keyCode === 13 || keyCode === 32) {\n          boundFunction();\n        }\n      };\n      domElement.addEventListener(\"keyup\", keyupListener, false);\n      this._domEventListenerCleanupQueue.push(function() {\n        domElement.removeEventListener(\"keyup\", keyupListener, false);\n      });\n    }\n  }, {\n    key: \"_cleanupTemporaryNodesAndEdges\",\n    value: function _cleanupTemporaryNodesAndEdges() {\n      for (var i = 0; i < this.temporaryIds.edges.length; i++) {\n        var _context26;\n        this.body.edges[this.temporaryIds.edges[i]].disconnect();\n        delete this.body.edges[this.temporaryIds.edges[i]];\n        var indexTempEdge = indexOf22(_context26 = this.body.edgeIndices).call(_context26, this.temporaryIds.edges[i]);\n        if (indexTempEdge !== -1) {\n          var _context27;\n          splice$12(_context27 = this.body.edgeIndices).call(_context27, indexTempEdge, 1);\n        }\n      }\n      for (var _i = 0; _i < this.temporaryIds.nodes.length; _i++) {\n        var _context28;\n        delete this.body.nodes[this.temporaryIds.nodes[_i]];\n        var indexTempNode = indexOf22(_context28 = this.body.nodeIndices).call(_context28, this.temporaryIds.nodes[_i]);\n        if (indexTempNode !== -1) {\n          var _context29;\n          splice$12(_context29 = this.body.nodeIndices).call(_context29, indexTempNode, 1);\n        }\n      }\n      this.temporaryIds = {\n        nodes: [],\n        edges: []\n      };\n    }\n  }, {\n    key: \"_controlNodeTouch\",\n    value: function _controlNodeTouch(event) {\n      this.selectionHandler.unselectAll();\n      this.lastTouch = this.body.functions.getPointer(event.center);\n      this.lastTouch.translation = assign$22({}, this.body.view.translation);\n    }\n  }, {\n    key: \"_controlNodeDragStart\",\n    value: function _controlNodeDragStart() {\n      var pointer = this.lastTouch;\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n      var from32 = this.body.nodes[this.temporaryIds.nodes[0]];\n      var to = this.body.nodes[this.temporaryIds.nodes[1]];\n      var edge = this.body.edges[this.edgeBeingEditedId];\n      this.selectedControlNode = void 0;\n      var fromSelect = from32.isOverlappingWith(pointerObj);\n      var toSelect = to.isOverlappingWith(pointerObj);\n      if (fromSelect === true) {\n        this.selectedControlNode = from32;\n        edge.edgeType.from = from32;\n      } else if (toSelect === true) {\n        this.selectedControlNode = to;\n        edge.edgeType.to = to;\n      }\n      if (this.selectedControlNode !== void 0) {\n        this.selectionHandler.selectObject(this.selectedControlNode);\n      }\n      this.body.emitter.emit(\"_redraw\");\n    }\n  }, {\n    key: \"_controlNodeDrag\",\n    value: function _controlNodeDrag(event) {\n      this.body.emitter.emit(\"disablePhysics\");\n      var pointer = this.body.functions.getPointer(event.center);\n      var pos = this.canvas.DOMtoCanvas(pointer);\n      if (this.selectedControlNode !== void 0) {\n        this.selectedControlNode.x = pos.x;\n        this.selectedControlNode.y = pos.y;\n      } else {\n        this.interactionHandler.onDrag(event);\n      }\n      this.body.emitter.emit(\"_redraw\");\n    }\n  }, {\n    key: \"_controlNodeDragEnd\",\n    value: function _controlNodeDragEnd(event) {\n      var pointer = this.body.functions.getPointer(event.center);\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n      var edge = this.body.edges[this.edgeBeingEditedId];\n      if (this.selectedControlNode === void 0) {\n        return;\n      }\n      this.selectionHandler.unselectAll();\n      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);\n      var node = void 0;\n      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {\n        if (overlappingNodeIds[i] !== this.selectedControlNode.id) {\n          node = this.body.nodes[overlappingNodeIds[i]];\n          break;\n        }\n      }\n      if (node !== void 0 && this.selectedControlNode !== void 0) {\n        if (node.isCluster === true) {\n          alert(this.options.locales[this.options.locale][\"createEdgeError\"] || this.options.locales[\"en\"][\"createEdgeError\"]);\n        } else {\n          var from32 = this.body.nodes[this.temporaryIds.nodes[0]];\n          if (this.selectedControlNode.id === from32.id) {\n            this._performEditEdge(node.id, edge.to.id);\n          } else {\n            this._performEditEdge(edge.from.id, node.id);\n          }\n        }\n      } else {\n        edge.updateEdgeType();\n        this.body.emitter.emit(\"restorePhysics\");\n      }\n      this.body.emitter.emit(\"_redraw\");\n    }\n  }, {\n    key: \"_handleConnect\",\n    value: function _handleConnect(event) {\n      if (new Date().valueOf() - this.touchTime > 100) {\n        this.lastTouch = this.body.functions.getPointer(event.center);\n        this.lastTouch.translation = assign$22({}, this.body.view.translation);\n        this.interactionHandler.drag.pointer = this.lastTouch;\n        this.interactionHandler.drag.translation = this.lastTouch.translation;\n        var pointer = this.lastTouch;\n        var node = this.selectionHandler.getNodeAt(pointer);\n        if (node !== void 0) {\n          if (node.isCluster === true) {\n            alert(this.options.locales[this.options.locale][\"createEdgeError\"] || this.options.locales[\"en\"][\"createEdgeError\"]);\n          } else {\n            var targetNode = this._getNewTargetNode(node.x, node.y);\n            this.body.nodes[targetNode.id] = targetNode;\n            this.body.nodeIndices.push(targetNode.id);\n            var connectionEdge = this.body.functions.createEdge({\n              id: \"connectionEdge\" + v42(),\n              from: node.id,\n              to: targetNode.id,\n              physics: false,\n              smooth: {\n                enabled: true,\n                type: \"continuous\",\n                roundness: 0.5\n              }\n            });\n            this.body.edges[connectionEdge.id] = connectionEdge;\n            this.body.edgeIndices.push(connectionEdge.id);\n            this.temporaryIds.nodes.push(targetNode.id);\n            this.temporaryIds.edges.push(connectionEdge.id);\n          }\n        }\n        this.touchTime = new Date().valueOf();\n      }\n    }\n  }, {\n    key: \"_dragControlNode\",\n    value: function _dragControlNode(event) {\n      var pointer = this.body.functions.getPointer(event.center);\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n      var connectFromId = void 0;\n      if (this.temporaryIds.edges[0] !== void 0) {\n        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;\n      }\n      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);\n      var node = void 0;\n      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {\n        var _context30;\n        if (indexOf22(_context30 = this.temporaryIds.nodes).call(_context30, overlappingNodeIds[i]) === -1) {\n          node = this.body.nodes[overlappingNodeIds[i]];\n          break;\n        }\n      }\n      event.controlEdge = {\n        from: connectFromId,\n        to: node ? node.id : void 0\n      };\n      this.selectionHandler.generateClickEvent(\"controlNodeDragging\", event, pointer);\n      if (this.temporaryIds.nodes[0] !== void 0) {\n        var targetNode = this.body.nodes[this.temporaryIds.nodes[0]];\n        targetNode.x = this.canvas._XconvertDOMtoCanvas(pointer.x);\n        targetNode.y = this.canvas._YconvertDOMtoCanvas(pointer.y);\n        this.body.emitter.emit(\"_redraw\");\n      } else {\n        this.interactionHandler.onDrag(event);\n      }\n    }\n  }, {\n    key: \"_finishConnect\",\n    value: function _finishConnect(event) {\n      var pointer = this.body.functions.getPointer(event.center);\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n      var connectFromId = void 0;\n      if (this.temporaryIds.edges[0] !== void 0) {\n        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;\n      }\n      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);\n      var node = void 0;\n      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {\n        var _context31;\n        if (indexOf22(_context31 = this.temporaryIds.nodes).call(_context31, overlappingNodeIds[i]) === -1) {\n          node = this.body.nodes[overlappingNodeIds[i]];\n          break;\n        }\n      }\n      this._cleanupTemporaryNodesAndEdges();\n      if (node !== void 0) {\n        if (node.isCluster === true) {\n          alert(this.options.locales[this.options.locale][\"createEdgeError\"] || this.options.locales[\"en\"][\"createEdgeError\"]);\n        } else {\n          if (this.body.nodes[connectFromId] !== void 0 && this.body.nodes[node.id] !== void 0) {\n            this._performAddEdge(connectFromId, node.id);\n          }\n        }\n      }\n      event.controlEdge = {\n        from: connectFromId,\n        to: node ? node.id : void 0\n      };\n      this.selectionHandler.generateClickEvent(\"controlNodeDragEnd\", event, pointer);\n      this.body.emitter.emit(\"_redraw\");\n    }\n  }, {\n    key: \"_dragStartEdge\",\n    value: function _dragStartEdge(event) {\n      var pointer = this.lastTouch;\n      this.selectionHandler.generateClickEvent(\"dragStart\", event, pointer, void 0, true);\n    }\n  }, {\n    key: \"_performAddNode\",\n    value: function _performAddNode(clickData) {\n      var _this4 = this;\n      var defaultData = {\n        id: v42(),\n        x: clickData.pointer.canvas.x,\n        y: clickData.pointer.canvas.y,\n        label: \"new\"\n      };\n      if (typeof this.options.addNode === \"function\") {\n        if (this.options.addNode.length === 2) {\n          this.options.addNode(defaultData, function(finalizedData) {\n            if (finalizedData !== null && finalizedData !== void 0 && _this4.inMode === \"addNode\") {\n              _this4.body.data.nodes.getDataSet().add(finalizedData);\n            }\n            _this4.showManipulatorToolbar();\n          });\n        } else {\n          this.showManipulatorToolbar();\n          throw new Error(\"The function for add does not support two arguments (data,callback)\");\n        }\n      } else {\n        this.body.data.nodes.getDataSet().add(defaultData);\n        this.showManipulatorToolbar();\n      }\n    }\n  }, {\n    key: \"_performAddEdge\",\n    value: function _performAddEdge(sourceNodeId, targetNodeId) {\n      var _this5 = this;\n      var defaultData = {\n        from: sourceNodeId,\n        to: targetNodeId\n      };\n      if (typeof this.options.addEdge === \"function\") {\n        if (this.options.addEdge.length === 2) {\n          this.options.addEdge(defaultData, function(finalizedData) {\n            if (finalizedData !== null && finalizedData !== void 0 && _this5.inMode === \"addEdge\") {\n              _this5.body.data.edges.getDataSet().add(finalizedData);\n              _this5.selectionHandler.unselectAll();\n              _this5.showManipulatorToolbar();\n            }\n          });\n        } else {\n          throw new Error(\"The function for connect does not support two arguments (data,callback)\");\n        }\n      } else {\n        this.body.data.edges.getDataSet().add(defaultData);\n        this.selectionHandler.unselectAll();\n        this.showManipulatorToolbar();\n      }\n    }\n  }, {\n    key: \"_performEditEdge\",\n    value: function _performEditEdge(sourceNodeId, targetNodeId) {\n      var _this6 = this;\n      var defaultData = {\n        id: this.edgeBeingEditedId,\n        from: sourceNodeId,\n        to: targetNodeId,\n        label: this.body.data.edges.get(this.edgeBeingEditedId).label\n      };\n      var eeFunct = this.options.editEdge;\n      if (_typeof2(eeFunct) === \"object\") {\n        eeFunct = eeFunct.editWithoutDrag;\n      }\n      if (typeof eeFunct === \"function\") {\n        if (eeFunct.length === 2) {\n          eeFunct(defaultData, function(finalizedData) {\n            if (finalizedData === null || finalizedData === void 0 || _this6.inMode !== \"editEdge\") {\n              _this6.body.edges[defaultData.id].updateEdgeType();\n              _this6.body.emitter.emit(\"_redraw\");\n              _this6.showManipulatorToolbar();\n            } else {\n              _this6.body.data.edges.getDataSet().update(finalizedData);\n              _this6.selectionHandler.unselectAll();\n              _this6.showManipulatorToolbar();\n            }\n          });\n        } else {\n          throw new Error(\"The function for edit does not support two arguments (data, callback)\");\n        }\n      } else {\n        this.body.data.edges.getDataSet().update(defaultData);\n        this.selectionHandler.unselectAll();\n        this.showManipulatorToolbar();\n      }\n    }\n  }]);\n  return ManipulationSystem2;\n}();\nvar string2 = \"string\";\nvar bool2 = \"boolean\";\nvar number2 = \"number\";\nvar array = \"array\";\nvar object = \"object\";\nvar dom = \"dom\";\nvar any = \"any\";\nvar endPoints = [\"arrow\", \"bar\", \"box\", \"circle\", \"crow\", \"curve\", \"diamond\", \"image\", \"inv_curve\", \"inv_triangle\", \"triangle\", \"vee\"];\nvar nodeOptions = {\n  borderWidth: {\n    number: number2\n  },\n  borderWidthSelected: {\n    number: number2,\n    undefined: \"undefined\"\n  },\n  brokenImage: {\n    string: string2,\n    undefined: \"undefined\"\n  },\n  chosen: {\n    label: {\n      boolean: bool2,\n      function: \"function\"\n    },\n    node: {\n      boolean: bool2,\n      function: \"function\"\n    },\n    __type__: {\n      object,\n      boolean: bool2\n    }\n  },\n  color: {\n    border: {\n      string: string2\n    },\n    background: {\n      string: string2\n    },\n    highlight: {\n      border: {\n        string: string2\n      },\n      background: {\n        string: string2\n      },\n      __type__: {\n        object,\n        string: string2\n      }\n    },\n    hover: {\n      border: {\n        string: string2\n      },\n      background: {\n        string: string2\n      },\n      __type__: {\n        object,\n        string: string2\n      }\n    },\n    __type__: {\n      object,\n      string: string2\n    }\n  },\n  opacity: {\n    number: number2,\n    undefined: \"undefined\"\n  },\n  fixed: {\n    x: {\n      boolean: bool2\n    },\n    y: {\n      boolean: bool2\n    },\n    __type__: {\n      object,\n      boolean: bool2\n    }\n  },\n  font: {\n    align: {\n      string: string2\n    },\n    color: {\n      string: string2\n    },\n    size: {\n      number: number2\n    },\n    face: {\n      string: string2\n    },\n    background: {\n      string: string2\n    },\n    strokeWidth: {\n      number: number2\n    },\n    strokeColor: {\n      string: string2\n    },\n    vadjust: {\n      number: number2\n    },\n    multi: {\n      boolean: bool2,\n      string: string2\n    },\n    bold: {\n      color: {\n        string: string2\n      },\n      size: {\n        number: number2\n      },\n      face: {\n        string: string2\n      },\n      mod: {\n        string: string2\n      },\n      vadjust: {\n        number: number2\n      },\n      __type__: {\n        object,\n        string: string2\n      }\n    },\n    boldital: {\n      color: {\n        string: string2\n      },\n      size: {\n        number: number2\n      },\n      face: {\n        string: string2\n      },\n      mod: {\n        string: string2\n      },\n      vadjust: {\n        number: number2\n      },\n      __type__: {\n        object,\n        string: string2\n      }\n    },\n    ital: {\n      color: {\n        string: string2\n      },\n      size: {\n        number: number2\n      },\n      face: {\n        string: string2\n      },\n      mod: {\n        string: string2\n      },\n      vadjust: {\n        number: number2\n      },\n      __type__: {\n        object,\n        string: string2\n      }\n    },\n    mono: {\n      color: {\n        string: string2\n      },\n      size: {\n        number: number2\n      },\n      face: {\n        string: string2\n      },\n      mod: {\n        string: string2\n      },\n      vadjust: {\n        number: number2\n      },\n      __type__: {\n        object,\n        string: string2\n      }\n    },\n    __type__: {\n      object,\n      string: string2\n    }\n  },\n  group: {\n    string: string2,\n    number: number2,\n    undefined: \"undefined\"\n  },\n  heightConstraint: {\n    minimum: {\n      number: number2\n    },\n    valign: {\n      string: string2\n    },\n    __type__: {\n      object,\n      boolean: bool2,\n      number: number2\n    }\n  },\n  hidden: {\n    boolean: bool2\n  },\n  icon: {\n    face: {\n      string: string2\n    },\n    code: {\n      string: string2\n    },\n    size: {\n      number: number2\n    },\n    color: {\n      string: string2\n    },\n    weight: {\n      string: string2,\n      number: number2\n    },\n    __type__: {\n      object\n    }\n  },\n  id: {\n    string: string2,\n    number: number2\n  },\n  image: {\n    selected: {\n      string: string2,\n      undefined: \"undefined\"\n    },\n    unselected: {\n      string: string2,\n      undefined: \"undefined\"\n    },\n    __type__: {\n      object,\n      string: string2\n    }\n  },\n  imagePadding: {\n    top: {\n      number: number2\n    },\n    right: {\n      number: number2\n    },\n    bottom: {\n      number: number2\n    },\n    left: {\n      number: number2\n    },\n    __type__: {\n      object,\n      number: number2\n    }\n  },\n  label: {\n    string: string2,\n    undefined: \"undefined\"\n  },\n  labelHighlightBold: {\n    boolean: bool2\n  },\n  level: {\n    number: number2,\n    undefined: \"undefined\"\n  },\n  margin: {\n    top: {\n      number: number2\n    },\n    right: {\n      number: number2\n    },\n    bottom: {\n      number: number2\n    },\n    left: {\n      number: number2\n    },\n    __type__: {\n      object,\n      number: number2\n    }\n  },\n  mass: {\n    number: number2\n  },\n  physics: {\n    boolean: bool2\n  },\n  scaling: {\n    min: {\n      number: number2\n    },\n    max: {\n      number: number2\n    },\n    label: {\n      enabled: {\n        boolean: bool2\n      },\n      min: {\n        number: number2\n      },\n      max: {\n        number: number2\n      },\n      maxVisible: {\n        number: number2\n      },\n      drawThreshold: {\n        number: number2\n      },\n      __type__: {\n        object,\n        boolean: bool2\n      }\n    },\n    customScalingFunction: {\n      function: \"function\"\n    },\n    __type__: {\n      object\n    }\n  },\n  shadow: {\n    enabled: {\n      boolean: bool2\n    },\n    color: {\n      string: string2\n    },\n    size: {\n      number: number2\n    },\n    x: {\n      number: number2\n    },\n    y: {\n      number: number2\n    },\n    __type__: {\n      object,\n      boolean: bool2\n    }\n  },\n  shape: {\n    string: [\"custom\", \"ellipse\", \"circle\", \"database\", \"box\", \"text\", \"image\", \"circularImage\", \"diamond\", \"dot\", \"star\", \"triangle\", \"triangleDown\", \"square\", \"icon\", \"hexagon\"]\n  },\n  ctxRenderer: {\n    function: \"function\"\n  },\n  shapeProperties: {\n    borderDashes: {\n      boolean: bool2,\n      array\n    },\n    borderRadius: {\n      number: number2\n    },\n    interpolation: {\n      boolean: bool2\n    },\n    useImageSize: {\n      boolean: bool2\n    },\n    useBorderWithImage: {\n      boolean: bool2\n    },\n    coordinateOrigin: {\n      string: [\"center\", \"top-left\"]\n    },\n    __type__: {\n      object\n    }\n  },\n  size: {\n    number: number2\n  },\n  title: {\n    string: string2,\n    dom,\n    undefined: \"undefined\"\n  },\n  value: {\n    number: number2,\n    undefined: \"undefined\"\n  },\n  widthConstraint: {\n    minimum: {\n      number: number2\n    },\n    maximum: {\n      number: number2\n    },\n    __type__: {\n      object,\n      boolean: bool2,\n      number: number2\n    }\n  },\n  x: {\n    number: number2\n  },\n  y: {\n    number: number2\n  },\n  __type__: {\n    object\n  }\n};\nvar allOptions = {\n  configure: {\n    enabled: {\n      boolean: bool2\n    },\n    filter: {\n      boolean: bool2,\n      string: string2,\n      array,\n      function: \"function\"\n    },\n    container: {\n      dom\n    },\n    showButton: {\n      boolean: bool2\n    },\n    __type__: {\n      object,\n      boolean: bool2,\n      string: string2,\n      array,\n      function: \"function\"\n    }\n  },\n  edges: {\n    arrows: {\n      to: {\n        enabled: {\n          boolean: bool2\n        },\n        scaleFactor: {\n          number: number2\n        },\n        type: {\n          string: endPoints\n        },\n        imageHeight: {\n          number: number2\n        },\n        imageWidth: {\n          number: number2\n        },\n        src: {\n          string: string2\n        },\n        __type__: {\n          object,\n          boolean: bool2\n        }\n      },\n      middle: {\n        enabled: {\n          boolean: bool2\n        },\n        scaleFactor: {\n          number: number2\n        },\n        type: {\n          string: endPoints\n        },\n        imageWidth: {\n          number: number2\n        },\n        imageHeight: {\n          number: number2\n        },\n        src: {\n          string: string2\n        },\n        __type__: {\n          object,\n          boolean: bool2\n        }\n      },\n      from: {\n        enabled: {\n          boolean: bool2\n        },\n        scaleFactor: {\n          number: number2\n        },\n        type: {\n          string: endPoints\n        },\n        imageWidth: {\n          number: number2\n        },\n        imageHeight: {\n          number: number2\n        },\n        src: {\n          string: string2\n        },\n        __type__: {\n          object,\n          boolean: bool2\n        }\n      },\n      __type__: {\n        string: [\"from\", \"to\", \"middle\"],\n        object\n      }\n    },\n    endPointOffset: {\n      from: {\n        number: number2\n      },\n      to: {\n        number: number2\n      },\n      __type__: {\n        object,\n        number: number2\n      }\n    },\n    arrowStrikethrough: {\n      boolean: bool2\n    },\n    background: {\n      enabled: {\n        boolean: bool2\n      },\n      color: {\n        string: string2\n      },\n      size: {\n        number: number2\n      },\n      dashes: {\n        boolean: bool2,\n        array\n      },\n      __type__: {\n        object,\n        boolean: bool2\n      }\n    },\n    chosen: {\n      label: {\n        boolean: bool2,\n        function: \"function\"\n      },\n      edge: {\n        boolean: bool2,\n        function: \"function\"\n      },\n      __type__: {\n        object,\n        boolean: bool2\n      }\n    },\n    color: {\n      color: {\n        string: string2\n      },\n      highlight: {\n        string: string2\n      },\n      hover: {\n        string: string2\n      },\n      inherit: {\n        string: [\"from\", \"to\", \"both\"],\n        boolean: bool2\n      },\n      opacity: {\n        number: number2\n      },\n      __type__: {\n        object,\n        string: string2\n      }\n    },\n    dashes: {\n      boolean: bool2,\n      array\n    },\n    font: {\n      color: {\n        string: string2\n      },\n      size: {\n        number: number2\n      },\n      face: {\n        string: string2\n      },\n      background: {\n        string: string2\n      },\n      strokeWidth: {\n        number: number2\n      },\n      strokeColor: {\n        string: string2\n      },\n      align: {\n        string: [\"horizontal\", \"top\", \"middle\", \"bottom\"]\n      },\n      vadjust: {\n        number: number2\n      },\n      multi: {\n        boolean: bool2,\n        string: string2\n      },\n      bold: {\n        color: {\n          string: string2\n        },\n        size: {\n          number: number2\n        },\n        face: {\n          string: string2\n        },\n        mod: {\n          string: string2\n        },\n        vadjust: {\n          number: number2\n        },\n        __type__: {\n          object,\n          string: string2\n        }\n      },\n      boldital: {\n        color: {\n          string: string2\n        },\n        size: {\n          number: number2\n        },\n        face: {\n          string: string2\n        },\n        mod: {\n          string: string2\n        },\n        vadjust: {\n          number: number2\n        },\n        __type__: {\n          object,\n          string: string2\n        }\n      },\n      ital: {\n        color: {\n          string: string2\n        },\n        size: {\n          number: number2\n        },\n        face: {\n          string: string2\n        },\n        mod: {\n          string: string2\n        },\n        vadjust: {\n          number: number2\n        },\n        __type__: {\n          object,\n          string: string2\n        }\n      },\n      mono: {\n        color: {\n          string: string2\n        },\n        size: {\n          number: number2\n        },\n        face: {\n          string: string2\n        },\n        mod: {\n          string: string2\n        },\n        vadjust: {\n          number: number2\n        },\n        __type__: {\n          object,\n          string: string2\n        }\n      },\n      __type__: {\n        object,\n        string: string2\n      }\n    },\n    hidden: {\n      boolean: bool2\n    },\n    hoverWidth: {\n      function: \"function\",\n      number: number2\n    },\n    label: {\n      string: string2,\n      undefined: \"undefined\"\n    },\n    labelHighlightBold: {\n      boolean: bool2\n    },\n    length: {\n      number: number2,\n      undefined: \"undefined\"\n    },\n    physics: {\n      boolean: bool2\n    },\n    scaling: {\n      min: {\n        number: number2\n      },\n      max: {\n        number: number2\n      },\n      label: {\n        enabled: {\n          boolean: bool2\n        },\n        min: {\n          number: number2\n        },\n        max: {\n          number: number2\n        },\n        maxVisible: {\n          number: number2\n        },\n        drawThreshold: {\n          number: number2\n        },\n        __type__: {\n          object,\n          boolean: bool2\n        }\n      },\n      customScalingFunction: {\n        function: \"function\"\n      },\n      __type__: {\n        object\n      }\n    },\n    selectionWidth: {\n      function: \"function\",\n      number: number2\n    },\n    selfReferenceSize: {\n      number: number2\n    },\n    selfReference: {\n      size: {\n        number: number2\n      },\n      angle: {\n        number: number2\n      },\n      renderBehindTheNode: {\n        boolean: bool2\n      },\n      __type__: {\n        object\n      }\n    },\n    shadow: {\n      enabled: {\n        boolean: bool2\n      },\n      color: {\n        string: string2\n      },\n      size: {\n        number: number2\n      },\n      x: {\n        number: number2\n      },\n      y: {\n        number: number2\n      },\n      __type__: {\n        object,\n        boolean: bool2\n      }\n    },\n    smooth: {\n      enabled: {\n        boolean: bool2\n      },\n      type: {\n        string: [\"dynamic\", \"continuous\", \"discrete\", \"diagonalCross\", \"straightCross\", \"horizontal\", \"vertical\", \"curvedCW\", \"curvedCCW\", \"cubicBezier\"]\n      },\n      roundness: {\n        number: number2\n      },\n      forceDirection: {\n        string: [\"horizontal\", \"vertical\", \"none\"],\n        boolean: bool2\n      },\n      __type__: {\n        object,\n        boolean: bool2\n      }\n    },\n    title: {\n      string: string2,\n      undefined: \"undefined\"\n    },\n    width: {\n      number: number2\n    },\n    widthConstraint: {\n      maximum: {\n        number: number2\n      },\n      __type__: {\n        object,\n        boolean: bool2,\n        number: number2\n      }\n    },\n    value: {\n      number: number2,\n      undefined: \"undefined\"\n    },\n    __type__: {\n      object\n    }\n  },\n  groups: {\n    useDefaultGroups: {\n      boolean: bool2\n    },\n    __any__: nodeOptions,\n    __type__: {\n      object\n    }\n  },\n  interaction: {\n    dragNodes: {\n      boolean: bool2\n    },\n    dragView: {\n      boolean: bool2\n    },\n    hideEdgesOnDrag: {\n      boolean: bool2\n    },\n    hideEdgesOnZoom: {\n      boolean: bool2\n    },\n    hideNodesOnDrag: {\n      boolean: bool2\n    },\n    hover: {\n      boolean: bool2\n    },\n    keyboard: {\n      enabled: {\n        boolean: bool2\n      },\n      speed: {\n        x: {\n          number: number2\n        },\n        y: {\n          number: number2\n        },\n        zoom: {\n          number: number2\n        },\n        __type__: {\n          object\n        }\n      },\n      bindToWindow: {\n        boolean: bool2\n      },\n      autoFocus: {\n        boolean: bool2\n      },\n      __type__: {\n        object,\n        boolean: bool2\n      }\n    },\n    multiselect: {\n      boolean: bool2\n    },\n    navigationButtons: {\n      boolean: bool2\n    },\n    selectable: {\n      boolean: bool2\n    },\n    selectConnectedEdges: {\n      boolean: bool2\n    },\n    hoverConnectedEdges: {\n      boolean: bool2\n    },\n    tooltipDelay: {\n      number: number2\n    },\n    zoomView: {\n      boolean: bool2\n    },\n    zoomSpeed: {\n      number: number2\n    },\n    __type__: {\n      object\n    }\n  },\n  layout: {\n    randomSeed: {\n      undefined: \"undefined\",\n      number: number2,\n      string: string2\n    },\n    improvedLayout: {\n      boolean: bool2\n    },\n    clusterThreshold: {\n      number: number2\n    },\n    hierarchical: {\n      enabled: {\n        boolean: bool2\n      },\n      levelSeparation: {\n        number: number2\n      },\n      nodeSpacing: {\n        number: number2\n      },\n      treeSpacing: {\n        number: number2\n      },\n      blockShifting: {\n        boolean: bool2\n      },\n      edgeMinimization: {\n        boolean: bool2\n      },\n      parentCentralization: {\n        boolean: bool2\n      },\n      direction: {\n        string: [\"UD\", \"DU\", \"LR\", \"RL\"]\n      },\n      sortMethod: {\n        string: [\"hubsize\", \"directed\"]\n      },\n      shakeTowards: {\n        string: [\"leaves\", \"roots\"]\n      },\n      __type__: {\n        object,\n        boolean: bool2\n      }\n    },\n    __type__: {\n      object\n    }\n  },\n  manipulation: {\n    enabled: {\n      boolean: bool2\n    },\n    initiallyActive: {\n      boolean: bool2\n    },\n    addNode: {\n      boolean: bool2,\n      function: \"function\"\n    },\n    addEdge: {\n      boolean: bool2,\n      function: \"function\"\n    },\n    editNode: {\n      function: \"function\"\n    },\n    editEdge: {\n      editWithoutDrag: {\n        function: \"function\"\n      },\n      __type__: {\n        object,\n        boolean: bool2,\n        function: \"function\"\n      }\n    },\n    deleteNode: {\n      boolean: bool2,\n      function: \"function\"\n    },\n    deleteEdge: {\n      boolean: bool2,\n      function: \"function\"\n    },\n    controlNodeStyle: nodeOptions,\n    __type__: {\n      object,\n      boolean: bool2\n    }\n  },\n  nodes: nodeOptions,\n  physics: {\n    enabled: {\n      boolean: bool2\n    },\n    barnesHut: {\n      theta: {\n        number: number2\n      },\n      gravitationalConstant: {\n        number: number2\n      },\n      centralGravity: {\n        number: number2\n      },\n      springLength: {\n        number: number2\n      },\n      springConstant: {\n        number: number2\n      },\n      damping: {\n        number: number2\n      },\n      avoidOverlap: {\n        number: number2\n      },\n      __type__: {\n        object\n      }\n    },\n    forceAtlas2Based: {\n      theta: {\n        number: number2\n      },\n      gravitationalConstant: {\n        number: number2\n      },\n      centralGravity: {\n        number: number2\n      },\n      springLength: {\n        number: number2\n      },\n      springConstant: {\n        number: number2\n      },\n      damping: {\n        number: number2\n      },\n      avoidOverlap: {\n        number: number2\n      },\n      __type__: {\n        object\n      }\n    },\n    repulsion: {\n      centralGravity: {\n        number: number2\n      },\n      springLength: {\n        number: number2\n      },\n      springConstant: {\n        number: number2\n      },\n      nodeDistance: {\n        number: number2\n      },\n      damping: {\n        number: number2\n      },\n      __type__: {\n        object\n      }\n    },\n    hierarchicalRepulsion: {\n      centralGravity: {\n        number: number2\n      },\n      springLength: {\n        number: number2\n      },\n      springConstant: {\n        number: number2\n      },\n      nodeDistance: {\n        number: number2\n      },\n      damping: {\n        number: number2\n      },\n      avoidOverlap: {\n        number: number2\n      },\n      __type__: {\n        object\n      }\n    },\n    maxVelocity: {\n      number: number2\n    },\n    minVelocity: {\n      number: number2\n    },\n    solver: {\n      string: [\"barnesHut\", \"repulsion\", \"hierarchicalRepulsion\", \"forceAtlas2Based\"]\n    },\n    stabilization: {\n      enabled: {\n        boolean: bool2\n      },\n      iterations: {\n        number: number2\n      },\n      updateInterval: {\n        number: number2\n      },\n      onlyDynamicEdges: {\n        boolean: bool2\n      },\n      fit: {\n        boolean: bool2\n      },\n      __type__: {\n        object,\n        boolean: bool2\n      }\n    },\n    timestep: {\n      number: number2\n    },\n    adaptiveTimestep: {\n      boolean: bool2\n    },\n    wind: {\n      x: {\n        number: number2\n      },\n      y: {\n        number: number2\n      },\n      __type__: {\n        object\n      }\n    },\n    __type__: {\n      object,\n      boolean: bool2\n    }\n  },\n  autoResize: {\n    boolean: bool2\n  },\n  clickToUse: {\n    boolean: bool2\n  },\n  locale: {\n    string: string2\n  },\n  locales: {\n    __any__: {\n      any\n    },\n    __type__: {\n      object\n    }\n  },\n  height: {\n    string: string2\n  },\n  width: {\n    string: string2\n  },\n  __type__: {\n    object\n  }\n};\nvar configureOptions = {\n  nodes: {\n    borderWidth: [1, 0, 10, 1],\n    borderWidthSelected: [2, 0, 10, 1],\n    color: {\n      border: [\"color\", \"#2B7CE9\"],\n      background: [\"color\", \"#97C2FC\"],\n      highlight: {\n        border: [\"color\", \"#2B7CE9\"],\n        background: [\"color\", \"#D2E5FF\"]\n      },\n      hover: {\n        border: [\"color\", \"#2B7CE9\"],\n        background: [\"color\", \"#D2E5FF\"]\n      }\n    },\n    opacity: [0, 0, 1, 0.1],\n    fixed: {\n      x: false,\n      y: false\n    },\n    font: {\n      color: [\"color\", \"#343434\"],\n      size: [14, 0, 100, 1],\n      face: [\"arial\", \"verdana\", \"tahoma\"],\n      background: [\"color\", \"none\"],\n      strokeWidth: [0, 0, 50, 1],\n      strokeColor: [\"color\", \"#ffffff\"]\n    },\n    hidden: false,\n    labelHighlightBold: true,\n    physics: true,\n    scaling: {\n      min: [10, 0, 200, 1],\n      max: [30, 0, 200, 1],\n      label: {\n        enabled: false,\n        min: [14, 0, 200, 1],\n        max: [30, 0, 200, 1],\n        maxVisible: [30, 0, 200, 1],\n        drawThreshold: [5, 0, 20, 1]\n      }\n    },\n    shadow: {\n      enabled: false,\n      color: \"rgba(0,0,0,0.5)\",\n      size: [10, 0, 20, 1],\n      x: [5, -30, 30, 1],\n      y: [5, -30, 30, 1]\n    },\n    shape: [\"ellipse\", \"box\", \"circle\", \"database\", \"diamond\", \"dot\", \"square\", \"star\", \"text\", \"triangle\", \"triangleDown\", \"hexagon\"],\n    shapeProperties: {\n      borderDashes: false,\n      borderRadius: [6, 0, 20, 1],\n      interpolation: true,\n      useImageSize: false\n    },\n    size: [25, 0, 200, 1]\n  },\n  edges: {\n    arrows: {\n      to: {\n        enabled: false,\n        scaleFactor: [1, 0, 3, 0.05],\n        type: \"arrow\"\n      },\n      middle: {\n        enabled: false,\n        scaleFactor: [1, 0, 3, 0.05],\n        type: \"arrow\"\n      },\n      from: {\n        enabled: false,\n        scaleFactor: [1, 0, 3, 0.05],\n        type: \"arrow\"\n      }\n    },\n    endPointOffset: {\n      from: [0, -10, 10, 1],\n      to: [0, -10, 10, 1]\n    },\n    arrowStrikethrough: true,\n    color: {\n      color: [\"color\", \"#848484\"],\n      highlight: [\"color\", \"#848484\"],\n      hover: [\"color\", \"#848484\"],\n      inherit: [\"from\", \"to\", \"both\", true, false],\n      opacity: [1, 0, 1, 0.05]\n    },\n    dashes: false,\n    font: {\n      color: [\"color\", \"#343434\"],\n      size: [14, 0, 100, 1],\n      face: [\"arial\", \"verdana\", \"tahoma\"],\n      background: [\"color\", \"none\"],\n      strokeWidth: [2, 0, 50, 1],\n      strokeColor: [\"color\", \"#ffffff\"],\n      align: [\"horizontal\", \"top\", \"middle\", \"bottom\"]\n    },\n    hidden: false,\n    hoverWidth: [1.5, 0, 5, 0.1],\n    labelHighlightBold: true,\n    physics: true,\n    scaling: {\n      min: [1, 0, 100, 1],\n      max: [15, 0, 100, 1],\n      label: {\n        enabled: true,\n        min: [14, 0, 200, 1],\n        max: [30, 0, 200, 1],\n        maxVisible: [30, 0, 200, 1],\n        drawThreshold: [5, 0, 20, 1]\n      }\n    },\n    selectionWidth: [1.5, 0, 5, 0.1],\n    selfReferenceSize: [20, 0, 200, 1],\n    selfReference: {\n      size: [20, 0, 200, 1],\n      angle: [Math.PI / 2, -6 * Math.PI, 6 * Math.PI, Math.PI / 8],\n      renderBehindTheNode: true\n    },\n    shadow: {\n      enabled: false,\n      color: \"rgba(0,0,0,0.5)\",\n      size: [10, 0, 20, 1],\n      x: [5, -30, 30, 1],\n      y: [5, -30, 30, 1]\n    },\n    smooth: {\n      enabled: true,\n      type: [\"dynamic\", \"continuous\", \"discrete\", \"diagonalCross\", \"straightCross\", \"horizontal\", \"vertical\", \"curvedCW\", \"curvedCCW\", \"cubicBezier\"],\n      forceDirection: [\"horizontal\", \"vertical\", \"none\"],\n      roundness: [0.5, 0, 1, 0.05]\n    },\n    width: [1, 0, 30, 1]\n  },\n  layout: {\n    hierarchical: {\n      enabled: false,\n      levelSeparation: [150, 20, 500, 5],\n      nodeSpacing: [100, 20, 500, 5],\n      treeSpacing: [200, 20, 500, 5],\n      blockShifting: true,\n      edgeMinimization: true,\n      parentCentralization: true,\n      direction: [\"UD\", \"DU\", \"LR\", \"RL\"],\n      sortMethod: [\"hubsize\", \"directed\"],\n      shakeTowards: [\"leaves\", \"roots\"]\n    }\n  },\n  interaction: {\n    dragNodes: true,\n    dragView: true,\n    hideEdgesOnDrag: false,\n    hideEdgesOnZoom: false,\n    hideNodesOnDrag: false,\n    hover: false,\n    keyboard: {\n      enabled: false,\n      speed: {\n        x: [10, 0, 40, 1],\n        y: [10, 0, 40, 1],\n        zoom: [0.02, 0, 0.1, 5e-3]\n      },\n      bindToWindow: true,\n      autoFocus: true\n    },\n    multiselect: false,\n    navigationButtons: false,\n    selectable: true,\n    selectConnectedEdges: true,\n    hoverConnectedEdges: true,\n    tooltipDelay: [300, 0, 1e3, 25],\n    zoomView: true,\n    zoomSpeed: [1, 0.1, 2, 0.1]\n  },\n  manipulation: {\n    enabled: false,\n    initiallyActive: false\n  },\n  physics: {\n    enabled: true,\n    barnesHut: {\n      theta: [0.5, 0.1, 1, 0.05],\n      gravitationalConstant: [-2e3, -3e4, 0, 50],\n      centralGravity: [0.3, 0, 10, 0.05],\n      springLength: [95, 0, 500, 5],\n      springConstant: [0.04, 0, 1.2, 5e-3],\n      damping: [0.09, 0, 1, 0.01],\n      avoidOverlap: [0, 0, 1, 0.01]\n    },\n    forceAtlas2Based: {\n      theta: [0.5, 0.1, 1, 0.05],\n      gravitationalConstant: [-50, -500, 0, 1],\n      centralGravity: [0.01, 0, 1, 5e-3],\n      springLength: [95, 0, 500, 5],\n      springConstant: [0.08, 0, 1.2, 5e-3],\n      damping: [0.4, 0, 1, 0.01],\n      avoidOverlap: [0, 0, 1, 0.01]\n    },\n    repulsion: {\n      centralGravity: [0.2, 0, 10, 0.05],\n      springLength: [200, 0, 500, 5],\n      springConstant: [0.05, 0, 1.2, 5e-3],\n      nodeDistance: [100, 0, 500, 5],\n      damping: [0.09, 0, 1, 0.01]\n    },\n    hierarchicalRepulsion: {\n      centralGravity: [0.2, 0, 10, 0.05],\n      springLength: [100, 0, 500, 5],\n      springConstant: [0.01, 0, 1.2, 5e-3],\n      nodeDistance: [120, 0, 500, 5],\n      damping: [0.09, 0, 1, 0.01],\n      avoidOverlap: [0, 0, 1, 0.01]\n    },\n    maxVelocity: [50, 0, 150, 1],\n    minVelocity: [0.1, 0.01, 0.5, 0.01],\n    solver: [\"barnesHut\", \"forceAtlas2Based\", \"repulsion\", \"hierarchicalRepulsion\"],\n    timestep: [0.5, 0.01, 1, 0.01],\n    wind: {\n      x: [0, -10, 10, 0.1],\n      y: [0, -10, 10, 0.1]\n    }\n  }\n};\nvar configuratorHideOption = function configuratorHideOption2(parentPath, optionName, options2) {\n  var _context;\n  if (includes32(parentPath).call(parentPath, \"physics\") && includes32(_context = configureOptions.physics.solver).call(_context, optionName) && options2.physics.solver !== optionName && optionName !== \"wind\") {\n    return true;\n  }\n  return false;\n};\nvar FloydWarshall = /* @__PURE__ */ function() {\n  function FloydWarshall2() {\n    _classCallCheck2(this, FloydWarshall2);\n  }\n  _createClass2(FloydWarshall2, [{\n    key: \"getDistances\",\n    value: function getDistances(body, nodesArray, edgesArray) {\n      var D_matrix = {};\n      var edges = body.edges;\n      for (var i = 0; i < nodesArray.length; i++) {\n        var node = nodesArray[i];\n        var cell = {};\n        D_matrix[node] = cell;\n        for (var j = 0; j < nodesArray.length; j++) {\n          cell[nodesArray[j]] = i == j ? 0 : 1e9;\n        }\n      }\n      for (var _i = 0; _i < edgesArray.length; _i++) {\n        var edge = edges[edgesArray[_i]];\n        if (edge.connected === true && D_matrix[edge.fromId] !== void 0 && D_matrix[edge.toId] !== void 0) {\n          D_matrix[edge.fromId][edge.toId] = 1;\n          D_matrix[edge.toId][edge.fromId] = 1;\n        }\n      }\n      var nodeCount = nodesArray.length;\n      for (var k2 = 0; k2 < nodeCount; k2++) {\n        var knode = nodesArray[k2];\n        var kcolm = D_matrix[knode];\n        for (var _i2 = 0; _i2 < nodeCount - 1; _i2++) {\n          var inode = nodesArray[_i2];\n          var icolm = D_matrix[inode];\n          for (var _j = _i2 + 1; _j < nodeCount; _j++) {\n            var jnode = nodesArray[_j];\n            var jcolm = D_matrix[jnode];\n            var val = Math.min(icolm[jnode], icolm[knode] + kcolm[jnode]);\n            icolm[jnode] = val;\n            jcolm[inode] = val;\n          }\n        }\n      }\n      return D_matrix;\n    }\n  }]);\n  return FloydWarshall2;\n}();\nvar KamadaKawai = /* @__PURE__ */ function() {\n  function KamadaKawai2(body, edgeLength, edgeStrength) {\n    _classCallCheck2(this, KamadaKawai2);\n    this.body = body;\n    this.springLength = edgeLength;\n    this.springConstant = edgeStrength;\n    this.distanceSolver = new FloydWarshall();\n  }\n  _createClass2(KamadaKawai2, [{\n    key: \"setOptions\",\n    value: function setOptions(options2) {\n      if (options2) {\n        if (options2.springLength) {\n          this.springLength = options2.springLength;\n        }\n        if (options2.springConstant) {\n          this.springConstant = options2.springConstant;\n        }\n      }\n    }\n  }, {\n    key: \"solve\",\n    value: function solve(nodesArray, edgesArray) {\n      var ignoreClusters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n      var D_matrix = this.distanceSolver.getDistances(this.body, nodesArray, edgesArray);\n      this._createL_matrix(D_matrix);\n      this._createK_matrix(D_matrix);\n      this._createE_matrix();\n      var threshold = 0.01;\n      var innerThreshold = 1;\n      var iterations = 0;\n      var maxIterations = Math.max(1e3, Math.min(10 * this.body.nodeIndices.length, 6e3));\n      var maxInnerIterations = 5;\n      var maxEnergy = 1e9;\n      var highE_nodeId = 0, dE_dx = 0, dE_dy = 0, delta_m = 0, subIterations = 0;\n      while (maxEnergy > threshold && iterations < maxIterations) {\n        iterations += 1;\n        var _this$_getHighestEner = this._getHighestEnergyNode(ignoreClusters);\n        var _this$_getHighestEner2 = _slicedToArray2(_this$_getHighestEner, 4);\n        highE_nodeId = _this$_getHighestEner2[0];\n        maxEnergy = _this$_getHighestEner2[1];\n        dE_dx = _this$_getHighestEner2[2];\n        dE_dy = _this$_getHighestEner2[3];\n        delta_m = maxEnergy;\n        subIterations = 0;\n        while (delta_m > innerThreshold && subIterations < maxInnerIterations) {\n          subIterations += 1;\n          this._moveNode(highE_nodeId, dE_dx, dE_dy);\n          var _this$_getEnergy = this._getEnergy(highE_nodeId);\n          var _this$_getEnergy2 = _slicedToArray2(_this$_getEnergy, 3);\n          delta_m = _this$_getEnergy2[0];\n          dE_dx = _this$_getEnergy2[1];\n          dE_dy = _this$_getEnergy2[2];\n        }\n      }\n    }\n  }, {\n    key: \"_getHighestEnergyNode\",\n    value: function _getHighestEnergyNode(ignoreClusters) {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      var maxEnergy = 0;\n      var maxEnergyNodeId = nodesArray[0];\n      var dE_dx_max = 0, dE_dy_max = 0;\n      for (var nodeIdx = 0; nodeIdx < nodesArray.length; nodeIdx++) {\n        var m = nodesArray[nodeIdx];\n        if (nodes[m].predefinedPosition !== true || nodes[m].isCluster === true && ignoreClusters === true || nodes[m].options.fixed.x !== true || nodes[m].options.fixed.y !== true) {\n          var _this$_getEnergy3 = this._getEnergy(m), _this$_getEnergy4 = _slicedToArray2(_this$_getEnergy3, 3), delta_m = _this$_getEnergy4[0], dE_dx = _this$_getEnergy4[1], dE_dy = _this$_getEnergy4[2];\n          if (maxEnergy < delta_m) {\n            maxEnergy = delta_m;\n            maxEnergyNodeId = m;\n            dE_dx_max = dE_dx;\n            dE_dy_max = dE_dy;\n          }\n        }\n      }\n      return [maxEnergyNodeId, maxEnergy, dE_dx_max, dE_dy_max];\n    }\n  }, {\n    key: \"_getEnergy\",\n    value: function _getEnergy(m) {\n      var _this$E_sums$m = _slicedToArray2(this.E_sums[m], 2), dE_dx = _this$E_sums$m[0], dE_dy = _this$E_sums$m[1];\n      var delta_m = Math.sqrt(Math.pow(dE_dx, 2) + Math.pow(dE_dy, 2));\n      return [delta_m, dE_dx, dE_dy];\n    }\n  }, {\n    key: \"_moveNode\",\n    value: function _moveNode(m, dE_dx, dE_dy) {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      var d2E_dx2 = 0;\n      var d2E_dxdy = 0;\n      var d2E_dy2 = 0;\n      var x_m = nodes[m].x;\n      var y_m = nodes[m].y;\n      var km = this.K_matrix[m];\n      var lm = this.L_matrix[m];\n      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {\n        var i = nodesArray[iIdx];\n        if (i !== m) {\n          var x_i = nodes[i].x;\n          var y_i = nodes[i].y;\n          var kmat = km[i];\n          var lmat = lm[i];\n          var denominator = 1 / Math.pow(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2), 1.5);\n          d2E_dx2 += kmat * (1 - lmat * Math.pow(y_m - y_i, 2) * denominator);\n          d2E_dxdy += kmat * (lmat * (x_m - x_i) * (y_m - y_i) * denominator);\n          d2E_dy2 += kmat * (1 - lmat * Math.pow(x_m - x_i, 2) * denominator);\n        }\n      }\n      var A2 = d2E_dx2, B3 = d2E_dxdy, C3 = dE_dx, D2 = d2E_dy2, E = dE_dy;\n      var dy = (C3 / A2 + E / B3) / (B3 / A2 - D2 / B3);\n      var dx = -(B3 * dy + C3) / A2;\n      nodes[m].x += dx;\n      nodes[m].y += dy;\n      this._updateE_matrix(m);\n    }\n  }, {\n    key: \"_createL_matrix\",\n    value: function _createL_matrix(D_matrix) {\n      var nodesArray = this.body.nodeIndices;\n      var edgeLength = this.springLength;\n      this.L_matrix = [];\n      for (var i = 0; i < nodesArray.length; i++) {\n        this.L_matrix[nodesArray[i]] = {};\n        for (var j = 0; j < nodesArray.length; j++) {\n          this.L_matrix[nodesArray[i]][nodesArray[j]] = edgeLength * D_matrix[nodesArray[i]][nodesArray[j]];\n        }\n      }\n    }\n  }, {\n    key: \"_createK_matrix\",\n    value: function _createK_matrix(D_matrix) {\n      var nodesArray = this.body.nodeIndices;\n      var edgeStrength = this.springConstant;\n      this.K_matrix = [];\n      for (var i = 0; i < nodesArray.length; i++) {\n        this.K_matrix[nodesArray[i]] = {};\n        for (var j = 0; j < nodesArray.length; j++) {\n          this.K_matrix[nodesArray[i]][nodesArray[j]] = edgeStrength * Math.pow(D_matrix[nodesArray[i]][nodesArray[j]], -2);\n        }\n      }\n    }\n  }, {\n    key: \"_createE_matrix\",\n    value: function _createE_matrix() {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      this.E_matrix = {};\n      this.E_sums = {};\n      for (var mIdx = 0; mIdx < nodesArray.length; mIdx++) {\n        this.E_matrix[nodesArray[mIdx]] = [];\n      }\n      for (var _mIdx = 0; _mIdx < nodesArray.length; _mIdx++) {\n        var m = nodesArray[_mIdx];\n        var x_m = nodes[m].x;\n        var y_m = nodes[m].y;\n        var dE_dx = 0;\n        var dE_dy = 0;\n        for (var iIdx = _mIdx; iIdx < nodesArray.length; iIdx++) {\n          var i = nodesArray[iIdx];\n          if (i !== m) {\n            var x_i = nodes[i].x;\n            var y_i = nodes[i].y;\n            var denominator = 1 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));\n            this.E_matrix[m][iIdx] = [this.K_matrix[m][i] * (x_m - x_i - this.L_matrix[m][i] * (x_m - x_i) * denominator), this.K_matrix[m][i] * (y_m - y_i - this.L_matrix[m][i] * (y_m - y_i) * denominator)];\n            this.E_matrix[i][_mIdx] = this.E_matrix[m][iIdx];\n            dE_dx += this.E_matrix[m][iIdx][0];\n            dE_dy += this.E_matrix[m][iIdx][1];\n          }\n        }\n        this.E_sums[m] = [dE_dx, dE_dy];\n      }\n    }\n  }, {\n    key: \"_updateE_matrix\",\n    value: function _updateE_matrix(m) {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      var colm = this.E_matrix[m];\n      var kcolm = this.K_matrix[m];\n      var lcolm = this.L_matrix[m];\n      var x_m = nodes[m].x;\n      var y_m = nodes[m].y;\n      var dE_dx = 0;\n      var dE_dy = 0;\n      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {\n        var i = nodesArray[iIdx];\n        if (i !== m) {\n          var cell = colm[iIdx];\n          var oldDx = cell[0];\n          var oldDy = cell[1];\n          var x_i = nodes[i].x;\n          var y_i = nodes[i].y;\n          var denominator = 1 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));\n          var dx = kcolm[i] * (x_m - x_i - lcolm[i] * (x_m - x_i) * denominator);\n          var dy = kcolm[i] * (y_m - y_i - lcolm[i] * (y_m - y_i) * denominator);\n          colm[iIdx] = [dx, dy];\n          dE_dx += dx;\n          dE_dy += dy;\n          var sum = this.E_sums[i];\n          sum[0] += dx - oldDx;\n          sum[1] += dy - oldDy;\n        }\n      }\n      this.E_sums[m] = [dE_dx, dE_dy];\n    }\n  }]);\n  return KamadaKawai2;\n}();\nfunction Network(container, data22, options2) {\n  var _context, _context2, _context3, _context4, _this = this;\n  if (!(this instanceof Network)) {\n    throw new SyntaxError(\"Constructor must be called with the new operator\");\n  }\n  this.options = {};\n  this.defaultOptions = {\n    locale: \"en\",\n    locales,\n    clickToUse: false\n  };\n  assign$22(this.options, this.defaultOptions);\n  this.body = {\n    container,\n    nodes: {},\n    nodeIndices: [],\n    edges: {},\n    edgeIndices: [],\n    emitter: {\n      on: bind$52(_context = this.on).call(_context, this),\n      off: bind$52(_context2 = this.off).call(_context2, this),\n      emit: bind$52(_context3 = this.emit).call(_context3, this),\n      once: bind$52(_context4 = this.once).call(_context4, this)\n    },\n    eventListeners: {\n      onTap: function onTap() {\n      },\n      onTouch: function onTouch2() {\n      },\n      onDoubleTap: function onDoubleTap() {\n      },\n      onHold: function onHold() {\n      },\n      onDragStart: function onDragStart() {\n      },\n      onDrag: function onDrag() {\n      },\n      onDragEnd: function onDragEnd() {\n      },\n      onMouseWheel: function onMouseWheel() {\n      },\n      onPinch: function onPinch() {\n      },\n      onMouseMove: function onMouseMove() {\n      },\n      onRelease: function onRelease2() {\n      },\n      onContext: function onContext() {\n      }\n    },\n    data: {\n      nodes: null,\n      edges: null\n    },\n    functions: {\n      createNode: function createNode() {\n      },\n      createEdge: function createEdge2() {\n      },\n      getPointer: function getPointer() {\n      }\n    },\n    modules: {},\n    view: {\n      scale: 1,\n      translation: {\n        x: 0,\n        y: 0\n      }\n    },\n    selectionBox: {\n      show: false,\n      position: {\n        start: {\n          x: 0,\n          y: 0\n        },\n        end: {\n          x: 0,\n          y: 0\n        }\n      }\n    }\n  };\n  this.bindEventListeners();\n  this.images = new Images(function() {\n    return _this.body.emitter.emit(\"_requestRedraw\");\n  });\n  this.groups = new Groups();\n  this.canvas = new Canvas(this.body);\n  this.selectionHandler = new SelectionHandler(this.body, this.canvas);\n  this.interactionHandler = new InteractionHandler(this.body, this.canvas, this.selectionHandler);\n  this.view = new View(this.body, this.canvas);\n  this.renderer = new CanvasRenderer(this.body, this.canvas);\n  this.physics = new PhysicsEngine(this.body);\n  this.layoutEngine = new LayoutEngine(this.body);\n  this.clustering = new ClusterEngine(this.body);\n  this.manipulation = new ManipulationSystem(this.body, this.canvas, this.selectionHandler, this.interactionHandler);\n  this.nodesHandler = new NodesHandler(this.body, this.images, this.groups, this.layoutEngine);\n  this.edgesHandler = new EdgesHandler(this.body, this.images, this.groups);\n  this.body.modules[\"kamadaKawai\"] = new KamadaKawai(this.body, 150, 0.05);\n  this.body.modules[\"clustering\"] = this.clustering;\n  this.canvas._create();\n  this.setOptions(options2);\n  this.setData(data22);\n}\nEmitter2(Network.prototype);\nNetwork.prototype.setOptions = function(options2) {\n  var _this2 = this;\n  if (options2 === null) {\n    options2 = void 0;\n  }\n  if (options2 !== void 0) {\n    var errorFound2 = Validator.validate(options2, allOptions);\n    if (errorFound2 === true) {\n      console.error(\"%cErrors have been found in the supplied options object.\", VALIDATOR_PRINT_STYLE);\n    }\n    var fields = [\"locale\", \"locales\", \"clickToUse\"];\n    selectiveDeepExtend(fields, this.options, options2);\n    if (options2.locale !== void 0) {\n      options2.locale = normalizeLanguageCode(options2.locales || this.options.locales, options2.locale);\n    }\n    options2 = this.layoutEngine.setOptions(options2.layout, options2);\n    this.canvas.setOptions(options2);\n    this.groups.setOptions(options2.groups);\n    this.nodesHandler.setOptions(options2.nodes);\n    this.edgesHandler.setOptions(options2.edges);\n    this.physics.setOptions(options2.physics);\n    this.manipulation.setOptions(options2.manipulation, options2, this.options);\n    this.interactionHandler.setOptions(options2.interaction);\n    this.renderer.setOptions(options2.interaction);\n    this.selectionHandler.setOptions(options2.interaction);\n    if (options2.groups !== void 0) {\n      this.body.emitter.emit(\"refreshNodes\");\n    }\n    if (\"configure\" in options2) {\n      if (!this.configurator) {\n        this.configurator = new Configurator(this, this.body.container, configureOptions, this.canvas.pixelRatio, configuratorHideOption);\n      }\n      this.configurator.setOptions(options2.configure);\n    }\n    if (this.configurator && this.configurator.options.enabled === true) {\n      var networkOptions = {\n        nodes: {},\n        edges: {},\n        layout: {},\n        interaction: {},\n        manipulation: {},\n        physics: {},\n        global: {}\n      };\n      deepExtend(networkOptions.nodes, this.nodesHandler.options);\n      deepExtend(networkOptions.edges, this.edgesHandler.options);\n      deepExtend(networkOptions.layout, this.layoutEngine.options);\n      deepExtend(networkOptions.interaction, this.selectionHandler.options);\n      deepExtend(networkOptions.interaction, this.renderer.options);\n      deepExtend(networkOptions.interaction, this.interactionHandler.options);\n      deepExtend(networkOptions.manipulation, this.manipulation.options);\n      deepExtend(networkOptions.physics, this.physics.options);\n      deepExtend(networkOptions.global, this.canvas.options);\n      deepExtend(networkOptions.global, this.options);\n      this.configurator.setModuleOptions(networkOptions);\n    }\n    if (options2.clickToUse !== void 0) {\n      if (options2.clickToUse === true) {\n        if (this.activator === void 0) {\n          this.activator = new Activator(this.canvas.frame);\n          this.activator.on(\"change\", function() {\n            _this2.body.emitter.emit(\"activate\");\n          });\n        }\n      } else {\n        if (this.activator !== void 0) {\n          this.activator.destroy();\n          delete this.activator;\n        }\n        this.body.emitter.emit(\"activate\");\n      }\n    } else {\n      this.body.emitter.emit(\"activate\");\n    }\n    this.canvas.setSize();\n    this.body.emitter.emit(\"startSimulation\");\n  }\n};\nNetwork.prototype._updateVisibleIndices = function() {\n  var nodes = this.body.nodes;\n  var edges = this.body.edges;\n  this.body.nodeIndices = [];\n  this.body.edgeIndices = [];\n  for (var nodeId in nodes) {\n    if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n      if (!this.clustering._isClusteredNode(nodeId) && nodes[nodeId].options.hidden === false) {\n        this.body.nodeIndices.push(nodes[nodeId].id);\n      }\n    }\n  }\n  for (var edgeId in edges) {\n    if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {\n      var edge = edges[edgeId];\n      var fromNode = nodes[edge.fromId];\n      var toNode = nodes[edge.toId];\n      var edgeNodesPresent = fromNode !== void 0 && toNode !== void 0;\n      var isVisible = !this.clustering._isClusteredEdge(edgeId) && edge.options.hidden === false && edgeNodesPresent && fromNode.options.hidden === false && toNode.options.hidden === false;\n      if (isVisible) {\n        this.body.edgeIndices.push(edge.id);\n      }\n    }\n  }\n};\nNetwork.prototype.bindEventListeners = function() {\n  var _this3 = this;\n  this.body.emitter.on(\"_dataChanged\", function() {\n    _this3.edgesHandler._updateState();\n    _this3.body.emitter.emit(\"_dataUpdated\");\n  });\n  this.body.emitter.on(\"_dataUpdated\", function() {\n    _this3.clustering._updateState();\n    _this3._updateVisibleIndices();\n    _this3._updateValueRange(_this3.body.nodes);\n    _this3._updateValueRange(_this3.body.edges);\n    _this3.body.emitter.emit(\"startSimulation\");\n    _this3.body.emitter.emit(\"_requestRedraw\");\n  });\n};\nNetwork.prototype.setData = function(data22) {\n  this.body.emitter.emit(\"resetPhysics\");\n  this.body.emitter.emit(\"_resetData\");\n  this.selectionHandler.unselectAll();\n  if (data22 && data22.dot && (data22.nodes || data22.edges)) {\n    throw new SyntaxError('Data must contain either parameter \"dot\" or  parameter pair \"nodes\" and \"edges\", but not both.');\n  }\n  this.setOptions(data22 && data22.options);\n  if (data22 && data22.dot) {\n    console.warn(\"The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);\");\n    var dotData = DOTToGraph(data22.dot);\n    this.setData(dotData);\n    return;\n  } else if (data22 && data22.gephi) {\n    console.warn(\"The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);\");\n    var gephiData = parseGephi(data22.gephi);\n    this.setData(gephiData);\n    return;\n  } else {\n    this.nodesHandler.setData(data22 && data22.nodes, true);\n    this.edgesHandler.setData(data22 && data22.edges, true);\n  }\n  this.body.emitter.emit(\"_dataChanged\");\n  this.body.emitter.emit(\"_dataLoaded\");\n  this.body.emitter.emit(\"initPhysics\");\n};\nNetwork.prototype.destroy = function() {\n  this.body.emitter.emit(\"destroy\");\n  this.body.emitter.off();\n  this.off();\n  delete this.groups;\n  delete this.canvas;\n  delete this.selectionHandler;\n  delete this.interactionHandler;\n  delete this.view;\n  delete this.renderer;\n  delete this.physics;\n  delete this.layoutEngine;\n  delete this.clustering;\n  delete this.manipulation;\n  delete this.nodesHandler;\n  delete this.edgesHandler;\n  delete this.configurator;\n  delete this.images;\n  for (var nodeId in this.body.nodes) {\n    if (!Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId))\n      continue;\n    delete this.body.nodes[nodeId];\n  }\n  for (var edgeId in this.body.edges) {\n    if (!Object.prototype.hasOwnProperty.call(this.body.edges, edgeId))\n      continue;\n    delete this.body.edges[edgeId];\n  }\n  recursiveDOMDelete(this.body.container);\n};\nNetwork.prototype._updateValueRange = function(obj) {\n  var id22;\n  var valueMin = void 0;\n  var valueMax = void 0;\n  var valueTotal = 0;\n  for (id22 in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, id22)) {\n      var value = obj[id22].getValue();\n      if (value !== void 0) {\n        valueMin = valueMin === void 0 ? value : Math.min(value, valueMin);\n        valueMax = valueMax === void 0 ? value : Math.max(value, valueMax);\n        valueTotal += value;\n      }\n    }\n  }\n  if (valueMin !== void 0 && valueMax !== void 0) {\n    for (id22 in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, id22)) {\n        obj[id22].setValueRange(valueMin, valueMax, valueTotal);\n      }\n    }\n  }\n};\nNetwork.prototype.isActive = function() {\n  return !this.activator || this.activator.active;\n};\nNetwork.prototype.setSize = function() {\n  return this.canvas.setSize.apply(this.canvas, arguments);\n};\nNetwork.prototype.canvasToDOM = function() {\n  return this.canvas.canvasToDOM.apply(this.canvas, arguments);\n};\nNetwork.prototype.DOMtoCanvas = function() {\n  return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);\n};\nNetwork.prototype.findNode = function() {\n  return this.clustering.findNode.apply(this.clustering, arguments);\n};\nNetwork.prototype.isCluster = function() {\n  return this.clustering.isCluster.apply(this.clustering, arguments);\n};\nNetwork.prototype.openCluster = function() {\n  return this.clustering.openCluster.apply(this.clustering, arguments);\n};\nNetwork.prototype.cluster = function() {\n  return this.clustering.cluster.apply(this.clustering, arguments);\n};\nNetwork.prototype.getNodesInCluster = function() {\n  return this.clustering.getNodesInCluster.apply(this.clustering, arguments);\n};\nNetwork.prototype.clusterByConnection = function() {\n  return this.clustering.clusterByConnection.apply(this.clustering, arguments);\n};\nNetwork.prototype.clusterByHubsize = function() {\n  return this.clustering.clusterByHubsize.apply(this.clustering, arguments);\n};\nNetwork.prototype.updateClusteredNode = function() {\n  return this.clustering.updateClusteredNode.apply(this.clustering, arguments);\n};\nNetwork.prototype.getClusteredEdges = function() {\n  return this.clustering.getClusteredEdges.apply(this.clustering, arguments);\n};\nNetwork.prototype.getBaseEdge = function() {\n  return this.clustering.getBaseEdge.apply(this.clustering, arguments);\n};\nNetwork.prototype.getBaseEdges = function() {\n  return this.clustering.getBaseEdges.apply(this.clustering, arguments);\n};\nNetwork.prototype.updateEdge = function() {\n  return this.clustering.updateEdge.apply(this.clustering, arguments);\n};\nNetwork.prototype.clusterOutliers = function() {\n  return this.clustering.clusterOutliers.apply(this.clustering, arguments);\n};\nNetwork.prototype.getSeed = function() {\n  return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);\n};\nNetwork.prototype.enableEditMode = function() {\n  return this.manipulation.enableEditMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.disableEditMode = function() {\n  return this.manipulation.disableEditMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.addNodeMode = function() {\n  return this.manipulation.addNodeMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.editNode = function() {\n  return this.manipulation.editNode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.editNodeMode = function() {\n  console.warn(\"Deprecated: Please use editNode instead of editNodeMode.\");\n  return this.manipulation.editNode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.addEdgeMode = function() {\n  return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.editEdgeMode = function() {\n  return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.deleteSelected = function() {\n  return this.manipulation.deleteSelected.apply(this.manipulation, arguments);\n};\nNetwork.prototype.getPositions = function() {\n  return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.getPosition = function() {\n  return this.nodesHandler.getPosition.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.storePositions = function() {\n  return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.moveNode = function() {\n  return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.getBoundingBox = function() {\n  return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.getConnectedNodes = function(objectId) {\n  if (this.body.nodes[objectId] !== void 0) {\n    return this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments);\n  } else {\n    return this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);\n  }\n};\nNetwork.prototype.getConnectedEdges = function() {\n  return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.startSimulation = function() {\n  return this.physics.startSimulation.apply(this.physics, arguments);\n};\nNetwork.prototype.stopSimulation = function() {\n  return this.physics.stopSimulation.apply(this.physics, arguments);\n};\nNetwork.prototype.stabilize = function() {\n  return this.physics.stabilize.apply(this.physics, arguments);\n};\nNetwork.prototype.getSelection = function() {\n  return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.setSelection = function() {\n  return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.getSelectedNodes = function() {\n  return this.selectionHandler.getSelectedNodeIds.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.getSelectedEdges = function() {\n  return this.selectionHandler.getSelectedEdgeIds.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.getNodeAt = function() {\n  var node = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);\n  if (node !== void 0 && node.id !== void 0) {\n    return node.id;\n  }\n  return node;\n};\nNetwork.prototype.getEdgeAt = function() {\n  var edge = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);\n  if (edge !== void 0 && edge.id !== void 0) {\n    return edge.id;\n  }\n  return edge;\n};\nNetwork.prototype.selectNodes = function() {\n  return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.selectEdges = function() {\n  return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.unselectAll = function() {\n  this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments);\n  this.selectionHandler.commitWithoutEmitting.apply(this.selectionHandler);\n  this.redraw();\n};\nNetwork.prototype.redraw = function() {\n  return this.renderer.redraw.apply(this.renderer, arguments);\n};\nNetwork.prototype.getScale = function() {\n  return this.view.getScale.apply(this.view, arguments);\n};\nNetwork.prototype.getViewPosition = function() {\n  return this.view.getViewPosition.apply(this.view, arguments);\n};\nNetwork.prototype.fit = function() {\n  return this.view.fit.apply(this.view, arguments);\n};\nNetwork.prototype.moveTo = function() {\n  return this.view.moveTo.apply(this.view, arguments);\n};\nNetwork.prototype.focus = function() {\n  return this.view.focus.apply(this.view, arguments);\n};\nNetwork.prototype.releaseNode = function() {\n  return this.view.releaseNode.apply(this.view, arguments);\n};\nNetwork.prototype.getOptionsFromConfigurator = function() {\n  var options2 = {};\n  if (this.configurator) {\n    options2 = this.configurator.getOptions.apply(this.configurator);\n  }\n  return options2;\n};\n\n// definyRpc/clientEditor/Chart.tsx\nvar SampleChart = () => {\n  const ref = We.useRef(null);\n  We.useEffect(() => {\n    const container = ref.current;\n    if (container === null) {\n      return;\n    }\n    const graph2d = new Network(\n      container,\n      {\n        nodes: [\n          { id: \"aId\", label: \"a\", shape: \"circle\" },\n          { id: \"bId\", label: \"b\", shape: \"circle\" }\n        ],\n        edges: [{ id: \"edgeId\", arrows: \"to\", from: \"aId\", to: \"bId\" }]\n      },\n      { width: \"200\", height: \"200\" }\n    );\n    console.log(graph2d);\n  }, [ref.current]);\n  return /* @__PURE__ */ We.createElement(\"div\", {\n    ref\n  });\n};\n\n// https://raw.githubusercontent.com/narumincho/definy/f662850e6a0cb9ec7a69e60f424624c07dd417fa/deno-lib/definyRpc/core/coreType.ts\nvar String3 = {\n  type: () => Type4.from({\n    namespace: Namespace2.coreType,\n    name: \"String\",\n    parameters: []\n  })\n};\nvar Unit = {\n  type: () => Type4.from({ namespace: Namespace2.coreType, name: \"Unit\", parameters: [] })\n};\nvar Bool2 = {\n  type: () => Type4.from({ namespace: Namespace2.coreType, name: \"Bool\", parameters: [] })\n};\nvar StructuredJsonValue2 = {\n  type: () => Type4.from({\n    namespace: Namespace2.coreType,\n    name: \"StructuredJsonValue\",\n    parameters: []\n  }),\n  string: (p) => ({\n    type: \"string\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.StructuredJsonValue\"\n  }),\n  array: (p) => ({\n    type: \"array\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.StructuredJsonValue\"\n  }),\n  boolean: (p) => ({\n    type: \"boolean\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.StructuredJsonValue\"\n  }),\n  null: { type: \"null\", [Symbol.toStringTag]: \"*coreType.StructuredJsonValue\" },\n  number: (p) => ({\n    type: \"number\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.StructuredJsonValue\"\n  }),\n  object: (p) => ({\n    type: \"object\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.StructuredJsonValue\"\n  })\n};\nvar List2 = {\n  type: (element) => Type4.from({\n    namespace: Namespace2.coreType,\n    name: \"List\",\n    parameters: [element]\n  })\n};\nvar Maybe2 = {\n  type: (element) => Type4.from({\n    namespace: Namespace2.coreType,\n    name: \"Maybe\",\n    parameters: [element]\n  }),\n  just: (p) => ({\n    type: \"just\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.Maybe\"\n  }),\n  nothing: () => ({\n    type: \"nothing\",\n    [Symbol.toStringTag]: \"*coreType.Maybe\"\n  })\n};\nvar Result5 = {\n  type: (ok, error) => Type4.from({\n    namespace: Namespace2.coreType,\n    name: \"Result\",\n    parameters: [ok, error]\n  }),\n  ok: (p) => ({\n    type: \"ok\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.Result\"\n  }),\n  error: (p) => ({\n    type: \"error\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.Result\"\n  })\n};\nvar Namespace2 = {\n  type: () => Type4.from({\n    namespace: Namespace2.coreType,\n    name: \"Namespace\",\n    parameters: []\n  }),\n  local: (p) => ({\n    type: \"local\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.Namespace\"\n  }),\n  coreType: { type: \"coreType\", [Symbol.toStringTag]: \"*coreType.Namespace\" },\n  typedJson: { type: \"typedJson\", [Symbol.toStringTag]: \"*coreType.Namespace\" },\n  request: { type: \"request\", [Symbol.toStringTag]: \"*coreType.Namespace\" },\n  meta: { type: \"meta\", [Symbol.toStringTag]: \"*coreType.Namespace\" }\n};\nvar DefinyRpcTypeInfo3 = {\n  type: () => Type4.from({\n    namespace: Namespace2.coreType,\n    name: \"DefinyRpcTypeInfo\",\n    parameters: []\n  }),\n  from: (obj) => ({\n    namespace: obj.namespace,\n    name: obj.name,\n    description: obj.description,\n    parameter: obj.parameter,\n    attribute: obj.attribute,\n    body: obj.body,\n    [Symbol.toStringTag]: \"*coreType.DefinyRpcTypeInfo\"\n  })\n};\nvar TypeParameterInfo3 = {\n  type: () => Type4.from({\n    namespace: Namespace2.coreType,\n    name: \"TypeParameterInfo\",\n    parameters: []\n  }),\n  from: (obj) => ({\n    name: obj.name,\n    description: obj.description,\n    [Symbol.toStringTag]: \"*coreType.TypeParameterInfo\"\n  })\n};\nvar TypeAttribute2 = {\n  type: () => Type4.from({\n    namespace: Namespace2.coreType,\n    name: \"TypeAttribute\",\n    parameters: []\n  }),\n  asType: { type: \"asType\", [Symbol.toStringTag]: \"*coreType.TypeAttribute\" }\n};\nvar TypeBody2 = {\n  type: () => Type4.from({\n    namespace: Namespace2.coreType,\n    name: \"TypeBody\",\n    parameters: []\n  }),\n  string: { type: \"string\", [Symbol.toStringTag]: \"*coreType.TypeBody\" },\n  number: { type: \"number\", [Symbol.toStringTag]: \"*coreType.TypeBody\" },\n  boolean: { type: \"boolean\", [Symbol.toStringTag]: \"*coreType.TypeBody\" },\n  unit: { type: \"unit\", [Symbol.toStringTag]: \"*coreType.TypeBody\" },\n  list: { type: \"list\", [Symbol.toStringTag]: \"*coreType.TypeBody\" },\n  set: { type: \"set\", [Symbol.toStringTag]: \"*coreType.TypeBody\" },\n  map: { type: \"map\", [Symbol.toStringTag]: \"*coreType.TypeBody\" },\n  url: { type: \"url\", [Symbol.toStringTag]: \"*coreType.TypeBody\" },\n  product: (p) => ({\n    type: \"product\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.TypeBody\"\n  }),\n  sum: (p) => ({\n    type: \"sum\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.TypeBody\"\n  })\n};\nvar Field3 = {\n  type: () => Type4.from({ namespace: Namespace2.coreType, name: \"Field\", parameters: [] }),\n  from: (obj) => ({\n    name: obj.name,\n    description: obj.description,\n    type: obj.type,\n    [Symbol.toStringTag]: \"*coreType.Field\"\n  })\n};\nvar Pattern2 = {\n  type: () => Type4.from({\n    namespace: Namespace2.coreType,\n    name: \"Pattern\",\n    parameters: []\n  }),\n  from: (obj) => ({\n    name: obj.name,\n    description: obj.description,\n    parameter: obj.parameter,\n    [Symbol.toStringTag]: \"*coreType.Pattern\"\n  })\n};\nvar Type4 = {\n  type: () => Type4.from({ namespace: Namespace2.coreType, name: \"Type\", parameters: [] }),\n  from: (obj) => ({\n    namespace: obj.namespace,\n    name: obj.name,\n    parameters: obj.parameters,\n    [Symbol.toStringTag]: \"*coreType.Type\",\n    __typeVariable: {}\n  })\n};\nvar FunctionNamespace4 = {\n  type: () => Type4.from({\n    namespace: Namespace2.coreType,\n    name: \"FunctionNamespace\",\n    parameters: []\n  }),\n  meta: { type: \"meta\", [Symbol.toStringTag]: \"*coreType.FunctionNamespace\" },\n  local: (p) => ({\n    type: \"local\",\n    value: p,\n    [Symbol.toStringTag]: \"*coreType.FunctionNamespace\"\n  })\n};\nvar FunctionDetail2 = {\n  type: () => Type4.from({\n    namespace: Namespace2.coreType,\n    name: \"FunctionDetail\",\n    parameters: []\n  }),\n  from: (obj) => ({\n    namespace: obj.namespace,\n    name: obj.name,\n    description: obj.description,\n    input: obj.input,\n    output: obj.output,\n    needAuthentication: obj.needAuthentication,\n    isMutation: obj.isMutation,\n    [Symbol.toStringTag]: \"*coreType.FunctionDetail\"\n  })\n};\n\n// https://raw.githubusercontent.com/narumincho/definy/f662850e6a0cb9ec7a69e60f424624c07dd417fa/deno-lib/typedJson.ts\nvar jsonParse2 = (value) => {\n  try {\n    return JSON.parse(value);\n  } catch (e) {\n    console.error(\"json \\u306E\\u30D1\\u30FC\\u30B9\\u30A8\\u30E9\\u30FC\", e);\n    return void 0;\n  }\n};\nvar structuredJsonParse2 = (value) => {\n  const rawJson = jsonParse2(value);\n  if (rawJson === void 0) {\n    return void 0;\n  }\n  return rawJsonToStructuredJsonValue2(rawJson);\n};\nvar rawJsonToStructuredJsonValue2 = (rawJson) => {\n  if (rawJson === null) {\n    return StructuredJsonValue2.null;\n  }\n  if (typeof rawJson === \"boolean\") {\n    return StructuredJsonValue2.boolean(rawJson);\n  }\n  if (typeof rawJson === \"string\") {\n    return StructuredJsonValue2.string(rawJson);\n  }\n  if (typeof rawJson === \"number\") {\n    return StructuredJsonValue2.number(rawJson);\n  }\n  if (rawJson instanceof Array) {\n    return StructuredJsonValue2.array(rawJson.map(rawJsonToStructuredJsonValue2));\n  }\n  return StructuredJsonValue2.object(\n    new Map(\n      Object.entries(rawJson).map(([k2, v]) => [\n        k2,\n        rawJsonToStructuredJsonValue2(v)\n      ])\n    )\n  );\n};\nvar jsonStringify2 = (jsonValue, indent = false) => {\n  if (indent) {\n    return JSON.stringify(jsonValue, void 0, 2);\n  }\n  return JSON.stringify(jsonValue);\n};\nvar structuredJsonStringify2 = (structuredJsonValue2, indent = false) => {\n  return jsonStringify2(\n    structuredJsonValueToRawJson2(structuredJsonValue2),\n    indent\n  );\n};\nvar structuredJsonValueToRawJson2 = (structuredJsonValue2) => {\n  switch (structuredJsonValue2.type) {\n    case \"null\":\n      return null;\n    case \"string\":\n      return structuredJsonValue2.value;\n    case \"number\":\n      return structuredJsonValue2.value;\n    case \"boolean\":\n      return structuredJsonValue2.value;\n    case \"array\":\n      return structuredJsonValue2.value.map(structuredJsonValueToRawJson2);\n    case \"object\":\n      return Object.fromEntries(\n        [...structuredJsonValue2.value.entries()].map(\n          ([k2, v]) => [k2, structuredJsonValueToRawJson2(v)]\n        )\n      );\n  }\n};\n\n// https://raw.githubusercontent.com/narumincho/definy/f662850e6a0cb9ec7a69e60f424624c07dd417fa/deno-lib/definyRpc/codeGen/namespace.ts\nvar namespaceToString2 = (namespace) => {\n  switch (namespace.type) {\n    case \"typedJson\":\n      return \"*typedJson\";\n    case \"request\":\n      return \"*request\";\n    case \"coreType\":\n      return \"*coreType\";\n    case \"meta\":\n      return \"*meta\";\n    case \"local\":\n      return namespace.value.join(\".\");\n  }\n};\n\n// https://raw.githubusercontent.com/narumincho/definy/f662850e6a0cb9ec7a69e60f424624c07dd417fa/deno-lib/definyRpc/core/collectType.ts\nvar createTypeKey2 = (namespace, typeName) => {\n  return namespaceToString2(namespace) + \".\" + typeName;\n};\nvar collectedDefinyRpcTypeMapGet2 = (map4, namespace, typeName) => {\n  const typeInfo = map4.get(createTypeKey2(namespace, typeName));\n  if (typeInfo === void 0) {\n    throw new Error(\n      \"type (\" + createTypeKey2(namespace, typeName) + \") not found\"\n    );\n  }\n  return typeInfo;\n};\n\n// https://raw.githubusercontent.com/narumincho/definy/f662850e6a0cb9ec7a69e60f424624c07dd417fa/deno-lib/definyRpc/core/fromStructuredJson.ts\nvar changeType2 = (type2) => type2;\nvar fromStructuredJsonValue2 = (type2, typeMap, jsonValue) => {\n  const typeInfo = collectedDefinyRpcTypeMapGet2(\n    typeMap,\n    type2.namespace,\n    type2.name\n  );\n  switch (typeInfo.body.type) {\n    case \"string\": {\n      if (jsonValue.type !== \"string\") {\n        throw new Error(\n          `expected json string in String type (${createTypeKey2(type2.namespace, type2.name)})`\n        );\n      }\n      return jsonValue.value;\n    }\n    case \"number\": {\n      if (jsonValue.type !== \"number\") {\n        throw new Error(\n          `expected json number in Number type (${createTypeKey2(type2.namespace, type2.name)})`\n        );\n      }\n      return jsonValue.value;\n    }\n    case \"boolean\": {\n      if (jsonValue.type !== \"boolean\") {\n        throw new Error(\n          `expected json boolean in Bool type (${createTypeKey2(type2.namespace, type2.name)})`\n        );\n      }\n      return jsonValue.value;\n    }\n    case \"unit\": {\n      return void 0;\n    }\n    case \"list\": {\n      const [elementType] = type2.parameters;\n      if (elementType === void 0) {\n        throw new Error(\n          `expected type parameter in List type (${createTypeKey2(type2.namespace, type2.name)})`\n        );\n      }\n      if (jsonValue.type !== \"array\") {\n        throw new Error(\n          `expected json array in List type (${createTypeKey2(type2.namespace, type2.name)})`\n        );\n      }\n      return jsonValue.value.map(\n        (element) => fromStructuredJsonValueConsiderTypeParameter2(\n          type2.parameters,\n          typeInfo.parameter,\n          elementType,\n          typeMap,\n          element\n        )\n      );\n    }\n    case \"set\": {\n      const [elementType] = type2.parameters;\n      if (elementType === void 0) {\n        throw new Error(\n          `expected type parameter in Set type (${createTypeKey2(type2.namespace, type2.name)})`\n        );\n      }\n      if (jsonValue.type !== \"array\") {\n        throw new Error(\n          `expected json array in List type (${createTypeKey2(type2.namespace, type2.name)})`\n        );\n      }\n      return new Set(\n        jsonValue.value.map(\n          (element) => fromStructuredJsonValueConsiderTypeParameter2(\n            type2.parameters,\n            typeInfo.parameter,\n            elementType,\n            typeMap,\n            element\n          )\n        )\n      );\n    }\n    case \"map\":\n      return toMap2(\n        changeType2(type2),\n        typeInfo,\n        typeMap,\n        jsonValue\n      );\n    case \"url\": {\n      if (jsonValue.type !== \"string\") {\n        throw new Error(\n          `expected json string in URL (${createTypeKey2(type2.namespace, type2.name)})`\n        );\n      }\n      return new URL(jsonValue.value);\n    }\n    case \"product\":\n      return toProduct2(\n        changeType2(type2),\n        typeInfo,\n        typeMap,\n        jsonValue,\n        typeInfo.body.value\n      );\n    case \"sum\":\n      return toSum2(\n        changeType2(type2),\n        typeInfo,\n        typeMap,\n        jsonValue,\n        typeInfo.body.value\n      );\n  }\n};\nvar toMap2 = (type2, typeInfo, typeMap, jsonValue) => {\n  const [keyType, valueType] = type2.parameters;\n  if (keyType === void 0 || valueType === void 0) {\n    throw new Error(\n      `expected 2 type parameter in Map type (${createTypeKey2(type2.namespace, type2.name)})`\n    );\n  }\n  if (jsonValue.type !== \"object\") {\n    throw new Error(\n      `expected json object in Map type (${createTypeKey2(type2.namespace, type2.name)})`\n    );\n  }\n  return new Map(\n    [...jsonValue.value].map(\n      ([key, valueJson]) => {\n        const keyTypeInfo = collectedDefinyRpcTypeMapGet2(\n          typeMap,\n          keyType.namespace,\n          keyType.name\n        );\n        if (keyTypeInfo.body.type === \"string\") {\n          return [\n            key,\n            fromStructuredJsonValueConsiderTypeParameter2(\n              type2.parameters,\n              typeInfo.parameter,\n              changeType2(valueType),\n              typeMap,\n              valueJson\n            )\n          ];\n        }\n        const keyJson = structuredJsonParse2(key);\n        if (keyJson === void 0) {\n          throw new Error(\n            `Map \\u578B\\u306E\\u3068\\u304D\\u306B key \\u304C string \\u4EE5\\u5916\\u3067\\u306E\\u5834\\u5408\\u306F json \\u3068\\u3057\\u3066\\u89E3\\u91C8\\u3067\\u304D\\u308B\\u6587\\u5B57\\u5217\\u3067\\u3042\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059 (${createTypeKey2(type2.namespace, type2.name)})`\n          );\n        }\n        return [\n          fromStructuredJsonValueConsiderTypeParameter2(\n            type2.parameters,\n            typeInfo.parameter,\n            changeType2(keyType),\n            typeMap,\n            keyJson\n          ),\n          fromStructuredJsonValueConsiderTypeParameter2(\n            type2.parameters,\n            typeInfo.parameter,\n            changeType2(valueType),\n            typeMap,\n            valueJson\n          )\n        ];\n      }\n    )\n  );\n};\nvar toProduct2 = (type2, typeInfo, typeMap, jsonValue, fields) => {\n  if (jsonValue.type !== \"object\") {\n    throw new Error(\n      `expected json object in product (${createTypeKey2(type2.namespace, type2.name)})`\n    );\n  }\n  return Object.fromEntries([\n    ...fields.map((field2) => {\n      const fieldValueJson = jsonValue.value.get(field2.name);\n      if (fieldValueJson === void 0) {\n        throw new Error(\n          `${createTypeKey2(type2.namespace, type2.name)} need ${field2.name} field (${createTypeKey2(type2.namespace, type2.name)})`\n        );\n      }\n      return [\n        field2.name,\n        fromStructuredJsonValueConsiderTypeParameter2(\n          type2.parameters,\n          typeInfo.parameter,\n          changeType2(field2.type),\n          typeMap,\n          fieldValueJson\n        )\n      ];\n    }),\n    [\n      Symbol.toStringTag,\n      createTypeKey2(type2.namespace, type2.name)\n    ]\n  ]);\n};\nvar toSum2 = (type2, typeInfo, typeMap, jsonValue, patternList) => {\n  if (jsonValue.type === \"string\") {\n    for (const pattern2 of patternList) {\n      if (pattern2.name === jsonValue.value) {\n        if (pattern2.parameter.type === \"just\") {\n          throw new Error(\n            `expected json object in sum pattern with parameter (${createTypeKey2(type2.namespace, type2.name)})`\n          );\n        }\n        return {\n          type: pattern2.name,\n          [Symbol.toStringTag]: createTypeKey2(\n            type2.namespace,\n            type2.name\n          )\n        };\n      }\n    }\n    throw new Error(\n      `unknown pattern name expected [${patternList.map((p) => p.name).join(\",\")}] but got ${jsonValue.value} (${createTypeKey2(type2.namespace, type2.name)})`\n    );\n  }\n  if (jsonValue.type === \"object\") {\n    const typeFieldJson = jsonValue.value.get(\"type\");\n    if (typeFieldJson?.type !== \"string\") {\n      throw new Error(\n        `expected json string in sum pattern key (${createTypeKey2(type2.namespace, type2.name)})`\n      );\n    }\n    for (const pattern2 of patternList) {\n      if (pattern2.name === typeFieldJson.value) {\n        if (pattern2.parameter.type === \"just\") {\n          const valueJson = jsonValue.value.get(\"value\");\n          if (valueJson === void 0) {\n            throw new Error(\n              `expected value field in sum pattern with parameter (${createTypeKey2(type2.namespace, type2.name)})`\n            );\n          }\n          return {\n            type: pattern2.name,\n            value: fromStructuredJsonValueConsiderTypeParameter2(\n              type2.parameters,\n              typeInfo.parameter,\n              pattern2.parameter.value,\n              typeMap,\n              valueJson\n            ),\n            [Symbol.toStringTag]: createTypeKey2(\n              type2.namespace,\n              type2.name\n            )\n          };\n        }\n        return {\n          type: pattern2.name,\n          [Symbol.toStringTag]: createTypeKey2(\n            type2.namespace,\n            type2.name\n          )\n        };\n      }\n    }\n    throw new Error(\n      `unknown pattern name expected [${patternList.map((p) => p.name).join(\",\")}] but got ${jsonValue.value} (${createTypeKey2(type2.namespace, type2.name)})`\n    );\n  }\n  throw new Error(\n    `expected json object or string in sum (${createTypeKey2(type2.namespace, type2.name)})`\n  );\n};\nvar fromStructuredJsonValueConsiderTypeParameter2 = (typeParameters, typeParameterInfoList, type2, typeMap, jsonValue) => {\n  if (typeParameters.length !== typeParameterInfoList.length) {\n    throw new Error(\n      \"\\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u306E\\u6570\\u304C\\u5408\\u308F\\u306A\\u3044! expected:\" + typeParameterInfoList.length + \" but got:\" + typeParameters.length\n    );\n  }\n  for (const [index2, typeParameter] of typeParameterInfoList.entries()) {\n    if (typeParameter.name === type2.name) {\n      const matchedTypeParameter = typeParameters[index2];\n      if (matchedTypeParameter === void 0) {\n        throw new Error(\"\\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u306E\\u6570\\u304C\\u5408\\u308F\\u306A\\u3044?\");\n      }\n      return fromStructuredJsonValue2(\n        changeType2(matchedTypeParameter),\n        typeMap,\n        jsonValue\n      );\n    }\n  }\n  return fromStructuredJsonValue2(\n    type2,\n    typeMap,\n    jsonValue\n  );\n};\n\n// https://raw.githubusercontent.com/narumincho/definy/f662850e6a0cb9ec7a69e60f424624c07dd417fa/deno-lib/definyRpc/core/toStructuredJson.ts\nvar toStructuredJsonValue2 = (type2, typeMap, value) => {\n  const typeInfo = collectedDefinyRpcTypeMapGet2(\n    typeMap,\n    type2.namespace,\n    type2.name\n  );\n  switch (typeInfo.body.type) {\n    case \"string\":\n      if (typeof value !== \"string\") {\n        throw new Error(\"expected string in toStructuredJsonValue\");\n      }\n      return StructuredJsonValue2.string(value);\n    case \"number\":\n      if (typeof value !== \"number\") {\n        throw new Error(\"expected number in toStructuredJsonValue\");\n      }\n      return StructuredJsonValue2.number(value);\n    case \"boolean\":\n      if (typeof value !== \"boolean\") {\n        throw new Error(\"expected boolean in toStructuredJsonValue\");\n      }\n      return StructuredJsonValue2.boolean(value);\n    case \"unit\":\n      return StructuredJsonValue2.null;\n    case \"list\": {\n      if (!(value instanceof Array)) {\n        throw new Error(\"expected Array in toStructuredJsonValue\");\n      }\n      const [elementType] = type2.parameters;\n      if (elementType === void 0) {\n        throw new Error(\n          `expected type parameter in List type (${createTypeKey2(type2.namespace, type2.name)})`\n        );\n      }\n      return StructuredJsonValue2.array(\n        value.map(\n          (element) => toStructuredJsonValueConsiderTypeParameter2(\n            type2.parameters,\n            typeInfo.parameter,\n            elementType,\n            typeMap,\n            element\n          )\n        )\n      );\n    }\n    case \"set\": {\n      if (!(value instanceof Set)) {\n        throw new Error(\"expected Set in toStructuredJsonValue\");\n      }\n      const [elementType] = type2.parameters;\n      if (elementType === void 0) {\n        throw new Error(\n          `expected type parameter in Set type (${createTypeKey2(type2.namespace, type2.name)})`\n        );\n      }\n      return StructuredJsonValue2.array(\n        [...value].map(\n          (element) => toStructuredJsonValueConsiderTypeParameter2(\n            type2.parameters,\n            typeInfo.parameter,\n            elementType,\n            typeMap,\n            element\n          )\n        )\n      );\n    }\n    case \"map\": {\n      if (!(value instanceof Map)) {\n        throw new Error(\"expected Map in toStructuredJsonValue\");\n      }\n      const [keyType, valueType] = type2.parameters;\n      if (keyType === void 0 || valueType === void 0) {\n        throw new Error(\n          `expected 2 type parameter in Map type (${createTypeKey2(type2.namespace, type2.name)})`\n        );\n      }\n      const keyTypeInfo = collectedDefinyRpcTypeMapGet2(\n        typeMap,\n        keyType.namespace,\n        keyType.name\n      );\n      if (keyTypeInfo.body.type === \"string\") {\n        return StructuredJsonValue2.object(\n          new Map(\n            [...value].map(([key, value2]) => [\n              key,\n              toStructuredJsonValueConsiderTypeParameter2(\n                type2.parameters,\n                typeInfo.parameter,\n                valueType,\n                typeMap,\n                value2\n              )\n            ])\n          )\n        );\n      }\n      return StructuredJsonValue2.object(\n        new Map(\n          [...value].map(([key, value2]) => [\n            structuredJsonStringify2(\n              toStructuredJsonValueConsiderTypeParameter2(\n                type2.parameters,\n                typeInfo.parameter,\n                keyType,\n                typeMap,\n                key\n              )\n            ),\n            toStructuredJsonValueConsiderTypeParameter2(\n              type2.parameters,\n              typeInfo.parameter,\n              valueType,\n              typeMap,\n              value2\n            )\n          ])\n        )\n      );\n    }\n    case \"url\": {\n      if (!(value instanceof URL)) {\n        throw new Error(\"expected Map in toStructuredJsonValue\");\n      }\n      return StructuredJsonValue2.string(value.toString());\n    }\n    case \"product\": {\n      return StructuredJsonValue2.object(\n        new Map(\n          typeInfo.body.value.map((field2) => [\n            field2.name,\n            toStructuredJsonValueConsiderTypeParameter2(\n              type2.parameters,\n              typeInfo.parameter,\n              field2.type,\n              typeMap,\n              value[field2.name]\n            )\n          ])\n        )\n      );\n    }\n    case \"sum\": {\n      const valueObj = value;\n      if (typeInfo.body.value.every(\n        (pattern2) => pattern2.parameter.type === \"nothing\"\n      )) {\n        return StructuredJsonValue2.string(valueObj.type);\n      }\n      for (const pattern2 of typeInfo.body.value) {\n        if (pattern2.name === valueObj.type) {\n          if (pattern2.parameter.type === \"just\") {\n            return StructuredJsonValue2.object(\n              /* @__PURE__ */ new Map([\n                [\"type\", StructuredJsonValue2.string(pattern2.name)],\n                [\n                  \"value\",\n                  toStructuredJsonValueConsiderTypeParameter2(\n                    type2.parameters,\n                    typeInfo.parameter,\n                    pattern2.parameter.value,\n                    typeMap,\n                    valueObj.value\n                  )\n                ]\n              ])\n            );\n          }\n          return StructuredJsonValue2.object(\n            /* @__PURE__ */ new Map([\n              [\"type\", StructuredJsonValue2.string(pattern2.name)]\n            ])\n          );\n        }\n      }\n      throw new Error(\n        `unknown pattern name expected [${typeInfo.body.value.map((p) => p.name).join(\",\")}] but got ${valueObj.type} (${createTypeKey2(type2.namespace, type2.name)})`\n      );\n    }\n  }\n};\nvar toStructuredJsonValueConsiderTypeParameter2 = (typeParameters, typeParameterInfoList, type2, typeMap, value) => {\n  if (typeParameters.length !== typeParameterInfoList.length) {\n    throw new Error(\n      \"\\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u306E\\u6570\\u304C\\u5408\\u308F\\u306A\\u3044! expected:\" + typeParameterInfoList.length + \" but got:\" + typeParameters.length\n    );\n  }\n  for (const [index2, typeParameter] of typeParameterInfoList.entries()) {\n    if (typeParameter.name === type2.name) {\n      const matchedTypeParameter = typeParameters[index2];\n      if (matchedTypeParameter === void 0) {\n        throw new Error(\"\\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u306E\\u6570\\u304C\\u5408\\u308F\\u306A\\u3044?\");\n      }\n      return toStructuredJsonValue2(\n        matchedTypeParameter,\n        typeMap,\n        value\n      );\n    }\n  }\n  return toStructuredJsonValue2(\n    type2,\n    typeMap,\n    value\n  );\n};\n\n// https://raw.githubusercontent.com/narumincho/definy/f662850e6a0cb9ec7a69e60f424624c07dd417fa/deno-lib/definyRpc/core/request.ts\nvar requestQuery2 = async (parameter) => {\n  const url = new URL(parameter.url.toString());\n  url.pathname = requestPath2(url.pathname, parameter.namespace, parameter.name);\n  const inputAsStructuredJson = toStructuredJsonValue2(\n    parameter.inputType,\n    parameter.typeMap,\n    parameter.input\n  );\n  try {\n    if (parameter.accountToken === void 0) {\n      const search = structuredJsonValueToUrlSearch2(\n        inputAsStructuredJson\n      );\n      if (search !== void 0) {\n        for (const [key, value] of search) {\n          url.searchParams.set(key, value);\n        }\n        const response2 = await fetch(url);\n        const jsonValue2 = await response2.json();\n        return Result5.ok(fromStructuredJsonValue2(\n          parameter.outputType,\n          parameter.typeMap,\n          rawJsonToStructuredJsonValue2(jsonValue2)\n        ));\n      }\n    }\n    const response = await fetch(url, {\n      method: \"POST\",\n      body: structuredJsonStringify2(\n        parameter.accountToken === void 0 ? StructuredJsonValue2.object(\n          /* @__PURE__ */ new Map([[\"input\", inputAsStructuredJson]])\n        ) : StructuredJsonValue2.object(\n          /* @__PURE__ */ new Map([[\n            \"accountToken\",\n            StructuredJsonValue2.string(parameter.accountToken)\n          ], [\n            \"input\",\n            inputAsStructuredJson\n          ]])\n        )\n      )\n    });\n    const jsonValue = await response.json();\n    return Result5.ok(fromStructuredJsonValue2(\n      parameter.outputType,\n      parameter.typeMap,\n      rawJsonToStructuredJsonValue2(jsonValue)\n    ));\n  } catch (e) {\n    return Result5.error(e.toString());\n  }\n};\nvar structuredJsonValueToUrlSearch2 = (structuredJsonValue2) => {\n  const search = structuredJsonValueToUrlSearchNoLimit2(structuredJsonValue2);\n  if (2e3 < search.toString().length) {\n    return void 0;\n  }\n  return search;\n};\nvar structuredJsonValueToUrlSearchNoLimit2 = (structuredJsonValue2) => {\n  switch (structuredJsonValue2.type) {\n    case \"string\":\n      return new URLSearchParams({ q: structuredJsonValue2.value });\n    case \"number\":\n      return new URLSearchParams({ q: structuredJsonValue2.value.toString() });\n    case \"boolean\":\n      return new URLSearchParams({ q: structuredJsonValue2.value.toString() });\n    case \"null\":\n      return new URLSearchParams({});\n    case \"array\":\n      return new URLSearchParams({\n        q: structuredJsonStringify2(structuredJsonValue2)\n      });\n    case \"object\": {\n      const search = new URLSearchParams(\n        [...structuredJsonValue2.value].map(([key, value]) => [key, structuredJsonStringify2(value)])\n      );\n      search.sort();\n      return search;\n    }\n  }\n};\nvar requestPath2 = (pathname, namespace, name2) => {\n  return pathname + (pathname.endsWith(\"/\") ? \"\" : \"/\") + (namespace.type === \"meta\" ? \"meta/\" : \"api/\" + namespace.value.join(\"/\") + \"/\") + name2;\n};\n\n// definyRpc/example/generated/meta.ts\nvar name = (parameter) => requestQuery2({\n  url: parameter.url ?? new globalThis.URL(\"http://localhost:2520\"),\n  namespace: FunctionNamespace4.meta,\n  name: \"name\",\n  inputType: Unit.type(),\n  outputType: String3.type(),\n  input: void 0,\n  typeMap: /* @__PURE__ */ new Map([\n    [\n      \"*coreType.String\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"String\",\n        description: \"\\u6587\\u5B57\\u5217\",\n        parameter: [],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.string\n      })\n    ],\n    [\n      \"*coreType.Unit\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"Unit\",\n        description: \"\\u5024\\u304C1\\u3064\\u3060\\u3051\",\n        parameter: [],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.unit\n      })\n    ]\n  ])\n});\nvar functionListByName = (parameter) => requestQuery2({\n  url: parameter.url ?? new globalThis.URL(\"http://localhost:2520\"),\n  namespace: FunctionNamespace4.meta,\n  name: \"functionListByName\",\n  inputType: Unit.type(),\n  outputType: List2.type(FunctionDetail2.type()),\n  input: void 0,\n  typeMap: /* @__PURE__ */ new Map([\n    [\n      \"*coreType.String\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"String\",\n        description: \"\\u6587\\u5B57\\u5217\",\n        parameter: [],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.string\n      })\n    ],\n    [\n      \"*coreType.Unit\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"Unit\",\n        description: \"\\u5024\\u304C1\\u3064\\u3060\\u3051\",\n        parameter: [],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.unit\n      })\n    ],\n    [\n      \"*coreType.Bool\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"Bool\",\n        description: \"Bool. boolean. \\u771F\\u507D\\u5024. True \\u304B False\",\n        parameter: [],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.boolean\n      })\n    ],\n    [\n      \"*coreType.List\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"List\",\n        description: \"\\u30EA\\u30B9\\u30C8\",\n        parameter: [\n          TypeParameterInfo3.from({\n            name: \"element\",\n            description: \"\\u8981\\u7D20\\u306E\\u578B\"\n          })\n        ],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.list\n      })\n    ],\n    [\n      \"*coreType.Namespace\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"Namespace\",\n        description: \"\\u540D\\u524D\\u7A7A\\u9593. \\u30E6\\u30FC\\u30B6\\u30FC\\u304C\\u751F\\u6210\\u3059\\u308B\\u3082\\u306E\\u304C\\u3053\\u3063\\u3061\\u304C\\u7528\\u610F\\u3059\\u308B\\u3082\\u306E\\u304B\",\n        parameter: [],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.sum([\n          Pattern2.from({\n            name: \"local\",\n            description: \"\\u30E6\\u30FC\\u30B6\\u30FC\\u304C\\u4F5C\\u3063\\u305FAPI\\u304C\\u3042\\u308B\\u3068\\u3053\\u308D\",\n            parameter: Maybe2.just(List2.type(String3.type()))\n          }),\n          Pattern2.from({\n            name: \"coreType\",\n            description: \"definyRpc \\u5171\\u901A\\u3067\\u4F7F\\u308F\\u308C\\u308B\\u578B\",\n            parameter: Maybe2.nothing()\n          }),\n          Pattern2.from({\n            name: \"typedJson\",\n            description: \"\\u578B\\u5B89\\u5168\\u306AJSON\\u306E\\u30B3\\u30FC\\u30C7\\u30C3\\u30AF\",\n            parameter: Maybe2.nothing()\n          }),\n          Pattern2.from({\n            name: \"request\",\n            description: \"HTTP\\u7D4C\\u8DEF\\u3067API\\u547C\\u3076\\u3068\\u304D\\u306B\\u4F7F\\u3046\\u30B3\\u30FC\\u30C9\",\n            parameter: Maybe2.nothing()\n          }),\n          Pattern2.from({\n            name: \"meta\",\n            description: \"\\u5404\\u30B5\\u30FC\\u30D0\\u30FC\\u306B\\u30A2\\u30AF\\u30BB\\u30B9\\u3057\\u578B\\u60C5\\u5831\\u3092\\u53D6\\u5F97\\u3059\\u308B\",\n            parameter: Maybe2.nothing()\n          })\n        ])\n      })\n    ],\n    [\n      \"*coreType.Type\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"Type\",\n        description: \"\\u578B\",\n        parameter: [],\n        attribute: Maybe2.just(TypeAttribute2.asType),\n        body: TypeBody2.product([\n          Field3.from({\n            name: \"namespace\",\n            description: \"\\u540D\\u524D\\u7A7A\\u9593\",\n            type: Namespace2.type()\n          }),\n          Field3.from({\n            name: \"name\",\n            description: \"\\u578B\\u306E\\u540D\\u524D\",\n            type: String3.type()\n          }),\n          Field3.from({\n            name: \"parameters\",\n            description: \"\\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\",\n            type: List2.type(Type4.type())\n          })\n        ])\n      })\n    ],\n    [\n      \"*coreType.FunctionNamespace\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"FunctionNamespace\",\n        description: \"\\u51FA\\u529B\\u3055\\u308C\\u308BAPI\\u95A2\\u6570\\u306E\\u30E2\\u30B8\\u30E5\\u30FC\\u30EB\\u540D\",\n        parameter: [],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.sum([\n          Pattern2.from({\n            name: \"meta\",\n            description: \"API\\u304C\\u3069\\u3093\\u306A\\u69CB\\u9020\\u3067\\u8868\\u73FE\\u3055\\u308C\\u3066\\u3044\\u308B\\u304B\\u3092\\u53D6\\u5F97\\u3059\\u308B\\u305F\\u3081\\u306EAPI\",\n            parameter: Maybe2.nothing()\n          }),\n          Pattern2.from({\n            name: \"local\",\n            description: \"definy RPC \\u3092\\u5229\\u7528\\u3059\\u308B\\u30E6\\u30FC\\u30B6\\u30FC\\u304C\\u5B9A\\u7FA9\\u3057\\u305F\\u30E2\\u30B8\\u30E5\\u30FC\\u30EB\",\n            parameter: Maybe2.just(List2.type(String3.type()))\n          })\n        ])\n      })\n    ],\n    [\n      \"*coreType.FunctionDetail\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"FunctionDetail\",\n        description: \"\\u95A2\\u6570\\u306E\\u30C7\\u30FC\\u30BF functionByName\\u306E\\u7D50\\u679C\",\n        parameter: [],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.product([\n          Field3.from({\n            name: \"namespace\",\n            description: \"\\u540D\\u524D\\u7A7A\\u9593\",\n            type: FunctionNamespace4.type()\n          }),\n          Field3.from({\n            name: \"name\",\n            description: \"api\\u540D\",\n            type: String3.type()\n          }),\n          Field3.from({\n            name: \"description\",\n            description: \"\\u8AAC\\u660E\\u6587\",\n            type: String3.type()\n          }),\n          Field3.from({\n            name: \"input\",\n            description: \"\\u5165\\u529B\\u306E\\u578B\",\n            type: Type4.type()\n          }),\n          Field3.from({\n            name: \"output\",\n            description: \"\\u51FA\\u529B\\u306E\\u578B\",\n            type: Type4.type()\n          }),\n          Field3.from({\n            name: \"needAuthentication\",\n            description: \"\\u8A8D\\u8A3C\\u304C\\u5FC5\\u8981\\u304B\\u3069\\u3046\\u304B (\\u30AD\\u30E3\\u30C3\\u30B7\\u30E5\\u3057\\u306A\\u304F\\u306A\\u308B)\",\n            type: Bool2.type()\n          }),\n          Field3.from({\n            name: \"isMutation\",\n            description: \"\\u5358\\u306A\\u308B\\u30C7\\u30FC\\u30BF\\u306E\\u53D6\\u5F97\\u3067\\u306F\\u306A\\u304F, \\u5909\\u66F4\\u3059\\u308B\\u3088\\u3046\\u306A\\u3082\\u306E\\u304B\",\n            type: Bool2.type()\n          })\n        ])\n      })\n    ]\n  ])\n});\nvar typeList = (parameter) => requestQuery2({\n  url: parameter.url ?? new globalThis.URL(\"http://localhost:2520\"),\n  namespace: FunctionNamespace4.meta,\n  name: \"typeList\",\n  inputType: Unit.type(),\n  outputType: List2.type(DefinyRpcTypeInfo3.type()),\n  input: void 0,\n  typeMap: /* @__PURE__ */ new Map([\n    [\n      \"*coreType.String\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"String\",\n        description: \"\\u6587\\u5B57\\u5217\",\n        parameter: [],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.string\n      })\n    ],\n    [\n      \"*coreType.Unit\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"Unit\",\n        description: \"\\u5024\\u304C1\\u3064\\u3060\\u3051\",\n        parameter: [],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.unit\n      })\n    ],\n    [\n      \"*coreType.List\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"List\",\n        description: \"\\u30EA\\u30B9\\u30C8\",\n        parameter: [\n          TypeParameterInfo3.from({\n            name: \"element\",\n            description: \"\\u8981\\u7D20\\u306E\\u578B\"\n          })\n        ],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.list\n      })\n    ],\n    [\n      \"*coreType.Maybe\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"Maybe\",\n        description: \"\",\n        parameter: [\n          TypeParameterInfo3.from({\n            name: \"element\",\n            description: \"just\\u306E\\u3068\\u304D\\u306B\\u5165\\u308B\\u5024\\u306E\\u578B\"\n          })\n        ],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.sum([\n          Pattern2.from({\n            name: \"just\",\n            description: \"\",\n            parameter: Maybe2.just(\n              Type4.from({\n                namespace: Namespace2.coreType,\n                name: \"element\",\n                parameters: []\n              })\n            )\n          }),\n          Pattern2.from({\n            name: \"nothing\",\n            description: \"\",\n            parameter: Maybe2.nothing()\n          })\n        ])\n      })\n    ],\n    [\n      \"*coreType.Namespace\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"Namespace\",\n        description: \"\\u540D\\u524D\\u7A7A\\u9593. \\u30E6\\u30FC\\u30B6\\u30FC\\u304C\\u751F\\u6210\\u3059\\u308B\\u3082\\u306E\\u304C\\u3053\\u3063\\u3061\\u304C\\u7528\\u610F\\u3059\\u308B\\u3082\\u306E\\u304B\",\n        parameter: [],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.sum([\n          Pattern2.from({\n            name: \"local\",\n            description: \"\\u30E6\\u30FC\\u30B6\\u30FC\\u304C\\u4F5C\\u3063\\u305FAPI\\u304C\\u3042\\u308B\\u3068\\u3053\\u308D\",\n            parameter: Maybe2.just(List2.type(String3.type()))\n          }),\n          Pattern2.from({\n            name: \"coreType\",\n            description: \"definyRpc \\u5171\\u901A\\u3067\\u4F7F\\u308F\\u308C\\u308B\\u578B\",\n            parameter: Maybe2.nothing()\n          }),\n          Pattern2.from({\n            name: \"typedJson\",\n            description: \"\\u578B\\u5B89\\u5168\\u306AJSON\\u306E\\u30B3\\u30FC\\u30C7\\u30C3\\u30AF\",\n            parameter: Maybe2.nothing()\n          }),\n          Pattern2.from({\n            name: \"request\",\n            description: \"HTTP\\u7D4C\\u8DEF\\u3067API\\u547C\\u3076\\u3068\\u304D\\u306B\\u4F7F\\u3046\\u30B3\\u30FC\\u30C9\",\n            parameter: Maybe2.nothing()\n          }),\n          Pattern2.from({\n            name: \"meta\",\n            description: \"\\u5404\\u30B5\\u30FC\\u30D0\\u30FC\\u306B\\u30A2\\u30AF\\u30BB\\u30B9\\u3057\\u578B\\u60C5\\u5831\\u3092\\u53D6\\u5F97\\u3059\\u308B\",\n            parameter: Maybe2.nothing()\n          })\n        ])\n      })\n    ],\n    [\n      \"*coreType.DefinyRpcTypeInfo\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"DefinyRpcTypeInfo\",\n        description: \"definy RPC \\u578B\\u306E\\u69CB\\u9020\",\n        parameter: [],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.product([\n          Field3.from({\n            name: \"namespace\",\n            description: \"\\u578B\\u304C\\u6240\\u5C5E\\u3059\\u308B\\u540D\\u524D\\u7A7A\\u9593\",\n            type: Namespace2.type()\n          }),\n          Field3.from({\n            name: \"name\",\n            description: \"\\u578B\\u306E\\u540D\\u524D\",\n            type: String3.type()\n          }),\n          Field3.from({\n            name: \"description\",\n            description: \"\\u8AAC\\u660E\\u6587. \\u30B3\\u30E1\\u30F3\\u30C8\\u306A\\u3069\\u306B\\u51FA\\u529B\\u3055\\u308C\\u308B\",\n            type: String3.type()\n          }),\n          Field3.from({\n            name: \"parameter\",\n            description: \"\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u30FC\",\n            type: List2.type(TypeParameterInfo3.type())\n          }),\n          Field3.from({\n            name: \"attribute\",\n            description: \"\\u7279\\u6B8A\\u306A\\u6271\\u3044\\u3092\\u3059\\u308B\",\n            type: Maybe2.type(TypeAttribute2.type())\n          }),\n          Field3.from({\n            name: \"body\",\n            description: \"\\u578B\\u306E\\u69CB\\u9020\\u3092\\u8868\\u73FE\\u3059\\u308B\",\n            type: TypeBody2.type()\n          })\n        ])\n      })\n    ],\n    [\n      \"*coreType.TypeParameterInfo\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"TypeParameterInfo\",\n        description: \"\\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u540D\\u3068\\u8AAC\\u660E\\u6587\",\n        parameter: [],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.product([\n          Field3.from({\n            name: \"name\",\n            description: \"\\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u30FC\\u540D\",\n            type: String3.type()\n          }),\n          Field3.from({\n            name: \"description\",\n            description: \"\\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u30FC\\u8AAC\\u660E\",\n            type: String3.type()\n          })\n        ])\n      })\n    ],\n    [\n      \"*coreType.TypeAttribute\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"TypeAttribute\",\n        description: \"\\u578B\\u3092\\u3069\\u306E\\u3088\\u3046\\u306A\\u7279\\u6B8A\\u306A\\u6271\\u3044\\u3092\\u3059\\u308B\\u304B\\u3069\\u3046\\u304B\",\n        parameter: [],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.sum([\n          Pattern2.from({\n            name: \"asType\",\n            description: \"\\u578B\\u306E\\u30C7\\u30FC\\u30BF. \\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u3092\\u4ED8\\u4E0E\\u3059\\u308B\",\n            parameter: Maybe2.nothing()\n          })\n        ])\n      })\n    ],\n    [\n      \"*coreType.TypeBody\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"TypeBody\",\n        description: \"\\u578B\\u306E\\u69CB\\u9020\\u3092\\u8868\\u73FE\\u3059\\u308B\",\n        parameter: [],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.sum([\n          Pattern2.from({\n            name: \"string\",\n            description: \"string\",\n            parameter: Maybe2.nothing()\n          }),\n          Pattern2.from({\n            name: \"number\",\n            description: \"number\",\n            parameter: Maybe2.nothing()\n          }),\n          Pattern2.from({\n            name: \"boolean\",\n            description: \"boolean\",\n            parameter: Maybe2.nothing()\n          }),\n          Pattern2.from({\n            name: \"unit\",\n            description: \"unit\",\n            parameter: Maybe2.nothing()\n          }),\n          Pattern2.from({\n            name: \"list\",\n            description: \"list\",\n            parameter: Maybe2.nothing()\n          }),\n          Pattern2.from({\n            name: \"set\",\n            description: \"set\",\n            parameter: Maybe2.nothing()\n          }),\n          Pattern2.from({\n            name: \"map\",\n            description: \"map\",\n            parameter: Maybe2.nothing()\n          }),\n          Pattern2.from({\n            name: \"url\",\n            description: \"url\",\n            parameter: Maybe2.nothing()\n          }),\n          Pattern2.from({\n            name: \"product\",\n            description: \"product\",\n            parameter: Maybe2.just(List2.type(Field3.type()))\n          }),\n          Pattern2.from({\n            name: \"sum\",\n            description: \"sum\",\n            parameter: Maybe2.just(List2.type(Pattern2.type()))\n          })\n        ])\n      })\n    ],\n    [\n      \"*coreType.Field\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"Field\",\n        description: \"product \\u76F4\\u7A4D\\u578B\\u3067\\u4F7F\\u3046\",\n        parameter: [],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.product([\n          Field3.from({\n            name: \"name\",\n            description: \"\\u30D5\\u30A3\\u30FC\\u30EB\\u30C9\\u540D\",\n            type: String3.type()\n          }),\n          Field3.from({\n            name: \"description\",\n            description: \"\\u30D5\\u30A3\\u30FC\\u30EB\\u30C9\\u306E\\u8AAC\\u660E\",\n            type: String3.type()\n          }),\n          Field3.from({\n            name: \"type\",\n            description: \"\\u578B\",\n            type: Type4.type()\n          })\n        ])\n      })\n    ],\n    [\n      \"*coreType.Pattern\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"Pattern\",\n        description: \"\\u76F4\\u548C\\u578B\\u306E\\u8868\\u73FE\",\n        parameter: [],\n        attribute: Maybe2.nothing(),\n        body: TypeBody2.product([\n          Field3.from({\n            name: \"name\",\n            description: \"\\u30D1\\u30BF\\u30FC\\u30F3\\u540D\",\n            type: String3.type()\n          }),\n          Field3.from({\n            name: \"description\",\n            description: \"\\u8AAC\\u660E\",\n            type: String3.type()\n          }),\n          Field3.from({\n            name: \"parameter\",\n            description: \"\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\\u30FC\",\n            type: Maybe2.type(Type4.type())\n          })\n        ])\n      })\n    ],\n    [\n      \"*coreType.Type\",\n      DefinyRpcTypeInfo3.from({\n        namespace: Namespace2.coreType,\n        name: \"Type\",\n        description: \"\\u578B\",\n        parameter: [],\n        attribute: Maybe2.just(TypeAttribute2.asType),\n        body: TypeBody2.product([\n          Field3.from({\n            name: \"namespace\",\n            description: \"\\u540D\\u524D\\u7A7A\\u9593\",\n            type: Namespace2.type()\n          }),\n          Field3.from({\n            name: \"name\",\n            description: \"\\u578B\\u306E\\u540D\\u524D\",\n            type: String3.type()\n          }),\n          Field3.from({\n            name: \"parameters\",\n            description: \"\\u578B\\u30D1\\u30E9\\u30E1\\u30FC\\u30BF\",\n            type: List2.type(Type4.type())\n          })\n        ])\n      })\n    ]\n  ])\n});\n\n// definyRpc/clientEditor/App.tsx\nvar containerStyle7 = toStyleAndHash({\n  backgroundColor: \"#111\",\n  color: \"white\",\n  height: \"100%\",\n  boxSizing: \"border-box\",\n  display: \"grid\",\n  gap: 16,\n  alignContent: \"start\",\n  overflowY: \"scroll\"\n});\nvar titleStyle = toStyleAndHash({\n  backgroundColor: \"#5fb58a\",\n  fontSize: 14,\n  color: \"#000\",\n  margin: 0,\n  padding: \"0 8px\"\n});\nvar App = () => {\n  const [functionAndTypeList, setFunctionAndTypeList] = We.useState(void 0);\n  const [serverName, setServerName] = We.useState();\n  const [serverUrl, setServerUrl] = We.useState(\n    new URL(location.href).toString()\n  );\n  const [editorCount, setEditorCount] = We.useState(1);\n  We.useEffect(() => {\n    functionListByName({ url: new URL(serverUrl) }).then((result2) => {\n      if (result2.type === \"ok\") {\n        console.log(\"result.value\", result2.value);\n        setFunctionAndTypeList((prev) => ({\n          funcList: result2.value,\n          typeList: prev?.typeList ?? []\n        }));\n      } else {\n        setFunctionAndTypeList(void 0);\n      }\n    }).catch(() => {\n      setFunctionAndTypeList(void 0);\n    });\n    typeList({ url: new URL(serverUrl) }).then((result2) => {\n      if (result2.type === \"ok\") {\n        console.log(\"result.value\", result2.value);\n        setFunctionAndTypeList((prev) => ({\n          funcList: prev?.funcList ?? [],\n          typeList: result2.value\n        }));\n      } else {\n        setFunctionAndTypeList(void 0);\n      }\n    }).catch(() => {\n      setFunctionAndTypeList(void 0);\n    });\n    name({ url: new URL(serverUrl) }).then((result2) => {\n      if (result2.type === \"ok\") {\n        console.log(\"result.value\", result2.value);\n        setServerName(result2.value);\n      } else {\n        setServerName(void 0);\n      }\n    }).catch(() => {\n      setServerName(void 0);\n    });\n  }, [serverUrl]);\n  return /* @__PURE__ */ We.createElement(\"div\", {\n    className: c(containerStyle7)\n  }, /* @__PURE__ */ We.createElement(\"h2\", {\n    className: c(titleStyle)\n  }, \"definy RPC Browser Client\"), /* @__PURE__ */ We.createElement(ServerOrigin, {\n    serverName,\n    initServerOrigin: serverUrl,\n    onChangeServerOrigin: setServerUrl\n  }), Array.from({ length: editorCount }, (_, i) => /* @__PURE__ */ We.createElement(Editor, {\n    key: i,\n    functionAndTypeList,\n    serverOrigin: serverUrl\n  })), /* @__PURE__ */ We.createElement(Button, {\n    onClick: () => {\n      setEditorCount((old) => old + 1);\n    }\n  }, \"+\"), /* @__PURE__ */ We.createElement(SampleChart, null));\n};\n\n// definyRpc/clientEditor/main.tsx\nvar rootElement = document.createElement(\"div\");\ndocument.body.style.height = \"100%\";\ndocument.body.style.margin = \"0\";\ndocument.documentElement.style.height = \"100%\";\ndocument.body.appendChild(rootElement);\nrootElement.style.height = \"100%\";\nIf(rootElement).render(\n  /* @__PURE__ */ We.createElement(We.StrictMode, null, /* @__PURE__ */ We.createElement(App, null))\n);\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/*! Hammer.JS - v2.0.17-rc - 2019-12-16\n * http://naver.github.io/egjs\n *\n * Forked By Naver egjs\n * Copyright (c) hammerjs\n * Licensed under the MIT license */\n/**\n * @license React\n * react-dom.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * @license React\n * scheduler.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * vis-data\n * http://visjs.org/\n *\n * Manage unstructured data using DataSet. Add, update, and remove data, and listen for changes in the data.\n *\n * @version 7.1.4\n * @date    2022-03-15T15:23:59.245Z\n *\n * @copyright (c) 2011-2017 Almende B.V, http://almende.com\n * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs\n *\n * @license\n * vis.js is dual licensed under both\n *\n *   1. The Apache 2.0 License\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *   and\n *\n *   2. The MIT License\n *      http://opensource.org/licenses/MIT\n *\n * vis.js may be distributed under either license.\n */\n"
}