/* eslint-disable */
/* generated by definy. Do not edit! */

import * as a from "https://raw.githubusercontent.com/narumincho/definy/d6d8ab20628f332bb6c07c445d4159d86261eb81/deno-lib/definyRpc/core/maybe.ts";
import * as b from "https://raw.githubusercontent.com/narumincho/definy/d6d8ab20628f332bb6c07c445d4159d86261eb81/deno-lib/typedJson.ts";
import * as c from "https://raw.githubusercontent.com/narumincho/definy/d6d8ab20628f332bb6c07c445d4159d86261eb81/deno-lib/definyRpc/core/coreType.ts";

/**
 * 認証が必要なリクエストに使用する
 */
export type AccountToken = string & { readonly __accountTokenBland: never };

/**
 * サーバー名の取得
 */
export const name = (parameter: {
  /**
   * api end point
   * @default http://localhost:2520
   */
  readonly url?: string | undefined;
}): globalThis.Promise<a.Result<string, "error">> => {
  const url: globalThis.URL = new globalThis.URL(
    parameter.url ?? "http://localhost:2520"
  );
  url.pathname = url.pathname + "/meta/name";
  return fetch(url)
    .then(
      (response: globalThis.Response): globalThis.Promise<b.RawJsonValue> =>
        response.json()
    )
    .then(
      (jsonValue: b.RawJsonValue): a.Result<string, "error"> => ({
        type: "ok",
        ok: c.String.fromStructuredJsonValue(
          b.rawJsonToStructuredJsonValue(jsonValue)
        ),
      })
    )
    .catch(
      (): a.Result<string, "error"> => ({ type: "error", error: "error" })
    );
};

/**
 * get namespace list. namespace は API の公開非公開, コード生成のモジュールを分けるチャンク. JavaScriptのSetの仕様上, オブジェクトのSetはうまく扱えないので List にしている
 */
export const namespaceList = (parameter: {
  /**
   * api end point
   * @default http://localhost:2520
   */
  readonly url?: string | undefined;
}): globalThis.Promise<
  a.Result<globalThis.ReadonlyArray<FunctionNamespace>, "error">
> => {
  const url: globalThis.URL = new globalThis.URL(
    parameter.url ?? "http://localhost:2520"
  );
  url.pathname = url.pathname + "/meta/namespaceList";
  return fetch(url)
    .then(
      (response: globalThis.Response): globalThis.Promise<b.RawJsonValue> =>
        response.json()
    )
    .then(
      (
        jsonValue: b.RawJsonValue
      ): a.Result<globalThis.ReadonlyArray<FunctionNamespace>, "error"> => ({
        type: "ok",
        ok: c.List.fromStructuredJsonValue(
          c.FunctionNamespace.fromStructuredJsonValue
        )(b.rawJsonToStructuredJsonValue(jsonValue)),
      })
    )
    .catch(
      (): a.Result<globalThis.ReadonlyArray<FunctionNamespace>, "error"> => ({
        type: "error",
        error: "error",
      })
    );
};

/**
 * 名前から関数を検索する (公開APIのみ)
 */
export const functionListByName = (parameter: {
  /**
   * api end point
   * @default http://localhost:2520
   */
  readonly url?: string | undefined;
}): globalThis.Promise<
  a.Result<globalThis.ReadonlyArray<FunctionDetail>, "error">
> => {
  const url: globalThis.URL = new globalThis.URL(
    parameter.url ?? "http://localhost:2520"
  );
  url.pathname = url.pathname + "/meta/functionListByName";
  return fetch(url)
    .then(
      (response: globalThis.Response): globalThis.Promise<b.RawJsonValue> =>
        response.json()
    )
    .then(
      (
        jsonValue: b.RawJsonValue
      ): a.Result<globalThis.ReadonlyArray<FunctionDetail>, "error"> => ({
        type: "ok",
        ok: c.List.fromStructuredJsonValue(
          c.FunctionDetail.fromStructuredJsonValue
        )(b.rawJsonToStructuredJsonValue(jsonValue)),
      })
    )
    .catch(
      (): a.Result<globalThis.ReadonlyArray<FunctionDetail>, "error"> => ({
        type: "error",
        error: "error",
      })
    );
};

/**
 * 名前から関数を検索する (非公開API)
 */
export const functionListByNamePrivate = (parameter: {
  /**
   * api end point
   * @default http://localhost:2520
   */
  readonly url?: string | undefined;
  readonly accountToken: AccountToken;
}): globalThis.Promise<
  a.Result<globalThis.ReadonlyArray<FunctionDetail>, "error">
> => {
  const url: globalThis.URL = new globalThis.URL(
    parameter.url ?? "http://localhost:2520"
  );
  url.pathname = url.pathname + "/meta/functionListByNamePrivate";
  return fetch(url, { headers: { authorization: parameter.accountToken } })
    .then(
      (response: globalThis.Response): globalThis.Promise<b.RawJsonValue> =>
        response.json()
    )
    .then(
      (
        jsonValue: b.RawJsonValue
      ): a.Result<globalThis.ReadonlyArray<FunctionDetail>, "error"> => ({
        type: "ok",
        ok: c.List.fromStructuredJsonValue(
          c.FunctionDetail.fromStructuredJsonValue
        )(b.rawJsonToStructuredJsonValue(jsonValue)),
      })
    )
    .catch(
      (): a.Result<globalThis.ReadonlyArray<FunctionDetail>, "error"> => ({
        type: "error",
        error: "error",
      })
    );
};

/**
 * 名前空間「definyRpc」のApiFunctionを呼ぶ TypeScript のコードを生成する
 */
export const generateCallDefinyRpcTypeScriptCode = (parameter: {
  /**
   * api end point
   * @default http://localhost:2520
   */
  readonly url?: string | undefined;
}): globalThis.Promise<a.Result<string, "error">> => {
  const url: globalThis.URL = new globalThis.URL(
    parameter.url ?? "http://localhost:2520"
  );
  url.pathname = url.pathname + "/meta/generateCallDefinyRpcTypeScriptCode";
  return fetch(url)
    .then(
      (response: globalThis.Response): globalThis.Promise<b.RawJsonValue> =>
        response.json()
    )
    .then(
      (jsonValue: b.RawJsonValue): a.Result<string, "error"> => ({
        type: "ok",
        ok: c.String.fromStructuredJsonValue(
          b.rawJsonToStructuredJsonValue(jsonValue)
        ),
      })
    )
    .catch(
      (): a.Result<string, "error"> => ({ type: "error", error: "error" })
    );
};

/**
 * サーバーが実行している環境でコードを生成し, ファイルとして保存する.
 *  保存先:file:///C:/Users/narum/Documents/GitHub/definy/deno-lib/definyRpc/example/generated/
 */
export const generateCodeAndWriteAsFileInServer = (parameter: {
  /**
   * api end point
   * @default http://localhost:2520
   */
  readonly url?: string | undefined;
}): globalThis.Promise<a.Result<undefined, "error">> => {
  const url: globalThis.URL = new globalThis.URL(
    parameter.url ?? "http://localhost:2520"
  );
  url.pathname = url.pathname + "/meta/generateCodeAndWriteAsFileInServer";
  return fetch(url)
    .then(
      (response: globalThis.Response): globalThis.Promise<b.RawJsonValue> =>
        response.json()
    )
    .then(
      (jsonValue: b.RawJsonValue): a.Result<undefined, "error"> => ({
        type: "ok",
        ok: c.Unit.fromStructuredJsonValue(
          b.rawJsonToStructuredJsonValue(jsonValue)
        ),
      })
    )
    .catch(
      (): a.Result<undefined, "error"> => ({ type: "error", error: "error" })
    );
};
