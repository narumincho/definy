/* eslint-disable */
/* generated by definy. Do not edit! */

import * as a from "https://raw.githubusercontent.com/narumincho/definy/c98453da243cdd8aac772e0cb8e83abcbf1c3957/deno-lib/definyRpc/core/coreType.ts";
import * as b from "https://raw.githubusercontent.com/narumincho/definy/c98453da243cdd8aac772e0cb8e83abcbf1c3957/deno-lib/maybe.ts";
import * as c from "https://raw.githubusercontent.com/narumincho/definy/c98453da243cdd8aac772e0cb8e83abcbf1c3957/deno-lib/typedJson.ts";

/**
 * 構造化されたJSON
 */
export type StructuredJsonValue =
  | {
      /**
       * string
       */
      readonly type: "string";
      /**
       * string
       */
      readonly value: string;
      readonly [Symbol.toStringTag]: "*coreType.StructuredJsonValue";
    }
  | {
      /**
       * array
       */
      readonly type: "array";
      /**
       * array
       */
      readonly value: globalThis.ReadonlyArray<a.StructuredJsonValue>;
      readonly [Symbol.toStringTag]: "*coreType.StructuredJsonValue";
    }
  | {
      /**
       * boolean
       */
      readonly type: "boolean";
      /**
       * boolean
       */
      readonly value: boolean;
      readonly [Symbol.toStringTag]: "*coreType.StructuredJsonValue";
    }
  | {
      /**
       * null
       */
      readonly type: "null";
      readonly [Symbol.toStringTag]: "*coreType.StructuredJsonValue";
    }
  | {
      /**
       * number
       */
      readonly type: "number";
      /**
       * number
       */
      readonly value: number;
      readonly [Symbol.toStringTag]: "*coreType.StructuredJsonValue";
    }
  | {
      /**
       * object
       */
      readonly type: "object";
      /**
       * object
       */
      readonly value: globalThis.ReadonlyMap<string, a.StructuredJsonValue>;
      readonly [Symbol.toStringTag]: "*coreType.StructuredJsonValue";
    };

/**
 * 名前空間. ユーザーが生成するものがこっちが用意するものか
 */
export type Namespace =
  | {
      /**
       * ユーザーが作ったAPIがあるところ
       */
      readonly type: "local";
      /**
       * ユーザーが作ったAPIがあるところ
       */
      readonly value: globalThis.ReadonlyArray<string>;
      readonly [Symbol.toStringTag]: "*coreType.Namespace";
    }
  | {
      /**
       * definyRpc 共通で使われる型
       */
      readonly type: "coreType";
      readonly [Symbol.toStringTag]: "*coreType.Namespace";
    }
  | {
      /**
       * 型安全なJSONのコーデック
       */
      readonly type: "typedJson";
      readonly [Symbol.toStringTag]: "*coreType.Namespace";
    }
  | {
      /**
       * HTTP経路でAPI呼ぶときに使うコード
       */
      readonly type: "request";
      readonly [Symbol.toStringTag]: "*coreType.Namespace";
    }
  | {
      /**
       * MaybeとResultがある (一時的対処. coreTypeに入れたい)
       */
      readonly type: "maybe";
      readonly [Symbol.toStringTag]: "*coreType.Namespace";
    }
  | {
      /**
       * 各サーバーにアクセスし型情報を取得する
       */
      readonly type: "meta";
      readonly [Symbol.toStringTag]: "*coreType.Namespace";
    };

/**
 * definy RPC 型の構造
 */
export type DefinyRpcTypeInfo = {
  /**
   * 型が所属する名前空間
   */
  readonly namespace: a.Namespace;
  /**
   * 型の名前
   */
  readonly name: string;
  /**
   * 説明文. コメントなどに出力される
   */
  readonly description: string;
  /**
   * パラメーターの数. パラメーター名やドキュメントはまたいつか復活させる
   */
  readonly parameterCount: number;
  /**
   * 型の構造を表現する
   */
  readonly body: a.TypeBody;
  readonly [Symbol.toStringTag]: "*coreType.DefinyRpcTypeInfo";
};

/**
 * 型の構造を表現する
 */
export type TypeBody =
  | {
      /**
       * string
       */
      readonly type: "string";
      readonly [Symbol.toStringTag]: "*coreType.TypeBody";
    }
  | {
      /**
       * number
       */
      readonly type: "number";
      readonly [Symbol.toStringTag]: "*coreType.TypeBody";
    }
  | {
      /**
       * boolean
       */
      readonly type: "boolean";
      readonly [Symbol.toStringTag]: "*coreType.TypeBody";
    }
  | {
      /**
       * unit
       */
      readonly type: "unit";
      readonly [Symbol.toStringTag]: "*coreType.TypeBody";
    }
  | {
      /**
       * list
       */
      readonly type: "list";
      readonly [Symbol.toStringTag]: "*coreType.TypeBody";
    }
  | {
      /**
       * set
       */
      readonly type: "set";
      readonly [Symbol.toStringTag]: "*coreType.TypeBody";
    }
  | {
      /**
       * map
       */
      readonly type: "map";
      readonly [Symbol.toStringTag]: "*coreType.TypeBody";
    }
  | {
      /**
       * url
       */
      readonly type: "url";
      readonly [Symbol.toStringTag]: "*coreType.TypeBody";
    }
  | {
      /**
       * product
       */
      readonly type: "product";
      /**
       * product
       */
      readonly value: globalThis.ReadonlyArray<a.Field>;
      readonly [Symbol.toStringTag]: "*coreType.TypeBody";
    }
  | {
      /**
       * sum
       */
      readonly type: "sum";
      /**
       * sum
       */
      readonly value: globalThis.ReadonlyArray<a.Pattern>;
      readonly [Symbol.toStringTag]: "*coreType.TypeBody";
    };

/**
 * product 直積型で使う
 */
export type Field = {
  /**
   * フィールド名
   */
  readonly name: string;
  /**
   * フィールドの説明
   */
  readonly description: string;
  /**
   * 型
   */
  readonly type: a.Type<unknown>;
  readonly [Symbol.toStringTag]: "*coreType.Field";
};

/**
 * 直和型の表現
 */
export type Pattern = {
  /**
   * パターン名
   */
  readonly name: string;
  /**
   * 説明
   */
  readonly description: string;
  /**
   * パラメーター
   */
  readonly parameter: b.Maybe<a.Type<unknown>>;
  readonly [Symbol.toStringTag]: "*coreType.Pattern";
};

/**
 * 型
 */
export type Type = {
  /**
   * 名前空間
   */
  readonly namespace: a.Namespace;
  /**
   * 型の名前
   */
  readonly name: string;
  /**
   * 型パラメータ
   */
  readonly parameters: globalThis.ReadonlyArray<a.Type<unknown>>;
  readonly [Symbol.toStringTag]: "*coreType.Type";
  readonly [neverSymbol]: p0;
};

/**
 * 出力されるAPI関数のモジュール名
 */
export type FunctionNamespace =
  | {
      /**
       * APIがどんな構造で表現されているかを取得するためのAPI
       */
      readonly type: "meta";
      readonly [Symbol.toStringTag]: "*coreType.FunctionNamespace";
    }
  | {
      /**
       * definy RPC を利用するユーザーが定義したモジュール
       */
      readonly type: "local";
      /**
       * definy RPC を利用するユーザーが定義したモジュール
       */
      readonly value: globalThis.ReadonlyArray<string>;
      readonly [Symbol.toStringTag]: "*coreType.FunctionNamespace";
    };

/**
 * 関数のデータ functionByNameの結果
 */
export type FunctionDetail = {
  /**
   * 名前空間
   */
  readonly namespace: a.FunctionNamespace;
  /**
   * api名
   */
  readonly name: string;
  /**
   * 説明文
   */
  readonly description: string;
  /**
   * 入力の型
   */
  readonly input: a.Type<unknown>;
  /**
   * 出力の型
   */
  readonly output: a.Type<unknown>;
  /**
   * 認証が必要かどうか (キャッシュしなくなる)
   */
  readonly needAuthentication: boolean;
  /**
   * 単なるデータの取得ではなく, 変更するようなものか
   */
  readonly isMutation: boolean;
  readonly [Symbol.toStringTag]: "*coreType.FunctionDetail";
};

/**
 * 文字列
 */
export const String: {
  /**
   * String の型の表現
   */
  readonly typeInfo: () => a.DefinyRpcTypeInfo;
  /**
   * String の型
   */
  readonly type: () => a.Type<string>;
  /**
   * JsonからStringに変換する. 失敗した場合はエラー
   */
  readonly fromStructuredJsonValue: (a: a.StructuredJsonValue) => string;
} = {
  typeInfo: (): a.DefinyRpcTypeInfo =>
    a.DefinyRpcTypeInfo.from({
      namespace: a.Namespace.coreType,
      name: "String",
      description: "文字列",
      parameterCount: 0,
      body: a.TypeBody.string,
    }),
  type: (): a.Type<string> =>
    a.Type.from({
      namespace: a.Namespace.coreType,
      name: "String",
      parameters: [],
    }),
  fromStructuredJsonValue: (jsonValue: a.StructuredJsonValue): string => {
    if (jsonValue.type === "string") {
      return jsonValue.value;
    }
    throw new Error("expected string in String.fromStructuredJsonValue");
  },
};

/**
 * 値が1つだけ
 */
export const Unit: {
  /**
   * Unit の型の表現
   */
  readonly typeInfo: () => a.DefinyRpcTypeInfo;
  /**
   * Unit の型
   */
  readonly type: () => a.Type<undefined>;
  /**
   * JsonからUnitに変換する. 失敗した場合はエラー
   */
  readonly fromStructuredJsonValue: (a: a.StructuredJsonValue) => undefined;
} = {
  typeInfo: (): a.DefinyRpcTypeInfo =>
    a.DefinyRpcTypeInfo.from({
      namespace: a.Namespace.coreType,
      name: "Unit",
      description: "値が1つだけ",
      parameterCount: 0,
      body: a.TypeBody.unit,
    }),
  type: (): a.Type<undefined> =>
    a.Type.from({
      namespace: a.Namespace.coreType,
      name: "Unit",
      parameters: [],
    }),
  fromStructuredJsonValue: (jsonValue: a.StructuredJsonValue): undefined =>
    undefined,
};

/**
 * Bool. boolean. 真偽値. True か False
 */
export const Bool: {
  /**
   * Bool の型の表現
   */
  readonly typeInfo: () => a.DefinyRpcTypeInfo;
  /**
   * Bool の型
   */
  readonly type: () => a.Type<boolean>;
  /**
   * JsonからBoolに変換する. 失敗した場合はエラー
   */
  readonly fromStructuredJsonValue: (a: a.StructuredJsonValue) => boolean;
} = {
  typeInfo: (): a.DefinyRpcTypeInfo =>
    a.DefinyRpcTypeInfo.from({
      namespace: a.Namespace.coreType,
      name: "Bool",
      description: "Bool. boolean. 真偽値. True か False",
      parameterCount: 0,
      body: a.TypeBody.boolean,
    }),
  type: (): a.Type<boolean> =>
    a.Type.from({
      namespace: a.Namespace.coreType,
      name: "Bool",
      parameters: [],
    }),
  fromStructuredJsonValue: (jsonValue: a.StructuredJsonValue): boolean => {
    if (jsonValue.type === "boolean") {
      return jsonValue.value;
    }
    throw new Error("expected boolean in Bool.fromStructuredJsonValue");
  },
};

/**
 * 64bit 浮動小数点数
 */
export const Number: {
  /**
   * Number の型の表現
   */
  readonly typeInfo: () => a.DefinyRpcTypeInfo;
  /**
   * Number の型
   */
  readonly type: () => a.Type<number>;
  /**
   * JsonからNumberに変換する. 失敗した場合はエラー
   */
  readonly fromStructuredJsonValue: (a: a.StructuredJsonValue) => number;
} = {
  typeInfo: (): a.DefinyRpcTypeInfo =>
    a.DefinyRpcTypeInfo.from({
      namespace: a.Namespace.coreType,
      name: "Number",
      description: "64bit 浮動小数点数",
      parameterCount: 0,
      body: a.TypeBody.number,
    }),
  type: (): a.Type<number> =>
    a.Type.from({
      namespace: a.Namespace.coreType,
      name: "Number",
      parameters: [],
    }),
  fromStructuredJsonValue: (jsonValue: a.StructuredJsonValue): number => {
    if (jsonValue.type === "number") {
      return jsonValue.value;
    }
    throw new Error("expected number in Number.fromStructuredJsonValue");
  },
};

/**
 * 構造化されたJSON
 */
export const StructuredJsonValue: {
  /**
   * StructuredJsonValue の型の表現
   */
  readonly typeInfo: () => a.DefinyRpcTypeInfo;
  /**
   * StructuredJsonValue の型
   */
  readonly type: () => a.Type<a.StructuredJsonValue>;
  /**
   * JsonからStructuredJsonValueに変換する. 失敗した場合はエラー
   */
  readonly fromStructuredJsonValue: (
    a: a.StructuredJsonValue
  ) => a.StructuredJsonValue;
  /**
   * string
   */
  readonly string: (a: string) => a.StructuredJsonValue;
  /**
   * array
   */
  readonly array: (
    a: globalThis.ReadonlyArray<a.StructuredJsonValue>
  ) => a.StructuredJsonValue;
  /**
   * boolean
   */
  readonly boolean: (a: boolean) => a.StructuredJsonValue;
  /**
   * null
   */
  readonly null: a.StructuredJsonValue;
  /**
   * number
   */
  readonly number: (a: number) => a.StructuredJsonValue;
  /**
   * object
   */
  readonly object: (
    a: globalThis.ReadonlyMap<string, a.StructuredJsonValue>
  ) => a.StructuredJsonValue;
} = {
  typeInfo: (): a.DefinyRpcTypeInfo =>
    a.DefinyRpcTypeInfo.from({
      namespace: a.Namespace.coreType,
      name: "StructuredJsonValue",
      description: "構造化されたJSON",
      parameterCount: 0,
      body: a.TypeBody.sum([
        a.Pattern.from({
          name: "string",
          description: "string",
          parameter: { type: "just", value: a.String.type() },
        }),
        a.Pattern.from({
          name: "array",
          description: "array",
          parameter: {
            type: "just",
            value: a.List.type(a.StructuredJsonValue.type()),
          },
        }),
        a.Pattern.from({
          name: "boolean",
          description: "boolean",
          parameter: { type: "just", value: a.Bool.type() },
        }),
        a.Pattern.from({
          name: "null",
          description: "null",
          parameter: { type: "nothing" },
        }),
        a.Pattern.from({
          name: "number",
          description: "number",
          parameter: { type: "just", value: a.Number.type() },
        }),
        a.Pattern.from({
          name: "object",
          description: "object",
          parameter: {
            type: "just",
            value: a.Map.type(a.String.type(), a.StructuredJsonValue.type()),
          },
        }),
      ]),
    }),
  type: (): a.Type<a.StructuredJsonValue> =>
    a.Type.from({
      namespace: a.Namespace.coreType,
      name: "StructuredJsonValue",
      parameters: [],
    }),
  fromStructuredJsonValue: (
    jsonValue: a.StructuredJsonValue
  ): a.StructuredJsonValue => {
    if (jsonValue.type !== "object") {
      throw new Error("expected object in StructuredJsonValue.fromJson");
    }
    const type: a.StructuredJsonValue | undefined = jsonValue.value.get("type");
    if (type === undefined || type.type !== "string") {
      throw new Error("expected type property type is string");
    }
    switch (type.value) {
      case "string": {
        const value: a.StructuredJsonValue | undefined =
          jsonValue.value.get("value");
        if (value === undefined) {
          throw new Error("expected value property in sum parameter");
        }
        return a.StructuredJsonValue.string(
          a.String.fromStructuredJsonValue(value)
        );
      }
      case "array": {
        const value: a.StructuredJsonValue | undefined =
          jsonValue.value.get("value");
        if (value === undefined) {
          throw new Error("expected value property in sum parameter");
        }
        return a.StructuredJsonValue.array(
          a.List.fromStructuredJsonValue(
            a.StructuredJsonValue.fromStructuredJsonValue
          )(value)
        );
      }
      case "boolean": {
        const value: a.StructuredJsonValue | undefined =
          jsonValue.value.get("value");
        if (value === undefined) {
          throw new Error("expected value property in sum parameter");
        }
        return a.StructuredJsonValue.boolean(
          a.Bool.fromStructuredJsonValue(value)
        );
      }
      case "null": {
        return a.StructuredJsonValue.null;
      }
      case "number": {
        const value: a.StructuredJsonValue | undefined =
          jsonValue.value.get("value");
        if (value === undefined) {
          throw new Error("expected value property in sum parameter");
        }
        return a.StructuredJsonValue.number(
          a.Number.fromStructuredJsonValue(value)
        );
      }
      case "object": {
        const value: a.StructuredJsonValue | undefined =
          jsonValue.value.get("value");
        if (value === undefined) {
          throw new Error("expected value property in sum parameter");
        }
        return a.StructuredJsonValue.object(
          a.Map.fromStructuredJsonValue(
            a.String.fromStructuredJsonValue,
            a.StructuredJsonValue.fromStructuredJsonValue
          )(value)
        );
      }
    }
    throw new Error(
      "unknown type value expected [string,array,boolean,null,number,object] but got " +
        type.value
    );
  },
  string: (p: string): a.StructuredJsonValue => ({
    type: "string",
    value: p,
    [Symbol.toStringTag]: "*coreType.StructuredJsonValue",
  }),
  array: (
    p: globalThis.ReadonlyArray<a.StructuredJsonValue>
  ): a.StructuredJsonValue => ({
    type: "array",
    value: p,
    [Symbol.toStringTag]: "*coreType.StructuredJsonValue",
  }),
  boolean: (p: boolean): a.StructuredJsonValue => ({
    type: "boolean",
    value: p,
    [Symbol.toStringTag]: "*coreType.StructuredJsonValue",
  }),
  null: { type: "null", [Symbol.toStringTag]: "*coreType.StructuredJsonValue" },
  number: (p: number): a.StructuredJsonValue => ({
    type: "number",
    value: p,
    [Symbol.toStringTag]: "*coreType.StructuredJsonValue",
  }),
  object: (
    p: globalThis.ReadonlyMap<string, a.StructuredJsonValue>
  ): a.StructuredJsonValue => ({
    type: "object",
    value: p,
    [Symbol.toStringTag]: "*coreType.StructuredJsonValue",
  }),
};

/**
 * リスト
 */
export const List: {
  /**
   * List の型の表現
   */
  readonly typeInfo: () => a.DefinyRpcTypeInfo;
  /**
   * List の型
   */
  readonly type: <p0 extends unknown>(
    a: a.Type<p0>
  ) => a.Type<globalThis.ReadonlyArray<p0>>;
  /**
   * JsonからListに変換する. 失敗した場合はエラー
   */
  readonly fromStructuredJsonValue: <p0 extends unknown>(
    a: (a: a.StructuredJsonValue) => p0
  ) => (a: a.StructuredJsonValue) => globalThis.ReadonlyArray<p0>;
} = {
  typeInfo: (): a.DefinyRpcTypeInfo =>
    a.DefinyRpcTypeInfo.from({
      namespace: a.Namespace.coreType,
      name: "List",
      description: "リスト",
      parameterCount: 1,
      body: a.TypeBody.list,
    }),
  type: <p0 extends unknown>(
    p0: a.Type<p0>
  ): a.Type<globalThis.ReadonlyArray<p0>> =>
    a.Type.from({
      namespace: a.Namespace.coreType,
      name: "List",
      parameters: [p0],
    }),
  fromStructuredJsonValue:
    <p0 extends unknown>(
      p0FromJson: (a: a.StructuredJsonValue) => p0
    ): ((a: a.StructuredJsonValue) => globalThis.ReadonlyArray<p0>) =>
    (jsonValue: a.StructuredJsonValue): globalThis.ReadonlyArray<p0> => {
      if (jsonValue.type === "array") {
        return jsonValue.value.map(p0FromJson);
      }
      throw new Error("expected array in List.fromStructuredJsonValue");
    },
};

/**
 * 辞書型. Map, Dictionary
 */
export const Map: {
  /**
   * Map の型の表現
   */
  readonly typeInfo: () => a.DefinyRpcTypeInfo;
  /**
   * Map の型
   */
  readonly type: <p0 extends unknown, p1 extends unknown>(
    a: a.Type<p0>,
    b: a.Type<p1>
  ) => a.Type<globalThis.ReadonlyMap<p0, p1>>;
  /**
   * JsonからMapに変換する. 失敗した場合はエラー
   */
  readonly fromStructuredJsonValue: <p0 extends unknown, p1 extends unknown>(
    a: (a: a.StructuredJsonValue) => p0,
    b: (a: a.StructuredJsonValue) => p1
  ) => (a: a.StructuredJsonValue) => globalThis.ReadonlyMap<p0, p1>;
} = {
  typeInfo: (): a.DefinyRpcTypeInfo =>
    a.DefinyRpcTypeInfo.from({
      namespace: a.Namespace.coreType,
      name: "Map",
      description: "辞書型. Map, Dictionary",
      parameterCount: 2,
      body: a.TypeBody.map,
    }),
  type: <p0 extends unknown, p1 extends unknown>(
    p0: a.Type<p0>,
    p1: a.Type<p1>
  ): a.Type<globalThis.ReadonlyMap<p0, p1>> =>
    a.Type.from({
      namespace: a.Namespace.coreType,
      name: "Map",
      parameters: [p0, p1],
    }),
  fromStructuredJsonValue:
    <p0 extends unknown, p1 extends unknown>(
      p0FromJson: (a: a.StructuredJsonValue) => p0,
      p1FromJson: (a: a.StructuredJsonValue) => p1
    ): ((a: a.StructuredJsonValue) => globalThis.ReadonlyMap<p0, p1>) =>
    (jsonValue: a.StructuredJsonValue): globalThis.ReadonlyMap<p0, p1> => {
      throw new Error("expected stringMap in Map.fromStructuredJsonValue");
    },
};

/**
 * Set. 集合
 */
export const Set: {
  /**
   * Set の型の表現
   */
  readonly typeInfo: () => a.DefinyRpcTypeInfo;
  /**
   * Set の型
   */
  readonly type: <p0 extends unknown>(
    a: a.Type<p0>
  ) => a.Type<globalThis.ReadonlySet<p0>>;
  /**
   * JsonからSetに変換する. 失敗した場合はエラー
   */
  readonly fromStructuredJsonValue: <p0 extends unknown>(
    a: (a: a.StructuredJsonValue) => p0
  ) => (a: a.StructuredJsonValue) => globalThis.ReadonlySet<p0>;
} = {
  typeInfo: (): a.DefinyRpcTypeInfo =>
    a.DefinyRpcTypeInfo.from({
      namespace: a.Namespace.coreType,
      name: "Set",
      description: "Set. 集合",
      parameterCount: 1,
      body: a.TypeBody.set,
    }),
  type: <p0 extends unknown>(
    p0: a.Type<p0>
  ): a.Type<globalThis.ReadonlySet<p0>> =>
    a.Type.from({
      namespace: a.Namespace.coreType,
      name: "Set",
      parameters: [p0],
    }),
  fromStructuredJsonValue:
    <p0 extends unknown>(
      p0FromJson: (a: a.StructuredJsonValue) => p0
    ): ((a: a.StructuredJsonValue) => globalThis.ReadonlySet<p0>) =>
    (jsonValue: a.StructuredJsonValue): globalThis.ReadonlySet<p0> => {
      if (jsonValue.type === "array") {
        return new globalThis.Set(jsonValue.value.map(p0FromJson));
      }
      throw new Error("expected array in Set.fromStructuredJsonValue");
    },
};

/**
 * 名前空間. ユーザーが生成するものがこっちが用意するものか
 */
export const Namespace: {
  /**
   * Namespace の型の表現
   */
  readonly typeInfo: () => a.DefinyRpcTypeInfo;
  /**
   * Namespace の型
   */
  readonly type: () => a.Type<a.Namespace>;
  /**
   * JsonからNamespaceに変換する. 失敗した場合はエラー
   */
  readonly fromStructuredJsonValue: (a: a.StructuredJsonValue) => a.Namespace;
  /**
   * ユーザーが作ったAPIがあるところ
   */
  readonly local: (a: globalThis.ReadonlyArray<string>) => a.Namespace;
  /**
   * definyRpc 共通で使われる型
   */
  readonly coreType: a.Namespace;
  /**
   * 型安全なJSONのコーデック
   */
  readonly typedJson: a.Namespace;
  /**
   * HTTP経路でAPI呼ぶときに使うコード
   */
  readonly request: a.Namespace;
  /**
   * MaybeとResultがある (一時的対処. coreTypeに入れたい)
   */
  readonly maybe: a.Namespace;
  /**
   * 各サーバーにアクセスし型情報を取得する
   */
  readonly meta: a.Namespace;
} = {
  typeInfo: (): a.DefinyRpcTypeInfo =>
    a.DefinyRpcTypeInfo.from({
      namespace: a.Namespace.coreType,
      name: "Namespace",
      description: "名前空間. ユーザーが生成するものがこっちが用意するものか",
      parameterCount: 0,
      body: a.TypeBody.sum([
        a.Pattern.from({
          name: "local",
          description: "ユーザーが作ったAPIがあるところ",
          parameter: { type: "just", value: a.List.type(a.String.type()) },
        }),
        a.Pattern.from({
          name: "coreType",
          description: "definyRpc 共通で使われる型",
          parameter: { type: "nothing" },
        }),
        a.Pattern.from({
          name: "typedJson",
          description: "型安全なJSONのコーデック",
          parameter: { type: "nothing" },
        }),
        a.Pattern.from({
          name: "request",
          description: "HTTP経路でAPI呼ぶときに使うコード",
          parameter: { type: "nothing" },
        }),
        a.Pattern.from({
          name: "maybe",
          description: "MaybeとResultがある (一時的対処. coreTypeに入れたい)",
          parameter: { type: "nothing" },
        }),
        a.Pattern.from({
          name: "meta",
          description: "各サーバーにアクセスし型情報を取得する",
          parameter: { type: "nothing" },
        }),
      ]),
    }),
  type: (): a.Type<a.Namespace> =>
    a.Type.from({
      namespace: a.Namespace.coreType,
      name: "Namespace",
      parameters: [],
    }),
  fromStructuredJsonValue: (jsonValue: a.StructuredJsonValue): a.Namespace => {
    if (jsonValue.type !== "object") {
      throw new Error("expected object in Namespace.fromJson");
    }
    const type: a.StructuredJsonValue | undefined = jsonValue.value.get("type");
    if (type === undefined || type.type !== "string") {
      throw new Error("expected type property type is string");
    }
    switch (type.value) {
      case "local": {
        const value: a.StructuredJsonValue | undefined =
          jsonValue.value.get("value");
        if (value === undefined) {
          throw new Error("expected value property in sum parameter");
        }
        return a.Namespace.local(
          a.List.fromStructuredJsonValue(a.String.fromStructuredJsonValue)(
            value
          )
        );
      }
      case "coreType": {
        return a.Namespace.coreType;
      }
      case "typedJson": {
        return a.Namespace.typedJson;
      }
      case "request": {
        return a.Namespace.request;
      }
      case "maybe": {
        return a.Namespace.maybe;
      }
      case "meta": {
        return a.Namespace.meta;
      }
    }
    throw new Error(
      "unknown type value expected [local,coreType,typedJson,request,maybe,meta] but got " +
        type.value
    );
  },
  local: (p: globalThis.ReadonlyArray<string>): a.Namespace => ({
    type: "local",
    value: p,
    [Symbol.toStringTag]: "*coreType.Namespace",
  }),
  coreType: { type: "coreType", [Symbol.toStringTag]: "*coreType.Namespace" },
  typedJson: { type: "typedJson", [Symbol.toStringTag]: "*coreType.Namespace" },
  request: { type: "request", [Symbol.toStringTag]: "*coreType.Namespace" },
  maybe: { type: "maybe", [Symbol.toStringTag]: "*coreType.Namespace" },
  meta: { type: "meta", [Symbol.toStringTag]: "*coreType.Namespace" },
};

/**
 * definy RPC 型の構造
 */
export const DefinyRpcTypeInfo: {
  /**
   * DefinyRpcTypeInfo の型の表現
   */
  readonly typeInfo: () => a.DefinyRpcTypeInfo;
  /**
   * DefinyRpcTypeInfo の型
   */
  readonly type: () => a.Type<a.DefinyRpcTypeInfo>;
  /**
   * オブジェクトから作成する. 余計なフィールドがレスポンスに含まれてしまうのを防ぐ. 型のチェックはしない
   */
  readonly from: (
    a: globalThis.Omit<a.DefinyRpcTypeInfo, typeof Symbol.toStringTag>
  ) => a.DefinyRpcTypeInfo;
  /**
   * JsonからDefinyRpcTypeInfoに変換する. 失敗した場合はエラー
   */
  readonly fromStructuredJsonValue: (
    a: a.StructuredJsonValue
  ) => a.DefinyRpcTypeInfo;
} = {
  typeInfo: (): a.DefinyRpcTypeInfo =>
    a.DefinyRpcTypeInfo.from({
      namespace: a.Namespace.coreType,
      name: "DefinyRpcTypeInfo",
      description: "definy RPC 型の構造",
      parameterCount: 0,
      body: a.TypeBody.product([
        a.Field.from({
          name: "namespace",
          description: "型が所属する名前空間",
          type: a.Namespace.type(),
        }),
        a.Field.from({
          name: "name",
          description: "型の名前",
          type: a.String.type(),
        }),
        a.Field.from({
          name: "description",
          description: "説明文. コメントなどに出力される",
          type: a.String.type(),
        }),
        a.Field.from({
          name: "parameterCount",
          description:
            "パラメーターの数. パラメーター名やドキュメントはまたいつか復活させる",
          type: a.Number.type(),
        }),
        a.Field.from({
          name: "body",
          description: "型の構造を表現する",
          type: a.TypeBody.type(),
        }),
      ]),
    }),
  type: (): a.Type<a.DefinyRpcTypeInfo> =>
    a.Type.from({
      namespace: a.Namespace.coreType,
      name: "DefinyRpcTypeInfo",
      parameters: [],
    }),
  from: (
    obj: globalThis.Omit<a.DefinyRpcTypeInfo, typeof Symbol.toStringTag>
  ): a.DefinyRpcTypeInfo => ({
    namespace: obj.namespace,
    name: obj.name,
    description: obj.description,
    parameterCount: obj.parameterCount,
    body: obj.body,
    [Symbol.toStringTag]: "*coreType.DefinyRpcTypeInfo",
  }),
  fromStructuredJsonValue: (
    jsonValue: a.StructuredJsonValue
  ): a.DefinyRpcTypeInfo => {
    if (jsonValue.type !== "object") {
      throw new Error(
        "expected object in DefinyRpcTypeInfo.fromStructuredJsonValue"
      );
    }
    const namespace: a.StructuredJsonValue | undefined =
      jsonValue.value.get("namespace");
    if (namespace === undefined) {
      throw new Error(
        "expected namespace field. in DefinyRpcTypeInfo.fromStructuredJsonValue"
      );
    }
    const name: a.StructuredJsonValue | undefined = jsonValue.value.get("name");
    if (name === undefined) {
      throw new Error(
        "expected name field. in DefinyRpcTypeInfo.fromStructuredJsonValue"
      );
    }
    const description: a.StructuredJsonValue | undefined =
      jsonValue.value.get("description");
    if (description === undefined) {
      throw new Error(
        "expected description field. in DefinyRpcTypeInfo.fromStructuredJsonValue"
      );
    }
    const parameterCount: a.StructuredJsonValue | undefined =
      jsonValue.value.get("parameterCount");
    if (parameterCount === undefined) {
      throw new Error(
        "expected parameterCount field. in DefinyRpcTypeInfo.fromStructuredJsonValue"
      );
    }
    const body: a.StructuredJsonValue | undefined = jsonValue.value.get("body");
    if (body === undefined) {
      throw new Error(
        "expected body field. in DefinyRpcTypeInfo.fromStructuredJsonValue"
      );
    }
    return a.DefinyRpcTypeInfo.from({
      namespace: a.Namespace.fromStructuredJsonValue(namespace),
      name: a.String.fromStructuredJsonValue(name),
      description: a.String.fromStructuredJsonValue(description),
      parameterCount: a.Number.fromStructuredJsonValue(parameterCount),
      body: a.TypeBody.fromStructuredJsonValue(body),
    });
  },
};

/**
 * 型の構造を表現する
 */
export const TypeBody: {
  /**
   * TypeBody の型の表現
   */
  readonly typeInfo: () => a.DefinyRpcTypeInfo;
  /**
   * TypeBody の型
   */
  readonly type: () => a.Type<a.TypeBody>;
  /**
   * JsonからTypeBodyに変換する. 失敗した場合はエラー
   */
  readonly fromStructuredJsonValue: (a: a.StructuredJsonValue) => a.TypeBody;
  /**
   * string
   */
  readonly string: a.TypeBody;
  /**
   * number
   */
  readonly number: a.TypeBody;
  /**
   * boolean
   */
  readonly boolean: a.TypeBody;
  /**
   * unit
   */
  readonly unit: a.TypeBody;
  /**
   * list
   */
  readonly list: a.TypeBody;
  /**
   * set
   */
  readonly set: a.TypeBody;
  /**
   * map
   */
  readonly map: a.TypeBody;
  /**
   * url
   */
  readonly url: a.TypeBody;
  /**
   * product
   */
  readonly product: (a: globalThis.ReadonlyArray<a.Field>) => a.TypeBody;
  /**
   * sum
   */
  readonly sum: (a: globalThis.ReadonlyArray<a.Pattern>) => a.TypeBody;
} = {
  typeInfo: (): a.DefinyRpcTypeInfo =>
    a.DefinyRpcTypeInfo.from({
      namespace: a.Namespace.coreType,
      name: "TypeBody",
      description: "型の構造を表現する",
      parameterCount: 0,
      body: a.TypeBody.sum([
        a.Pattern.from({
          name: "string",
          description: "string",
          parameter: { type: "nothing" },
        }),
        a.Pattern.from({
          name: "number",
          description: "number",
          parameter: { type: "nothing" },
        }),
        a.Pattern.from({
          name: "boolean",
          description: "boolean",
          parameter: { type: "nothing" },
        }),
        a.Pattern.from({
          name: "unit",
          description: "unit",
          parameter: { type: "nothing" },
        }),
        a.Pattern.from({
          name: "list",
          description: "list",
          parameter: { type: "nothing" },
        }),
        a.Pattern.from({
          name: "set",
          description: "set",
          parameter: { type: "nothing" },
        }),
        a.Pattern.from({
          name: "map",
          description: "map",
          parameter: { type: "nothing" },
        }),
        a.Pattern.from({
          name: "url",
          description: "url",
          parameter: { type: "nothing" },
        }),
        a.Pattern.from({
          name: "product",
          description: "product",
          parameter: { type: "just", value: a.List.type(a.Field.type()) },
        }),
        a.Pattern.from({
          name: "sum",
          description: "sum",
          parameter: { type: "just", value: a.List.type(a.Pattern.type()) },
        }),
      ]),
    }),
  type: (): a.Type<a.TypeBody> =>
    a.Type.from({
      namespace: a.Namespace.coreType,
      name: "TypeBody",
      parameters: [],
    }),
  fromStructuredJsonValue: (jsonValue: a.StructuredJsonValue): a.TypeBody => {
    if (jsonValue.type !== "object") {
      throw new Error("expected object in TypeBody.fromJson");
    }
    const type: a.StructuredJsonValue | undefined = jsonValue.value.get("type");
    if (type === undefined || type.type !== "string") {
      throw new Error("expected type property type is string");
    }
    switch (type.value) {
      case "string": {
        return a.TypeBody.string;
      }
      case "number": {
        return a.TypeBody.number;
      }
      case "boolean": {
        return a.TypeBody.boolean;
      }
      case "unit": {
        return a.TypeBody.unit;
      }
      case "list": {
        return a.TypeBody.list;
      }
      case "set": {
        return a.TypeBody.set;
      }
      case "map": {
        return a.TypeBody.map;
      }
      case "url": {
        return a.TypeBody.url;
      }
      case "product": {
        const value: a.StructuredJsonValue | undefined =
          jsonValue.value.get("value");
        if (value === undefined) {
          throw new Error("expected value property in sum parameter");
        }
        return a.TypeBody.product(
          a.List.fromStructuredJsonValue(a.Field.fromStructuredJsonValue)(value)
        );
      }
      case "sum": {
        const value: a.StructuredJsonValue | undefined =
          jsonValue.value.get("value");
        if (value === undefined) {
          throw new Error("expected value property in sum parameter");
        }
        return a.TypeBody.sum(
          a.List.fromStructuredJsonValue(a.Pattern.fromStructuredJsonValue)(
            value
          )
        );
      }
    }
    throw new Error(
      "unknown type value expected [string,number,boolean,unit,list,set,map,url,product,sum] but got " +
        type.value
    );
  },
  string: { type: "string", [Symbol.toStringTag]: "*coreType.TypeBody" },
  number: { type: "number", [Symbol.toStringTag]: "*coreType.TypeBody" },
  boolean: { type: "boolean", [Symbol.toStringTag]: "*coreType.TypeBody" },
  unit: { type: "unit", [Symbol.toStringTag]: "*coreType.TypeBody" },
  list: { type: "list", [Symbol.toStringTag]: "*coreType.TypeBody" },
  set: { type: "set", [Symbol.toStringTag]: "*coreType.TypeBody" },
  map: { type: "map", [Symbol.toStringTag]: "*coreType.TypeBody" },
  url: { type: "url", [Symbol.toStringTag]: "*coreType.TypeBody" },
  product: (p: globalThis.ReadonlyArray<a.Field>): a.TypeBody => ({
    type: "product",
    value: p,
    [Symbol.toStringTag]: "*coreType.TypeBody",
  }),
  sum: (p: globalThis.ReadonlyArray<a.Pattern>): a.TypeBody => ({
    type: "sum",
    value: p,
    [Symbol.toStringTag]: "*coreType.TypeBody",
  }),
};

/**
 * product 直積型で使う
 */
export const Field: {
  /**
   * Field の型の表現
   */
  readonly typeInfo: () => a.DefinyRpcTypeInfo;
  /**
   * Field の型
   */
  readonly type: () => a.Type<a.Field>;
  /**
   * オブジェクトから作成する. 余計なフィールドがレスポンスに含まれてしまうのを防ぐ. 型のチェックはしない
   */
  readonly from: (
    a: globalThis.Omit<a.Field, typeof Symbol.toStringTag>
  ) => a.Field;
  /**
   * JsonからFieldに変換する. 失敗した場合はエラー
   */
  readonly fromStructuredJsonValue: (a: a.StructuredJsonValue) => a.Field;
} = {
  typeInfo: (): a.DefinyRpcTypeInfo =>
    a.DefinyRpcTypeInfo.from({
      namespace: a.Namespace.coreType,
      name: "Field",
      description: "product 直積型で使う",
      parameterCount: 0,
      body: a.TypeBody.product([
        a.Field.from({
          name: "name",
          description: "フィールド名",
          type: a.String.type(),
        }),
        a.Field.from({
          name: "description",
          description: "フィールドの説明",
          type: a.String.type(),
        }),
        a.Field.from({ name: "type", description: "型", type: a.Type.type() }),
      ]),
    }),
  type: (): a.Type<a.Field> =>
    a.Type.from({
      namespace: a.Namespace.coreType,
      name: "Field",
      parameters: [],
    }),
  from: (
    obj: globalThis.Omit<a.Field, typeof Symbol.toStringTag>
  ): a.Field => ({
    name: obj.name,
    description: obj.description,
    type: obj.type,
    [Symbol.toStringTag]: "*coreType.Field",
  }),
  fromStructuredJsonValue: (jsonValue: a.StructuredJsonValue): a.Field => {
    if (jsonValue.type !== "object") {
      throw new Error("expected object in Field.fromStructuredJsonValue");
    }
    const name: a.StructuredJsonValue | undefined = jsonValue.value.get("name");
    if (name === undefined) {
      throw new Error("expected name field. in Field.fromStructuredJsonValue");
    }
    const description: a.StructuredJsonValue | undefined =
      jsonValue.value.get("description");
    if (description === undefined) {
      throw new Error(
        "expected description field. in Field.fromStructuredJsonValue"
      );
    }
    const type: a.StructuredJsonValue | undefined = jsonValue.value.get("type");
    if (type === undefined) {
      throw new Error("expected type field. in Field.fromStructuredJsonValue");
    }
    return a.Field.from({
      name: a.String.fromStructuredJsonValue(name),
      description: a.String.fromStructuredJsonValue(description),
      type: a.Type.fromStructuredJsonValue(type),
    });
  },
};

/**
 * 直和型の表現
 */
export const Pattern: {
  /**
   * Pattern の型の表現
   */
  readonly typeInfo: () => a.DefinyRpcTypeInfo;
  /**
   * Pattern の型
   */
  readonly type: () => a.Type<a.Pattern>;
  /**
   * オブジェクトから作成する. 余計なフィールドがレスポンスに含まれてしまうのを防ぐ. 型のチェックはしない
   */
  readonly from: (
    a: globalThis.Omit<a.Pattern, typeof Symbol.toStringTag>
  ) => a.Pattern;
  /**
   * JsonからPatternに変換する. 失敗した場合はエラー
   */
  readonly fromStructuredJsonValue: (a: a.StructuredJsonValue) => a.Pattern;
} = {
  typeInfo: (): a.DefinyRpcTypeInfo =>
    a.DefinyRpcTypeInfo.from({
      namespace: a.Namespace.coreType,
      name: "Pattern",
      description: "直和型の表現",
      parameterCount: 0,
      body: a.TypeBody.product([
        a.Field.from({
          name: "name",
          description: "パターン名",
          type: a.String.type(),
        }),
        a.Field.from({
          name: "description",
          description: "説明",
          type: a.String.type(),
        }),
        a.Field.from({
          name: "parameter",
          description: "パラメーター",
          type: b.Maybe.type(a.Type.type()),
        }),
      ]),
    }),
  type: (): a.Type<a.Pattern> =>
    a.Type.from({
      namespace: a.Namespace.coreType,
      name: "Pattern",
      parameters: [],
    }),
  from: (
    obj: globalThis.Omit<a.Pattern, typeof Symbol.toStringTag>
  ): a.Pattern => ({
    name: obj.name,
    description: obj.description,
    parameter: obj.parameter,
    [Symbol.toStringTag]: "*coreType.Pattern",
  }),
  fromStructuredJsonValue: (jsonValue: a.StructuredJsonValue): a.Pattern => {
    if (jsonValue.type !== "object") {
      throw new Error("expected object in Pattern.fromStructuredJsonValue");
    }
    const name: a.StructuredJsonValue | undefined = jsonValue.value.get("name");
    if (name === undefined) {
      throw new Error(
        "expected name field. in Pattern.fromStructuredJsonValue"
      );
    }
    const description: a.StructuredJsonValue | undefined =
      jsonValue.value.get("description");
    if (description === undefined) {
      throw new Error(
        "expected description field. in Pattern.fromStructuredJsonValue"
      );
    }
    const parameter: a.StructuredJsonValue | undefined =
      jsonValue.value.get("parameter");
    if (parameter === undefined) {
      throw new Error(
        "expected parameter field. in Pattern.fromStructuredJsonValue"
      );
    }
    return a.Pattern.from({
      name: a.String.fromStructuredJsonValue(name),
      description: a.String.fromStructuredJsonValue(description),
      parameter: b.Maybe.fromStructuredJsonValue(
        a.Type.fromStructuredJsonValue
      )(parameter),
    });
  },
};

/**
 * 型
 */
export const Type: {
  /**
   * Type の型の表現
   */
  readonly typeInfo: () => a.DefinyRpcTypeInfo;
  /**
   * Type の型
   */
  readonly type: () => a.Type<a.Type>;
  /**
   * オブジェクトから作成する. 余計なフィールドがレスポンスに含まれてしまうのを防ぐ. 型のチェックはしない
   */
  readonly from: <p0 extends unknown>(
    a: globalThis.Omit<Type<p0>, typeof neverSymbol | typeof Symbol.toStringTag>
  ) => Type<p0>;
  /**
   * JsonからTypeに変換する. 失敗した場合はエラー
   */
  readonly fromStructuredJsonValue: (a: a.StructuredJsonValue) => a.Type;
} = {
  typeInfo: (): a.DefinyRpcTypeInfo =>
    a.DefinyRpcTypeInfo.from({
      namespace: a.Namespace.coreType,
      name: "Type",
      description: "型",
      parameterCount: 0,
      body: a.TypeBody.product([
        a.Field.from({
          name: "namespace",
          description: "名前空間",
          type: a.Namespace.type(),
        }),
        a.Field.from({
          name: "name",
          description: "型の名前",
          type: a.String.type(),
        }),
        a.Field.from({
          name: "parameters",
          description: "型パラメータ",
          type: a.List.type(a.Type.type()),
        }),
      ]),
    }),
  type: (): a.Type<a.Type> =>
    a.Type.from({
      namespace: a.Namespace.coreType,
      name: "Type",
      parameters: [],
    }),
  from: <p0 extends unknown>(
    obj: globalThis.Omit<
      Type<p0>,
      typeof neverSymbol | typeof Symbol.toStringTag
    >
  ): Type<p0> => ({
    namespace: obj.namespace,
    name: obj.name,
    parameters: obj.parameters,
    [Symbol.toStringTag]: "*coreType.Type",
    [neverSymbol]: {} as p0,
  }),
  fromStructuredJsonValue: (jsonValue: a.StructuredJsonValue): a.Type => {
    if (jsonValue.type !== "object") {
      throw new Error("expected object in Type.fromStructuredJsonValue");
    }
    const namespace: a.StructuredJsonValue | undefined =
      jsonValue.value.get("namespace");
    if (namespace === undefined) {
      throw new Error(
        "expected namespace field. in Type.fromStructuredJsonValue"
      );
    }
    const name: a.StructuredJsonValue | undefined = jsonValue.value.get("name");
    if (name === undefined) {
      throw new Error("expected name field. in Type.fromStructuredJsonValue");
    }
    const parameters: a.StructuredJsonValue | undefined =
      jsonValue.value.get("parameters");
    if (parameters === undefined) {
      throw new Error(
        "expected parameters field. in Type.fromStructuredJsonValue"
      );
    }
    return a.Type.from({
      namespace: a.Namespace.fromStructuredJsonValue(namespace),
      name: a.String.fromStructuredJsonValue(name),
      parameters: a.List.fromStructuredJsonValue(
        a.Type.fromStructuredJsonValue
      )(parameters),
    });
  },
};

/**
 * 出力されるAPI関数のモジュール名
 */
export const FunctionNamespace: {
  /**
   * FunctionNamespace の型の表現
   */
  readonly typeInfo: () => a.DefinyRpcTypeInfo;
  /**
   * FunctionNamespace の型
   */
  readonly type: () => a.Type<a.FunctionNamespace>;
  /**
   * JsonからFunctionNamespaceに変換する. 失敗した場合はエラー
   */
  readonly fromStructuredJsonValue: (
    a: a.StructuredJsonValue
  ) => a.FunctionNamespace;
  /**
   * APIがどんな構造で表現されているかを取得するためのAPI
   */
  readonly meta: a.FunctionNamespace;
  /**
   * definy RPC を利用するユーザーが定義したモジュール
   */
  readonly local: (a: globalThis.ReadonlyArray<string>) => a.FunctionNamespace;
} = {
  typeInfo: (): a.DefinyRpcTypeInfo =>
    a.DefinyRpcTypeInfo.from({
      namespace: a.Namespace.coreType,
      name: "FunctionNamespace",
      description: "出力されるAPI関数のモジュール名",
      parameterCount: 0,
      body: a.TypeBody.sum([
        a.Pattern.from({
          name: "meta",
          description: "APIがどんな構造で表現されているかを取得するためのAPI",
          parameter: { type: "nothing" },
        }),
        a.Pattern.from({
          name: "local",
          description: "definy RPC を利用するユーザーが定義したモジュール",
          parameter: { type: "just", value: a.List.type(a.String.type()) },
        }),
      ]),
    }),
  type: (): a.Type<a.FunctionNamespace> =>
    a.Type.from({
      namespace: a.Namespace.coreType,
      name: "FunctionNamespace",
      parameters: [],
    }),
  fromStructuredJsonValue: (
    jsonValue: a.StructuredJsonValue
  ): a.FunctionNamespace => {
    if (jsonValue.type !== "object") {
      throw new Error("expected object in FunctionNamespace.fromJson");
    }
    const type: a.StructuredJsonValue | undefined = jsonValue.value.get("type");
    if (type === undefined || type.type !== "string") {
      throw new Error("expected type property type is string");
    }
    switch (type.value) {
      case "meta": {
        return a.FunctionNamespace.meta;
      }
      case "local": {
        const value: a.StructuredJsonValue | undefined =
          jsonValue.value.get("value");
        if (value === undefined) {
          throw new Error("expected value property in sum parameter");
        }
        return a.FunctionNamespace.local(
          a.List.fromStructuredJsonValue(a.String.fromStructuredJsonValue)(
            value
          )
        );
      }
    }
    throw new Error(
      "unknown type value expected [meta,local] but got " + type.value
    );
  },
  meta: { type: "meta", [Symbol.toStringTag]: "*coreType.FunctionNamespace" },
  local: (p: globalThis.ReadonlyArray<string>): a.FunctionNamespace => ({
    type: "local",
    value: p,
    [Symbol.toStringTag]: "*coreType.FunctionNamespace",
  }),
};

/**
 * 関数のデータ functionByNameの結果
 */
export const FunctionDetail: {
  /**
   * FunctionDetail の型の表現
   */
  readonly typeInfo: () => a.DefinyRpcTypeInfo;
  /**
   * FunctionDetail の型
   */
  readonly type: () => a.Type<a.FunctionDetail>;
  /**
   * オブジェクトから作成する. 余計なフィールドがレスポンスに含まれてしまうのを防ぐ. 型のチェックはしない
   */
  readonly from: (
    a: globalThis.Omit<a.FunctionDetail, typeof Symbol.toStringTag>
  ) => a.FunctionDetail;
  /**
   * JsonからFunctionDetailに変換する. 失敗した場合はエラー
   */
  readonly fromStructuredJsonValue: (
    a: a.StructuredJsonValue
  ) => a.FunctionDetail;
} = {
  typeInfo: (): a.DefinyRpcTypeInfo =>
    a.DefinyRpcTypeInfo.from({
      namespace: a.Namespace.coreType,
      name: "FunctionDetail",
      description: "関数のデータ functionByNameの結果",
      parameterCount: 0,
      body: a.TypeBody.product([
        a.Field.from({
          name: "namespace",
          description: "名前空間",
          type: a.FunctionNamespace.type(),
        }),
        a.Field.from({
          name: "name",
          description: "api名",
          type: a.String.type(),
        }),
        a.Field.from({
          name: "description",
          description: "説明文",
          type: a.String.type(),
        }),
        a.Field.from({
          name: "input",
          description: "入力の型",
          type: a.Type.type(),
        }),
        a.Field.from({
          name: "output",
          description: "出力の型",
          type: a.Type.type(),
        }),
        a.Field.from({
          name: "needAuthentication",
          description: "認証が必要かどうか (キャッシュしなくなる)",
          type: a.Bool.type(),
        }),
        a.Field.from({
          name: "isMutation",
          description: "単なるデータの取得ではなく, 変更するようなものか",
          type: a.Bool.type(),
        }),
      ]),
    }),
  type: (): a.Type<a.FunctionDetail> =>
    a.Type.from({
      namespace: a.Namespace.coreType,
      name: "FunctionDetail",
      parameters: [],
    }),
  from: (
    obj: globalThis.Omit<a.FunctionDetail, typeof Symbol.toStringTag>
  ): a.FunctionDetail => ({
    namespace: obj.namespace,
    name: obj.name,
    description: obj.description,
    input: obj.input,
    output: obj.output,
    needAuthentication: obj.needAuthentication,
    isMutation: obj.isMutation,
    [Symbol.toStringTag]: "*coreType.FunctionDetail",
  }),
  fromStructuredJsonValue: (
    jsonValue: a.StructuredJsonValue
  ): a.FunctionDetail => {
    if (jsonValue.type !== "object") {
      throw new Error(
        "expected object in FunctionDetail.fromStructuredJsonValue"
      );
    }
    const namespace: a.StructuredJsonValue | undefined =
      jsonValue.value.get("namespace");
    if (namespace === undefined) {
      throw new Error(
        "expected namespace field. in FunctionDetail.fromStructuredJsonValue"
      );
    }
    const name: a.StructuredJsonValue | undefined = jsonValue.value.get("name");
    if (name === undefined) {
      throw new Error(
        "expected name field. in FunctionDetail.fromStructuredJsonValue"
      );
    }
    const description: a.StructuredJsonValue | undefined =
      jsonValue.value.get("description");
    if (description === undefined) {
      throw new Error(
        "expected description field. in FunctionDetail.fromStructuredJsonValue"
      );
    }
    const input: a.StructuredJsonValue | undefined =
      jsonValue.value.get("input");
    if (input === undefined) {
      throw new Error(
        "expected input field. in FunctionDetail.fromStructuredJsonValue"
      );
    }
    const output: a.StructuredJsonValue | undefined =
      jsonValue.value.get("output");
    if (output === undefined) {
      throw new Error(
        "expected output field. in FunctionDetail.fromStructuredJsonValue"
      );
    }
    const needAuthentication: a.StructuredJsonValue | undefined =
      jsonValue.value.get("needAuthentication");
    if (needAuthentication === undefined) {
      throw new Error(
        "expected needAuthentication field. in FunctionDetail.fromStructuredJsonValue"
      );
    }
    const isMutation: a.StructuredJsonValue | undefined =
      jsonValue.value.get("isMutation");
    if (isMutation === undefined) {
      throw new Error(
        "expected isMutation field. in FunctionDetail.fromStructuredJsonValue"
      );
    }
    return a.FunctionDetail.from({
      namespace: a.FunctionNamespace.fromStructuredJsonValue(namespace),
      name: a.String.fromStructuredJsonValue(name),
      description: a.String.fromStructuredJsonValue(description),
      input: a.Type.fromStructuredJsonValue(input),
      output: a.Type.fromStructuredJsonValue(output),
      needAuthentication: a.Bool.fromStructuredJsonValue(needAuthentication),
      isMutation: a.Bool.fromStructuredJsonValue(isMutation),
    });
  },
};

/**
 * hello と挨拶が返ってくる
 */
export const hello = (parameter: {
  /**
   * api end point
   * @default http://localhost:2520
   */
  readonly url?: string | undefined;
}): globalThis.Promise<b.Result<string, "error">> => {
  const url: globalThis.URL = new globalThis.URL(
    parameter.url ?? "http://localhost:2520"
  );
  url.pathname = url.pathname + "/api/main/hello";
  return fetch(url)
    .then(
      (response: globalThis.Response): globalThis.Promise<c.RawJsonValue> =>
        response.json()
    )
    .then(
      (jsonValue: c.RawJsonValue): b.Result<string, "error"> => ({
        type: "ok",
        ok: a.String.fromStructuredJsonValue(
          c.rawJsonToStructuredJsonValue(jsonValue)
        ),
      })
    )
    .catch(
      (): b.Result<string, "error"> => ({ type: "error", error: "error" })
    );
};

/**
 * 現在時刻を文字列で返す
 */
export const now = (parameter: {
  /**
   * api end point
   * @default http://localhost:2520
   */
  readonly url?: string | undefined;
}): globalThis.Promise<b.Result<string, "error">> => {
  const url: globalThis.URL = new globalThis.URL(
    parameter.url ?? "http://localhost:2520"
  );
  url.pathname = url.pathname + "/api/main/now";
  return fetch(url)
    .then(
      (response: globalThis.Response): globalThis.Promise<c.RawJsonValue> =>
        response.json()
    )
    .then(
      (jsonValue: c.RawJsonValue): b.Result<string, "error"> => ({
        type: "ok",
        ok: a.String.fromStructuredJsonValue(
          c.rawJsonToStructuredJsonValue(jsonValue)
        ),
      })
    )
    .catch(
      (): b.Result<string, "error"> => ({ type: "error", error: "error" })
    );
};

/**
 * "ok"を指定した回数分繰り返して返す
 */
export const repeat = (parameter: {
  /**
   * api end point
   * @default http://localhost:2520
   */
  readonly url?: string | undefined;
  readonly input: number;
}): globalThis.Promise<b.Result<string, "error">> => {
  const url: globalThis.URL = new globalThis.URL(
    parameter.url ?? "http://localhost:2520"
  );
  url.pathname = url.pathname + "/api/main/repeat";
  return fetch(url)
    .then(
      (response: globalThis.Response): globalThis.Promise<c.RawJsonValue> =>
        response.json()
    )
    .then(
      (jsonValue: c.RawJsonValue): b.Result<string, "error"> => ({
        type: "ok",
        ok: a.String.fromStructuredJsonValue(
          c.rawJsonToStructuredJsonValue(jsonValue)
        ),
      })
    )
    .catch(
      (): b.Result<string, "error"> => ({ type: "error", error: "error" })
    );
};
