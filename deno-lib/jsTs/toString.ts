import * as d from "./data.ts";
import {
  documentToString,
  typeParameterListToString,
} from "./toString/common.ts";
import { exprToString, lambdaBodyToString } from "./toString/expr.ts";
import { typeAnnotation, typeToString } from "./toString/type.ts";
import { statementListToString } from "./toString/statement.ts";
import { TsIdentifier } from "./identifier.ts";

/**
 * コードを文字列にする
 * @param code コードを表すデータ
 * @param moduleMap モジュールの名をnamed importで使う名前
 * @param codeType JavaScriptかTypeScriptか
 */
export const toString = (
  code: d.JsTsCode,
  moduleMap: ReadonlyMap<string, TsIdentifier>,
  codeType: d.CodeType
): string => {
  const importCode =
    "/* eslint-disable */\n/* generated by definy. Do not edit! */\n\n" +
    [...moduleMap.entries()]
      .map(
        ([name, identifier]) =>
          "import * as " + identifier + ' from "' + name + '";'
      )
      .join("\n") +
    "\n";

  const definitionCode =
    code.exportDefinitionList
      .map((definition) => definitionToString(definition, moduleMap, codeType))
      .join("") + "\n";

  const statementCode = statementListToString(
    code.statementList,
    0,
    moduleMap,
    codeType
  );

  if (code.statementList.length === 0) {
    return importCode + definitionCode;
  }
  return importCode + definitionCode + statementCode;
};

const definitionToString = (
  definition: d.ExportDefinition,
  moduleMap: ReadonlyMap<string, TsIdentifier>,
  codeType: d.CodeType
): string => {
  switch (definition.type) {
    case "typeAlias":
      if (codeType === "JavaScript") {
        return "";
      }
      return typeAliasToString(definition.typeAlias, moduleMap);

    case "function":
      return exportFunctionToString(definition.function, moduleMap, codeType);

    case "variable":
      return exportVariableToString(definition.variable, moduleMap, codeType);
  }
};

const typeAliasToString = (
  typeAlias: d.TypeAlias,
  moduleMap: ReadonlyMap<string, TsIdentifier>
): string => {
  const content =
    documentToString(typeAlias.document) +
    "export type " +
    typeAlias.name +
    typeParameterListToString(typeAlias.typeParameterList) +
    " = " +
    typeToString(typeAlias.type, moduleMap) +
    ";\n\n";
  if (typeAlias.namespace.length === 0) {
    return content;
  }
  return (
    "export declare namespace " +
    typeAlias.namespace.join(".") +
    " {\n" +
    content +
    "\n}"
  );
};

const exportFunctionToString = (
  function_: d.Function,
  moduleMap: ReadonlyMap<string, TsIdentifier>,
  codeType: d.CodeType
): string =>
  documentToString(
    function_.document + parameterListToDocument(function_.parameterList)
  ) +
  "export const " +
  function_.name +
  " = " +
  typeParameterListToString(function_.typeParameterList) +
  "(" +
  function_.parameterList
    .map(
      (parameter) =>
        parameter.name + typeAnnotation(parameter.type, codeType, moduleMap)
    )
    .join(", ") +
  ")" +
  typeAnnotation(function_.returnType, codeType, moduleMap) +
  " => " +
  lambdaBodyToString(function_.statementList, 0, moduleMap, codeType) +
  ";\n\n";

const exportVariableToString = (
  variable: d.Variable,
  moduleMap: ReadonlyMap<string, TsIdentifier>,
  codeType: d.CodeType
): string =>
  documentToString(variable.document) +
  "export const " +
  variable.name +
  typeAnnotation(variable.type, codeType, moduleMap) +
  " = " +
  exprToString(variable.expr, 0, moduleMap, codeType) +
  ";\n\n";

const parameterListToDocument = (
  parameterList: ReadonlyArray<d.ParameterWithDocument>
): string =>
  parameterList.length === 0
    ? ""
    : "\n" +
      parameterList
        .map((parameter) =>
          parameter.document === ""
            ? ""
            : "@param " + parameter.name + " " + parameter.document
        )
        .join("\n");
