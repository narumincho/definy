/* eslint-disable */
/* generated by js-ts-code-generator. Do not edit! */

/**
 * UserId, ProjectIdなどのIdをバイナリ形式にエンコードする
 */
export const encodeId = (value: string): ReadonlyArray<number> =>
  Array.from({ length: 16 }, (_: undefined, i: number): number =>
    Number.parseInt(value.slice(i * 2, i * 2 + 2), 16)
  );

/**
 * バイナリ形式をUserId, ProjectIdなどのIdにデコードする
 * @param index バイナリを読み込み開始位置
 * @param binary バイナリ
 */
export const decodeId = (
  index: number,
  binary: Uint8Array
): { readonly result: string; readonly nextIndex: number } => ({
  result: [...binary.slice(index, index + 16)]
    .map((n: number): string => n.toString(16).padStart(2, "0"))
    .join(""),
  nextIndex: index + 16,
});

/**
 * ImageTokenなどのTokenをバイナリ形式にエンコードする
 */
export const encodeToken = (value: string): ReadonlyArray<number> =>
  Array.from({ length: 32 }, (_: undefined, i: number): number =>
    Number.parseInt(value.slice(i * 2, i * 2 + 2), 16)
  );

/**
 * バイナリ形式をImageTokenなどのTokenにエンコードする
 * @param index バイナリを読み込み開始位置
 * @param binary バイナリ
 */
export const decodeToken = (
  index: number,
  binary: Uint8Array
): { readonly result: string; readonly nextIndex: number } => ({
  result: [...binary.slice(index, index + 32)]
    .map((n: number): string => n.toString(16).padStart(2, "0"))
    .join(""),
  nextIndex: index + 32,
});

/**
 * バイナリと相互変換するための関数
 */
export type Codec<T extends unknown> = {
  readonly encode: (a: T) => ReadonlyArray<number>;
  readonly decode: (
    a: number,
    b: Uint8Array
  ) => { readonly result: T; readonly nextIndex: number };
};

/**
 * バリアント. 値コンストラクタ. タグ
 * @typePartId 0bc2e5ab2fd2caeb6e6c331573ae735f
 */
export type ElmVariant = {
  /**
   * バリアント名
   */
  readonly name: ElmVariantName;
  /**
   * パラメーター
   */
  readonly parameter: List<ElmType>;
};

/**
 * 外部に公開する定義
 * @typePartId 0c8b854b812290a054877ca5de6c4daf
 */
export type ExportDefinition =
  | { readonly _: "TypeAlias"; readonly typeAlias: TypeAlias }
  | { readonly _: "Function"; readonly function: Function }
  | { readonly _: "Variable"; readonly variable: Variable };

/**
 * 単項演算子と適用される式
 * @typePartId 0cb0a34b3953e57b30f4a5c8f9d305da
 */
export type UnaryOperatorExpr = {
  /**
   * 単項演算子
   */
  readonly operator: UnaryOperator;
  /**
   * 適用される式
   */
  readonly expr: TsExpr;
};

/**
 * プロジェクトの識別子
 * @typePartId 0cd913118a2ad1469d656146a08c5f76
 */
export type ProjectId = string & { readonly _projectId: never };

/**
 * 英語,日本語,エスペラント語
 *
 * ナルミンチョが使える? プログラミングじゃない言語
 * @typePartId 0d9510723f4d34605e41f3a47a8b0ea7
 */
export type Language = "Japanese" | "English" | "Esperanto";

/**
 * Elmで使う型の名前. Elmで使える型名ということを確認済み
 * @typePartId 13e52324ba81c7ffe655455ad739ea73
 */
export type ElmTypeName = {
  readonly _: "ElmTypeName";
  readonly string: String;
};

/**
 * -2 147 483 648 ～ 2 147 483 647. 32bit 符号付き整数. JavaScriptのnumberとして扱える. numberの32bit符号あり整数をSigned Leb128のバイナリに変換する
 * @typePartId 16c2d8602e3e5e2d38b9215bd0c44d8d
 */
export type Int32 = number;

/**
 * Elm の 型
 * @typePartId 173f661790b059baf212043f816ba1a9
 */
export type ElmType =
  | { readonly _: "ImportedType"; readonly elmImportedType: ElmImportedType }
  | { readonly _: "TypeParameter"; readonly string: String }
  | { readonly _: "Function"; readonly elmFunctionType: ElmFunctionType }
  | { readonly _: "List"; readonly elmType: ElmType }
  | { readonly _: "Tuple0" }
  | { readonly _: "Tuple2"; readonly elmTuple2: ElmTuple2 }
  | { readonly _: "Tuple3"; readonly elmTuple3: ElmTuple3 }
  | { readonly _: "Record"; readonly elmFieldList: List<ElmField> }
  | { readonly _: "LocalType"; readonly elmLocalType: ElmLocalType };

/**
 * @typePartId 1835ebdc909b0fa93d11ae0ed93d0606
 */
export type TsType =
  | { readonly _: "Number" }
  | { readonly _: "String" }
  | { readonly _: "Boolean" }
  | { readonly _: "Undefined" }
  | { readonly _: "Null" }
  | { readonly _: "Never" }
  | { readonly _: "Void" }
  | { readonly _: "Object"; readonly tsMemberTypeList: List<TsMemberType> }
  | { readonly _: "Function"; readonly functionType: FunctionType }
  | {
      readonly _: "WithTypeParameter";
      readonly tsTypeWithTypeParameter: TsTypeWithTypeParameter;
    }
  | { readonly _: "Union"; readonly tsTypeList: List<TsType> }
  | { readonly _: "Intersection"; readonly intersectionType: IntersectionType }
  | { readonly _: "ImportedType"; readonly importedType: ImportedType }
  | { readonly _: "ScopeInFile"; readonly tsIdentifer: TsIdentifer }
  | { readonly _: "ScopeInGlobal"; readonly tsIdentifer: TsIdentifer }
  | { readonly _: "StringLiteral"; readonly string: String };

/**
 * Project, Account, TypePartなどのリソースの状態とデータ. 読み込み中だとか
 * @typePartId 18cbd2fa4bd72a0eacf3f0f44aeb6feb
 */
export type ResourceState<data extends unknown> =
  | { readonly _: "Loaded"; readonly dataWithTime: WithTime<data> }
  | { readonly _: "Deleted"; readonly time: Time }
  | { readonly _: "Unknown"; readonly time: Time }
  | { readonly _: "Requesting" };

/**
 * Unit. 1つの値しかない型. JavaScriptのundefinedで扱う
 * @typePartId 217263d8cdca613c2d1ba77e19d4cbb0
 */
export type Unit = undefined;

/**
 * コンパイラに向けた, 型のデータ形式をどうするかの情報
 * @typePartId 22d8f2d392c573a7aa54c39fa4c98ad0
 */
export type TypeAttribute = "AsBoolean" | "AsUndefined";

/**
 * @typePartId 2392b884a9c2238a65ecd272bd23a9cd
 */
export type ElmField = {
  /**
   * フィールド名
   */
  readonly name: ElmFieldName;
  /**
   * 型
   */
  readonly type: ElmType;
};

/**
 * パラメーター付きの型
 * @typePartId 23fa0e8b66c9d093d4c18579ffefaaa3
 */
export type TsTypeWithTypeParameter = {
  /**
   * パラメーターをつけられる型
   */
  readonly type: TsType;
  /**
   * パラメーターに指定する型. なにも要素を入れなけければ T<>ではなく T の形式で出力される
   */
  readonly typeParameterList: List<TsType>;
};

/**
 * 評価したときに失敗した原因を表すもの
 * @typePartId 25d0af5522da614f7617016ca7868edd
 */
export type EvaluateExprError =
  | { readonly _: "NeedPartDefinition"; readonly partId: PartId }
  | { readonly _: "Blank" }
  | { readonly _: "TypeError"; readonly string: String }
  | { readonly _: "NotSupported" };

/**
 * TypeScriptの識別子として使える文字
 * @typePartId 2a75ad7c7ccc58ba56f6c8545c8150d1
 */
export type TsIdentifer = { readonly _: "Identifer"; readonly string: String };

/**
 * モジュール内の型
 * @typePartId 2b42264a878355f0257141fa013fed5c
 */
export type ElmLocalType = {
  /**
   * 型名
   */
  readonly typeName: ElmTypeName;
  /**
   * 型パラメーター
   */
  readonly parameter: List<ElmType>;
};

/**
 * 関数呼び出し
 * @typePartId 2f9784d2c41d0974487a1ca2b0a51ec5
 */
export type FunctionCall = {
  /**
   * 関数
   */
  readonly function: Expr;
  /**
   * パラメーター
   */
  readonly parameter: Expr;
};

/**
 * Maybe. nullableのようなもの. 今後はRustのstd::Optionに出力するために属性をつけよう (確信)
 * @typePartId 304f21ae8208a21d08731aa6d183742d
 */
export type Maybe<value extends unknown> =
  | { readonly _: "Just"; readonly value: value }
  | { readonly _: "Nothing" };

/**
 * 配列リテラルの要素
 * @typePartId 35f7e442c0838f9982e6b49da398d97f
 */
export type ArrayItem = {
  /**
   * 式
   */
  readonly expr: TsExpr;
  /**
   * スプレッド ...a のようにするか
   */
  readonly spread: Bool;
};

/**
 * バイナリ. JavaScriptのUint8Arrayで扱える. 最初にLED128でバイト数, その次にバイナリそのまま
 * @typePartId 3e2f740c88923b0393a1ef93d92f157b
 */
export type Binary = Uint8Array;

/**
 * 3つの要素のタプルの型
 * @typePartId 42e5ab4936af4abf8673472ce96fd794
 */
export type ElmTuple3 = {
  /**
   * 左の型
   */
  readonly first: ElmType;
  /**
   * 真ん中の型
   */
  readonly second: ElmType;
  /**
   * 右の型
   */
  readonly third: ElmType;
};

/**
 * 外部のモジュールの型
 * @typePartId 43aa21ed2225cacc4489c30113e87787
 */
export type ElmImportedType = {
  /**
   * モジュール名
   */
  readonly moduleName: String;
  /**
   * 型名
   */
  readonly typeName: ElmTypeName;
  /**
   * 型パラメーター
   */
  readonly parameter: List<ElmType>;
};

/**
 * 2項演算子
 * @typePartId 4953938f040aefdaa5f2601e2a78d43b
 */
export type BinaryOperator =
  | "Exponentiation"
  | "Multiplication"
  | "Division"
  | "Remainder"
  | "Addition"
  | "Subtraction"
  | "LeftShift"
  | "SignedRightShift"
  | "UnsignedRightShift"
  | "LessThan"
  | "LessThanOrEqual"
  | "Equal"
  | "NotEqual"
  | "BitwiseAnd"
  | "BitwiseXOr"
  | "BitwiseOr"
  | "LogicalAnd"
  | "LogicalOr";

/**
 * 型アサーション
 * @typePartId 49f05a756bd75da670fa5b64ed8bf1ae
 */
export type TypeAssertion = {
  /**
   * 型アサーションを受ける式
   */
  readonly expr: TsExpr;
  /**
   * 型
   */
  readonly type: TsType;
};

/**
 * JavaScriptの単項演算子
 * @typePartId 4b4c3f8f34d1c05bb9d7d1b930bc9c9a
 */
export type UnaryOperator = "Minus" | "BitwiseNot" | "LogicalNot";

/**
 * 型の定義本体
 * @typePartId 4c60c73d6b8f236d34281fbb9119a598
 */
export type TypePartBody =
  | { readonly _: "Product"; readonly memberList: List<Member> }
  | { readonly _: "Sum"; readonly patternList: List<Pattern> }
  | { readonly _: "Kernel"; readonly typePartBodyKernel: TypePartBodyKernel };

/**
 * カスタム型の公開レベル
 * @typePartId 4e1cab8c9074c1a058d6ef3ffcf29ab0
 */
export type ElmCustomTypeExportLevel =
  | "NoExport"
  | "ExportTypeOnly"
  | "ExportTypeAndVariant";

/**
 * quest の アカウント
 * @typePartId 4e6857a774597ae66e5c316642a8ae8b
 */
export type QAccount = {
  /**
   * アカウント名
   */
  readonly name: String;
  /**
   * アイコン画像のハッシュ値
   */
  readonly iconHash: ImageHash;
};

/**
 * 関数のパラメーター. パラメーター名, 型
 * @typePartId 5433bade7738da21e7663ff043f588d5
 */
export type Parameter = {
  /**
   * パラメーター名
   */
  readonly name: TsIdentifer;
  /**
   * パラメーターの型
   */
  readonly type: TsType;
};

/**
 * 取得日時と任意のデータ
 * @typePartId 55d4de38cfb884b9008abd7f7f63325e
 */
export type WithTime<data extends unknown> = {
  /**
   * データベースから取得した日時
   */
  readonly getTime: Time;
  /**
   * データ
   */
  readonly data: data;
};

/**
 * 型エイリアス. 型に名前を付け, レコード型の場合, その名前の関数を作成する
 * @typePartId 57f429fd5c67eb2542447a2eaeb34497
 */
export type ElmTypeAlias = {
  /**
   * 型エイリアス名
   */
  readonly name: ElmTypeName;
  /**
   * 外部に公開するか
   */
  readonly export: Bool;
  /**
   * コメント
   */
  readonly comment: String;
  /**
   * 型パラメーター
   */
  readonly parameter: List<String>;
  /**
   * 別名を付ける型
   */
  readonly type: ElmType;
};

/**
 * パーツの識別子
 * @typePartId 5880cd7c0b6f0205c739a06181898d03
 */
export type PartId = string & { readonly _partId: never };

/**
 * AccountToken と UserId
 * @typePartId 5d291325e9d7bc27ff35e907f59bde54
 */
export type AccountTokenAndUserId = {
  /**
   * accountToken
   */
  readonly accountToken: AccountToken;
  /**
   * UserId
   */
  readonly userId: AccountId;
};

/**
 * タグの識別子. タグは直和型に使うもの.
 *
 * 実行時に使わないことは確定しているが, コード内の形式としてタグにUUIDを使うべきかは考慮中. index で充分かと思ったが別に型の情報も必要になることが多い
 * @typePartId 5ec292c48424e5e9ee8cc2d672830ecd
 */
export type TagId = string & { readonly _tagId: never };

/**
 * 関数の型. 入力と出力
 * @typePartId 5ec9dae951d8d2b250c81185a259adca
 */
export type ElmFunctionType = {
  /**
   * 入力の型
   */
  readonly input: ElmType;
  /**
   * 出力の型
   */
  readonly output: ElmType;
};

/**
 * switch文のcase "text": { statementList } の部分
 * @typePartId 6126431def47ecba239b3add7f472b19
 */
export type TsPattern = {
  /**
   * case に使う文字列
   */
  readonly caseString: String;
  /**
   * マッチしたときに実行する部分
   */
  readonly statementList: List<Statement>;
};

/**
 * 型パラメーター
 * @typePartId 627dc8fa15214481812af12268d97b6b
 */
export type TypeParameter = {
  /**
   * 型パラメーターの名前
   */
  readonly name: String;
  /**
   * 型パラメーターの型ID
   */
  readonly typePartId: TypePartId;
};

/**
 * Elmのコードを表現するもの
 * @typePartId 62923d32a2730114e665cef13f93ff13
 */
export type ElmCode = {
  /**
   * モジュール名
   */
  readonly moduleName: String;
  /**
   * 型定義
   */
  readonly typeDeclarationList: List<ElmTypeDeclaration>;
};

/**
 * Definyだけでは表現できないデータ型
 * @typePartId 657b5a5519b095480a21fdadd0f6fbd1
 */
export type TypePartBodyKernel =
  | "Function"
  | "Int32"
  | "String"
  | "Binary"
  | "Id"
  | "Token"
  | "List"
  | "Dict";

/**
 * 文字列. JavaScriptのstringで扱う. バイナリ形式はUTF-8. 不正な文字が入っている可能性がある
 * @typePartId 666361c9ae68ab64f273c47f3feb8c73
 */
export type String = string;

/**
 * ユーザー名. 表示される名前. 他のユーザーとかぶっても良い. 絵文字も使える. 全角英数は半角英数,半角カタカナは全角カタカナ, (株)の合字を分解するなどのNFKCの正規化がされる. U+0000-U+0019 と U+007F-U+00A0 の範囲の文字は入らない. 前後に空白を含められない. 間の空白は2文字以上連続しない. 文字数のカウント方法は正規化されたあとのCodePoint単位. Twitterと同じ, 1文字以上50文字以下
 * @typePartId 67d4e3bc4f13e1132b6c5e81d5b74395
 */
export type Account = {
  /**
   * プロフィール画像
   */
  readonly imageHash: ImageHash;
  /**
   * initMemberDescription
   */
  readonly introduction: String;
  /**
   * Definyでユーザーが作成された日時
   */
  readonly createTime: Time;
  /**
   * アカウント名. 表示される名前. 他のユーザーとかぶっても良い. 絵文字も使える. 全角英数は半角英数,半角カタカナは全角カタカナ, (株)の合字を分解するなどのNFKCの正規化がされる. U+0000-U+0019 と U+007F-U+00A0 の範囲の文字は入らない. 前後に空白を含められない. 間の空白は2文字以上連続しない. 文字数のカウント方法は正規化されたあとのCodePoint単位. Twitterと同じ, 1文字以上50文字以下
   */
  readonly name: String;
};

/**
 * キーであるTokenによってデータが必ず1つに決まるもの. 絶対に更新されない. リソースがないということはデータが不正な状態になっているということ
 * @typePartId 68d925f7b35bab8f265cd9e5eb7ea3da
 */
export type StaticResourceState<data extends unknown> =
  | { readonly _: "Loaded"; readonly data: data }
  | { readonly _: "Unknown" }
  | { readonly _: "Loading" }
  | { readonly _: "Requesting" };

/**
 * 代入文
 * @typePartId 6a5a7886b0f117a50d9d7b11ffe87c9f
 */
export type SetStatement = {
  /**
   * 対象となる式. 指定の仕方によってはJSのSyntaxErrorになる
   */
  readonly target: TsExpr;
  /**
   * 演算子を=の左につける
   */
  readonly operatorMaybe: Maybe<BinaryOperator>;
  /**
   * 式
   */
  readonly expr: TsExpr;
};

/**
 * ドキュメント付きの関数のパラメーター. パラメーター名, ドキュメント, 型
 * @typePartId 6b05e33009ade6b4decd452e8fd4bff1
 */
export type ParameterWithDocument = {
  /**
   * パラメーター名
   */
  readonly name: TsIdentifer;
  /**
   * ドキュメント
   */
  readonly document: String;
  /**
   * パラメーターの型
   */
  readonly type: TsType;
};

/**
 * 型パーツの識別子
 * @typePartId 6e3cff317f8bfbbd1391c0afb9ad6b72
 */
export type TypePartId = string & { readonly _typePartId: never };

/**
 * 成功と失敗を表す型. 今後はRustのstd::Resultに出力するために属性をつける?
 * @typePartId 6f937e46fce1cf70d29c54780f132c18
 */
export type Result<ok extends unknown, error extends unknown> =
  | { readonly _: "Ok"; readonly ok: ok }
  | { readonly _: "Error"; readonly error: error };

/**
 * 言語とページの場所. URLとして表現されるデータ. Googleなどの検索エンジンの都合( https://support.google.com/webmasters/answer/182192?hl=ja )で,URLにページの言語を入れて,言語ごとに別のURLである必要がある.
 * @typePartId 7210f04a85c5f0f58f7aa20826d67f05
 */
export type UrlData = {
  /**
   * 場所
   */
  readonly location: Location;
  /**
   * 言語
   */
  readonly language: Language;
};

/**
 * switch文
 * @typePartId 725f84ef82e6c3b5b5f6fd5208977dd8
 */
export type SwitchStatement = {
  /**
   * switch(a) {} の a
   */
  readonly expr: TsExpr;
  /**
   * case "text": { statementList }
   */
  readonly patternList: List<TsPattern>;
};

/**
 * ローカル変数定義
 * @typePartId 7277cf2483388ee2f5ad7a7fc8585d98
 */
export type VariableDefinitionStatement = {
  /**
   * 変数名
   */
  readonly name: TsIdentifer;
  /**
   * 変数の型
   */
  readonly type: TsType;
  /**
   * 式
   */
  readonly expr: TsExpr;
  /**
   * constかどうか. falseはlet
   */
  readonly isConst: Bool;
};

/**
 * プロジェクト作成時に必要なパラメーター
 * @typePartId 7b987551cc112a64f5c9a8cb1647f4bd
 */
export type CreateProjectParameter = {
  /**
   * プロジェクトを作るときのアカウント
   */
  readonly accountToken: AccountToken;
  /**
   * プロジェクト名
   */
  readonly projectName: String;
};

/**
 * JavaScript の 文
 * @typePartId 7c957d411f448a03764f16d43e6e5008
 */
export type Statement =
  | { readonly _: "EvaluateExpr"; readonly tsExpr: TsExpr }
  | { readonly _: "Set"; readonly setStatement: SetStatement }
  | { readonly _: "If"; readonly ifStatement: IfStatement }
  | { readonly _: "ThrowError"; readonly tsExpr: TsExpr }
  | { readonly _: "Return"; readonly tsExpr: TsExpr }
  | { readonly _: "ReturnVoid" }
  | { readonly _: "Continue" }
  | {
      readonly _: "VariableDefinition";
      readonly variableDefinitionStatement: VariableDefinitionStatement;
    }
  | {
      readonly _: "FunctionDefinition";
      readonly functionDefinitionStatement: FunctionDefinitionStatement;
    }
  | { readonly _: "For"; readonly forStatement: ForStatement }
  | { readonly _: "ForOf"; readonly forOfStatement: ForOfStatement }
  | { readonly _: "WhileTrue"; readonly statementList: List<Statement> }
  | { readonly _: "Break" }
  | { readonly _: "Switch"; readonly switchStatement: SwitchStatement };

/**
 * 日時. 0001-01-01T00:00:00.000Z to 9999-12-31T23:59:59.999Z 最小単位はミリ秒. ミリ秒の求め方は day*1000*60*60*24 + millisecond
 * @typePartId 7d91f0f70643799692aa144ee51a62b1
 */
export type Time = {
  /**
   * 1970-01-01からの経過日数. マイナスになることもある
   */
  readonly day: Int32;
  /**
   * 日にちの中のミリ秒. 0 to 86399999 (=1000*60*60*24-1)
   */
  readonly millisecond: Int32;
};

/**
 * アカウントトークンとプロジェクトID
 * @typePartId 7e4613f18e8e3bcfdfc00356654414d5
 */
export type AccountTokenAndProjectId = {
  /**
   * アカウントトークン
   */
  readonly accountToken: AccountToken;
  /**
   * プロジェクトID
   */
  readonly projectId: ProjectId;
};

/**
 * インポートした変数
 * @typePartId 8150e2833dc1f2a77715aa1bb7b2baad
 */
export type ImportedVariable = {
  /**
   * モジュール名, 使うときにはnamedインポートされ, そのモジュール識別子は自動的につけられる
   */
  readonly moduleName: String;
  /**
   * 変数名
   */
  readonly name: TsIdentifer;
};

/**
 * "ソーシャルログインを提供するプロバイダー (例: Google, GitHub)
 *
 * GitHub いらないかも (GitHubのアカウント作成するの分かりづらいので, 選択肢を減らしたい)
 * @typePartId 84597034eb252267ce1a599ab7a0b543
 */
export type OpenIdConnectProvider = "Google" | "GitHub";

/**
 * 型パーツ
 * @typePartId 87fc411d10f6986dd33e5dbaff6d06ae
 */
export type TypePart = {
  /**
   * 型パーツの名前
   */
  readonly name: String;
  /**
   * 型パーツの説明
   */
  readonly description: String;
  /**
   * 所属しているプロジェクトのID
   */
  readonly projectId: ProjectId;
  /**
   * コンパイラに与える,この型を表現するのにどういう特殊な状態にするかという情報
   */
  readonly attribute: Maybe<TypeAttribute>;
  /**
   * 型パラメーター
   */
  readonly typeParameterList: List<TypeParameter>;
  /**
   * 定義本体
   */
  readonly body: TypePartBody;
};

/**
 * JavaScript の 式
 * @typePartId 8b0bdbeae05df3badac2ee69bf22011f
 */
export type TsExpr =
  | { readonly _: "NumberLiteral"; readonly int32: Int32 }
  | { readonly _: "StringLiteral"; readonly string: String }
  | { readonly _: "BooleanLiteral"; readonly bool: Bool }
  | { readonly _: "NullLiteral" }
  | { readonly _: "UndefinedLiteral" }
  | {
      readonly _: "UnaryOperator";
      readonly unaryOperatorExpr: UnaryOperatorExpr;
    }
  | {
      readonly _: "BinaryOperator";
      readonly binaryOperatorExpr: BinaryOperatorExpr;
    }
  | {
      readonly _: "ConditionalOperator";
      readonly conditionalOperatorExpr: ConditionalOperatorExpr;
    }
  | { readonly _: "ArrayLiteral"; readonly arrayItemList: List<ArrayItem> }
  | { readonly _: "ObjectLiteral"; readonly tsMemberList: List<TsMember> }
  | { readonly _: "Lambda"; readonly lambdaExpr: LambdaExpr }
  | { readonly _: "Variable"; readonly tsIdentifer: TsIdentifer }
  | { readonly _: "GlobalObjects"; readonly tsIdentifer: TsIdentifer }
  | {
      readonly _: "ImportedVariable";
      readonly importedVariable: ImportedVariable;
    }
  | { readonly _: "Get"; readonly getExpr: GetExpr }
  | { readonly _: "Call"; readonly callExpr: CallExpr }
  | { readonly _: "New"; readonly callExpr: CallExpr }
  | { readonly _: "TypeAssertion"; readonly typeAssertion: TypeAssertion };

/**
 * 2つの要素のタプルの型
 * @typePartId 8b479d8726bb494ac76d529fbf03908c
 */
export type ElmTuple2 = {
  /**
   * 左の型
   */
  readonly first: ElmType;
  /**
   * 右の型
   */
  readonly second: ElmType;
};

/**
 * Definy の プロジェクト
 * @typePartId 8bc81fa2a15bdbd8c2414d22f3e1b462
 */
export type Project = {
  /**
   * プロジェクト名
   */
  readonly name: String;
  /**
   * プロジェクトのアイコン画像
   */
  readonly iconHash: ImageHash;
  /**
   * initMemberDescription
   */
  readonly imageHash: ImageHash;
  /**
   * initMemberDescription
   */
  readonly createTime: Time;
  /**
   * プロジェクトを作成したアカウント
   */
  readonly createAccountId: AccountId;
  /**
   * 更新日時
   */
  readonly updateTime: Time;
};

/**
 * forOf文
 * @typePartId 8be8db4404f302dd36c8a2c6c6e37e7c
 */
export type ForOfStatement = {
  /**
   * 要素の変数名
   */
  readonly elementVariableName: TsIdentifer;
  /**
   * 繰り返す対象
   */
  readonly iterableExpr: TsExpr;
  /**
   * 繰り返す文
   */
  readonly statementList: List<Statement>;
};

/**
 * TypeScriptやJavaScriptのコードを表現する. TypeScriptでも出力できるように型情報をつける必要がある
 * @typePartId 92ea504049ca5b7e2227a95195fe74eb
 */
export type JsTsCode = {
  /**
   * 外部に公開する定義
   */
  readonly exportDefinitionList: List<ExportDefinition>;
  /**
   * 定義した後に実行するコード
   */
  readonly statementList: List<Statement>;
};

/**
 * 直積型のメンバー
 * @typePartId 9481ceae2c3e2765243f5c7ce7eb76c7
 */
export type Member = {
  /**
   * メンバー名
   */
  readonly name: String;
  /**
   * メンバーの説明
   */
  readonly description: String;
  /**
   * メンバー値の型
   */
  readonly type: Type;
};

/**
 * Elm の 式
 * @typePartId 94e53139b3a82087777ea3e001b2adb4
 */
export type ElmExpr =
  | { readonly _: "StringLiteral"; readonly string: String }
  | { readonly _: "IntLiteral"; readonly int32: Int32 }
  | { readonly _: "LocalVariant" }
  | { readonly _: "ImportedVariant" }
  | { readonly _: "List"; readonly elmExprList: List<ElmExpr> }
  | { readonly _: "Op" }
  | { readonly _: "Negate"; readonly elmExpr: ElmExpr }
  | { readonly _: "Binops" }
  | { readonly _: "Lambda" }
  | { readonly _: "Call" }
  | { readonly _: "If" }
  | { readonly _: "Let" }
  | { readonly _: "Case" }
  | { readonly _: "Accessor"; readonly string: String }
  | { readonly _: "Access" }
  | { readonly _: "Update" }
  | { readonly _: "Record" }
  | { readonly _: "Unit" }
  | { readonly _: "Tuple2" }
  | { readonly _: "Tuple3" };

/**
 * 関数の型
 * @typePartId 98904215e50e04fa2197a7a96df8f646
 */
export type FunctionType = {
  /**
   * 型パラメーターのリスト
   */
  readonly typeParameterList: List<TsIdentifer>;
  /**
   * パラメーターの型. 意味のない引数名は適当に付く
   */
  readonly parameterList: List<TsType>;
  /**
   * 戻り値の型
   */
  readonly return: TsType;
};

/**
 * カスタム型. 代数的データ型
 * @typePartId a0cee28e982f5fbcae6b2c7bd1e27e2a
 */
export type ElmCustomType = {
  /**
   * カスタム型名
   */
  readonly name: ElmTypeName;
  /**
   * 外部に公開するレベル
   */
  readonly export: ElmCustomTypeExportLevel;
  /**
   * コメント
   */
  readonly comment: String;
  /**
   * 型パラメーター
   */
  readonly parameter: List<String>;
  /**
   * バリアントのリスト. 値コンストラクタ. タグ
   */
  readonly variantList: List<ElmVariant>;
};

/**
 * 式と呼ぶパラメーター
 * @typePartId a1f71188b7c3ab2a21954471f3ac67f1
 */
export type CallExpr = {
  /**
   * 呼ばれる式
   */
  readonly expr: TsExpr;
  /**
   * パラメーター
   */
  readonly parameterList: List<TsExpr>;
};

/**
 * @typePartId a2580a29c047f54d635c4456696bbef3
 */
export type Variable = {
  /**
   * 変数の名前
   */
  readonly name: TsIdentifer;
  /**
   * ドキュメント
   */
  readonly document: String;
  /**
   * 変数の型
   */
  readonly type: TsType;
  /**
   * 変数の式
   */
  readonly expr: TsExpr;
};

/**
 * データを識別するIdとデータ
 * @typePartId a541cb9bb64930be40dc83bf8870f36b
 */
export type IdAndData<id extends unknown, data extends unknown> = {
  /**
   * ID
   */
  readonly id: id;
  /**
   * データ
   */
  readonly data: data;
};

/**
 * 複数の引数が必要な内部関数の部分呼び出し
 * @typePartId a8c830bd6b3473f2fac7a62ede58ecf0
 */
export type KernelCall = {
  /**
   * 関数
   */
  readonly kernel: KernelExpr;
  /**
   * 呼び出すパラメーター
   */
  readonly expr: EvaluatedExpr;
};

/**
 * プロパティアクセス
 * @typePartId a9ce526a22f09800aa3773a1614cce89
 */
export type GetExpr = {
  /**
   * 式
   */
  readonly expr: TsExpr;
  /**
   * プロパティの式
   */
  readonly propertyExpr: TsExpr;
};

/**
 * Definy の 型. 式に対してつけるし, つく. 型パーツの定義にも使う
 * @typePartId b3b36f39469d23321ed01b92f048ccc0
 */
export type Type = {
  /**
   * 型の参照
   */
  readonly typePartId: TypePartId;
  /**
   * 型のパラメーター
   */
  readonly parameter: List<Type>;
};

/**
 * インポートされた型
 * @typePartId b44289bc65640d4ad0ad79a5a627ef78
 */
export type ImportedType = {
  /**
   * モジュール名. namedImportされるがその識別子は自動的に作成される
   */
  readonly moduleName: String;
  /**
   * 型の名前
   */
  readonly name: TsIdentifer;
};

/**
 * アカウントトークンのハッシュ値. データベースに保存する用
 * @typePartId b553ab17ca45f4975d9fe17fe1a63ac4
 */
export type AccountTokenHash = string & { readonly _accountTokenHash: never };

/**
 * Definyだけでは表現できない式
 * @typePartId b6eef263a982482747a8ad0bc9f05e21
 */
export type KernelExpr = "Int32Add" | "Int32Sub" | "Int32Mul";

/**
 * 型パーツのリストを保存, 変更する
 * @typePartId b8bf6c22e275c06c7dc42300c332b47d
 */
export type SetTypePartListParameter = {
  /**
   * アカウントトークン
   */
  readonly accountToken: AccountToken;
  /**
   * プロジェクトID
   */
  readonly projectId: ProjectId;
  /**
   * 型パーツのリスト
   */
  readonly typePartList: List<IdAndData<TypePartId, TypePart>>;
};

/**
 * DefinyWebアプリ内での場所を示すもの. URLから求められる. URLに変換できる
 * @typePartId bbcb8e43df8afff9fe24b001c66fb065
 */
export type Location =
  | { readonly _: "Home" }
  | { readonly _: "CreateProject" }
  | { readonly _: "Project"; readonly projectId: ProjectId }
  | { readonly _: "Account"; readonly accountId: AccountId }
  | { readonly _: "Setting" }
  | { readonly _: "About" }
  | { readonly _: "Debug" }
  | { readonly _: "TypePart"; readonly typePartId: TypePartId };

/**
 * TypeAlias. `export type T = {}`
 * @typePartId bf69f7e46f5e4949fe801c234fc3ad15
 */
export type TypeAlias = {
  /**
   * 型の名前
   */
  readonly name: TsIdentifer;
  /**
   * 型パラメーターのリスト
   */
  readonly typeParameterList: List<TsIdentifer>;
  /**
   * ドキュメント
   */
  readonly document: String;
  /**
   * 型本体
   */
  readonly type: TsType;
};

/**
 * アカウントを識別するためのID
 * @typePartId c1a17b07e8e664ca80217833ff2ad3f1
 */
export type AccountId = string & { readonly _accountId: never };

/**
 * 文字列のkeyと式のvalue
 * @typePartId c2428cbcd62b33ce2c904a200b876863
 */
export type KeyValue = {
  /**
   * key
   */
  readonly key: String;
  /**
   * value
   */
  readonly value: TsExpr;
};

/**
 * リスト. JavaScriptのArrayで扱う
 * @typePartId c3fc2a6cea61086db59e11dc2bef0eee
 */
export type List<element extends unknown> = ReadonlyArray<element>;

/**
 * definy.app の ログイン状態
 * @typePartId c4b574e3ca8bad17022054d5e77fd3d0
 */
export type LogInState =
  | { readonly _: "LoadingAccountTokenFromIndexedDB" }
  | { readonly _: "Guest" }
  | {
      readonly _: "RequestingLogInUrl";
      readonly openIdConnectProvider: OpenIdConnectProvider;
    }
  | { readonly _: "JumpingToLogInPage"; readonly string: String }
  | { readonly _: "VerifyingAccountToken"; readonly accountToken: AccountToken }
  | {
      readonly _: "LoggedIn";
      readonly accountTokenAndUserId: AccountTokenAndUserId;
    };

/**
 * for文
 * @typePartId c53be8bcaf56ff90080cf7a75f1e4815
 */
export type ForStatement = {
  /**
   * カウンタ変数名
   */
  readonly counterVariableName: TsIdentifer;
  /**
   * ループの上限の式
   */
  readonly untilExpr: TsExpr;
  /**
   * 繰り返す文
   */
  readonly statementList: List<Statement>;
};

/**
 * オブジェクトのメンバーの型
 * @typePartId c68bac5afb1a1d35af096bf317d09339
 */
export type TsMemberType = {
  /**
   * プロパティ名
   */
  readonly name: String;
  /**
   * 必須かどうか falseの場合 ? がつく
   */
  readonly required: Bool;
  /**
   * 型
   */
  readonly type: TsType;
  /**
   * ドキュメント
   */
  readonly document: String;
};

/**
 * 条件演算子
 * @typePartId c7a771f770f0f92690faeb59eaff6268
 */
export type ConditionalOperatorExpr = {
  /**
   * 条件の式
   */
  readonly condition: TsExpr;
  /**
   * 条件がtrueのときに評価される式
   */
  readonly thenExpr: TsExpr;
  /**
   * 条件がfalseのときに評価される式
   */
  readonly elseExpr: TsExpr;
};

/**
 * if文
 * @typePartId cd325760f992e47a8438ae78ca9b1529
 */
export type IfStatement = {
  /**
   * 条件の式
   */
  readonly condition: TsExpr;
  /**
   * 条件がtrueのときに実行する文
   */
  readonly thenStatementList: List<Statement>;
};

/**
 * フィールド名
 * @typePartId d256109676f834b74931495891b61d1b
 */
export type ElmFieldName = { readonly _: "FieldName"; readonly string: String };

/**
 * バリアント名
 * @typePartId d77f1f967b892c739a1555f74d2ff9fd
 */
export type ElmVariantName = {
  readonly _: "VariantName";
  readonly string: String;
};

/**
 * 交差型
 * @typePartId d82150857d0f2e78c1df0f418ba9b01a
 */
export type IntersectionType = {
  /**
   * 左に指定する型
   */
  readonly left: TsType;
  /**
   * 右に指定する型
   */
  readonly right: TsType;
};

/**
 * パーツの定義. 他のプログラミング言語でいう関数や, 変数のこと
 * @typePartId d8bccc70252cee9ce70784bf5dfa493b
 */
export type Part = {
  /**
   * パーツの名前
   */
  readonly name: String;
  /**
   * パーツの説明
   */
  readonly description: String;
  /**
   * パーツの型
   */
  readonly type: Type;
  /**
   * パーツの式
   */
  readonly expr: Expr;
  /**
   * 所属しているプロジェクトのID
   */
  readonly projectId: ProjectId;
};

/**
 * Definyの評価しきった式
 * @typePartId daa9bf22c3f2e52ff92edcdd896d6a6d
 */
export type EvaluatedExpr =
  | { readonly _: "Kernel"; readonly kernelExpr: KernelExpr }
  | { readonly _: "Int32"; readonly int32: Int32 }
  | { readonly _: "TagReference"; readonly tagReference: TagReference }
  | { readonly _: "KernelCall"; readonly kernelCall: KernelCall };

/**
 * 1つの型パーツを保存するために指定するパラメーター
 * @typePartId dac038758a5c45f762de388bb5193fb8
 */
export type SetTypePartParameter = {
  /**
   * アカウントトークン
   */
  readonly accountToken: AccountToken;
  /**
   * 型パーツのID
   */
  readonly typePartId: TypePartId;
  /**
   * 型パーツ
   */
  readonly typePart: TypePart;
};

/**
 * Bool. 真か偽. JavaScriptのbooleanで扱える. true: 1, false: 0. (1byte)としてバイナリに変換する
 * @typePartId db57caf129f60db969b5b5224a72b937
 */
export type Bool = boolean;

/**
 * Elmの関数の定義. 引数がない関数(定数)も含まれる
 * @typePartId db8b9f83d99ef58fd206acca4e56d098
 */
export type ElmDefinition = {
  /**
   * 関数名
   */
  readonly name: String;
  /**
   * 型
   */
  readonly type: ElmType;
  /**
   * 式
   */
  readonly expr: ElmType;
  /**
   * コメント
   */
  readonly comment: String;
};

/**
 * 外部に公開する関数
 * @typePartId dd3366ce7254327c85732d2932ff219b
 */
export type Function = {
  /**
   * 外部に公開する関数の名前
   */
  readonly name: TsIdentifer;
  /**
   * ドキュメント
   */
  readonly document: String;
  /**
   * 型パラメーターのリスト
   */
  readonly typeParameterList: List<TsIdentifer>;
  /**
   * パラメーター
   */
  readonly parameterList: List<ParameterWithDocument>;
  /**
   * 戻り値の型
   */
  readonly returnType: TsType;
  /**
   * 関数の本体
   */
  readonly statementList: List<Statement>;
};

/**
 * アカウントトークン. アカウントトークンを持っていればアクセストークンをDefinyのサーバーにリクエストした際に得られるIDのアカウントを保有していると証明できる. サーバーにハッシュ化したものを保存している. これが盗まれた場合,不正に得た人はアカウントを乗っ取ることができる. 有効期限はなし, 最後に発行したアカウントトークン以外は無効になる
 * @typePartId deb01f82879754c03aa4d244e136e59d
 */
export type AccountToken = string & { readonly _accountToken: never };

/**
 * ローカル関数定義
 * @typePartId df5c5388248252a92864ceb219628b8e
 */
export type FunctionDefinitionStatement = {
  /**
   * 変数名
   */
  readonly name: TsIdentifer;
  /**
   * 型パラメーターのリスト
   */
  readonly typeParameterList: List<TsIdentifer>;
  /**
   * パラメーターのリスト
   */
  readonly parameterList: List<ParameterWithDocument>;
  /**
   * 戻り値の型
   */
  readonly returnType: TsType;
  /**
   * 関数本体
   */
  readonly statementList: List<Statement>;
};

/**
 * 直積型のパターン
 * @typePartId e4ef8a0713aceb0eaa7606cd516ad847
 */
export type Pattern = {
  /**
   * タグ名
   */
  readonly name: String;
  /**
   * パターンの説明
   */
  readonly description: String;
  /**
   * そのパターンにつけるデータの型
   */
  readonly parameter: Maybe<Type>;
};

/**
 * 画像から求められるトークン.キャッシュのキーとして使われる.1つのトークンに対して永久に1つの画像データしか表さない. キャッシュを更新する必要はない
 * @typePartId e71e15a15b0883940a75e58367151d1a
 */
export type ImageHash = string & { readonly _imageHash: never };

/**
 * Definy の 式
 * @typePartId ed9a046b5f121f6e54ac7f3834cbc644
 */
export type Expr =
  | { readonly _: "Kernel"; readonly kernelExpr: KernelExpr }
  | { readonly _: "Int32Literal"; readonly int32: Int32 }
  | { readonly _: "PartReference"; readonly partId: PartId }
  | { readonly _: "TagReference"; readonly tagReference: TagReference }
  | { readonly _: "FunctionCall"; readonly functionCall: FunctionCall };

/**
 * タグの参照を表す
 * @typePartId edd59bd2ab4852c149f6ce5917767908
 */
export type TagReference = {
  /**
   * 型ID. タグIDがあれば, 型を導出できそうだが……
   */
  readonly typePartId: TypePartId;
  /**
   * タグID
   */
  readonly tagId: TagId;
};

/**
 * definy.app を開発する上での動作モード. デベロップモード(http://localhost:2520)か, リリースモード(https://definy.app)
 * @typePartId ee0590e764618611ffa8e1a0a2e22f79
 */
export type Mode = "Develop" | "Release";

/**
 * 2項演算子と左右の式
 * @typePartId eec2dab74fbcd3237bfa1c773f9b9d21
 */
export type BinaryOperatorExpr = {
  /**
   * 2項演算子
   */
  readonly operator: BinaryOperator;
  /**
   * 左の式
   */
  readonly left: TsExpr;
  /**
   * 右の式
   */
  readonly right: TsExpr;
};

/**
 * 出力するコードの種類
 * @typePartId eedf73c97f9dd61159572322f6d7e0a5
 */
export type CodeType = "JavaScript" | "TypeScript";

/**
 * ラムダ式
 * @typePartId eeeef818144e5a42460c4efdaa221460
 */
export type LambdaExpr = {
  /**
   * パラメーターのリスト
   */
  readonly parameterList: List<Parameter>;
  /**
   * 型パラメーターのリスト
   */
  readonly typeParameterList: List<TsIdentifer>;
  /**
   * 戻り値の型
   */
  readonly returnType: TsType;
  /**
   * ラムダ式本体
   */
  readonly statementList: List<Statement>;
};

/**
 * ログインのURLを発行するために必要なデータ
 * @typePartId f03ea5331c1a3adcde80a04054d35e07
 */
export type RequestLogInUrlRequestData = {
  /**
   * ログインに使用するプロバイダー
   */
  readonly openIdConnectProvider: OpenIdConnectProvider;
  /**
   * ログインした後に返ってくるURLに必要なデータ
   */
  readonly urlData: UrlData;
};

/**
 * Elmの型定義
 * @typePartId f4bed793b657b39db5a579c9e158eba5
 */
export type ElmTypeDeclaration =
  | { readonly _: "TypeAlias"; readonly elmTypeAlias: ElmTypeAlias }
  | { readonly _: "CustomType"; readonly elmCustomType: ElmCustomType };

/**
 * JavaScriptのオブジェクトリテラルの要素
 * @typePartId fddd2a65994fae205dd636f3a6b9f1ea
 */
export type TsMember =
  | { readonly _: "Spread"; readonly tsExpr: TsExpr }
  | { readonly _: "KeyValue"; readonly keyValue: KeyValue };

/**
 * バリアント. 値コンストラクタ. タグ
 * @typePartId 0bc2e5ab2fd2caeb6e6c331573ae735f
 */
export const ElmVariant: {
  readonly codec: Codec<ElmVariant>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ElmVariant) => ElmVariant;
} = {
  helper: (elmVariant: ElmVariant): ElmVariant => elmVariant,
  codec: {
    encode: (value: ElmVariant): ReadonlyArray<number> =>
      ElmVariantName.codec
        .encode(value.name)
        .concat(List.codec(ElmType.codec).encode(value.parameter)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ElmVariant; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: ElmVariantName;
        readonly nextIndex: number;
      } = ElmVariantName.codec.decode(index, binary);
      const parameterAndNextIndex: {
        readonly result: List<ElmType>;
        readonly nextIndex: number;
      } = List.codec(ElmType.codec).decode(nameAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          parameter: parameterAndNextIndex.result,
        },
        nextIndex: parameterAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 外部に公開する定義
 * @typePartId 0c8b854b812290a054877ca5de6c4daf
 */
export const ExportDefinition: {
  /**
   * TypeAlias
   */
  readonly TypeAlias: (a: TypeAlias) => ExportDefinition;
  /**
   * Function
   */
  readonly Function: (a: Function) => ExportDefinition;
  /**
   * Variable
   */
  readonly Variable: (a: Variable) => ExportDefinition;
  readonly codec: Codec<ExportDefinition>;
} = {
  TypeAlias: (typeAlias: TypeAlias): ExportDefinition => ({
    _: "TypeAlias",
    typeAlias,
  }),
  Function: (function_: Function): ExportDefinition => ({
    _: "Function",
    function: function_,
  }),
  Variable: (variable: Variable): ExportDefinition => ({
    _: "Variable",
    variable,
  }),
  codec: {
    encode: (value: ExportDefinition): ReadonlyArray<number> => {
      switch (value._) {
        case "TypeAlias": {
          return [0].concat(TypeAlias.codec.encode(value.typeAlias));
        }
        case "Function": {
          return [1].concat(Function.codec.encode(value.function));
        }
        case "Variable": {
          return [2].concat(Variable.codec.encode(value.variable));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ExportDefinition; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: TypeAlias;
          readonly nextIndex: number;
        } = TypeAlias.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ExportDefinition.TypeAlias(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: Function;
          readonly nextIndex: number;
        } = Function.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ExportDefinition.Function(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: Variable;
          readonly nextIndex: number;
        } = Variable.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ExportDefinition.Variable(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 単項演算子と適用される式
 * @typePartId 0cb0a34b3953e57b30f4a5c8f9d305da
 */
export const UnaryOperatorExpr: {
  readonly codec: Codec<UnaryOperatorExpr>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: UnaryOperatorExpr) => UnaryOperatorExpr;
} = {
  helper: (unaryOperatorExpr: UnaryOperatorExpr): UnaryOperatorExpr =>
    unaryOperatorExpr,
  codec: {
    encode: (value: UnaryOperatorExpr): ReadonlyArray<number> =>
      UnaryOperator.codec
        .encode(value.operator)
        .concat(TsExpr.codec.encode(value.expr)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: UnaryOperatorExpr; readonly nextIndex: number } => {
      const operatorAndNextIndex: {
        readonly result: UnaryOperator;
        readonly nextIndex: number;
      } = UnaryOperator.codec.decode(index, binary);
      const exprAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(operatorAndNextIndex.nextIndex, binary);
      return {
        result: {
          operator: operatorAndNextIndex.result,
          expr: exprAndNextIndex.result,
        },
        nextIndex: exprAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * プロジェクトの識別子
 * @typePartId 0cd913118a2ad1469d656146a08c5f76
 */
export const ProjectId: { readonly codec: Codec<ProjectId> } = {
  codec: {
    encode: (value: ProjectId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ProjectId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: ProjectId;
        readonly nextIndex: number;
      },
  },
};

/**
 * 英語,日本語,エスペラント語
 *
 * ナルミンチョが使える? プログラミングじゃない言語
 * @typePartId 0d9510723f4d34605e41f3a47a8b0ea7
 */
export const Language: {
  /**
   * 日本語
   */
  readonly Japanese: Language;
  /**
   * 英語
   */
  readonly English: Language;
  /**
   * エスペラント語
   */
  readonly Esperanto: Language;
  readonly codec: Codec<Language>;
} = {
  Japanese: "Japanese",
  English: "English",
  Esperanto: "Esperanto",
  codec: {
    encode: (value: Language): ReadonlyArray<number> => {
      switch (value) {
        case "Japanese": {
          return [0];
        }
        case "English": {
          return [1];
        }
        case "Esperanto": {
          return [2];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Language; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: Language.Japanese, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return { result: Language.English, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 2) {
        return {
          result: Language.Esperanto,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * Elmで使う型の名前. Elmで使える型名ということを確認済み
 * @typePartId 13e52324ba81c7ffe655455ad739ea73
 */
export const ElmTypeName: {
  /**
   * **直接 ElmTypeName.ElmTypeName("Int") と指定してはいけない!! Elmの識別子として使える文字としてチェックできないため**
   */
  readonly ElmTypeName: (a: String) => ElmTypeName;
  readonly codec: Codec<ElmTypeName>;
} = {
  ElmTypeName: (string_: String): ElmTypeName => ({
    _: "ElmTypeName",
    string: string_,
  }),
  codec: {
    encode: (value: ElmTypeName): ReadonlyArray<number> => {
      switch (value._) {
        case "ElmTypeName": {
          return [0].concat(String.codec.encode(value.string));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ElmTypeName; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: String;
          readonly nextIndex: number;
        } = String.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ElmTypeName.ElmTypeName(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * -2 147 483 648 ～ 2 147 483 647. 32bit 符号付き整数. JavaScriptのnumberとして扱える. numberの32bit符号あり整数をSigned Leb128のバイナリに変換する
 * @typePartId 16c2d8602e3e5e2d38b9215bd0c44d8d
 */
export const Int32: { readonly codec: Codec<Int32> } = {
  codec: {
    encode: (value: Int32): ReadonlyArray<number> => {
      let rest: number = value | 0;
      const result: Array<number> = [];
      while (true) {
        const byte: number = rest & 127;
        rest >>= 7;
        if (
          (rest === 0 && (byte & 64) === 0) ||
          (rest === -1 && (byte & 64) !== 0)
        ) {
          result.push(byte);
          return result;
        }
        result.push(byte | 128);
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Int32; readonly nextIndex: number } => {
      let result: number = 0;
      let offset: number = 0;
      while (true) {
        const byte: number | undefined = binary[index + offset];
        if (byte === undefined) {
          throw new Error("invalid byte in decode int32");
        }
        result |= (byte & 127) << (offset * 7);
        offset += 1;
        if ((128 & byte) === 0) {
          if (offset * 7 < 32 && (byte & 64) !== 0) {
            return {
              result: result | (~0 << (offset * 7)),
              nextIndex: index + offset,
            };
          }
          return { result, nextIndex: index + offset };
        }
      }
    },
  },
};

/**
 * Elm の 型
 * @typePartId 173f661790b059baf212043f816ba1a9
 */
export const ElmType: {
  /**
   * インポートした型
   */
  readonly ImportedType: (a: ElmImportedType) => ElmType;
  /**
   * 型パラメーター
   */
  readonly TypeParameter: (a: String) => ElmType;
  /**
   * 関数
   */
  readonly Function: (a: ElmFunctionType) => ElmType;
  /**
   * List リスト
   */
  readonly List: (a: ElmType) => ElmType;
  /**
   * () 1種類の値だけ持つ型. Unit
   */
  readonly Tuple0: ElmType;
  /**
   * (a, b)
   */
  readonly Tuple2: (a: ElmTuple2) => ElmType;
  /**
   * (a, b, c)
   */
  readonly Tuple3: (a: ElmTuple3) => ElmType;
  /**
   * { name: String, age: Int } レコード型
   */
  readonly Record: (a: List<ElmField>) => ElmType;
  /**
   * モジュール内にある型
   */
  readonly LocalType: (a: ElmLocalType) => ElmType;
  readonly codec: Codec<ElmType>;
} = {
  ImportedType: (elmImportedType: ElmImportedType): ElmType => ({
    _: "ImportedType",
    elmImportedType,
  }),
  TypeParameter: (string_: String): ElmType => ({
    _: "TypeParameter",
    string: string_,
  }),
  Function: (elmFunctionType: ElmFunctionType): ElmType => ({
    _: "Function",
    elmFunctionType,
  }),
  List: (elmType: ElmType): ElmType => ({ _: "List", elmType }),
  Tuple0: { _: "Tuple0" },
  Tuple2: (elmTuple2: ElmTuple2): ElmType => ({ _: "Tuple2", elmTuple2 }),
  Tuple3: (elmTuple3: ElmTuple3): ElmType => ({ _: "Tuple3", elmTuple3 }),
  Record: (elmFieldList: List<ElmField>): ElmType => ({
    _: "Record",
    elmFieldList,
  }),
  LocalType: (elmLocalType: ElmLocalType): ElmType => ({
    _: "LocalType",
    elmLocalType,
  }),
  codec: {
    encode: (value: ElmType): ReadonlyArray<number> => {
      switch (value._) {
        case "ImportedType": {
          return [0].concat(
            ElmImportedType.codec.encode(value.elmImportedType)
          );
        }
        case "TypeParameter": {
          return [1].concat(String.codec.encode(value.string));
        }
        case "Function": {
          return [2].concat(
            ElmFunctionType.codec.encode(value.elmFunctionType)
          );
        }
        case "List": {
          return [3].concat(ElmType.codec.encode(value.elmType));
        }
        case "Tuple0": {
          return [4];
        }
        case "Tuple2": {
          return [5].concat(ElmTuple2.codec.encode(value.elmTuple2));
        }
        case "Tuple3": {
          return [6].concat(ElmTuple3.codec.encode(value.elmTuple3));
        }
        case "Record": {
          return [7].concat(
            List.codec(ElmField.codec).encode(value.elmFieldList)
          );
        }
        case "LocalType": {
          return [8].concat(ElmLocalType.codec.encode(value.elmLocalType));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ElmType; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: ElmImportedType;
          readonly nextIndex: number;
        } = ElmImportedType.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ElmType.ImportedType(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: String;
          readonly nextIndex: number;
        } = String.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ElmType.TypeParameter(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: ElmFunctionType;
          readonly nextIndex: number;
        } = ElmFunctionType.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ElmType.Function(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        const result: {
          readonly result: ElmType;
          readonly nextIndex: number;
        } = ElmType.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ElmType.List(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 4) {
        return { result: ElmType.Tuple0, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 5) {
        const result: {
          readonly result: ElmTuple2;
          readonly nextIndex: number;
        } = ElmTuple2.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ElmType.Tuple2(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 6) {
        const result: {
          readonly result: ElmTuple3;
          readonly nextIndex: number;
        } = ElmTuple3.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ElmType.Tuple3(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 7) {
        const result: {
          readonly result: List<ElmField>;
          readonly nextIndex: number;
        } = List.codec(ElmField.codec).decode(patternIndex.nextIndex, binary);
        return {
          result: ElmType.Record(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 8) {
        const result: {
          readonly result: ElmLocalType;
          readonly nextIndex: number;
        } = ElmLocalType.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ElmType.LocalType(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * @typePartId 1835ebdc909b0fa93d11ae0ed93d0606
 */
export const TsType: {
  /**
   * プリミティブの型のnumber
   */
  readonly Number: TsType;
  /**
   * プリミティブの型のstring
   */
  readonly String: TsType;
  /**
   * プリミティブの型のboolean
   */
  readonly Boolean: TsType;
  /**
   * プリミティブの型のundefined
   */
  readonly Undefined: TsType;
  /**
   * プリミティブの型のnull
   */
  readonly Null: TsType;
  /**
   * never型
   */
  readonly Never: TsType;
  /**
   * void型
   */
  readonly Void: TsType;
  /**
   * オブジェクト
   */
  readonly Object: (a: List<TsMemberType>) => TsType;
  /**
   * 関数 `(parameter: parameter) => returnType`
   */
  readonly Function: (a: FunctionType) => TsType;
  /**
   * 型パラメータ付きの型 `Promise<number>` `ReadonlyArray<string>`
   */
  readonly WithTypeParameter: (a: TsTypeWithTypeParameter) => TsType;
  /**
   * ユニオン型 `a | b`
   */
  readonly Union: (a: List<TsType>) => TsType;
  /**
   * "交差型 `left & right`
   */
  readonly Intersection: (a: IntersectionType) => TsType;
  /**
   * インポートされた外部の型
   */
  readonly ImportedType: (a: ImportedType) => TsType;
  /**
   * ファイル内で定義された型
   */
  readonly ScopeInFile: (a: TsIdentifer) => TsType;
  /**
   * グローバル空間の型
   */
  readonly ScopeInGlobal: (a: TsIdentifer) => TsType;
  /**
   * 文字列リテラル型
   */
  readonly StringLiteral: (a: String) => TsType;
  readonly codec: Codec<TsType>;
} = {
  Number: { _: "Number" },
  String: { _: "String" },
  Boolean: { _: "Boolean" },
  Undefined: { _: "Undefined" },
  Null: { _: "Null" },
  Never: { _: "Never" },
  Void: { _: "Void" },
  Object: (tsMemberTypeList: List<TsMemberType>): TsType => ({
    _: "Object",
    tsMemberTypeList,
  }),
  Function: (functionType: FunctionType): TsType => ({
    _: "Function",
    functionType,
  }),
  WithTypeParameter: (
    tsTypeWithTypeParameter: TsTypeWithTypeParameter
  ): TsType => ({ _: "WithTypeParameter", tsTypeWithTypeParameter }),
  Union: (tsTypeList: List<TsType>): TsType => ({ _: "Union", tsTypeList }),
  Intersection: (intersectionType: IntersectionType): TsType => ({
    _: "Intersection",
    intersectionType,
  }),
  ImportedType: (importedType: ImportedType): TsType => ({
    _: "ImportedType",
    importedType,
  }),
  ScopeInFile: (tsIdentifer: TsIdentifer): TsType => ({
    _: "ScopeInFile",
    tsIdentifer,
  }),
  ScopeInGlobal: (tsIdentifer: TsIdentifer): TsType => ({
    _: "ScopeInGlobal",
    tsIdentifer,
  }),
  StringLiteral: (string_: String): TsType => ({
    _: "StringLiteral",
    string: string_,
  }),
  codec: {
    encode: (value: TsType): ReadonlyArray<number> => {
      switch (value._) {
        case "Number": {
          return [0];
        }
        case "String": {
          return [1];
        }
        case "Boolean": {
          return [2];
        }
        case "Undefined": {
          return [3];
        }
        case "Null": {
          return [4];
        }
        case "Never": {
          return [5];
        }
        case "Void": {
          return [6];
        }
        case "Object": {
          return [7].concat(
            List.codec(TsMemberType.codec).encode(value.tsMemberTypeList)
          );
        }
        case "Function": {
          return [8].concat(FunctionType.codec.encode(value.functionType));
        }
        case "WithTypeParameter": {
          return [9].concat(
            TsTypeWithTypeParameter.codec.encode(value.tsTypeWithTypeParameter)
          );
        }
        case "Union": {
          return [10].concat(List.codec(TsType.codec).encode(value.tsTypeList));
        }
        case "Intersection": {
          return [11].concat(
            IntersectionType.codec.encode(value.intersectionType)
          );
        }
        case "ImportedType": {
          return [12].concat(ImportedType.codec.encode(value.importedType));
        }
        case "ScopeInFile": {
          return [13].concat(TsIdentifer.codec.encode(value.tsIdentifer));
        }
        case "ScopeInGlobal": {
          return [14].concat(TsIdentifer.codec.encode(value.tsIdentifer));
        }
        case "StringLiteral": {
          return [15].concat(String.codec.encode(value.string));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TsType; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: TsType.Number, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return { result: TsType.String, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 2) {
        return { result: TsType.Boolean, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 3) {
        return { result: TsType.Undefined, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 4) {
        return { result: TsType.Null, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 5) {
        return { result: TsType.Never, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 6) {
        return { result: TsType.Void, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 7) {
        const result: {
          readonly result: List<TsMemberType>;
          readonly nextIndex: number;
        } = List.codec(TsMemberType.codec).decode(
          patternIndex.nextIndex,
          binary
        );
        return {
          result: TsType.Object(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 8) {
        const result: {
          readonly result: FunctionType;
          readonly nextIndex: number;
        } = FunctionType.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsType.Function(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 9) {
        const result: {
          readonly result: TsTypeWithTypeParameter;
          readonly nextIndex: number;
        } = TsTypeWithTypeParameter.codec.decode(
          patternIndex.nextIndex,
          binary
        );
        return {
          result: TsType.WithTypeParameter(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 10) {
        const result: {
          readonly result: List<TsType>;
          readonly nextIndex: number;
        } = List.codec(TsType.codec).decode(patternIndex.nextIndex, binary);
        return {
          result: TsType.Union(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 11) {
        const result: {
          readonly result: IntersectionType;
          readonly nextIndex: number;
        } = IntersectionType.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsType.Intersection(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 12) {
        const result: {
          readonly result: ImportedType;
          readonly nextIndex: number;
        } = ImportedType.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsType.ImportedType(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 13) {
        const result: {
          readonly result: TsIdentifer;
          readonly nextIndex: number;
        } = TsIdentifer.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsType.ScopeInFile(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 14) {
        const result: {
          readonly result: TsIdentifer;
          readonly nextIndex: number;
        } = TsIdentifer.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsType.ScopeInGlobal(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 15) {
        const result: {
          readonly result: String;
          readonly nextIndex: number;
        } = String.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsType.StringLiteral(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * Project, Account, TypePartなどのリソースの状態とデータ. 読み込み中だとか
 * @typePartId 18cbd2fa4bd72a0eacf3f0f44aeb6feb
 */
export const ResourceState: {
  /**
   * 読み込み済み
   */
  readonly Loaded: <data extends unknown>(
    a: WithTime<data>
  ) => ResourceState<data>;
  /**
   * 削除されたか, 存在しない
   */
  readonly Deleted: <data extends unknown>(a: Time) => ResourceState<data>;
  /**
   * 削除されたか, 存在しない
   */
  readonly Unknown: <data extends unknown>(a: Time) => ResourceState<data>;
  /**
   * サーバに問い合わせ中
   */
  readonly Requesting: <data extends unknown>() => ResourceState<data>;
  readonly codec: <data extends unknown>(
    a: Codec<data>
  ) => Codec<ResourceState<data>>;
} = {
  Loaded: <data extends unknown>(
    dataWithTime: WithTime<data>
  ): ResourceState<data> => ({ _: "Loaded", dataWithTime }),
  Deleted: <data extends unknown>(time: Time): ResourceState<data> => ({
    _: "Deleted",
    time,
  }),
  Unknown: <data extends unknown>(time: Time): ResourceState<data> => ({
    _: "Unknown",
    time,
  }),
  Requesting: <data extends unknown>(): ResourceState<data> => ({
    _: "Requesting",
  }),
  codec: <data extends unknown>(
    dataCodec: Codec<data>
  ): Codec<ResourceState<data>> => ({
    encode: (value: ResourceState<data>): ReadonlyArray<number> => {
      switch (value._) {
        case "Loaded": {
          return [0].concat(
            WithTime.codec(dataCodec).encode(value.dataWithTime)
          );
        }
        case "Deleted": {
          return [1].concat(Time.codec.encode(value.time));
        }
        case "Unknown": {
          return [2].concat(Time.codec.encode(value.time));
        }
        case "Requesting": {
          return [3];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ResourceState<data>; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: WithTime<data>;
          readonly nextIndex: number;
        } = WithTime.codec(dataCodec).decode(patternIndex.nextIndex, binary);
        return {
          result: ResourceState.Loaded(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: Time;
          readonly nextIndex: number;
        } = Time.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ResourceState.Deleted(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: Time;
          readonly nextIndex: number;
        } = Time.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ResourceState.Unknown(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        return {
          result: ResourceState.Requesting(),
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  }),
};

/**
 * Unit. 1つの値しかない型. JavaScriptのundefinedで扱う
 * @typePartId 217263d8cdca613c2d1ba77e19d4cbb0
 */
export const Unit: {
  /**
   * Unit型にある.唯一の値
   */
  readonly UnitValue: Unit;
  readonly codec: Codec<Unit>;
} = {
  UnitValue: undefined,
  codec: {
    encode: (value: Unit): ReadonlyArray<number> => [],
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Unit; readonly nextIndex: number } => ({
      result: Unit.UnitValue,
      nextIndex: index,
    }),
  },
};

/**
 * コンパイラに向けた, 型のデータ形式をどうするかの情報
 * @typePartId 22d8f2d392c573a7aa54c39fa4c98ad0
 */
export const TypeAttribute: {
  /**
   * JavaScript, TypeScript で boolean として扱うように指示する. 定義が2つのパターンで両方パラメーターなし false, trueの順である必要がある
   */
  readonly AsBoolean: TypeAttribute;
  /**
   * cription:             "JavaScript, TypeScript で undefined として扱うように指示する. 定義が1つのパターンでパラメーターなしである必要がある
   */
  readonly AsUndefined: TypeAttribute;
  readonly codec: Codec<TypeAttribute>;
} = {
  AsBoolean: "AsBoolean",
  AsUndefined: "AsUndefined",
  codec: {
    encode: (value: TypeAttribute): ReadonlyArray<number> => {
      switch (value) {
        case "AsBoolean": {
          return [0];
        }
        case "AsUndefined": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypeAttribute; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: TypeAttribute.AsBoolean,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: TypeAttribute.AsUndefined,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * @typePartId 2392b884a9c2238a65ecd272bd23a9cd
 */
export const ElmField: {
  readonly codec: Codec<ElmField>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ElmField) => ElmField;
} = {
  helper: (elmField: ElmField): ElmField => elmField,
  codec: {
    encode: (value: ElmField): ReadonlyArray<number> =>
      ElmFieldName.codec
        .encode(value.name)
        .concat(ElmType.codec.encode(value.type)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ElmField; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: ElmFieldName;
        readonly nextIndex: number;
      } = ElmFieldName.codec.decode(index, binary);
      const typeAndNextIndex: {
        readonly result: ElmType;
        readonly nextIndex: number;
      } = ElmType.codec.decode(nameAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          type: typeAndNextIndex.result,
        },
        nextIndex: typeAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * パラメーター付きの型
 * @typePartId 23fa0e8b66c9d093d4c18579ffefaaa3
 */
export const TsTypeWithTypeParameter: {
  readonly codec: Codec<TsTypeWithTypeParameter>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: TsTypeWithTypeParameter) => TsTypeWithTypeParameter;
} = {
  helper: (
    tsTypeWithTypeParameter: TsTypeWithTypeParameter
  ): TsTypeWithTypeParameter => tsTypeWithTypeParameter,
  codec: {
    encode: (value: TsTypeWithTypeParameter): ReadonlyArray<number> =>
      TsType.codec
        .encode(value.type)
        .concat(List.codec(TsType.codec).encode(value.typeParameterList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: TsTypeWithTypeParameter;
      readonly nextIndex: number;
    } => {
      const typeAndNextIndex: {
        readonly result: TsType;
        readonly nextIndex: number;
      } = TsType.codec.decode(index, binary);
      const typeParameterListAndNextIndex: {
        readonly result: List<TsType>;
        readonly nextIndex: number;
      } = List.codec(TsType.codec).decode(typeAndNextIndex.nextIndex, binary);
      return {
        result: {
          type: typeAndNextIndex.result,
          typeParameterList: typeParameterListAndNextIndex.result,
        },
        nextIndex: typeParameterListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 評価したときに失敗した原因を表すもの
 * @typePartId 25d0af5522da614f7617016ca7868edd
 */
export const EvaluateExprError: {
  /**
   * 式を評価するには,このパーツの定義が必要だと言っている
   */
  readonly NeedPartDefinition: (a: PartId) => EvaluateExprError;
  /**
   * 計算結果にblankが含まれている
   */
  readonly Blank: EvaluateExprError;
  /**
   * 型が合わない
   */
  readonly TypeError: (a: String) => EvaluateExprError;
  /**
   * まだサポートしていないものが含まれている
   */
  readonly NotSupported: EvaluateExprError;
  readonly codec: Codec<EvaluateExprError>;
} = {
  NeedPartDefinition: (partId: PartId): EvaluateExprError => ({
    _: "NeedPartDefinition",
    partId,
  }),
  Blank: { _: "Blank" },
  TypeError: (string_: String): EvaluateExprError => ({
    _: "TypeError",
    string: string_,
  }),
  NotSupported: { _: "NotSupported" },
  codec: {
    encode: (value: EvaluateExprError): ReadonlyArray<number> => {
      switch (value._) {
        case "NeedPartDefinition": {
          return [0].concat(PartId.codec.encode(value.partId));
        }
        case "Blank": {
          return [1];
        }
        case "TypeError": {
          return [2].concat(String.codec.encode(value.string));
        }
        case "NotSupported": {
          return [3];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: EvaluateExprError; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: PartId;
          readonly nextIndex: number;
        } = PartId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: EvaluateExprError.NeedPartDefinition(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: EvaluateExprError.Blank,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: String;
          readonly nextIndex: number;
        } = String.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: EvaluateExprError.TypeError(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        return {
          result: EvaluateExprError.NotSupported,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * TypeScriptの識別子として使える文字
 * @typePartId 2a75ad7c7ccc58ba56f6c8545c8150d1
 */
export const TsIdentifer: {
  /**
   * **直接 Identifer.Identifer("name") と指定してはいけない!! TypeScriptの識別子として使える文字としてチェックできないため**
   */
  readonly Identifer: (a: String) => TsIdentifer;
  readonly codec: Codec<TsIdentifer>;
} = {
  Identifer: (string_: String): TsIdentifer => ({
    _: "Identifer",
    string: string_,
  }),
  codec: {
    encode: (value: TsIdentifer): ReadonlyArray<number> => {
      switch (value._) {
        case "Identifer": {
          return [0].concat(String.codec.encode(value.string));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TsIdentifer; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: String;
          readonly nextIndex: number;
        } = String.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsIdentifer.Identifer(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * モジュール内の型
 * @typePartId 2b42264a878355f0257141fa013fed5c
 */
export const ElmLocalType: {
  readonly codec: Codec<ElmLocalType>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ElmLocalType) => ElmLocalType;
} = {
  helper: (elmLocalType: ElmLocalType): ElmLocalType => elmLocalType,
  codec: {
    encode: (value: ElmLocalType): ReadonlyArray<number> =>
      ElmTypeName.codec
        .encode(value.typeName)
        .concat(List.codec(ElmType.codec).encode(value.parameter)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ElmLocalType; readonly nextIndex: number } => {
      const typeNameAndNextIndex: {
        readonly result: ElmTypeName;
        readonly nextIndex: number;
      } = ElmTypeName.codec.decode(index, binary);
      const parameterAndNextIndex: {
        readonly result: List<ElmType>;
        readonly nextIndex: number;
      } = List.codec(ElmType.codec).decode(
        typeNameAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          typeName: typeNameAndNextIndex.result,
          parameter: parameterAndNextIndex.result,
        },
        nextIndex: parameterAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 関数呼び出し
 * @typePartId 2f9784d2c41d0974487a1ca2b0a51ec5
 */
export const FunctionCall: {
  readonly codec: Codec<FunctionCall>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: FunctionCall) => FunctionCall;
} = {
  helper: (functionCall: FunctionCall): FunctionCall => functionCall,
  codec: {
    encode: (value: FunctionCall): ReadonlyArray<number> =>
      Expr.codec
        .encode(value.function)
        .concat(Expr.codec.encode(value.parameter)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: FunctionCall; readonly nextIndex: number } => {
      const functionAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(index, binary);
      const parameterAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(functionAndNextIndex.nextIndex, binary);
      return {
        result: {
          function: functionAndNextIndex.result,
          parameter: parameterAndNextIndex.result,
        },
        nextIndex: parameterAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * Maybe. nullableのようなもの. 今後はRustのstd::Optionに出力するために属性をつけよう (確信)
 * @typePartId 304f21ae8208a21d08731aa6d183742d
 */
export const Maybe: {
  /**
   * 値があるということ
   */
  readonly Just: <value extends unknown>(a: value) => Maybe<value>;
  /**
   * 値がないということ
   */
  readonly Nothing: <value extends unknown>() => Maybe<value>;
  readonly codec: <value extends unknown>(
    a: Codec<value>
  ) => Codec<Maybe<value>>;
} = {
  Just: <value extends unknown>(value: value): Maybe<value> => ({
    _: "Just",
    value,
  }),
  Nothing: <value extends unknown>(): Maybe<value> => ({ _: "Nothing" }),
  codec: <value extends unknown>(
    valueCodec: Codec<value>
  ): Codec<Maybe<value>> => ({
    encode: (value: Maybe<value>): ReadonlyArray<number> => {
      switch (value._) {
        case "Just": {
          return [0].concat(valueCodec.encode(value.value));
        }
        case "Nothing": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Maybe<value>; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: value;
          readonly nextIndex: number;
        } = valueCodec.decode(patternIndex.nextIndex, binary);
        return {
          result: Maybe.Just(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return { result: Maybe.Nothing(), nextIndex: patternIndex.nextIndex };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  }),
};

/**
 * 配列リテラルの要素
 * @typePartId 35f7e442c0838f9982e6b49da398d97f
 */
export const ArrayItem: {
  readonly codec: Codec<ArrayItem>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ArrayItem) => ArrayItem;
} = {
  helper: (arrayItem: ArrayItem): ArrayItem => arrayItem,
  codec: {
    encode: (value: ArrayItem): ReadonlyArray<number> =>
      TsExpr.codec.encode(value.expr).concat(Bool.codec.encode(value.spread)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ArrayItem; readonly nextIndex: number } => {
      const exprAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(index, binary);
      const spreadAndNextIndex: {
        readonly result: Bool;
        readonly nextIndex: number;
      } = Bool.codec.decode(exprAndNextIndex.nextIndex, binary);
      return {
        result: {
          expr: exprAndNextIndex.result,
          spread: spreadAndNextIndex.result,
        },
        nextIndex: spreadAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * バイナリ. JavaScriptのUint8Arrayで扱える. 最初にLED128でバイト数, その次にバイナリそのまま
 * @typePartId 3e2f740c88923b0393a1ef93d92f157b
 */
export const Binary: { readonly codec: Codec<Binary> } = {
  codec: {
    encode: (value: Binary): ReadonlyArray<number> =>
      Int32.codec.encode(value.length).concat([...value]),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Binary; readonly nextIndex: number } => {
      const length: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      const nextIndex: number = length.nextIndex + length.result;
      return { result: binary.slice(length.nextIndex, nextIndex), nextIndex };
    },
  },
};

/**
 * 3つの要素のタプルの型
 * @typePartId 42e5ab4936af4abf8673472ce96fd794
 */
export const ElmTuple3: {
  readonly codec: Codec<ElmTuple3>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ElmTuple3) => ElmTuple3;
} = {
  helper: (elmTuple3: ElmTuple3): ElmTuple3 => elmTuple3,
  codec: {
    encode: (value: ElmTuple3): ReadonlyArray<number> =>
      ElmType.codec
        .encode(value.first)
        .concat(ElmType.codec.encode(value.second))
        .concat(ElmType.codec.encode(value.third)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ElmTuple3; readonly nextIndex: number } => {
      const firstAndNextIndex: {
        readonly result: ElmType;
        readonly nextIndex: number;
      } = ElmType.codec.decode(index, binary);
      const secondAndNextIndex: {
        readonly result: ElmType;
        readonly nextIndex: number;
      } = ElmType.codec.decode(firstAndNextIndex.nextIndex, binary);
      const thirdAndNextIndex: {
        readonly result: ElmType;
        readonly nextIndex: number;
      } = ElmType.codec.decode(secondAndNextIndex.nextIndex, binary);
      return {
        result: {
          first: firstAndNextIndex.result,
          second: secondAndNextIndex.result,
          third: thirdAndNextIndex.result,
        },
        nextIndex: thirdAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 外部のモジュールの型
 * @typePartId 43aa21ed2225cacc4489c30113e87787
 */
export const ElmImportedType: {
  readonly codec: Codec<ElmImportedType>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ElmImportedType) => ElmImportedType;
} = {
  helper: (elmImportedType: ElmImportedType): ElmImportedType =>
    elmImportedType,
  codec: {
    encode: (value: ElmImportedType): ReadonlyArray<number> =>
      String.codec
        .encode(value.moduleName)
        .concat(ElmTypeName.codec.encode(value.typeName))
        .concat(List.codec(ElmType.codec).encode(value.parameter)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ElmImportedType; readonly nextIndex: number } => {
      const moduleNameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const typeNameAndNextIndex: {
        readonly result: ElmTypeName;
        readonly nextIndex: number;
      } = ElmTypeName.codec.decode(moduleNameAndNextIndex.nextIndex, binary);
      const parameterAndNextIndex: {
        readonly result: List<ElmType>;
        readonly nextIndex: number;
      } = List.codec(ElmType.codec).decode(
        typeNameAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          moduleName: moduleNameAndNextIndex.result,
          typeName: typeNameAndNextIndex.result,
          parameter: parameterAndNextIndex.result,
        },
        nextIndex: parameterAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 2項演算子
 * @typePartId 4953938f040aefdaa5f2601e2a78d43b
 */
export const BinaryOperator: {
  /**
   * べき乗 `a ** b`
   */
  readonly Exponentiation: BinaryOperator;
  /**
   * 数値の掛け算 `a * b`
   */
  readonly Multiplication: BinaryOperator;
  /**
   * 数値の割り算 `a / b`
   */
  readonly Division: BinaryOperator;
  /**
   * 剰余演算 `a % b`
   */
  readonly Remainder: BinaryOperator;
  /**
   * 数値の足し算, 文字列の結合 `a + b`
   */
  readonly Addition: BinaryOperator;
  /**
   * 数値の引き算 `a - b`
   */
  readonly Subtraction: BinaryOperator;
  /**
   * 左シフト `a << b`
   */
  readonly LeftShift: BinaryOperator;
  /**
   * 符号を維持する右シフト `a >> b`
   */
  readonly SignedRightShift: BinaryOperator;
  /**
   * 符号を維持しない(0埋め)右シフト `a >>> b`
   */
  readonly UnsignedRightShift: BinaryOperator;
  /**
   * 未満 `a < b`
   */
  readonly LessThan: BinaryOperator;
  /**
   * 以下 `a <= b`
   */
  readonly LessThanOrEqual: BinaryOperator;
  /**
   * 等号 `a === b`
   */
  readonly Equal: BinaryOperator;
  /**
   * 不等号 `a !== b`
   */
  readonly NotEqual: BinaryOperator;
  /**
   * ビットAND `a & b`
   */
  readonly BitwiseAnd: BinaryOperator;
  /**
   * ビットXOR `a ^ b`
   */
  readonly BitwiseXOr: BinaryOperator;
  /**
   * ビットOR `a | b`
   */
  readonly BitwiseOr: BinaryOperator;
  /**
   * 論理AND `a && b`
   */
  readonly LogicalAnd: BinaryOperator;
  /**
   * 論理OR `a || b`
   */
  readonly LogicalOr: BinaryOperator;
  readonly codec: Codec<BinaryOperator>;
} = {
  Exponentiation: "Exponentiation",
  Multiplication: "Multiplication",
  Division: "Division",
  Remainder: "Remainder",
  Addition: "Addition",
  Subtraction: "Subtraction",
  LeftShift: "LeftShift",
  SignedRightShift: "SignedRightShift",
  UnsignedRightShift: "UnsignedRightShift",
  LessThan: "LessThan",
  LessThanOrEqual: "LessThanOrEqual",
  Equal: "Equal",
  NotEqual: "NotEqual",
  BitwiseAnd: "BitwiseAnd",
  BitwiseXOr: "BitwiseXOr",
  BitwiseOr: "BitwiseOr",
  LogicalAnd: "LogicalAnd",
  LogicalOr: "LogicalOr",
  codec: {
    encode: (value: BinaryOperator): ReadonlyArray<number> => {
      switch (value) {
        case "Exponentiation": {
          return [0];
        }
        case "Multiplication": {
          return [1];
        }
        case "Division": {
          return [2];
        }
        case "Remainder": {
          return [3];
        }
        case "Addition": {
          return [4];
        }
        case "Subtraction": {
          return [5];
        }
        case "LeftShift": {
          return [6];
        }
        case "SignedRightShift": {
          return [7];
        }
        case "UnsignedRightShift": {
          return [8];
        }
        case "LessThan": {
          return [9];
        }
        case "LessThanOrEqual": {
          return [10];
        }
        case "Equal": {
          return [11];
        }
        case "NotEqual": {
          return [12];
        }
        case "BitwiseAnd": {
          return [13];
        }
        case "BitwiseXOr": {
          return [14];
        }
        case "BitwiseOr": {
          return [15];
        }
        case "LogicalAnd": {
          return [16];
        }
        case "LogicalOr": {
          return [17];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: BinaryOperator; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: BinaryOperator.Exponentiation,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: BinaryOperator.Multiplication,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        return {
          result: BinaryOperator.Division,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        return {
          result: BinaryOperator.Remainder,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 4) {
        return {
          result: BinaryOperator.Addition,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 5) {
        return {
          result: BinaryOperator.Subtraction,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 6) {
        return {
          result: BinaryOperator.LeftShift,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 7) {
        return {
          result: BinaryOperator.SignedRightShift,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 8) {
        return {
          result: BinaryOperator.UnsignedRightShift,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 9) {
        return {
          result: BinaryOperator.LessThan,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 10) {
        return {
          result: BinaryOperator.LessThanOrEqual,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 11) {
        return {
          result: BinaryOperator.Equal,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 12) {
        return {
          result: BinaryOperator.NotEqual,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 13) {
        return {
          result: BinaryOperator.BitwiseAnd,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 14) {
        return {
          result: BinaryOperator.BitwiseXOr,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 15) {
        return {
          result: BinaryOperator.BitwiseOr,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 16) {
        return {
          result: BinaryOperator.LogicalAnd,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 17) {
        return {
          result: BinaryOperator.LogicalOr,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 型アサーション
 * @typePartId 49f05a756bd75da670fa5b64ed8bf1ae
 */
export const TypeAssertion: {
  readonly codec: Codec<TypeAssertion>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: TypeAssertion) => TypeAssertion;
} = {
  helper: (typeAssertion: TypeAssertion): TypeAssertion => typeAssertion,
  codec: {
    encode: (value: TypeAssertion): ReadonlyArray<number> =>
      TsExpr.codec.encode(value.expr).concat(TsType.codec.encode(value.type)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypeAssertion; readonly nextIndex: number } => {
      const exprAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(index, binary);
      const typeAndNextIndex: {
        readonly result: TsType;
        readonly nextIndex: number;
      } = TsType.codec.decode(exprAndNextIndex.nextIndex, binary);
      return {
        result: {
          expr: exprAndNextIndex.result,
          type: typeAndNextIndex.result,
        },
        nextIndex: typeAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * JavaScriptの単項演算子
 * @typePartId 4b4c3f8f34d1c05bb9d7d1b930bc9c9a
 */
export const UnaryOperator: {
  /**
   * 単項マイナス演算子 `-a`
   */
  readonly Minus: UnaryOperator;
  /**
   * ビット否定 `~a`
   */
  readonly BitwiseNot: UnaryOperator;
  /**
   * 論理否定 `!a`
   */
  readonly LogicalNot: UnaryOperator;
  readonly codec: Codec<UnaryOperator>;
} = {
  Minus: "Minus",
  BitwiseNot: "BitwiseNot",
  LogicalNot: "LogicalNot",
  codec: {
    encode: (value: UnaryOperator): ReadonlyArray<number> => {
      switch (value) {
        case "Minus": {
          return [0];
        }
        case "BitwiseNot": {
          return [1];
        }
        case "LogicalNot": {
          return [2];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: UnaryOperator; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: UnaryOperator.Minus,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: UnaryOperator.BitwiseNot,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        return {
          result: UnaryOperator.LogicalNot,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 型の定義本体
 * @typePartId 4c60c73d6b8f236d34281fbb9119a598
 */
export const TypePartBody: {
  /**
   * 直積型
   */
  readonly Product: (a: List<Member>) => TypePartBody;
  /**
   * 直和型
   */
  readonly Sum: (a: List<Pattern>) => TypePartBody;
  /**
   * Definyだけでは表現できないデータ型
   */
  readonly Kernel: (a: TypePartBodyKernel) => TypePartBody;
  readonly codec: Codec<TypePartBody>;
} = {
  Product: (memberList: List<Member>): TypePartBody => ({
    _: "Product",
    memberList,
  }),
  Sum: (patternList: List<Pattern>): TypePartBody => ({
    _: "Sum",
    patternList,
  }),
  Kernel: (typePartBodyKernel: TypePartBodyKernel): TypePartBody => ({
    _: "Kernel",
    typePartBodyKernel,
  }),
  codec: {
    encode: (value: TypePartBody): ReadonlyArray<number> => {
      switch (value._) {
        case "Product": {
          return [0].concat(List.codec(Member.codec).encode(value.memberList));
        }
        case "Sum": {
          return [1].concat(
            List.codec(Pattern.codec).encode(value.patternList)
          );
        }
        case "Kernel": {
          return [2].concat(
            TypePartBodyKernel.codec.encode(value.typePartBodyKernel)
          );
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypePartBody; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: List<Member>;
          readonly nextIndex: number;
        } = List.codec(Member.codec).decode(patternIndex.nextIndex, binary);
        return {
          result: TypePartBody.Product(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: List<Pattern>;
          readonly nextIndex: number;
        } = List.codec(Pattern.codec).decode(patternIndex.nextIndex, binary);
        return {
          result: TypePartBody.Sum(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: TypePartBodyKernel;
          readonly nextIndex: number;
        } = TypePartBodyKernel.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TypePartBody.Kernel(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * カスタム型の公開レベル
 * @typePartId 4e1cab8c9074c1a058d6ef3ffcf29ab0
 */
export const ElmCustomTypeExportLevel: {
  /**
   * 公開しない
   */
  readonly NoExport: ElmCustomTypeExportLevel;
  /**
   * 型の指定のみ公開. 外部のモジュールで値の構成とパターンマッチングの分岐がされることはない
   */
  readonly ExportTypeOnly: ElmCustomTypeExportLevel;
  /**
   * 型とバリアントを公開する. 外部のモジュールで値の構成とパターンマッチングができる
   */
  readonly ExportTypeAndVariant: ElmCustomTypeExportLevel;
  readonly codec: Codec<ElmCustomTypeExportLevel>;
} = {
  NoExport: "NoExport",
  ExportTypeOnly: "ExportTypeOnly",
  ExportTypeAndVariant: "ExportTypeAndVariant",
  codec: {
    encode: (value: ElmCustomTypeExportLevel): ReadonlyArray<number> => {
      switch (value) {
        case "NoExport": {
          return [0];
        }
        case "ExportTypeOnly": {
          return [1];
        }
        case "ExportTypeAndVariant": {
          return [2];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: ElmCustomTypeExportLevel;
      readonly nextIndex: number;
    } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: ElmCustomTypeExportLevel.NoExport,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: ElmCustomTypeExportLevel.ExportTypeOnly,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        return {
          result: ElmCustomTypeExportLevel.ExportTypeAndVariant,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * quest の アカウント
 * @typePartId 4e6857a774597ae66e5c316642a8ae8b
 */
export const QAccount: {
  readonly codec: Codec<QAccount>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: QAccount) => QAccount;
} = {
  helper: (qAccount: QAccount): QAccount => qAccount,
  codec: {
    encode: (value: QAccount): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(ImageHash.codec.encode(value.iconHash)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: QAccount; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const iconHashAndNextIndex: {
        readonly result: ImageHash;
        readonly nextIndex: number;
      } = ImageHash.codec.decode(nameAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          iconHash: iconHashAndNextIndex.result,
        },
        nextIndex: iconHashAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 関数のパラメーター. パラメーター名, 型
 * @typePartId 5433bade7738da21e7663ff043f588d5
 */
export const Parameter: {
  readonly codec: Codec<Parameter>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: Parameter) => Parameter;
} = {
  helper: (parameter: Parameter): Parameter => parameter,
  codec: {
    encode: (value: Parameter): ReadonlyArray<number> =>
      TsIdentifer.codec
        .encode(value.name)
        .concat(TsType.codec.encode(value.type)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Parameter; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: TsIdentifer;
        readonly nextIndex: number;
      } = TsIdentifer.codec.decode(index, binary);
      const typeAndNextIndex: {
        readonly result: TsType;
        readonly nextIndex: number;
      } = TsType.codec.decode(nameAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          type: typeAndNextIndex.result,
        },
        nextIndex: typeAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 取得日時と任意のデータ
 * @typePartId 55d4de38cfb884b9008abd7f7f63325e
 */
export const WithTime: {
  readonly codec: <data extends unknown>(
    a: Codec<data>
  ) => Codec<WithTime<data>>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: <data extends unknown>(a: WithTime<data>) => WithTime<data>;
} = {
  helper: <data extends unknown>(withTime: WithTime<data>): WithTime<data> =>
    withTime,
  codec: <data extends unknown>(
    dataCodec: Codec<data>
  ): Codec<WithTime<data>> => ({
    encode: (value: WithTime<data>): ReadonlyArray<number> =>
      Time.codec.encode(value.getTime).concat(dataCodec.encode(value.data)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: WithTime<data>; readonly nextIndex: number } => {
      const getTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(index, binary);
      const dataAndNextIndex: {
        readonly result: data;
        readonly nextIndex: number;
      } = dataCodec.decode(getTimeAndNextIndex.nextIndex, binary);
      return {
        result: {
          getTime: getTimeAndNextIndex.result,
          data: dataAndNextIndex.result,
        },
        nextIndex: dataAndNextIndex.nextIndex,
      };
    },
  }),
};

/**
 * 型エイリアス. 型に名前を付け, レコード型の場合, その名前の関数を作成する
 * @typePartId 57f429fd5c67eb2542447a2eaeb34497
 */
export const ElmTypeAlias: {
  readonly codec: Codec<ElmTypeAlias>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ElmTypeAlias) => ElmTypeAlias;
} = {
  helper: (elmTypeAlias: ElmTypeAlias): ElmTypeAlias => elmTypeAlias,
  codec: {
    encode: (value: ElmTypeAlias): ReadonlyArray<number> =>
      ElmTypeName.codec
        .encode(value.name)
        .concat(Bool.codec.encode(value.export))
        .concat(String.codec.encode(value.comment))
        .concat(List.codec(String.codec).encode(value.parameter))
        .concat(ElmType.codec.encode(value.type)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ElmTypeAlias; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: ElmTypeName;
        readonly nextIndex: number;
      } = ElmTypeName.codec.decode(index, binary);
      const exportAndNextIndex: {
        readonly result: Bool;
        readonly nextIndex: number;
      } = Bool.codec.decode(nameAndNextIndex.nextIndex, binary);
      const commentAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(exportAndNextIndex.nextIndex, binary);
      const parameterAndNextIndex: {
        readonly result: List<String>;
        readonly nextIndex: number;
      } = List.codec(String.codec).decode(
        commentAndNextIndex.nextIndex,
        binary
      );
      const typeAndNextIndex: {
        readonly result: ElmType;
        readonly nextIndex: number;
      } = ElmType.codec.decode(parameterAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          export: exportAndNextIndex.result,
          comment: commentAndNextIndex.result,
          parameter: parameterAndNextIndex.result,
          type: typeAndNextIndex.result,
        },
        nextIndex: typeAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * パーツの識別子
 * @typePartId 5880cd7c0b6f0205c739a06181898d03
 */
export const PartId: { readonly codec: Codec<PartId> } = {
  codec: {
    encode: (value: PartId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: PartId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: PartId;
        readonly nextIndex: number;
      },
  },
};

/**
 * AccountToken と UserId
 * @typePartId 5d291325e9d7bc27ff35e907f59bde54
 */
export const AccountTokenAndUserId: {
  readonly codec: Codec<AccountTokenAndUserId>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: AccountTokenAndUserId) => AccountTokenAndUserId;
} = {
  helper: (
    accountTokenAndUserId: AccountTokenAndUserId
  ): AccountTokenAndUserId => accountTokenAndUserId,
  codec: {
    encode: (value: AccountTokenAndUserId): ReadonlyArray<number> =>
      AccountToken.codec
        .encode(value.accountToken)
        .concat(AccountId.codec.encode(value.userId)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: AccountTokenAndUserId;
      readonly nextIndex: number;
    } => {
      const accountTokenAndNextIndex: {
        readonly result: AccountToken;
        readonly nextIndex: number;
      } = AccountToken.codec.decode(index, binary);
      const userIdAndNextIndex: {
        readonly result: AccountId;
        readonly nextIndex: number;
      } = AccountId.codec.decode(accountTokenAndNextIndex.nextIndex, binary);
      return {
        result: {
          accountToken: accountTokenAndNextIndex.result,
          userId: userIdAndNextIndex.result,
        },
        nextIndex: userIdAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * タグの識別子. タグは直和型に使うもの.
 *
 * 実行時に使わないことは確定しているが, コード内の形式としてタグにUUIDを使うべきかは考慮中. index で充分かと思ったが別に型の情報も必要になることが多い
 * @typePartId 5ec292c48424e5e9ee8cc2d672830ecd
 */
export const TagId: { readonly codec: Codec<TagId> } = {
  codec: {
    encode: (value: TagId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TagId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: TagId;
        readonly nextIndex: number;
      },
  },
};

/**
 * 関数の型. 入力と出力
 * @typePartId 5ec9dae951d8d2b250c81185a259adca
 */
export const ElmFunctionType: {
  readonly codec: Codec<ElmFunctionType>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ElmFunctionType) => ElmFunctionType;
} = {
  helper: (elmFunctionType: ElmFunctionType): ElmFunctionType =>
    elmFunctionType,
  codec: {
    encode: (value: ElmFunctionType): ReadonlyArray<number> =>
      ElmType.codec
        .encode(value.input)
        .concat(ElmType.codec.encode(value.output)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ElmFunctionType; readonly nextIndex: number } => {
      const inputAndNextIndex: {
        readonly result: ElmType;
        readonly nextIndex: number;
      } = ElmType.codec.decode(index, binary);
      const outputAndNextIndex: {
        readonly result: ElmType;
        readonly nextIndex: number;
      } = ElmType.codec.decode(inputAndNextIndex.nextIndex, binary);
      return {
        result: {
          input: inputAndNextIndex.result,
          output: outputAndNextIndex.result,
        },
        nextIndex: outputAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * switch文のcase "text": { statementList } の部分
 * @typePartId 6126431def47ecba239b3add7f472b19
 */
export const TsPattern: {
  readonly codec: Codec<TsPattern>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: TsPattern) => TsPattern;
} = {
  helper: (tsPattern: TsPattern): TsPattern => tsPattern,
  codec: {
    encode: (value: TsPattern): ReadonlyArray<number> =>
      String.codec
        .encode(value.caseString)
        .concat(List.codec(Statement.codec).encode(value.statementList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TsPattern; readonly nextIndex: number } => {
      const caseStringAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const statementListAndNextIndex: {
        readonly result: List<Statement>;
        readonly nextIndex: number;
      } = List.codec(Statement.codec).decode(
        caseStringAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          caseString: caseStringAndNextIndex.result,
          statementList: statementListAndNextIndex.result,
        },
        nextIndex: statementListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 型パラメーター
 * @typePartId 627dc8fa15214481812af12268d97b6b
 */
export const TypeParameter: {
  readonly codec: Codec<TypeParameter>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: TypeParameter) => TypeParameter;
} = {
  helper: (typeParameter: TypeParameter): TypeParameter => typeParameter,
  codec: {
    encode: (value: TypeParameter): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(TypePartId.codec.encode(value.typePartId)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypeParameter; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const typePartIdAndNextIndex: {
        readonly result: TypePartId;
        readonly nextIndex: number;
      } = TypePartId.codec.decode(nameAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          typePartId: typePartIdAndNextIndex.result,
        },
        nextIndex: typePartIdAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * Elmのコードを表現するもの
 * @typePartId 62923d32a2730114e665cef13f93ff13
 */
export const ElmCode: {
  readonly codec: Codec<ElmCode>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ElmCode) => ElmCode;
} = {
  helper: (elmCode: ElmCode): ElmCode => elmCode,
  codec: {
    encode: (value: ElmCode): ReadonlyArray<number> =>
      String.codec
        .encode(value.moduleName)
        .concat(
          List.codec(ElmTypeDeclaration.codec).encode(value.typeDeclarationList)
        ),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ElmCode; readonly nextIndex: number } => {
      const moduleNameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const typeDeclarationListAndNextIndex: {
        readonly result: List<ElmTypeDeclaration>;
        readonly nextIndex: number;
      } = List.codec(ElmTypeDeclaration.codec).decode(
        moduleNameAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          moduleName: moduleNameAndNextIndex.result,
          typeDeclarationList: typeDeclarationListAndNextIndex.result,
        },
        nextIndex: typeDeclarationListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * Definyだけでは表現できないデータ型
 * @typePartId 657b5a5519b095480a21fdadd0f6fbd1
 */
export const TypePartBodyKernel: {
  /**
   * 関数
   */
  readonly Function: TypePartBodyKernel;
  /**
   * 32bit整数
   */
  readonly Int32: TypePartBodyKernel;
  /**
   * 文字列. Definyだけで表現できるが, TypeScriptでstringとして扱うために必要
   */
  readonly String: TypePartBodyKernel;
  /**
   * バイナリ型. TypeScriptではUint8Arrayとして扱う
   */
  readonly Binary: TypePartBodyKernel;
  /**
   * UUID (16byte) を表現する. 内部表現はとりあえず0-f長さ32の文字列
   */
  readonly Id: TypePartBodyKernel;
  /**
   * sha256などでハッシュ化したもの (32byte) を表現する. 内部表現はとりあえず0-f長さ64の文字列
   */
  readonly Token: TypePartBodyKernel;
  /**
   * 配列型. TypeScriptではReadonlyArrayとして扱う
   */
  readonly List: TypePartBodyKernel;
  /**
   * 辞書型. TypeScriptでは ReadonlyMapとして扱う
   */
  readonly Dict: TypePartBodyKernel;
  readonly codec: Codec<TypePartBodyKernel>;
} = {
  Function: "Function",
  Int32: "Int32",
  String: "String",
  Binary: "Binary",
  Id: "Id",
  Token: "Token",
  List: "List",
  Dict: "Dict",
  codec: {
    encode: (value: TypePartBodyKernel): ReadonlyArray<number> => {
      switch (value) {
        case "Function": {
          return [0];
        }
        case "Int32": {
          return [1];
        }
        case "String": {
          return [2];
        }
        case "Binary": {
          return [3];
        }
        case "Id": {
          return [4];
        }
        case "Token": {
          return [5];
        }
        case "List": {
          return [6];
        }
        case "Dict": {
          return [7];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypePartBodyKernel; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: TypePartBodyKernel.Function,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: TypePartBodyKernel.Int32,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        return {
          result: TypePartBodyKernel.String,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        return {
          result: TypePartBodyKernel.Binary,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 4) {
        return {
          result: TypePartBodyKernel.Id,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 5) {
        return {
          result: TypePartBodyKernel.Token,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 6) {
        return {
          result: TypePartBodyKernel.List,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 7) {
        return {
          result: TypePartBodyKernel.Dict,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 文字列. JavaScriptのstringで扱う. バイナリ形式はUTF-8. 不正な文字が入っている可能性がある
 * @typePartId 666361c9ae68ab64f273c47f3feb8c73
 */
export const String: { readonly codec: Codec<String> } = {
  codec: {
    encode: (value: String): ReadonlyArray<number> => {
      const result: ReadonlyArray<number> = [
        ...new TextEncoder().encode(value),
      ];
      return Int32.codec.encode(result.length).concat(result);
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: String; readonly nextIndex: number } => {
      const length: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      const nextIndex: number = length.nextIndex + length.result;
      const textBinary: Uint8Array = binary.slice(length.nextIndex, nextIndex);
      return { result: new TextDecoder().decode(textBinary), nextIndex };
    },
  },
};

/**
 * ユーザー名. 表示される名前. 他のユーザーとかぶっても良い. 絵文字も使える. 全角英数は半角英数,半角カタカナは全角カタカナ, (株)の合字を分解するなどのNFKCの正規化がされる. U+0000-U+0019 と U+007F-U+00A0 の範囲の文字は入らない. 前後に空白を含められない. 間の空白は2文字以上連続しない. 文字数のカウント方法は正規化されたあとのCodePoint単位. Twitterと同じ, 1文字以上50文字以下
 * @typePartId 67d4e3bc4f13e1132b6c5e81d5b74395
 */
export const Account: {
  readonly codec: Codec<Account>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: Account) => Account;
} = {
  helper: (account: Account): Account => account,
  codec: {
    encode: (value: Account): ReadonlyArray<number> =>
      ImageHash.codec
        .encode(value.imageHash)
        .concat(String.codec.encode(value.introduction))
        .concat(Time.codec.encode(value.createTime))
        .concat(String.codec.encode(value.name)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Account; readonly nextIndex: number } => {
      const imageHashAndNextIndex: {
        readonly result: ImageHash;
        readonly nextIndex: number;
      } = ImageHash.codec.decode(index, binary);
      const introductionAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(imageHashAndNextIndex.nextIndex, binary);
      const createTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(introductionAndNextIndex.nextIndex, binary);
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(createTimeAndNextIndex.nextIndex, binary);
      return {
        result: {
          imageHash: imageHashAndNextIndex.result,
          introduction: introductionAndNextIndex.result,
          createTime: createTimeAndNextIndex.result,
          name: nameAndNextIndex.result,
        },
        nextIndex: nameAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * キーであるTokenによってデータが必ず1つに決まるもの. 絶対に更新されない. リソースがないということはデータが不正な状態になっているということ
 * @typePartId 68d925f7b35bab8f265cd9e5eb7ea3da
 */
export const StaticResourceState: {
  /**
   * 取得済み
   */
  readonly Loaded: <data extends unknown>(a: data) => StaticResourceState<data>;
  /**
   * データを取得できなかった (サーバーの障害, オフライン)
   */
  readonly Unknown: <data extends unknown>() => StaticResourceState<data>;
  /**
   * indexedDBにアクセス中
   */
  readonly Loading: <data extends unknown>() => StaticResourceState<data>;
  /**
   * サーバに問い合わせ中
   */
  readonly Requesting: <data extends unknown>() => StaticResourceState<data>;
  readonly codec: <data extends unknown>(
    a: Codec<data>
  ) => Codec<StaticResourceState<data>>;
} = {
  Loaded: <data extends unknown>(data: data): StaticResourceState<data> => ({
    _: "Loaded",
    data,
  }),
  Unknown: <data extends unknown>(): StaticResourceState<data> => ({
    _: "Unknown",
  }),
  Loading: <data extends unknown>(): StaticResourceState<data> => ({
    _: "Loading",
  }),
  Requesting: <data extends unknown>(): StaticResourceState<data> => ({
    _: "Requesting",
  }),
  codec: <data extends unknown>(
    dataCodec: Codec<data>
  ): Codec<StaticResourceState<data>> => ({
    encode: (value: StaticResourceState<data>): ReadonlyArray<number> => {
      switch (value._) {
        case "Loaded": {
          return [0].concat(dataCodec.encode(value.data));
        }
        case "Unknown": {
          return [1];
        }
        case "Loading": {
          return [2];
        }
        case "Requesting": {
          return [3];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: StaticResourceState<data>;
      readonly nextIndex: number;
    } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: data;
          readonly nextIndex: number;
        } = dataCodec.decode(patternIndex.nextIndex, binary);
        return {
          result: StaticResourceState.Loaded(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: StaticResourceState.Unknown(),
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        return {
          result: StaticResourceState.Loading(),
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        return {
          result: StaticResourceState.Requesting(),
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  }),
};

/**
 * 代入文
 * @typePartId 6a5a7886b0f117a50d9d7b11ffe87c9f
 */
export const SetStatement: {
  readonly codec: Codec<SetStatement>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: SetStatement) => SetStatement;
} = {
  helper: (setStatement: SetStatement): SetStatement => setStatement,
  codec: {
    encode: (value: SetStatement): ReadonlyArray<number> =>
      TsExpr.codec
        .encode(value.target)
        .concat(Maybe.codec(BinaryOperator.codec).encode(value.operatorMaybe))
        .concat(TsExpr.codec.encode(value.expr)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: SetStatement; readonly nextIndex: number } => {
      const targetAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(index, binary);
      const operatorMaybeAndNextIndex: {
        readonly result: Maybe<BinaryOperator>;
        readonly nextIndex: number;
      } = Maybe.codec(BinaryOperator.codec).decode(
        targetAndNextIndex.nextIndex,
        binary
      );
      const exprAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(operatorMaybeAndNextIndex.nextIndex, binary);
      return {
        result: {
          target: targetAndNextIndex.result,
          operatorMaybe: operatorMaybeAndNextIndex.result,
          expr: exprAndNextIndex.result,
        },
        nextIndex: exprAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * ドキュメント付きの関数のパラメーター. パラメーター名, ドキュメント, 型
 * @typePartId 6b05e33009ade6b4decd452e8fd4bff1
 */
export const ParameterWithDocument: {
  readonly codec: Codec<ParameterWithDocument>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ParameterWithDocument) => ParameterWithDocument;
} = {
  helper: (
    parameterWithDocument: ParameterWithDocument
  ): ParameterWithDocument => parameterWithDocument,
  codec: {
    encode: (value: ParameterWithDocument): ReadonlyArray<number> =>
      TsIdentifer.codec
        .encode(value.name)
        .concat(String.codec.encode(value.document))
        .concat(TsType.codec.encode(value.type)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: ParameterWithDocument;
      readonly nextIndex: number;
    } => {
      const nameAndNextIndex: {
        readonly result: TsIdentifer;
        readonly nextIndex: number;
      } = TsIdentifer.codec.decode(index, binary);
      const documentAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
      const typeAndNextIndex: {
        readonly result: TsType;
        readonly nextIndex: number;
      } = TsType.codec.decode(documentAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          document: documentAndNextIndex.result,
          type: typeAndNextIndex.result,
        },
        nextIndex: typeAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 型パーツの識別子
 * @typePartId 6e3cff317f8bfbbd1391c0afb9ad6b72
 */
export const TypePartId: { readonly codec: Codec<TypePartId> } = {
  codec: {
    encode: (value: TypePartId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypePartId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: TypePartId;
        readonly nextIndex: number;
      },
  },
};

/**
 * 成功と失敗を表す型. 今後はRustのstd::Resultに出力するために属性をつける?
 * @typePartId 6f937e46fce1cf70d29c54780f132c18
 */
export const Result: {
  /**
   * 成功
   */
  readonly Ok: <ok extends unknown, error extends unknown>(
    a: ok
  ) => Result<ok, error>;
  /**
   * 失敗
   */
  readonly Error: <ok extends unknown, error extends unknown>(
    a: error
  ) => Result<ok, error>;
  readonly codec: <ok extends unknown, error extends unknown>(
    a: Codec<ok>,
    b: Codec<error>
  ) => Codec<Result<ok, error>>;
} = {
  Ok: <ok extends unknown, error extends unknown>(
    ok: ok
  ): Result<ok, error> => ({ _: "Ok", ok }),
  Error: <ok extends unknown, error extends unknown>(
    error: error
  ): Result<ok, error> => ({ _: "Error", error }),
  codec: <ok extends unknown, error extends unknown>(
    okCodec: Codec<ok>,
    errorCodec: Codec<error>
  ): Codec<Result<ok, error>> => ({
    encode: (value: Result<ok, error>): ReadonlyArray<number> => {
      switch (value._) {
        case "Ok": {
          return [0].concat(okCodec.encode(value.ok));
        }
        case "Error": {
          return [1].concat(errorCodec.encode(value.error));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Result<ok, error>; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: ok;
          readonly nextIndex: number;
        } = okCodec.decode(patternIndex.nextIndex, binary);
        return {
          result: Result.Ok(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: error;
          readonly nextIndex: number;
        } = errorCodec.decode(patternIndex.nextIndex, binary);
        return {
          result: Result.Error(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  }),
};

/**
 * 言語とページの場所. URLとして表現されるデータ. Googleなどの検索エンジンの都合( https://support.google.com/webmasters/answer/182192?hl=ja )で,URLにページの言語を入れて,言語ごとに別のURLである必要がある.
 * @typePartId 7210f04a85c5f0f58f7aa20826d67f05
 */
export const UrlData: {
  readonly codec: Codec<UrlData>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: UrlData) => UrlData;
} = {
  helper: (urlData: UrlData): UrlData => urlData,
  codec: {
    encode: (value: UrlData): ReadonlyArray<number> =>
      Location.codec
        .encode(value.location)
        .concat(Language.codec.encode(value.language)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: UrlData; readonly nextIndex: number } => {
      const locationAndNextIndex: {
        readonly result: Location;
        readonly nextIndex: number;
      } = Location.codec.decode(index, binary);
      const languageAndNextIndex: {
        readonly result: Language;
        readonly nextIndex: number;
      } = Language.codec.decode(locationAndNextIndex.nextIndex, binary);
      return {
        result: {
          location: locationAndNextIndex.result,
          language: languageAndNextIndex.result,
        },
        nextIndex: languageAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * switch文
 * @typePartId 725f84ef82e6c3b5b5f6fd5208977dd8
 */
export const SwitchStatement: {
  readonly codec: Codec<SwitchStatement>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: SwitchStatement) => SwitchStatement;
} = {
  helper: (switchStatement: SwitchStatement): SwitchStatement =>
    switchStatement,
  codec: {
    encode: (value: SwitchStatement): ReadonlyArray<number> =>
      TsExpr.codec
        .encode(value.expr)
        .concat(List.codec(TsPattern.codec).encode(value.patternList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: SwitchStatement; readonly nextIndex: number } => {
      const exprAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(index, binary);
      const patternListAndNextIndex: {
        readonly result: List<TsPattern>;
        readonly nextIndex: number;
      } = List.codec(TsPattern.codec).decode(
        exprAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          expr: exprAndNextIndex.result,
          patternList: patternListAndNextIndex.result,
        },
        nextIndex: patternListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * ローカル変数定義
 * @typePartId 7277cf2483388ee2f5ad7a7fc8585d98
 */
export const VariableDefinitionStatement: {
  readonly codec: Codec<VariableDefinitionStatement>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (
    a: VariableDefinitionStatement
  ) => VariableDefinitionStatement;
} = {
  helper: (
    variableDefinitionStatement: VariableDefinitionStatement
  ): VariableDefinitionStatement => variableDefinitionStatement,
  codec: {
    encode: (value: VariableDefinitionStatement): ReadonlyArray<number> =>
      TsIdentifer.codec
        .encode(value.name)
        .concat(TsType.codec.encode(value.type))
        .concat(TsExpr.codec.encode(value.expr))
        .concat(Bool.codec.encode(value.isConst)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: VariableDefinitionStatement;
      readonly nextIndex: number;
    } => {
      const nameAndNextIndex: {
        readonly result: TsIdentifer;
        readonly nextIndex: number;
      } = TsIdentifer.codec.decode(index, binary);
      const typeAndNextIndex: {
        readonly result: TsType;
        readonly nextIndex: number;
      } = TsType.codec.decode(nameAndNextIndex.nextIndex, binary);
      const exprAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(typeAndNextIndex.nextIndex, binary);
      const isConstAndNextIndex: {
        readonly result: Bool;
        readonly nextIndex: number;
      } = Bool.codec.decode(exprAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          type: typeAndNextIndex.result,
          expr: exprAndNextIndex.result,
          isConst: isConstAndNextIndex.result,
        },
        nextIndex: isConstAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * プロジェクト作成時に必要なパラメーター
 * @typePartId 7b987551cc112a64f5c9a8cb1647f4bd
 */
export const CreateProjectParameter: {
  readonly codec: Codec<CreateProjectParameter>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: CreateProjectParameter) => CreateProjectParameter;
} = {
  helper: (
    createProjectParameter: CreateProjectParameter
  ): CreateProjectParameter => createProjectParameter,
  codec: {
    encode: (value: CreateProjectParameter): ReadonlyArray<number> =>
      AccountToken.codec
        .encode(value.accountToken)
        .concat(String.codec.encode(value.projectName)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: CreateProjectParameter;
      readonly nextIndex: number;
    } => {
      const accountTokenAndNextIndex: {
        readonly result: AccountToken;
        readonly nextIndex: number;
      } = AccountToken.codec.decode(index, binary);
      const projectNameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(accountTokenAndNextIndex.nextIndex, binary);
      return {
        result: {
          accountToken: accountTokenAndNextIndex.result,
          projectName: projectNameAndNextIndex.result,
        },
        nextIndex: projectNameAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * JavaScript の 文
 * @typePartId 7c957d411f448a03764f16d43e6e5008
 */
export const Statement: {
  /**
   * 式を評価する
   */
  readonly EvaluateExpr: (a: TsExpr) => Statement;
  /**
   * 代入やプロパティの値を設定する
   */
  readonly Set: (a: SetStatement) => Statement;
  /**
   * if (condition) { thenStatementList }
   */
  readonly If: (a: IfStatement) => Statement;
  /**
   * throw new Error("エラーメッセージ");
   */
  readonly ThrowError: (a: TsExpr) => Statement;
  /**
   * return expr;
   */
  readonly Return: (a: TsExpr) => Statement;
  /**
   * 戻り値がvoidの関数を早く抜ける
   */
  readonly ReturnVoid: Statement;
  /**
   * forの繰り返しを次に進める
   */
  readonly Continue: Statement;
  /**
   * `const a: type_ = expr`\nローカル変数の定義
   */
  readonly VariableDefinition: (a: VariableDefinitionStatement) => Statement;
  /**
   * `const name = (parameterList): returnType => { statementList }`\nローカル関数の定義
   */
  readonly FunctionDefinition: (a: FunctionDefinitionStatement) => Statement;
  /**
   * for文. 繰り返し.
   */
  readonly For: (a: ForStatement) => Statement;
  /**
   * for文. 繰り返し.
   */
  readonly ForOf: (a: ForOfStatement) => Statement;
  /**
   * while (true) での無限ループ
   */
  readonly WhileTrue: (a: List<Statement>) => Statement;
  /**
   * whileのループから抜ける
   */
  readonly Break: Statement;
  /**
   * switch文
   */
  readonly Switch: (a: SwitchStatement) => Statement;
  readonly codec: Codec<Statement>;
} = {
  EvaluateExpr: (tsExpr: TsExpr): Statement => ({ _: "EvaluateExpr", tsExpr }),
  Set: (setStatement: SetStatement): Statement => ({ _: "Set", setStatement }),
  If: (ifStatement: IfStatement): Statement => ({ _: "If", ifStatement }),
  ThrowError: (tsExpr: TsExpr): Statement => ({ _: "ThrowError", tsExpr }),
  Return: (tsExpr: TsExpr): Statement => ({ _: "Return", tsExpr }),
  ReturnVoid: { _: "ReturnVoid" },
  Continue: { _: "Continue" },
  VariableDefinition: (
    variableDefinitionStatement: VariableDefinitionStatement
  ): Statement => ({ _: "VariableDefinition", variableDefinitionStatement }),
  FunctionDefinition: (
    functionDefinitionStatement: FunctionDefinitionStatement
  ): Statement => ({ _: "FunctionDefinition", functionDefinitionStatement }),
  For: (forStatement: ForStatement): Statement => ({ _: "For", forStatement }),
  ForOf: (forOfStatement: ForOfStatement): Statement => ({
    _: "ForOf",
    forOfStatement,
  }),
  WhileTrue: (statementList: List<Statement>): Statement => ({
    _: "WhileTrue",
    statementList,
  }),
  Break: { _: "Break" },
  Switch: (switchStatement: SwitchStatement): Statement => ({
    _: "Switch",
    switchStatement,
  }),
  codec: {
    encode: (value: Statement): ReadonlyArray<number> => {
      switch (value._) {
        case "EvaluateExpr": {
          return [0].concat(TsExpr.codec.encode(value.tsExpr));
        }
        case "Set": {
          return [1].concat(SetStatement.codec.encode(value.setStatement));
        }
        case "If": {
          return [2].concat(IfStatement.codec.encode(value.ifStatement));
        }
        case "ThrowError": {
          return [3].concat(TsExpr.codec.encode(value.tsExpr));
        }
        case "Return": {
          return [4].concat(TsExpr.codec.encode(value.tsExpr));
        }
        case "ReturnVoid": {
          return [5];
        }
        case "Continue": {
          return [6];
        }
        case "VariableDefinition": {
          return [7].concat(
            VariableDefinitionStatement.codec.encode(
              value.variableDefinitionStatement
            )
          );
        }
        case "FunctionDefinition": {
          return [8].concat(
            FunctionDefinitionStatement.codec.encode(
              value.functionDefinitionStatement
            )
          );
        }
        case "For": {
          return [9].concat(ForStatement.codec.encode(value.forStatement));
        }
        case "ForOf": {
          return [10].concat(ForOfStatement.codec.encode(value.forOfStatement));
        }
        case "WhileTrue": {
          return [11].concat(
            List.codec(Statement.codec).encode(value.statementList)
          );
        }
        case "Break": {
          return [12];
        }
        case "Switch": {
          return [13].concat(
            SwitchStatement.codec.encode(value.switchStatement)
          );
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Statement; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: TsExpr;
          readonly nextIndex: number;
        } = TsExpr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.EvaluateExpr(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: SetStatement;
          readonly nextIndex: number;
        } = SetStatement.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.Set(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: IfStatement;
          readonly nextIndex: number;
        } = IfStatement.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.If(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        const result: {
          readonly result: TsExpr;
          readonly nextIndex: number;
        } = TsExpr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.ThrowError(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 4) {
        const result: {
          readonly result: TsExpr;
          readonly nextIndex: number;
        } = TsExpr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.Return(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 5) {
        return {
          result: Statement.ReturnVoid,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 6) {
        return {
          result: Statement.Continue,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 7) {
        const result: {
          readonly result: VariableDefinitionStatement;
          readonly nextIndex: number;
        } = VariableDefinitionStatement.codec.decode(
          patternIndex.nextIndex,
          binary
        );
        return {
          result: Statement.VariableDefinition(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 8) {
        const result: {
          readonly result: FunctionDefinitionStatement;
          readonly nextIndex: number;
        } = FunctionDefinitionStatement.codec.decode(
          patternIndex.nextIndex,
          binary
        );
        return {
          result: Statement.FunctionDefinition(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 9) {
        const result: {
          readonly result: ForStatement;
          readonly nextIndex: number;
        } = ForStatement.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.For(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 10) {
        const result: {
          readonly result: ForOfStatement;
          readonly nextIndex: number;
        } = ForOfStatement.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.ForOf(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 11) {
        const result: {
          readonly result: List<Statement>;
          readonly nextIndex: number;
        } = List.codec(Statement.codec).decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.WhileTrue(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 12) {
        return { result: Statement.Break, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 13) {
        const result: {
          readonly result: SwitchStatement;
          readonly nextIndex: number;
        } = SwitchStatement.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.Switch(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 日時. 0001-01-01T00:00:00.000Z to 9999-12-31T23:59:59.999Z 最小単位はミリ秒. ミリ秒の求め方は day*1000*60*60*24 + millisecond
 * @typePartId 7d91f0f70643799692aa144ee51a62b1
 */
export const Time: {
  readonly codec: Codec<Time>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: Time) => Time;
} = {
  helper: (time: Time): Time => time,
  codec: {
    encode: (value: Time): ReadonlyArray<number> =>
      Int32.codec
        .encode(value.day)
        .concat(Int32.codec.encode(value.millisecond)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Time; readonly nextIndex: number } => {
      const dayAndNextIndex: {
        readonly result: Int32;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      const millisecondAndNextIndex: {
        readonly result: Int32;
        readonly nextIndex: number;
      } = Int32.codec.decode(dayAndNextIndex.nextIndex, binary);
      return {
        result: {
          day: dayAndNextIndex.result,
          millisecond: millisecondAndNextIndex.result,
        },
        nextIndex: millisecondAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * アカウントトークンとプロジェクトID
 * @typePartId 7e4613f18e8e3bcfdfc00356654414d5
 */
export const AccountTokenAndProjectId: {
  readonly codec: Codec<AccountTokenAndProjectId>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: AccountTokenAndProjectId) => AccountTokenAndProjectId;
} = {
  helper: (
    accountTokenAndProjectId: AccountTokenAndProjectId
  ): AccountTokenAndProjectId => accountTokenAndProjectId,
  codec: {
    encode: (value: AccountTokenAndProjectId): ReadonlyArray<number> =>
      AccountToken.codec
        .encode(value.accountToken)
        .concat(ProjectId.codec.encode(value.projectId)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: AccountTokenAndProjectId;
      readonly nextIndex: number;
    } => {
      const accountTokenAndNextIndex: {
        readonly result: AccountToken;
        readonly nextIndex: number;
      } = AccountToken.codec.decode(index, binary);
      const projectIdAndNextIndex: {
        readonly result: ProjectId;
        readonly nextIndex: number;
      } = ProjectId.codec.decode(accountTokenAndNextIndex.nextIndex, binary);
      return {
        result: {
          accountToken: accountTokenAndNextIndex.result,
          projectId: projectIdAndNextIndex.result,
        },
        nextIndex: projectIdAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * インポートした変数
 * @typePartId 8150e2833dc1f2a77715aa1bb7b2baad
 */
export const ImportedVariable: {
  readonly codec: Codec<ImportedVariable>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ImportedVariable) => ImportedVariable;
} = {
  helper: (importedVariable: ImportedVariable): ImportedVariable =>
    importedVariable,
  codec: {
    encode: (value: ImportedVariable): ReadonlyArray<number> =>
      String.codec
        .encode(value.moduleName)
        .concat(TsIdentifer.codec.encode(value.name)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ImportedVariable; readonly nextIndex: number } => {
      const moduleNameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const nameAndNextIndex: {
        readonly result: TsIdentifer;
        readonly nextIndex: number;
      } = TsIdentifer.codec.decode(moduleNameAndNextIndex.nextIndex, binary);
      return {
        result: {
          moduleName: moduleNameAndNextIndex.result,
          name: nameAndNextIndex.result,
        },
        nextIndex: nameAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * "ソーシャルログインを提供するプロバイダー (例: Google, GitHub)
 *
 * GitHub いらないかも (GitHubのアカウント作成するの分かりづらいので, 選択肢を減らしたい)
 * @typePartId 84597034eb252267ce1a599ab7a0b543
 */
export const OpenIdConnectProvider: {
  /**
   * Google ( https://developers.google.com/identity/sign-in/web/ )
   */
  readonly Google: OpenIdConnectProvider;
  /**
   * GitHub ( https://developer.github.com/v3/guides/basics-of-authentication/ )
   */
  readonly GitHub: OpenIdConnectProvider;
  readonly codec: Codec<OpenIdConnectProvider>;
} = {
  Google: "Google",
  GitHub: "GitHub",
  codec: {
    encode: (value: OpenIdConnectProvider): ReadonlyArray<number> => {
      switch (value) {
        case "Google": {
          return [0];
        }
        case "GitHub": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: OpenIdConnectProvider;
      readonly nextIndex: number;
    } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: OpenIdConnectProvider.Google,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: OpenIdConnectProvider.GitHub,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 型パーツ
 * @typePartId 87fc411d10f6986dd33e5dbaff6d06ae
 */
export const TypePart: {
  readonly codec: Codec<TypePart>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: TypePart) => TypePart;
} = {
  helper: (typePart: TypePart): TypePart => typePart,
  codec: {
    encode: (value: TypePart): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(String.codec.encode(value.description))
        .concat(ProjectId.codec.encode(value.projectId))
        .concat(Maybe.codec(TypeAttribute.codec).encode(value.attribute))
        .concat(List.codec(TypeParameter.codec).encode(value.typeParameterList))
        .concat(TypePartBody.codec.encode(value.body)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypePart; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const descriptionAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
      const projectIdAndNextIndex: {
        readonly result: ProjectId;
        readonly nextIndex: number;
      } = ProjectId.codec.decode(descriptionAndNextIndex.nextIndex, binary);
      const attributeAndNextIndex: {
        readonly result: Maybe<TypeAttribute>;
        readonly nextIndex: number;
      } = Maybe.codec(TypeAttribute.codec).decode(
        projectIdAndNextIndex.nextIndex,
        binary
      );
      const typeParameterListAndNextIndex: {
        readonly result: List<TypeParameter>;
        readonly nextIndex: number;
      } = List.codec(TypeParameter.codec).decode(
        attributeAndNextIndex.nextIndex,
        binary
      );
      const bodyAndNextIndex: {
        readonly result: TypePartBody;
        readonly nextIndex: number;
      } = TypePartBody.codec.decode(
        typeParameterListAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          name: nameAndNextIndex.result,
          description: descriptionAndNextIndex.result,
          projectId: projectIdAndNextIndex.result,
          attribute: attributeAndNextIndex.result,
          typeParameterList: typeParameterListAndNextIndex.result,
          body: bodyAndNextIndex.result,
        },
        nextIndex: bodyAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * JavaScript の 式
 * @typePartId 8b0bdbeae05df3badac2ee69bf22011f
 */
export const TsExpr: {
  /**
   * 数値リテラル `123`
   */
  readonly NumberLiteral: (a: Int32) => TsExpr;
  /**
   * 文字列リテラル `"text"`
   */
  readonly StringLiteral: (a: String) => TsExpr;
  /**
   * booleanリテラル
   */
  readonly BooleanLiteral: (a: Bool) => TsExpr;
  /**
   * `null`
   */
  readonly NullLiteral: TsExpr;
  /**
   * `undefined`
   */
  readonly UndefinedLiteral: TsExpr;
  /**
   * 単項演算子での式
   */
  readonly UnaryOperator: (a: UnaryOperatorExpr) => TsExpr;
  /**
   * 2項演算子での式
   */
  readonly BinaryOperator: (a: BinaryOperatorExpr) => TsExpr;
  /**
   * 条件演算子 `a ? b : c`
   */
  readonly ConditionalOperator: (a: ConditionalOperatorExpr) => TsExpr;
  /**
   * 配列リテラル `[1, 2, 3]`
   */
  readonly ArrayLiteral: (a: List<ArrayItem>) => TsExpr;
  /**
   * オブジェクトリテラル `{ data: 123, text: "sorena" }`
   */
  readonly ObjectLiteral: (a: List<TsMember>) => TsExpr;
  /**
   * ラムダ式 `() => {}`
   */
  readonly Lambda: (a: LambdaExpr) => TsExpr;
  /**
   * 変数. 変数が存在するかのチャックがされる
   */
  readonly Variable: (a: TsIdentifer) => TsExpr;
  /**
   * グローバルオブジェクト
   */
  readonly GlobalObjects: (a: TsIdentifer) => TsExpr;
  /**
   * インポートされた変数
   */
  readonly ImportedVariable: (a: ImportedVariable) => TsExpr;
  /**
   * プロパティの値を取得する `a.b a[12] data[f(2)]`
   */
  readonly Get: (a: GetExpr) => TsExpr;
  /**
   * 関数を呼ぶ f(x)",
   */
  readonly Call: (a: CallExpr) => TsExpr;
  /**
   * 式からインスタンスを作成する `new Date()`
   */
  readonly New: (a: CallExpr) => TsExpr;
  /**
   * 型アサーション `a as string`
   */
  readonly TypeAssertion: (a: TypeAssertion) => TsExpr;
  readonly codec: Codec<TsExpr>;
} = {
  NumberLiteral: (int32: Int32): TsExpr => ({ _: "NumberLiteral", int32 }),
  StringLiteral: (string_: String): TsExpr => ({
    _: "StringLiteral",
    string: string_,
  }),
  BooleanLiteral: (bool: Bool): TsExpr => ({ _: "BooleanLiteral", bool }),
  NullLiteral: { _: "NullLiteral" },
  UndefinedLiteral: { _: "UndefinedLiteral" },
  UnaryOperator: (unaryOperatorExpr: UnaryOperatorExpr): TsExpr => ({
    _: "UnaryOperator",
    unaryOperatorExpr,
  }),
  BinaryOperator: (binaryOperatorExpr: BinaryOperatorExpr): TsExpr => ({
    _: "BinaryOperator",
    binaryOperatorExpr,
  }),
  ConditionalOperator: (
    conditionalOperatorExpr: ConditionalOperatorExpr
  ): TsExpr => ({ _: "ConditionalOperator", conditionalOperatorExpr }),
  ArrayLiteral: (arrayItemList: List<ArrayItem>): TsExpr => ({
    _: "ArrayLiteral",
    arrayItemList,
  }),
  ObjectLiteral: (tsMemberList: List<TsMember>): TsExpr => ({
    _: "ObjectLiteral",
    tsMemberList,
  }),
  Lambda: (lambdaExpr: LambdaExpr): TsExpr => ({ _: "Lambda", lambdaExpr }),
  Variable: (tsIdentifer: TsIdentifer): TsExpr => ({
    _: "Variable",
    tsIdentifer,
  }),
  GlobalObjects: (tsIdentifer: TsIdentifer): TsExpr => ({
    _: "GlobalObjects",
    tsIdentifer,
  }),
  ImportedVariable: (importedVariable: ImportedVariable): TsExpr => ({
    _: "ImportedVariable",
    importedVariable,
  }),
  Get: (getExpr: GetExpr): TsExpr => ({ _: "Get", getExpr }),
  Call: (callExpr: CallExpr): TsExpr => ({ _: "Call", callExpr }),
  New: (callExpr: CallExpr): TsExpr => ({ _: "New", callExpr }),
  TypeAssertion: (typeAssertion: TypeAssertion): TsExpr => ({
    _: "TypeAssertion",
    typeAssertion,
  }),
  codec: {
    encode: (value: TsExpr): ReadonlyArray<number> => {
      switch (value._) {
        case "NumberLiteral": {
          return [0].concat(Int32.codec.encode(value.int32));
        }
        case "StringLiteral": {
          return [1].concat(String.codec.encode(value.string));
        }
        case "BooleanLiteral": {
          return [2].concat(Bool.codec.encode(value.bool));
        }
        case "NullLiteral": {
          return [3];
        }
        case "UndefinedLiteral": {
          return [4];
        }
        case "UnaryOperator": {
          return [5].concat(
            UnaryOperatorExpr.codec.encode(value.unaryOperatorExpr)
          );
        }
        case "BinaryOperator": {
          return [6].concat(
            BinaryOperatorExpr.codec.encode(value.binaryOperatorExpr)
          );
        }
        case "ConditionalOperator": {
          return [7].concat(
            ConditionalOperatorExpr.codec.encode(value.conditionalOperatorExpr)
          );
        }
        case "ArrayLiteral": {
          return [8].concat(
            List.codec(ArrayItem.codec).encode(value.arrayItemList)
          );
        }
        case "ObjectLiteral": {
          return [9].concat(
            List.codec(TsMember.codec).encode(value.tsMemberList)
          );
        }
        case "Lambda": {
          return [10].concat(LambdaExpr.codec.encode(value.lambdaExpr));
        }
        case "Variable": {
          return [11].concat(TsIdentifer.codec.encode(value.tsIdentifer));
        }
        case "GlobalObjects": {
          return [12].concat(TsIdentifer.codec.encode(value.tsIdentifer));
        }
        case "ImportedVariable": {
          return [13].concat(
            ImportedVariable.codec.encode(value.importedVariable)
          );
        }
        case "Get": {
          return [14].concat(GetExpr.codec.encode(value.getExpr));
        }
        case "Call": {
          return [15].concat(CallExpr.codec.encode(value.callExpr));
        }
        case "New": {
          return [16].concat(CallExpr.codec.encode(value.callExpr));
        }
        case "TypeAssertion": {
          return [17].concat(TypeAssertion.codec.encode(value.typeAssertion));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TsExpr; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: Int32;
          readonly nextIndex: number;
        } = Int32.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsExpr.NumberLiteral(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: String;
          readonly nextIndex: number;
        } = String.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsExpr.StringLiteral(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: Bool;
          readonly nextIndex: number;
        } = Bool.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsExpr.BooleanLiteral(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        return {
          result: TsExpr.NullLiteral,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 4) {
        return {
          result: TsExpr.UndefinedLiteral,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 5) {
        const result: {
          readonly result: UnaryOperatorExpr;
          readonly nextIndex: number;
        } = UnaryOperatorExpr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsExpr.UnaryOperator(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 6) {
        const result: {
          readonly result: BinaryOperatorExpr;
          readonly nextIndex: number;
        } = BinaryOperatorExpr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsExpr.BinaryOperator(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 7) {
        const result: {
          readonly result: ConditionalOperatorExpr;
          readonly nextIndex: number;
        } = ConditionalOperatorExpr.codec.decode(
          patternIndex.nextIndex,
          binary
        );
        return {
          result: TsExpr.ConditionalOperator(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 8) {
        const result: {
          readonly result: List<ArrayItem>;
          readonly nextIndex: number;
        } = List.codec(ArrayItem.codec).decode(patternIndex.nextIndex, binary);
        return {
          result: TsExpr.ArrayLiteral(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 9) {
        const result: {
          readonly result: List<TsMember>;
          readonly nextIndex: number;
        } = List.codec(TsMember.codec).decode(patternIndex.nextIndex, binary);
        return {
          result: TsExpr.ObjectLiteral(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 10) {
        const result: {
          readonly result: LambdaExpr;
          readonly nextIndex: number;
        } = LambdaExpr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsExpr.Lambda(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 11) {
        const result: {
          readonly result: TsIdentifer;
          readonly nextIndex: number;
        } = TsIdentifer.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsExpr.Variable(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 12) {
        const result: {
          readonly result: TsIdentifer;
          readonly nextIndex: number;
        } = TsIdentifer.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsExpr.GlobalObjects(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 13) {
        const result: {
          readonly result: ImportedVariable;
          readonly nextIndex: number;
        } = ImportedVariable.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsExpr.ImportedVariable(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 14) {
        const result: {
          readonly result: GetExpr;
          readonly nextIndex: number;
        } = GetExpr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsExpr.Get(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 15) {
        const result: {
          readonly result: CallExpr;
          readonly nextIndex: number;
        } = CallExpr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsExpr.Call(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 16) {
        const result: {
          readonly result: CallExpr;
          readonly nextIndex: number;
        } = CallExpr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsExpr.New(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 17) {
        const result: {
          readonly result: TypeAssertion;
          readonly nextIndex: number;
        } = TypeAssertion.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsExpr.TypeAssertion(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 2つの要素のタプルの型
 * @typePartId 8b479d8726bb494ac76d529fbf03908c
 */
export const ElmTuple2: {
  readonly codec: Codec<ElmTuple2>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ElmTuple2) => ElmTuple2;
} = {
  helper: (elmTuple2: ElmTuple2): ElmTuple2 => elmTuple2,
  codec: {
    encode: (value: ElmTuple2): ReadonlyArray<number> =>
      ElmType.codec
        .encode(value.first)
        .concat(ElmType.codec.encode(value.second)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ElmTuple2; readonly nextIndex: number } => {
      const firstAndNextIndex: {
        readonly result: ElmType;
        readonly nextIndex: number;
      } = ElmType.codec.decode(index, binary);
      const secondAndNextIndex: {
        readonly result: ElmType;
        readonly nextIndex: number;
      } = ElmType.codec.decode(firstAndNextIndex.nextIndex, binary);
      return {
        result: {
          first: firstAndNextIndex.result,
          second: secondAndNextIndex.result,
        },
        nextIndex: secondAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * Definy の プロジェクト
 * @typePartId 8bc81fa2a15bdbd8c2414d22f3e1b462
 */
export const Project: {
  readonly codec: Codec<Project>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: Project) => Project;
} = {
  helper: (project: Project): Project => project,
  codec: {
    encode: (value: Project): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(ImageHash.codec.encode(value.iconHash))
        .concat(ImageHash.codec.encode(value.imageHash))
        .concat(Time.codec.encode(value.createTime))
        .concat(AccountId.codec.encode(value.createAccountId))
        .concat(Time.codec.encode(value.updateTime)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Project; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const iconHashAndNextIndex: {
        readonly result: ImageHash;
        readonly nextIndex: number;
      } = ImageHash.codec.decode(nameAndNextIndex.nextIndex, binary);
      const imageHashAndNextIndex: {
        readonly result: ImageHash;
        readonly nextIndex: number;
      } = ImageHash.codec.decode(iconHashAndNextIndex.nextIndex, binary);
      const createTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(imageHashAndNextIndex.nextIndex, binary);
      const createAccountIdAndNextIndex: {
        readonly result: AccountId;
        readonly nextIndex: number;
      } = AccountId.codec.decode(createTimeAndNextIndex.nextIndex, binary);
      const updateTimeAndNextIndex: {
        readonly result: Time;
        readonly nextIndex: number;
      } = Time.codec.decode(createAccountIdAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          iconHash: iconHashAndNextIndex.result,
          imageHash: imageHashAndNextIndex.result,
          createTime: createTimeAndNextIndex.result,
          createAccountId: createAccountIdAndNextIndex.result,
          updateTime: updateTimeAndNextIndex.result,
        },
        nextIndex: updateTimeAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * forOf文
 * @typePartId 8be8db4404f302dd36c8a2c6c6e37e7c
 */
export const ForOfStatement: {
  readonly codec: Codec<ForOfStatement>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ForOfStatement) => ForOfStatement;
} = {
  helper: (forOfStatement: ForOfStatement): ForOfStatement => forOfStatement,
  codec: {
    encode: (value: ForOfStatement): ReadonlyArray<number> =>
      TsIdentifer.codec
        .encode(value.elementVariableName)
        .concat(TsExpr.codec.encode(value.iterableExpr))
        .concat(List.codec(Statement.codec).encode(value.statementList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ForOfStatement; readonly nextIndex: number } => {
      const elementVariableNameAndNextIndex: {
        readonly result: TsIdentifer;
        readonly nextIndex: number;
      } = TsIdentifer.codec.decode(index, binary);
      const iterableExprAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(
        elementVariableNameAndNextIndex.nextIndex,
        binary
      );
      const statementListAndNextIndex: {
        readonly result: List<Statement>;
        readonly nextIndex: number;
      } = List.codec(Statement.codec).decode(
        iterableExprAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          elementVariableName: elementVariableNameAndNextIndex.result,
          iterableExpr: iterableExprAndNextIndex.result,
          statementList: statementListAndNextIndex.result,
        },
        nextIndex: statementListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * TypeScriptやJavaScriptのコードを表現する. TypeScriptでも出力できるように型情報をつける必要がある
 * @typePartId 92ea504049ca5b7e2227a95195fe74eb
 */
export const JsTsCode: {
  readonly codec: Codec<JsTsCode>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: JsTsCode) => JsTsCode;
} = {
  helper: (jsTsCode: JsTsCode): JsTsCode => jsTsCode,
  codec: {
    encode: (value: JsTsCode): ReadonlyArray<number> =>
      List.codec(ExportDefinition.codec)
        .encode(value.exportDefinitionList)
        .concat(List.codec(Statement.codec).encode(value.statementList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: JsTsCode; readonly nextIndex: number } => {
      const exportDefinitionListAndNextIndex: {
        readonly result: List<ExportDefinition>;
        readonly nextIndex: number;
      } = List.codec(ExportDefinition.codec).decode(index, binary);
      const statementListAndNextIndex: {
        readonly result: List<Statement>;
        readonly nextIndex: number;
      } = List.codec(Statement.codec).decode(
        exportDefinitionListAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          exportDefinitionList: exportDefinitionListAndNextIndex.result,
          statementList: statementListAndNextIndex.result,
        },
        nextIndex: statementListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 直積型のメンバー
 * @typePartId 9481ceae2c3e2765243f5c7ce7eb76c7
 */
export const Member: {
  readonly codec: Codec<Member>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: Member) => Member;
} = {
  helper: (member: Member): Member => member,
  codec: {
    encode: (value: Member): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(String.codec.encode(value.description))
        .concat(Type.codec.encode(value.type)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Member; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const descriptionAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
      const typeAndNextIndex: {
        readonly result: Type;
        readonly nextIndex: number;
      } = Type.codec.decode(descriptionAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          description: descriptionAndNextIndex.result,
          type: typeAndNextIndex.result,
        },
        nextIndex: typeAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * Elm の 式
 * @typePartId 94e53139b3a82087777ea3e001b2adb4
 */
export const ElmExpr: {
  /**
   * 文字列リテラル
   */
  readonly StringLiteral: (a: String) => ElmExpr;
  /**
   * 整数リテラル
   */
  readonly IntLiteral: (a: Int32) => ElmExpr;
  /**
   * ファイル内で定義したバリアント. 値コンストラクタ. タグ.
   */
  readonly LocalVariant: ElmExpr;
  /**
   * インポートしたバリアント. 値コンストラクタ. タグ.
   */
  readonly ImportedVariant: ElmExpr;
  /**
   * リストリテラル
   */
  readonly List: (a: List<ElmExpr>) => ElmExpr;
  /**
   * ????
   */
  readonly Op: ElmExpr;
  /**
   * 単行マイナス
   */
  readonly Negate: (a: ElmExpr) => ElmExpr;
  /**
   * ????
   */
  readonly Binops: ElmExpr;
  /**
   * ラムダ式. 関数リテラル
   */
  readonly Lambda: ElmExpr;
  /**
   * 関数呼び出し
   */
  readonly Call: ElmExpr;
  /**
   * if式. else ifも含めている
   */
  readonly If: ElmExpr;
  /**
   * let式. ローカル関数定義
   */
  readonly Let: ElmExpr;
  /**
   * case式
   */
  readonly Case: ElmExpr;
  /**
   * アクセサ .name メンバーを取得する関数
   */
  readonly Accessor: (a: String) => ElmExpr;
  /**
   * user.name メンバー取得
   */
  readonly Access: ElmExpr;
  /**
   * { user | name = "新しい名前" }
   */
  readonly Update: ElmExpr;
  /**
   * レコード. { name = "名前", age = 20 }
   */
  readonly Record: ElmExpr;
  /**
   * Unit. ()
   */
  readonly Unit: ElmExpr;
  /**
   * 2つの要素のタプル. (1, "あ")
   */
  readonly Tuple2: ElmExpr;
  /**
   * 3つの要素のタプル. (1, "い", 3)
   */
  readonly Tuple3: ElmExpr;
  readonly codec: Codec<ElmExpr>;
} = {
  StringLiteral: (string_: String): ElmExpr => ({
    _: "StringLiteral",
    string: string_,
  }),
  IntLiteral: (int32: Int32): ElmExpr => ({ _: "IntLiteral", int32 }),
  LocalVariant: { _: "LocalVariant" },
  ImportedVariant: { _: "ImportedVariant" },
  List: (elmExprList: List<ElmExpr>): ElmExpr => ({ _: "List", elmExprList }),
  Op: { _: "Op" },
  Negate: (elmExpr: ElmExpr): ElmExpr => ({ _: "Negate", elmExpr }),
  Binops: { _: "Binops" },
  Lambda: { _: "Lambda" },
  Call: { _: "Call" },
  If: { _: "If" },
  Let: { _: "Let" },
  Case: { _: "Case" },
  Accessor: (string_: String): ElmExpr => ({ _: "Accessor", string: string_ }),
  Access: { _: "Access" },
  Update: { _: "Update" },
  Record: { _: "Record" },
  Unit: { _: "Unit" },
  Tuple2: { _: "Tuple2" },
  Tuple3: { _: "Tuple3" },
  codec: {
    encode: (value: ElmExpr): ReadonlyArray<number> => {
      switch (value._) {
        case "StringLiteral": {
          return [0].concat(String.codec.encode(value.string));
        }
        case "IntLiteral": {
          return [1].concat(Int32.codec.encode(value.int32));
        }
        case "LocalVariant": {
          return [2];
        }
        case "ImportedVariant": {
          return [3];
        }
        case "List": {
          return [4].concat(
            List.codec(ElmExpr.codec).encode(value.elmExprList)
          );
        }
        case "Op": {
          return [5];
        }
        case "Negate": {
          return [6].concat(ElmExpr.codec.encode(value.elmExpr));
        }
        case "Binops": {
          return [7];
        }
        case "Lambda": {
          return [8];
        }
        case "Call": {
          return [9];
        }
        case "If": {
          return [10];
        }
        case "Let": {
          return [11];
        }
        case "Case": {
          return [12];
        }
        case "Accessor": {
          return [13].concat(String.codec.encode(value.string));
        }
        case "Access": {
          return [14];
        }
        case "Update": {
          return [15];
        }
        case "Record": {
          return [16];
        }
        case "Unit": {
          return [17];
        }
        case "Tuple2": {
          return [18];
        }
        case "Tuple3": {
          return [19];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ElmExpr; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: String;
          readonly nextIndex: number;
        } = String.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ElmExpr.StringLiteral(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: Int32;
          readonly nextIndex: number;
        } = Int32.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ElmExpr.IntLiteral(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        return {
          result: ElmExpr.LocalVariant,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        return {
          result: ElmExpr.ImportedVariant,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 4) {
        const result: {
          readonly result: List<ElmExpr>;
          readonly nextIndex: number;
        } = List.codec(ElmExpr.codec).decode(patternIndex.nextIndex, binary);
        return {
          result: ElmExpr.List(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 5) {
        return { result: ElmExpr.Op, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 6) {
        const result: {
          readonly result: ElmExpr;
          readonly nextIndex: number;
        } = ElmExpr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ElmExpr.Negate(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 7) {
        return { result: ElmExpr.Binops, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 8) {
        return { result: ElmExpr.Lambda, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 9) {
        return { result: ElmExpr.Call, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 10) {
        return { result: ElmExpr.If, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 11) {
        return { result: ElmExpr.Let, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 12) {
        return { result: ElmExpr.Case, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 13) {
        const result: {
          readonly result: String;
          readonly nextIndex: number;
        } = String.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ElmExpr.Accessor(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 14) {
        return { result: ElmExpr.Access, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 15) {
        return { result: ElmExpr.Update, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 16) {
        return { result: ElmExpr.Record, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 17) {
        return { result: ElmExpr.Unit, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 18) {
        return { result: ElmExpr.Tuple2, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 19) {
        return { result: ElmExpr.Tuple3, nextIndex: patternIndex.nextIndex };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 関数の型
 * @typePartId 98904215e50e04fa2197a7a96df8f646
 */
export const FunctionType: {
  readonly codec: Codec<FunctionType>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: FunctionType) => FunctionType;
} = {
  helper: (functionType: FunctionType): FunctionType => functionType,
  codec: {
    encode: (value: FunctionType): ReadonlyArray<number> =>
      List.codec(TsIdentifer.codec)
        .encode(value.typeParameterList)
        .concat(List.codec(TsType.codec).encode(value.parameterList))
        .concat(TsType.codec.encode(value.return)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: FunctionType; readonly nextIndex: number } => {
      const typeParameterListAndNextIndex: {
        readonly result: List<TsIdentifer>;
        readonly nextIndex: number;
      } = List.codec(TsIdentifer.codec).decode(index, binary);
      const parameterListAndNextIndex: {
        readonly result: List<TsType>;
        readonly nextIndex: number;
      } = List.codec(TsType.codec).decode(
        typeParameterListAndNextIndex.nextIndex,
        binary
      );
      const returnAndNextIndex: {
        readonly result: TsType;
        readonly nextIndex: number;
      } = TsType.codec.decode(parameterListAndNextIndex.nextIndex, binary);
      return {
        result: {
          typeParameterList: typeParameterListAndNextIndex.result,
          parameterList: parameterListAndNextIndex.result,
          return: returnAndNextIndex.result,
        },
        nextIndex: returnAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * カスタム型. 代数的データ型
 * @typePartId a0cee28e982f5fbcae6b2c7bd1e27e2a
 */
export const ElmCustomType: {
  readonly codec: Codec<ElmCustomType>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ElmCustomType) => ElmCustomType;
} = {
  helper: (elmCustomType: ElmCustomType): ElmCustomType => elmCustomType,
  codec: {
    encode: (value: ElmCustomType): ReadonlyArray<number> =>
      ElmTypeName.codec
        .encode(value.name)
        .concat(ElmCustomTypeExportLevel.codec.encode(value.export))
        .concat(String.codec.encode(value.comment))
        .concat(List.codec(String.codec).encode(value.parameter))
        .concat(List.codec(ElmVariant.codec).encode(value.variantList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ElmCustomType; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: ElmTypeName;
        readonly nextIndex: number;
      } = ElmTypeName.codec.decode(index, binary);
      const exportAndNextIndex: {
        readonly result: ElmCustomTypeExportLevel;
        readonly nextIndex: number;
      } = ElmCustomTypeExportLevel.codec.decode(
        nameAndNextIndex.nextIndex,
        binary
      );
      const commentAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(exportAndNextIndex.nextIndex, binary);
      const parameterAndNextIndex: {
        readonly result: List<String>;
        readonly nextIndex: number;
      } = List.codec(String.codec).decode(
        commentAndNextIndex.nextIndex,
        binary
      );
      const variantListAndNextIndex: {
        readonly result: List<ElmVariant>;
        readonly nextIndex: number;
      } = List.codec(ElmVariant.codec).decode(
        parameterAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          name: nameAndNextIndex.result,
          export: exportAndNextIndex.result,
          comment: commentAndNextIndex.result,
          parameter: parameterAndNextIndex.result,
          variantList: variantListAndNextIndex.result,
        },
        nextIndex: variantListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 式と呼ぶパラメーター
 * @typePartId a1f71188b7c3ab2a21954471f3ac67f1
 */
export const CallExpr: {
  readonly codec: Codec<CallExpr>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: CallExpr) => CallExpr;
} = {
  helper: (callExpr: CallExpr): CallExpr => callExpr,
  codec: {
    encode: (value: CallExpr): ReadonlyArray<number> =>
      TsExpr.codec
        .encode(value.expr)
        .concat(List.codec(TsExpr.codec).encode(value.parameterList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: CallExpr; readonly nextIndex: number } => {
      const exprAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(index, binary);
      const parameterListAndNextIndex: {
        readonly result: List<TsExpr>;
        readonly nextIndex: number;
      } = List.codec(TsExpr.codec).decode(exprAndNextIndex.nextIndex, binary);
      return {
        result: {
          expr: exprAndNextIndex.result,
          parameterList: parameterListAndNextIndex.result,
        },
        nextIndex: parameterListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * @typePartId a2580a29c047f54d635c4456696bbef3
 */
export const Variable: {
  readonly codec: Codec<Variable>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: Variable) => Variable;
} = {
  helper: (variable: Variable): Variable => variable,
  codec: {
    encode: (value: Variable): ReadonlyArray<number> =>
      TsIdentifer.codec
        .encode(value.name)
        .concat(String.codec.encode(value.document))
        .concat(TsType.codec.encode(value.type))
        .concat(TsExpr.codec.encode(value.expr)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Variable; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: TsIdentifer;
        readonly nextIndex: number;
      } = TsIdentifer.codec.decode(index, binary);
      const documentAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
      const typeAndNextIndex: {
        readonly result: TsType;
        readonly nextIndex: number;
      } = TsType.codec.decode(documentAndNextIndex.nextIndex, binary);
      const exprAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(typeAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          document: documentAndNextIndex.result,
          type: typeAndNextIndex.result,
          expr: exprAndNextIndex.result,
        },
        nextIndex: exprAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * データを識別するIdとデータ
 * @typePartId a541cb9bb64930be40dc83bf8870f36b
 */
export const IdAndData: {
  readonly codec: <id extends unknown, data extends unknown>(
    a: Codec<id>,
    b: Codec<data>
  ) => Codec<IdAndData<id, data>>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: <id extends unknown, data extends unknown>(
    a: IdAndData<id, data>
  ) => IdAndData<id, data>;
} = {
  helper: <id extends unknown, data extends unknown>(
    idAndData: IdAndData<id, data>
  ): IdAndData<id, data> => idAndData,
  codec: <id extends unknown, data extends unknown>(
    idCodec: Codec<id>,
    dataCodec: Codec<data>
  ): Codec<IdAndData<id, data>> => ({
    encode: (value: IdAndData<id, data>): ReadonlyArray<number> =>
      idCodec.encode(value.id).concat(dataCodec.encode(value.data)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: IdAndData<id, data>; readonly nextIndex: number } => {
      const idAndNextIndex: {
        readonly result: id;
        readonly nextIndex: number;
      } = idCodec.decode(index, binary);
      const dataAndNextIndex: {
        readonly result: data;
        readonly nextIndex: number;
      } = dataCodec.decode(idAndNextIndex.nextIndex, binary);
      return {
        result: { id: idAndNextIndex.result, data: dataAndNextIndex.result },
        nextIndex: dataAndNextIndex.nextIndex,
      };
    },
  }),
};

/**
 * 複数の引数が必要な内部関数の部分呼び出し
 * @typePartId a8c830bd6b3473f2fac7a62ede58ecf0
 */
export const KernelCall: {
  readonly codec: Codec<KernelCall>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: KernelCall) => KernelCall;
} = {
  helper: (kernelCall: KernelCall): KernelCall => kernelCall,
  codec: {
    encode: (value: KernelCall): ReadonlyArray<number> =>
      KernelExpr.codec
        .encode(value.kernel)
        .concat(EvaluatedExpr.codec.encode(value.expr)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: KernelCall; readonly nextIndex: number } => {
      const kernelAndNextIndex: {
        readonly result: KernelExpr;
        readonly nextIndex: number;
      } = KernelExpr.codec.decode(index, binary);
      const exprAndNextIndex: {
        readonly result: EvaluatedExpr;
        readonly nextIndex: number;
      } = EvaluatedExpr.codec.decode(kernelAndNextIndex.nextIndex, binary);
      return {
        result: {
          kernel: kernelAndNextIndex.result,
          expr: exprAndNextIndex.result,
        },
        nextIndex: exprAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * プロパティアクセス
 * @typePartId a9ce526a22f09800aa3773a1614cce89
 */
export const GetExpr: {
  readonly codec: Codec<GetExpr>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: GetExpr) => GetExpr;
} = {
  helper: (getExpr: GetExpr): GetExpr => getExpr,
  codec: {
    encode: (value: GetExpr): ReadonlyArray<number> =>
      TsExpr.codec
        .encode(value.expr)
        .concat(TsExpr.codec.encode(value.propertyExpr)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: GetExpr; readonly nextIndex: number } => {
      const exprAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(index, binary);
      const propertyExprAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(exprAndNextIndex.nextIndex, binary);
      return {
        result: {
          expr: exprAndNextIndex.result,
          propertyExpr: propertyExprAndNextIndex.result,
        },
        nextIndex: propertyExprAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * Definy の 型. 式に対してつけるし, つく. 型パーツの定義にも使う
 * @typePartId b3b36f39469d23321ed01b92f048ccc0
 */
export const Type: {
  readonly codec: Codec<Type>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: Type) => Type;
} = {
  helper: (type_: Type): Type => type_,
  codec: {
    encode: (value: Type): ReadonlyArray<number> =>
      TypePartId.codec
        .encode(value.typePartId)
        .concat(List.codec(Type.codec).encode(value.parameter)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Type; readonly nextIndex: number } => {
      const typePartIdAndNextIndex: {
        readonly result: TypePartId;
        readonly nextIndex: number;
      } = TypePartId.codec.decode(index, binary);
      const parameterAndNextIndex: {
        readonly result: List<Type>;
        readonly nextIndex: number;
      } = List.codec(Type.codec).decode(
        typePartIdAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          typePartId: typePartIdAndNextIndex.result,
          parameter: parameterAndNextIndex.result,
        },
        nextIndex: parameterAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * インポートされた型
 * @typePartId b44289bc65640d4ad0ad79a5a627ef78
 */
export const ImportedType: {
  readonly codec: Codec<ImportedType>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ImportedType) => ImportedType;
} = {
  helper: (importedType: ImportedType): ImportedType => importedType,
  codec: {
    encode: (value: ImportedType): ReadonlyArray<number> =>
      String.codec
        .encode(value.moduleName)
        .concat(TsIdentifer.codec.encode(value.name)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ImportedType; readonly nextIndex: number } => {
      const moduleNameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const nameAndNextIndex: {
        readonly result: TsIdentifer;
        readonly nextIndex: number;
      } = TsIdentifer.codec.decode(moduleNameAndNextIndex.nextIndex, binary);
      return {
        result: {
          moduleName: moduleNameAndNextIndex.result,
          name: nameAndNextIndex.result,
        },
        nextIndex: nameAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * アカウントトークンのハッシュ値. データベースに保存する用
 * @typePartId b553ab17ca45f4975d9fe17fe1a63ac4
 */
export const AccountTokenHash: { readonly codec: Codec<AccountTokenHash> } = {
  codec: {
    encode: (value: AccountTokenHash): ReadonlyArray<number> =>
      encodeToken(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: AccountTokenHash; readonly nextIndex: number } =>
      decodeToken(index, binary) as {
        readonly result: AccountTokenHash;
        readonly nextIndex: number;
      },
  },
};

/**
 * Definyだけでは表現できない式
 * @typePartId b6eef263a982482747a8ad0bc9f05e21
 */
export const KernelExpr: {
  /**
   * 32bit整数を足す関数
   */
  readonly Int32Add: KernelExpr;
  /**
   * 32bit整数を引く関数
   */
  readonly Int32Sub: KernelExpr;
  /**
   * 32bit整数をかける関数
   */
  readonly Int32Mul: KernelExpr;
  readonly codec: Codec<KernelExpr>;
} = {
  Int32Add: "Int32Add",
  Int32Sub: "Int32Sub",
  Int32Mul: "Int32Mul",
  codec: {
    encode: (value: KernelExpr): ReadonlyArray<number> => {
      switch (value) {
        case "Int32Add": {
          return [0];
        }
        case "Int32Sub": {
          return [1];
        }
        case "Int32Mul": {
          return [2];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: KernelExpr; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: KernelExpr.Int32Add,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: KernelExpr.Int32Sub,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        return {
          result: KernelExpr.Int32Mul,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 型パーツのリストを保存, 変更する
 * @typePartId b8bf6c22e275c06c7dc42300c332b47d
 */
export const SetTypePartListParameter: {
  readonly codec: Codec<SetTypePartListParameter>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: SetTypePartListParameter) => SetTypePartListParameter;
} = {
  helper: (
    setTypePartListParameter: SetTypePartListParameter
  ): SetTypePartListParameter => setTypePartListParameter,
  codec: {
    encode: (value: SetTypePartListParameter): ReadonlyArray<number> =>
      AccountToken.codec
        .encode(value.accountToken)
        .concat(ProjectId.codec.encode(value.projectId))
        .concat(
          List.codec(IdAndData.codec(TypePartId.codec, TypePart.codec)).encode(
            value.typePartList
          )
        ),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: SetTypePartListParameter;
      readonly nextIndex: number;
    } => {
      const accountTokenAndNextIndex: {
        readonly result: AccountToken;
        readonly nextIndex: number;
      } = AccountToken.codec.decode(index, binary);
      const projectIdAndNextIndex: {
        readonly result: ProjectId;
        readonly nextIndex: number;
      } = ProjectId.codec.decode(accountTokenAndNextIndex.nextIndex, binary);
      const typePartListAndNextIndex: {
        readonly result: List<IdAndData<TypePartId, TypePart>>;
        readonly nextIndex: number;
      } = List.codec(IdAndData.codec(TypePartId.codec, TypePart.codec)).decode(
        projectIdAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          accountToken: accountTokenAndNextIndex.result,
          projectId: projectIdAndNextIndex.result,
          typePartList: typePartListAndNextIndex.result,
        },
        nextIndex: typePartListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * DefinyWebアプリ内での場所を示すもの. URLから求められる. URLに変換できる
 * @typePartId bbcb8e43df8afff9fe24b001c66fb065
 */
export const Location: {
  /**
   * 最初のページ
   */
  readonly Home: Location;
  /**
   * プロジェクト作成画面
   */
  readonly CreateProject: Location;
  /**
   * プロジェクトの詳細ページ
   */
  readonly Project: (a: ProjectId) => Location;
  /**
   * アカウント詳細ページ
   */
  readonly Account: (a: AccountId) => Location;
  /**
   * 設定ページ
   */
  readonly Setting: Location;
  /**
   * Definyについて説明したページ
   */
  readonly About: Location;
  /**
   * デバッグページ
   */
  readonly Debug: Location;
  /**
   * 型パーツ編集ページ
   */
  readonly TypePart: (a: TypePartId) => Location;
  readonly codec: Codec<Location>;
} = {
  Home: { _: "Home" },
  CreateProject: { _: "CreateProject" },
  Project: (projectId: ProjectId): Location => ({ _: "Project", projectId }),
  Account: (accountId: AccountId): Location => ({ _: "Account", accountId }),
  Setting: { _: "Setting" },
  About: { _: "About" },
  Debug: { _: "Debug" },
  TypePart: (typePartId: TypePartId): Location => ({
    _: "TypePart",
    typePartId,
  }),
  codec: {
    encode: (value: Location): ReadonlyArray<number> => {
      switch (value._) {
        case "Home": {
          return [0];
        }
        case "CreateProject": {
          return [1];
        }
        case "Project": {
          return [2].concat(ProjectId.codec.encode(value.projectId));
        }
        case "Account": {
          return [3].concat(AccountId.codec.encode(value.accountId));
        }
        case "Setting": {
          return [4];
        }
        case "About": {
          return [5];
        }
        case "Debug": {
          return [6];
        }
        case "TypePart": {
          return [7].concat(TypePartId.codec.encode(value.typePartId));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Location; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: Location.Home, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return {
          result: Location.CreateProject,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: ProjectId;
          readonly nextIndex: number;
        } = ProjectId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Location.Project(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        const result: {
          readonly result: AccountId;
          readonly nextIndex: number;
        } = AccountId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Location.Account(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 4) {
        return { result: Location.Setting, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 5) {
        return { result: Location.About, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 6) {
        return { result: Location.Debug, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 7) {
        const result: {
          readonly result: TypePartId;
          readonly nextIndex: number;
        } = TypePartId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Location.TypePart(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * TypeAlias. `export type T = {}`
 * @typePartId bf69f7e46f5e4949fe801c234fc3ad15
 */
export const TypeAlias: {
  readonly codec: Codec<TypeAlias>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: TypeAlias) => TypeAlias;
} = {
  helper: (typeAlias: TypeAlias): TypeAlias => typeAlias,
  codec: {
    encode: (value: TypeAlias): ReadonlyArray<number> =>
      TsIdentifer.codec
        .encode(value.name)
        .concat(List.codec(TsIdentifer.codec).encode(value.typeParameterList))
        .concat(String.codec.encode(value.document))
        .concat(TsType.codec.encode(value.type)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypeAlias; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: TsIdentifer;
        readonly nextIndex: number;
      } = TsIdentifer.codec.decode(index, binary);
      const typeParameterListAndNextIndex: {
        readonly result: List<TsIdentifer>;
        readonly nextIndex: number;
      } = List.codec(TsIdentifer.codec).decode(
        nameAndNextIndex.nextIndex,
        binary
      );
      const documentAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(typeParameterListAndNextIndex.nextIndex, binary);
      const typeAndNextIndex: {
        readonly result: TsType;
        readonly nextIndex: number;
      } = TsType.codec.decode(documentAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          typeParameterList: typeParameterListAndNextIndex.result,
          document: documentAndNextIndex.result,
          type: typeAndNextIndex.result,
        },
        nextIndex: typeAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * アカウントを識別するためのID
 * @typePartId c1a17b07e8e664ca80217833ff2ad3f1
 */
export const AccountId: { readonly codec: Codec<AccountId> } = {
  codec: {
    encode: (value: AccountId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: AccountId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: AccountId;
        readonly nextIndex: number;
      },
  },
};

/**
 * 文字列のkeyと式のvalue
 * @typePartId c2428cbcd62b33ce2c904a200b876863
 */
export const KeyValue: {
  readonly codec: Codec<KeyValue>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: KeyValue) => KeyValue;
} = {
  helper: (keyValue: KeyValue): KeyValue => keyValue,
  codec: {
    encode: (value: KeyValue): ReadonlyArray<number> =>
      String.codec.encode(value.key).concat(TsExpr.codec.encode(value.value)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: KeyValue; readonly nextIndex: number } => {
      const keyAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const valueAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(keyAndNextIndex.nextIndex, binary);
      return {
        result: {
          key: keyAndNextIndex.result,
          value: valueAndNextIndex.result,
        },
        nextIndex: valueAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * リスト. JavaScriptのArrayで扱う
 * @typePartId c3fc2a6cea61086db59e11dc2bef0eee
 */
export const List: {
  readonly codec: <element extends unknown>(
    a: Codec<element>
  ) => Codec<List<element>>;
} = {
  codec: <element extends unknown>(
    elementCodec: Codec<element>
  ): Codec<List<element>> => ({
    encode: (value: List<element>): ReadonlyArray<number> => {
      let result: Array<number> = Int32.codec.encode(
        value.length
      ) as Array<number>;
      for (const element of value) {
        result = result.concat(elementCodec.encode(element));
      }
      return result;
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: List<element>; readonly nextIndex: number } => {
      const lengthResult: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      let nextIndex: number = lengthResult.nextIndex;
      const result: Array<element> = [];
      for (let i = 0; i < lengthResult.result; i += 1) {
        const resultAndNextIndex: {
          readonly result: element;
          readonly nextIndex: number;
        } = elementCodec.decode(nextIndex, binary);
        result.push(resultAndNextIndex.result);
        nextIndex = resultAndNextIndex.nextIndex;
      }
      return { result, nextIndex };
    },
  }),
};

/**
 * definy.app の ログイン状態
 * @typePartId c4b574e3ca8bad17022054d5e77fd3d0
 */
export const LogInState: {
  /**
   * アカウントトークンをindexedDBから読み取っている状態
   */
  readonly LoadingAccountTokenFromIndexedDB: LogInState;
  /**
   * ログインしていない状態
   */
  readonly Guest: LogInState;
  /**
   * ログインへの画面URLをリクエストした状態
   */
  readonly RequestingLogInUrl: (a: OpenIdConnectProvider) => LogInState;
  /**
   * ログインURLを受け取り,ログイン画面へ移行中
   */
  readonly JumpingToLogInPage: (a: String) => LogInState;
  /**
   * アカウントトークンの検証とログインしているユーザーの情報を取得している状態
   */
  readonly VerifyingAccountToken: (a: AccountToken) => LogInState;
  /**
   * ログインしている状態
   */
  readonly LoggedIn: (a: AccountTokenAndUserId) => LogInState;
  readonly codec: Codec<LogInState>;
} = {
  LoadingAccountTokenFromIndexedDB: { _: "LoadingAccountTokenFromIndexedDB" },
  Guest: { _: "Guest" },
  RequestingLogInUrl: (
    openIdConnectProvider: OpenIdConnectProvider
  ): LogInState => ({ _: "RequestingLogInUrl", openIdConnectProvider }),
  JumpingToLogInPage: (string_: String): LogInState => ({
    _: "JumpingToLogInPage",
    string: string_,
  }),
  VerifyingAccountToken: (accountToken: AccountToken): LogInState => ({
    _: "VerifyingAccountToken",
    accountToken,
  }),
  LoggedIn: (accountTokenAndUserId: AccountTokenAndUserId): LogInState => ({
    _: "LoggedIn",
    accountTokenAndUserId,
  }),
  codec: {
    encode: (value: LogInState): ReadonlyArray<number> => {
      switch (value._) {
        case "LoadingAccountTokenFromIndexedDB": {
          return [0];
        }
        case "Guest": {
          return [1];
        }
        case "RequestingLogInUrl": {
          return [2].concat(
            OpenIdConnectProvider.codec.encode(value.openIdConnectProvider)
          );
        }
        case "JumpingToLogInPage": {
          return [3].concat(String.codec.encode(value.string));
        }
        case "VerifyingAccountToken": {
          return [4].concat(AccountToken.codec.encode(value.accountToken));
        }
        case "LoggedIn": {
          return [5].concat(
            AccountTokenAndUserId.codec.encode(value.accountTokenAndUserId)
          );
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: LogInState; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: LogInState.LoadingAccountTokenFromIndexedDB,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return { result: LogInState.Guest, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: OpenIdConnectProvider;
          readonly nextIndex: number;
        } = OpenIdConnectProvider.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: LogInState.RequestingLogInUrl(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        const result: {
          readonly result: String;
          readonly nextIndex: number;
        } = String.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: LogInState.JumpingToLogInPage(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 4) {
        const result: {
          readonly result: AccountToken;
          readonly nextIndex: number;
        } = AccountToken.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: LogInState.VerifyingAccountToken(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 5) {
        const result: {
          readonly result: AccountTokenAndUserId;
          readonly nextIndex: number;
        } = AccountTokenAndUserId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: LogInState.LoggedIn(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * for文
 * @typePartId c53be8bcaf56ff90080cf7a75f1e4815
 */
export const ForStatement: {
  readonly codec: Codec<ForStatement>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ForStatement) => ForStatement;
} = {
  helper: (forStatement: ForStatement): ForStatement => forStatement,
  codec: {
    encode: (value: ForStatement): ReadonlyArray<number> =>
      TsIdentifer.codec
        .encode(value.counterVariableName)
        .concat(TsExpr.codec.encode(value.untilExpr))
        .concat(List.codec(Statement.codec).encode(value.statementList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ForStatement; readonly nextIndex: number } => {
      const counterVariableNameAndNextIndex: {
        readonly result: TsIdentifer;
        readonly nextIndex: number;
      } = TsIdentifer.codec.decode(index, binary);
      const untilExprAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(
        counterVariableNameAndNextIndex.nextIndex,
        binary
      );
      const statementListAndNextIndex: {
        readonly result: List<Statement>;
        readonly nextIndex: number;
      } = List.codec(Statement.codec).decode(
        untilExprAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          counterVariableName: counterVariableNameAndNextIndex.result,
          untilExpr: untilExprAndNextIndex.result,
          statementList: statementListAndNextIndex.result,
        },
        nextIndex: statementListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * オブジェクトのメンバーの型
 * @typePartId c68bac5afb1a1d35af096bf317d09339
 */
export const TsMemberType: {
  readonly codec: Codec<TsMemberType>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: TsMemberType) => TsMemberType;
} = {
  helper: (tsMemberType: TsMemberType): TsMemberType => tsMemberType,
  codec: {
    encode: (value: TsMemberType): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(Bool.codec.encode(value.required))
        .concat(TsType.codec.encode(value.type))
        .concat(String.codec.encode(value.document)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TsMemberType; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const requiredAndNextIndex: {
        readonly result: Bool;
        readonly nextIndex: number;
      } = Bool.codec.decode(nameAndNextIndex.nextIndex, binary);
      const typeAndNextIndex: {
        readonly result: TsType;
        readonly nextIndex: number;
      } = TsType.codec.decode(requiredAndNextIndex.nextIndex, binary);
      const documentAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(typeAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          required: requiredAndNextIndex.result,
          type: typeAndNextIndex.result,
          document: documentAndNextIndex.result,
        },
        nextIndex: documentAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 条件演算子
 * @typePartId c7a771f770f0f92690faeb59eaff6268
 */
export const ConditionalOperatorExpr: {
  readonly codec: Codec<ConditionalOperatorExpr>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ConditionalOperatorExpr) => ConditionalOperatorExpr;
} = {
  helper: (
    conditionalOperatorExpr: ConditionalOperatorExpr
  ): ConditionalOperatorExpr => conditionalOperatorExpr,
  codec: {
    encode: (value: ConditionalOperatorExpr): ReadonlyArray<number> =>
      TsExpr.codec
        .encode(value.condition)
        .concat(TsExpr.codec.encode(value.thenExpr))
        .concat(TsExpr.codec.encode(value.elseExpr)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: ConditionalOperatorExpr;
      readonly nextIndex: number;
    } => {
      const conditionAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(index, binary);
      const thenExprAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(conditionAndNextIndex.nextIndex, binary);
      const elseExprAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(thenExprAndNextIndex.nextIndex, binary);
      return {
        result: {
          condition: conditionAndNextIndex.result,
          thenExpr: thenExprAndNextIndex.result,
          elseExpr: elseExprAndNextIndex.result,
        },
        nextIndex: elseExprAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * if文
 * @typePartId cd325760f992e47a8438ae78ca9b1529
 */
export const IfStatement: {
  readonly codec: Codec<IfStatement>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: IfStatement) => IfStatement;
} = {
  helper: (ifStatement: IfStatement): IfStatement => ifStatement,
  codec: {
    encode: (value: IfStatement): ReadonlyArray<number> =>
      TsExpr.codec
        .encode(value.condition)
        .concat(List.codec(Statement.codec).encode(value.thenStatementList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: IfStatement; readonly nextIndex: number } => {
      const conditionAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(index, binary);
      const thenStatementListAndNextIndex: {
        readonly result: List<Statement>;
        readonly nextIndex: number;
      } = List.codec(Statement.codec).decode(
        conditionAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          condition: conditionAndNextIndex.result,
          thenStatementList: thenStatementListAndNextIndex.result,
        },
        nextIndex: thenStatementListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * フィールド名
 * @typePartId d256109676f834b74931495891b61d1b
 */
export const ElmFieldName: {
  /**
   * **直接 FieldName.FieldName("name") と指定してはいけない!! Elmの識別子として使える文字としてチェックできないため**
   */
  readonly FieldName: (a: String) => ElmFieldName;
  readonly codec: Codec<ElmFieldName>;
} = {
  FieldName: (string_: String): ElmFieldName => ({
    _: "FieldName",
    string: string_,
  }),
  codec: {
    encode: (value: ElmFieldName): ReadonlyArray<number> => {
      switch (value._) {
        case "FieldName": {
          return [0].concat(String.codec.encode(value.string));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ElmFieldName; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: String;
          readonly nextIndex: number;
        } = String.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ElmFieldName.FieldName(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * バリアント名
 * @typePartId d77f1f967b892c739a1555f74d2ff9fd
 */
export const ElmVariantName: {
  /**
   * **直接 VariantName.VariantName("Loading") と指定してはいけない!! Elmの識別子として使える文字としてチェックできないため**
   */
  readonly VariantName: (a: String) => ElmVariantName;
  readonly codec: Codec<ElmVariantName>;
} = {
  VariantName: (string_: String): ElmVariantName => ({
    _: "VariantName",
    string: string_,
  }),
  codec: {
    encode: (value: ElmVariantName): ReadonlyArray<number> => {
      switch (value._) {
        case "VariantName": {
          return [0].concat(String.codec.encode(value.string));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ElmVariantName; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: String;
          readonly nextIndex: number;
        } = String.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ElmVariantName.VariantName(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 交差型
 * @typePartId d82150857d0f2e78c1df0f418ba9b01a
 */
export const IntersectionType: {
  readonly codec: Codec<IntersectionType>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: IntersectionType) => IntersectionType;
} = {
  helper: (intersectionType: IntersectionType): IntersectionType =>
    intersectionType,
  codec: {
    encode: (value: IntersectionType): ReadonlyArray<number> =>
      TsType.codec.encode(value.left).concat(TsType.codec.encode(value.right)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: IntersectionType; readonly nextIndex: number } => {
      const leftAndNextIndex: {
        readonly result: TsType;
        readonly nextIndex: number;
      } = TsType.codec.decode(index, binary);
      const rightAndNextIndex: {
        readonly result: TsType;
        readonly nextIndex: number;
      } = TsType.codec.decode(leftAndNextIndex.nextIndex, binary);
      return {
        result: {
          left: leftAndNextIndex.result,
          right: rightAndNextIndex.result,
        },
        nextIndex: rightAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * パーツの定義. 他のプログラミング言語でいう関数や, 変数のこと
 * @typePartId d8bccc70252cee9ce70784bf5dfa493b
 */
export const Part: {
  readonly codec: Codec<Part>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: Part) => Part;
} = {
  helper: (part: Part): Part => part,
  codec: {
    encode: (value: Part): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(String.codec.encode(value.description))
        .concat(Type.codec.encode(value.type))
        .concat(Expr.codec.encode(value.expr))
        .concat(ProjectId.codec.encode(value.projectId)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Part; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const descriptionAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
      const typeAndNextIndex: {
        readonly result: Type;
        readonly nextIndex: number;
      } = Type.codec.decode(descriptionAndNextIndex.nextIndex, binary);
      const exprAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(typeAndNextIndex.nextIndex, binary);
      const projectIdAndNextIndex: {
        readonly result: ProjectId;
        readonly nextIndex: number;
      } = ProjectId.codec.decode(exprAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          description: descriptionAndNextIndex.result,
          type: typeAndNextIndex.result,
          expr: exprAndNextIndex.result,
          projectId: projectIdAndNextIndex.result,
        },
        nextIndex: projectIdAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * Definyの評価しきった式
 * @typePartId daa9bf22c3f2e52ff92edcdd896d6a6d
 */
export const EvaluatedExpr: {
  /**
   * Definyだけでは表現できない式
   */
  readonly Kernel: (a: KernelExpr) => EvaluatedExpr;
  /**
   * 32bit整数
   */
  readonly Int32: (a: Int32) => EvaluatedExpr;
  /**
   * タグを参照
   */
  readonly TagReference: (a: TagReference) => EvaluatedExpr;
  /**
   * 内部関数呼び出し
   */
  readonly KernelCall: (a: KernelCall) => EvaluatedExpr;
  readonly codec: Codec<EvaluatedExpr>;
} = {
  Kernel: (kernelExpr: KernelExpr): EvaluatedExpr => ({
    _: "Kernel",
    kernelExpr,
  }),
  Int32: (int32: Int32): EvaluatedExpr => ({ _: "Int32", int32 }),
  TagReference: (tagReference: TagReference): EvaluatedExpr => ({
    _: "TagReference",
    tagReference,
  }),
  KernelCall: (kernelCall: KernelCall): EvaluatedExpr => ({
    _: "KernelCall",
    kernelCall,
  }),
  codec: {
    encode: (value: EvaluatedExpr): ReadonlyArray<number> => {
      switch (value._) {
        case "Kernel": {
          return [0].concat(KernelExpr.codec.encode(value.kernelExpr));
        }
        case "Int32": {
          return [1].concat(Int32.codec.encode(value.int32));
        }
        case "TagReference": {
          return [2].concat(TagReference.codec.encode(value.tagReference));
        }
        case "KernelCall": {
          return [3].concat(KernelCall.codec.encode(value.kernelCall));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: EvaluatedExpr; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: KernelExpr;
          readonly nextIndex: number;
        } = KernelExpr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: EvaluatedExpr.Kernel(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: Int32;
          readonly nextIndex: number;
        } = Int32.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: EvaluatedExpr.Int32(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: TagReference;
          readonly nextIndex: number;
        } = TagReference.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: EvaluatedExpr.TagReference(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        const result: {
          readonly result: KernelCall;
          readonly nextIndex: number;
        } = KernelCall.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: EvaluatedExpr.KernelCall(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 1つの型パーツを保存するために指定するパラメーター
 * @typePartId dac038758a5c45f762de388bb5193fb8
 */
export const SetTypePartParameter: {
  readonly codec: Codec<SetTypePartParameter>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: SetTypePartParameter) => SetTypePartParameter;
} = {
  helper: (setTypePartParameter: SetTypePartParameter): SetTypePartParameter =>
    setTypePartParameter,
  codec: {
    encode: (value: SetTypePartParameter): ReadonlyArray<number> =>
      AccountToken.codec
        .encode(value.accountToken)
        .concat(TypePartId.codec.encode(value.typePartId))
        .concat(TypePart.codec.encode(value.typePart)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: SetTypePartParameter;
      readonly nextIndex: number;
    } => {
      const accountTokenAndNextIndex: {
        readonly result: AccountToken;
        readonly nextIndex: number;
      } = AccountToken.codec.decode(index, binary);
      const typePartIdAndNextIndex: {
        readonly result: TypePartId;
        readonly nextIndex: number;
      } = TypePartId.codec.decode(accountTokenAndNextIndex.nextIndex, binary);
      const typePartAndNextIndex: {
        readonly result: TypePart;
        readonly nextIndex: number;
      } = TypePart.codec.decode(typePartIdAndNextIndex.nextIndex, binary);
      return {
        result: {
          accountToken: accountTokenAndNextIndex.result,
          typePartId: typePartIdAndNextIndex.result,
          typePart: typePartAndNextIndex.result,
        },
        nextIndex: typePartAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * Bool. 真か偽. JavaScriptのbooleanで扱える. true: 1, false: 0. (1byte)としてバイナリに変換する
 * @typePartId db57caf129f60db969b5b5224a72b937
 */
export const Bool: {
  /**
   * 偽
   */
  readonly False: Bool;
  /**
   * 真
   */
  readonly True: Bool;
  readonly codec: Codec<Bool>;
} = {
  False: false,
  True: true,
  codec: {
    encode: (value: Bool): ReadonlyArray<number> => [value ? 1 : 0],
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Bool; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: Bool.False, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return { result: Bool.True, nextIndex: patternIndex.nextIndex };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * Elmの関数の定義. 引数がない関数(定数)も含まれる
 * @typePartId db8b9f83d99ef58fd206acca4e56d098
 */
export const ElmDefinition: {
  readonly codec: Codec<ElmDefinition>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ElmDefinition) => ElmDefinition;
} = {
  helper: (elmDefinition: ElmDefinition): ElmDefinition => elmDefinition,
  codec: {
    encode: (value: ElmDefinition): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(ElmType.codec.encode(value.type))
        .concat(ElmType.codec.encode(value.expr))
        .concat(String.codec.encode(value.comment)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ElmDefinition; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const typeAndNextIndex: {
        readonly result: ElmType;
        readonly nextIndex: number;
      } = ElmType.codec.decode(nameAndNextIndex.nextIndex, binary);
      const exprAndNextIndex: {
        readonly result: ElmType;
        readonly nextIndex: number;
      } = ElmType.codec.decode(typeAndNextIndex.nextIndex, binary);
      const commentAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(exprAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          type: typeAndNextIndex.result,
          expr: exprAndNextIndex.result,
          comment: commentAndNextIndex.result,
        },
        nextIndex: commentAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 外部に公開する関数
 * @typePartId dd3366ce7254327c85732d2932ff219b
 */
export const Function: {
  readonly codec: Codec<Function>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: Function) => Function;
} = {
  helper: (function_: Function): Function => function_,
  codec: {
    encode: (value: Function): ReadonlyArray<number> =>
      TsIdentifer.codec
        .encode(value.name)
        .concat(String.codec.encode(value.document))
        .concat(List.codec(TsIdentifer.codec).encode(value.typeParameterList))
        .concat(
          List.codec(ParameterWithDocument.codec).encode(value.parameterList)
        )
        .concat(TsType.codec.encode(value.returnType))
        .concat(List.codec(Statement.codec).encode(value.statementList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Function; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: TsIdentifer;
        readonly nextIndex: number;
      } = TsIdentifer.codec.decode(index, binary);
      const documentAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
      const typeParameterListAndNextIndex: {
        readonly result: List<TsIdentifer>;
        readonly nextIndex: number;
      } = List.codec(TsIdentifer.codec).decode(
        documentAndNextIndex.nextIndex,
        binary
      );
      const parameterListAndNextIndex: {
        readonly result: List<ParameterWithDocument>;
        readonly nextIndex: number;
      } = List.codec(ParameterWithDocument.codec).decode(
        typeParameterListAndNextIndex.nextIndex,
        binary
      );
      const returnTypeAndNextIndex: {
        readonly result: TsType;
        readonly nextIndex: number;
      } = TsType.codec.decode(parameterListAndNextIndex.nextIndex, binary);
      const statementListAndNextIndex: {
        readonly result: List<Statement>;
        readonly nextIndex: number;
      } = List.codec(Statement.codec).decode(
        returnTypeAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          name: nameAndNextIndex.result,
          document: documentAndNextIndex.result,
          typeParameterList: typeParameterListAndNextIndex.result,
          parameterList: parameterListAndNextIndex.result,
          returnType: returnTypeAndNextIndex.result,
          statementList: statementListAndNextIndex.result,
        },
        nextIndex: statementListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * アカウントトークン. アカウントトークンを持っていればアクセストークンをDefinyのサーバーにリクエストした際に得られるIDのアカウントを保有していると証明できる. サーバーにハッシュ化したものを保存している. これが盗まれた場合,不正に得た人はアカウントを乗っ取ることができる. 有効期限はなし, 最後に発行したアカウントトークン以外は無効になる
 * @typePartId deb01f82879754c03aa4d244e136e59d
 */
export const AccountToken: { readonly codec: Codec<AccountToken> } = {
  codec: {
    encode: (value: AccountToken): ReadonlyArray<number> => encodeToken(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: AccountToken; readonly nextIndex: number } =>
      decodeToken(index, binary) as {
        readonly result: AccountToken;
        readonly nextIndex: number;
      },
  },
};

/**
 * ローカル関数定義
 * @typePartId df5c5388248252a92864ceb219628b8e
 */
export const FunctionDefinitionStatement: {
  readonly codec: Codec<FunctionDefinitionStatement>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (
    a: FunctionDefinitionStatement
  ) => FunctionDefinitionStatement;
} = {
  helper: (
    functionDefinitionStatement: FunctionDefinitionStatement
  ): FunctionDefinitionStatement => functionDefinitionStatement,
  codec: {
    encode: (value: FunctionDefinitionStatement): ReadonlyArray<number> =>
      TsIdentifer.codec
        .encode(value.name)
        .concat(List.codec(TsIdentifer.codec).encode(value.typeParameterList))
        .concat(
          List.codec(ParameterWithDocument.codec).encode(value.parameterList)
        )
        .concat(TsType.codec.encode(value.returnType))
        .concat(List.codec(Statement.codec).encode(value.statementList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: FunctionDefinitionStatement;
      readonly nextIndex: number;
    } => {
      const nameAndNextIndex: {
        readonly result: TsIdentifer;
        readonly nextIndex: number;
      } = TsIdentifer.codec.decode(index, binary);
      const typeParameterListAndNextIndex: {
        readonly result: List<TsIdentifer>;
        readonly nextIndex: number;
      } = List.codec(TsIdentifer.codec).decode(
        nameAndNextIndex.nextIndex,
        binary
      );
      const parameterListAndNextIndex: {
        readonly result: List<ParameterWithDocument>;
        readonly nextIndex: number;
      } = List.codec(ParameterWithDocument.codec).decode(
        typeParameterListAndNextIndex.nextIndex,
        binary
      );
      const returnTypeAndNextIndex: {
        readonly result: TsType;
        readonly nextIndex: number;
      } = TsType.codec.decode(parameterListAndNextIndex.nextIndex, binary);
      const statementListAndNextIndex: {
        readonly result: List<Statement>;
        readonly nextIndex: number;
      } = List.codec(Statement.codec).decode(
        returnTypeAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          name: nameAndNextIndex.result,
          typeParameterList: typeParameterListAndNextIndex.result,
          parameterList: parameterListAndNextIndex.result,
          returnType: returnTypeAndNextIndex.result,
          statementList: statementListAndNextIndex.result,
        },
        nextIndex: statementListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 直積型のパターン
 * @typePartId e4ef8a0713aceb0eaa7606cd516ad847
 */
export const Pattern: {
  readonly codec: Codec<Pattern>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: Pattern) => Pattern;
} = {
  helper: (pattern: Pattern): Pattern => pattern,
  codec: {
    encode: (value: Pattern): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(String.codec.encode(value.description))
        .concat(Maybe.codec(Type.codec).encode(value.parameter)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Pattern; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const descriptionAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
      const parameterAndNextIndex: {
        readonly result: Maybe<Type>;
        readonly nextIndex: number;
      } = Maybe.codec(Type.codec).decode(
        descriptionAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          name: nameAndNextIndex.result,
          description: descriptionAndNextIndex.result,
          parameter: parameterAndNextIndex.result,
        },
        nextIndex: parameterAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 画像から求められるトークン.キャッシュのキーとして使われる.1つのトークンに対して永久に1つの画像データしか表さない. キャッシュを更新する必要はない
 * @typePartId e71e15a15b0883940a75e58367151d1a
 */
export const ImageHash: { readonly codec: Codec<ImageHash> } = {
  codec: {
    encode: (value: ImageHash): ReadonlyArray<number> => encodeToken(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ImageHash; readonly nextIndex: number } =>
      decodeToken(index, binary) as {
        readonly result: ImageHash;
        readonly nextIndex: number;
      },
  },
};

/**
 * Definy の 式
 * @typePartId ed9a046b5f121f6e54ac7f3834cbc644
 */
export const Expr: {
  /**
   * Definyだけでは表現できない式
   */
  readonly Kernel: (a: KernelExpr) => Expr;
  /**
   * 32bit整数
   */
  readonly Int32Literal: (a: Int32) => Expr;
  /**
   * パーツの値を参照
   */
  readonly PartReference: (a: PartId) => Expr;
  /**
   * タグを参照
   */
  readonly TagReference: (a: TagReference) => Expr;
  /**
   * 関数呼び出し
   */
  readonly FunctionCall: (a: FunctionCall) => Expr;
  readonly codec: Codec<Expr>;
} = {
  Kernel: (kernelExpr: KernelExpr): Expr => ({ _: "Kernel", kernelExpr }),
  Int32Literal: (int32: Int32): Expr => ({ _: "Int32Literal", int32 }),
  PartReference: (partId: PartId): Expr => ({ _: "PartReference", partId }),
  TagReference: (tagReference: TagReference): Expr => ({
    _: "TagReference",
    tagReference,
  }),
  FunctionCall: (functionCall: FunctionCall): Expr => ({
    _: "FunctionCall",
    functionCall,
  }),
  codec: {
    encode: (value: Expr): ReadonlyArray<number> => {
      switch (value._) {
        case "Kernel": {
          return [0].concat(KernelExpr.codec.encode(value.kernelExpr));
        }
        case "Int32Literal": {
          return [1].concat(Int32.codec.encode(value.int32));
        }
        case "PartReference": {
          return [2].concat(PartId.codec.encode(value.partId));
        }
        case "TagReference": {
          return [3].concat(TagReference.codec.encode(value.tagReference));
        }
        case "FunctionCall": {
          return [4].concat(FunctionCall.codec.encode(value.functionCall));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Expr; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: KernelExpr;
          readonly nextIndex: number;
        } = KernelExpr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.Kernel(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: Int32;
          readonly nextIndex: number;
        } = Int32.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.Int32Literal(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: PartId;
          readonly nextIndex: number;
        } = PartId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.PartReference(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        const result: {
          readonly result: TagReference;
          readonly nextIndex: number;
        } = TagReference.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.TagReference(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 4) {
        const result: {
          readonly result: FunctionCall;
          readonly nextIndex: number;
        } = FunctionCall.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.FunctionCall(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * タグの参照を表す
 * @typePartId edd59bd2ab4852c149f6ce5917767908
 */
export const TagReference: {
  readonly codec: Codec<TagReference>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: TagReference) => TagReference;
} = {
  helper: (tagReference: TagReference): TagReference => tagReference,
  codec: {
    encode: (value: TagReference): ReadonlyArray<number> =>
      TypePartId.codec
        .encode(value.typePartId)
        .concat(TagId.codec.encode(value.tagId)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TagReference; readonly nextIndex: number } => {
      const typePartIdAndNextIndex: {
        readonly result: TypePartId;
        readonly nextIndex: number;
      } = TypePartId.codec.decode(index, binary);
      const tagIdAndNextIndex: {
        readonly result: TagId;
        readonly nextIndex: number;
      } = TagId.codec.decode(typePartIdAndNextIndex.nextIndex, binary);
      return {
        result: {
          typePartId: typePartIdAndNextIndex.result,
          tagId: tagIdAndNextIndex.result,
        },
        nextIndex: tagIdAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * definy.app を開発する上での動作モード. デベロップモード(http://localhost:2520)か, リリースモード(https://definy.app)
 * @typePartId ee0590e764618611ffa8e1a0a2e22f79
 */
export const Mode: {
  /**
   * ローカルで開発するときのモード. オリジンは http://localshot:2520
   */
  readonly Develop: Mode;
  /**
   * リリースモード. オリジンは https://definy.app
   */
  readonly Release: Mode;
  readonly codec: Codec<Mode>;
} = {
  Develop: "Develop",
  Release: "Release",
  codec: {
    encode: (value: Mode): ReadonlyArray<number> => {
      switch (value) {
        case "Develop": {
          return [0];
        }
        case "Release": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Mode; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: Mode.Develop, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return { result: Mode.Release, nextIndex: patternIndex.nextIndex };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 2項演算子と左右の式
 * @typePartId eec2dab74fbcd3237bfa1c773f9b9d21
 */
export const BinaryOperatorExpr: {
  readonly codec: Codec<BinaryOperatorExpr>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: BinaryOperatorExpr) => BinaryOperatorExpr;
} = {
  helper: (binaryOperatorExpr: BinaryOperatorExpr): BinaryOperatorExpr =>
    binaryOperatorExpr,
  codec: {
    encode: (value: BinaryOperatorExpr): ReadonlyArray<number> =>
      BinaryOperator.codec
        .encode(value.operator)
        .concat(TsExpr.codec.encode(value.left))
        .concat(TsExpr.codec.encode(value.right)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: BinaryOperatorExpr; readonly nextIndex: number } => {
      const operatorAndNextIndex: {
        readonly result: BinaryOperator;
        readonly nextIndex: number;
      } = BinaryOperator.codec.decode(index, binary);
      const leftAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(operatorAndNextIndex.nextIndex, binary);
      const rightAndNextIndex: {
        readonly result: TsExpr;
        readonly nextIndex: number;
      } = TsExpr.codec.decode(leftAndNextIndex.nextIndex, binary);
      return {
        result: {
          operator: operatorAndNextIndex.result,
          left: leftAndNextIndex.result,
          right: rightAndNextIndex.result,
        },
        nextIndex: rightAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 出力するコードの種類
 * @typePartId eedf73c97f9dd61159572322f6d7e0a5
 */
export const CodeType: {
  /**
   * JavaScript
   */
  readonly JavaScript: CodeType;
  /**
   * TypeScript
   */
  readonly TypeScript: CodeType;
  readonly codec: Codec<CodeType>;
} = {
  JavaScript: "JavaScript",
  TypeScript: "TypeScript",
  codec: {
    encode: (value: CodeType): ReadonlyArray<number> => {
      switch (value) {
        case "JavaScript": {
          return [0];
        }
        case "TypeScript": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: CodeType; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: CodeType.JavaScript,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: CodeType.TypeScript,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * ラムダ式
 * @typePartId eeeef818144e5a42460c4efdaa221460
 */
export const LambdaExpr: {
  readonly codec: Codec<LambdaExpr>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: LambdaExpr) => LambdaExpr;
} = {
  helper: (lambdaExpr: LambdaExpr): LambdaExpr => lambdaExpr,
  codec: {
    encode: (value: LambdaExpr): ReadonlyArray<number> =>
      List.codec(Parameter.codec)
        .encode(value.parameterList)
        .concat(List.codec(TsIdentifer.codec).encode(value.typeParameterList))
        .concat(TsType.codec.encode(value.returnType))
        .concat(List.codec(Statement.codec).encode(value.statementList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: LambdaExpr; readonly nextIndex: number } => {
      const parameterListAndNextIndex: {
        readonly result: List<Parameter>;
        readonly nextIndex: number;
      } = List.codec(Parameter.codec).decode(index, binary);
      const typeParameterListAndNextIndex: {
        readonly result: List<TsIdentifer>;
        readonly nextIndex: number;
      } = List.codec(TsIdentifer.codec).decode(
        parameterListAndNextIndex.nextIndex,
        binary
      );
      const returnTypeAndNextIndex: {
        readonly result: TsType;
        readonly nextIndex: number;
      } = TsType.codec.decode(typeParameterListAndNextIndex.nextIndex, binary);
      const statementListAndNextIndex: {
        readonly result: List<Statement>;
        readonly nextIndex: number;
      } = List.codec(Statement.codec).decode(
        returnTypeAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          parameterList: parameterListAndNextIndex.result,
          typeParameterList: typeParameterListAndNextIndex.result,
          returnType: returnTypeAndNextIndex.result,
          statementList: statementListAndNextIndex.result,
        },
        nextIndex: statementListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * ログインのURLを発行するために必要なデータ
 * @typePartId f03ea5331c1a3adcde80a04054d35e07
 */
export const RequestLogInUrlRequestData: {
  readonly codec: Codec<RequestLogInUrlRequestData>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (
    a: RequestLogInUrlRequestData
  ) => RequestLogInUrlRequestData;
} = {
  helper: (
    requestLogInUrlRequestData: RequestLogInUrlRequestData
  ): RequestLogInUrlRequestData => requestLogInUrlRequestData,
  codec: {
    encode: (value: RequestLogInUrlRequestData): ReadonlyArray<number> =>
      OpenIdConnectProvider.codec
        .encode(value.openIdConnectProvider)
        .concat(UrlData.codec.encode(value.urlData)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: RequestLogInUrlRequestData;
      readonly nextIndex: number;
    } => {
      const openIdConnectProviderAndNextIndex: {
        readonly result: OpenIdConnectProvider;
        readonly nextIndex: number;
      } = OpenIdConnectProvider.codec.decode(index, binary);
      const urlDataAndNextIndex: {
        readonly result: UrlData;
        readonly nextIndex: number;
      } = UrlData.codec.decode(
        openIdConnectProviderAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          openIdConnectProvider: openIdConnectProviderAndNextIndex.result,
          urlData: urlDataAndNextIndex.result,
        },
        nextIndex: urlDataAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * Elmの型定義
 * @typePartId f4bed793b657b39db5a579c9e158eba5
 */
export const ElmTypeDeclaration: {
  /**
   * 型エイリアス. レコード型に名前を付ける
   */
  readonly TypeAlias: (a: ElmTypeAlias) => ElmTypeDeclaration;
  /**
   * カスタム型. 代数的データ型
   */
  readonly CustomType: (a: ElmCustomType) => ElmTypeDeclaration;
  readonly codec: Codec<ElmTypeDeclaration>;
} = {
  TypeAlias: (elmTypeAlias: ElmTypeAlias): ElmTypeDeclaration => ({
    _: "TypeAlias",
    elmTypeAlias,
  }),
  CustomType: (elmCustomType: ElmCustomType): ElmTypeDeclaration => ({
    _: "CustomType",
    elmCustomType,
  }),
  codec: {
    encode: (value: ElmTypeDeclaration): ReadonlyArray<number> => {
      switch (value._) {
        case "TypeAlias": {
          return [0].concat(ElmTypeAlias.codec.encode(value.elmTypeAlias));
        }
        case "CustomType": {
          return [1].concat(ElmCustomType.codec.encode(value.elmCustomType));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ElmTypeDeclaration; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: ElmTypeAlias;
          readonly nextIndex: number;
        } = ElmTypeAlias.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ElmTypeDeclaration.TypeAlias(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: ElmCustomType;
          readonly nextIndex: number;
        } = ElmCustomType.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ElmTypeDeclaration.CustomType(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * JavaScriptのオブジェクトリテラルの要素
 * @typePartId fddd2a65994fae205dd636f3a6b9f1ea
 */
export const TsMember: {
  /**
   * ...a のようにする
   */
  readonly Spread: (a: TsExpr) => TsMember;
  /**
   * a: b のようにする
   */
  readonly KeyValue: (a: KeyValue) => TsMember;
  readonly codec: Codec<TsMember>;
} = {
  Spread: (tsExpr: TsExpr): TsMember => ({ _: "Spread", tsExpr }),
  KeyValue: (keyValue: KeyValue): TsMember => ({ _: "KeyValue", keyValue }),
  codec: {
    encode: (value: TsMember): ReadonlyArray<number> => {
      switch (value._) {
        case "Spread": {
          return [0].concat(TsExpr.codec.encode(value.tsExpr));
        }
        case "KeyValue": {
          return [1].concat(KeyValue.codec.encode(value.keyValue));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TsMember; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: TsExpr;
          readonly nextIndex: number;
        } = TsExpr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsMember.Spread(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: KeyValue;
          readonly nextIndex: number;
        } = KeyValue.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: TsMember.KeyValue(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};
