{"clientJavaScript":"(() => {\n  var __defProp = Object.defineProperty;\n  var __export = (target, all) => {\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n\n  // ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/hono@4.7.11/node_modules/hono/dist/jsx/dom/intrinsic-element/components.js\n  var components_exports2 = {};\n  __export(components_exports2, {\n    button: () => button,\n    clearCache: () => clearCache,\n    composeRef: () => composeRef,\n    form: () => form,\n    input: () => input,\n    link: () => link,\n    meta: () => meta,\n    script: () => script,\n    style: () => style,\n    title: () => title\n  });\n\n  // ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/hono@4.7.11/node_modules/hono/dist/utils/html.js\n  var HtmlEscapedCallbackPhase = {\n    Stringify: 1,\n    BeforeStream: 2,\n    Stream: 3\n  };\n  var raw = (value, callbacks) => {\n    const escapedString = new String(value);\n    escapedString.isEscaped = true;\n    escapedString.callbacks = callbacks;\n    return escapedString;\n  };\n  var resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {\n    if (typeof str === \"object\" && !(str instanceof String)) {\n      if (!(str instanceof Promise)) {\n        str = str.toString();\n      }\n      if (str instanceof Promise) {\n        str = await str;\n      }\n    }\n    const callbacks = str.callbacks;\n    if (!callbacks?.length) {\n      return Promise.resolve(str);\n    }\n    if (buffer) {\n      buffer[0] += str;\n    } else {\n      buffer = [str];\n    }\n    const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then(\n      (res) => Promise.all(\n        res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))\n      ).then(() => buffer[0])\n    );\n    if (preserveCallbacks) {\n      return raw(await resStr, callbacks);\n    } else {\n      return resStr;\n    }\n  };\n\n  // ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/hono@4.7.11/node_modules/hono/dist/jsx/constants.js\n  var DOM_RENDERER = Symbol(\"RENDERER\");\n  var DOM_ERROR_HANDLER = Symbol(\"ERROR_HANDLER\");\n  var DOM_STASH = Symbol(\"STASH\");\n  var DOM_INTERNAL_TAG = Symbol(\"INTERNAL\");\n  var DOM_MEMO = Symbol(\"MEMO\");\n  var PERMALINK = Symbol(\"PERMALINK\");\n\n  // ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/hono@4.7.11/node_modules/hono/dist/jsx/intrinsic-element/common.js\n  var deDupeKeyMap = {\n    title: [],\n    script: [\"src\"],\n    style: [\"data-href\"],\n    link: [\"href\"],\n    meta: [\"name\", \"httpEquiv\", \"charset\", \"itemProp\"]\n  };\n  var domRenderers = {};\n  var dataPrecedenceAttr = \"data-precedence\";\n\n  // ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/hono@4.7.11/node_modules/hono/dist/jsx/children.js\n  var toArray = (children) => Array.isArray(children) ? children : [children];\n\n  // ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/hono@4.7.11/node_modules/hono/dist/jsx/utils.js\n  var normalizeElementKeyMap = /* @__PURE__ */ new Map([\n    [\"className\", \"class\"],\n    [\"htmlFor\", \"for\"],\n    [\"crossOrigin\", \"crossorigin\"],\n    [\"httpEquiv\", \"http-equiv\"],\n    [\"itemProp\", \"itemprop\"],\n    [\"fetchPriority\", \"fetchpriority\"],\n    [\"noModule\", \"nomodule\"],\n    [\"formAction\", \"formaction\"]\n  ]);\n  var normalizeIntrinsicElementKey = (key) => normalizeElementKeyMap.get(key) || key;\n  var styleObjectForEach = (style2, fn) => {\n    for (const [k, v] of Object.entries(style2)) {\n      const key = k[0] === \"-\" || !/[A-Z]/.test(k) ? k : k.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`);\n      fn(\n        key,\n        v == null ? null : typeof v === \"number\" ? !key.match(\n          /^(?:a|border-im|column(?:-c|s)|flex(?:$|-[^b])|grid-(?:ar|[^a])|font-w|li|or|sca|st|ta|wido|z)|ty$/\n        ) ? `${v}px` : `${v}` : v\n      );\n    }\n  };\n\n  // ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/hono@4.7.11/node_modules/hono/dist/jsx/dom/utils.js\n  var setInternalTagFlag = (fn) => {\n    ;\n    fn[DOM_INTERNAL_TAG] = true;\n    return fn;\n  };\n\n  // ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/hono@4.7.11/node_modules/hono/dist/jsx/dom/context.js\n  var createContextProviderFunction = (values) => ({ value, children }) => {\n    if (!children) {\n      return void 0;\n    }\n    const props = {\n      children: [\n        {\n          tag: setInternalTagFlag(() => {\n            values.push(value);\n          }),\n          props: {}\n        }\n      ]\n    };\n    if (Array.isArray(children)) {\n      props.children.push(...children.flat());\n    } else {\n      props.children.push(children);\n    }\n    props.children.push({\n      tag: setInternalTagFlag(() => {\n        values.pop();\n      }),\n      props: {}\n    });\n    const res = { tag: \"\", props, type: \"\" };\n    res[DOM_ERROR_HANDLER] = (err2) => {\n      values.pop();\n      throw err2;\n    };\n    return res;\n  };\n  var createContext2 = (defaultValue) => {\n    const values = [defaultValue];\n    const context = createContextProviderFunction(values);\n    context.values = values;\n    context.Provider = context;\n    globalContexts.push(context);\n    return context;\n  };\n\n  // ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/hono@4.7.11/node_modules/hono/dist/jsx/context.js\n  var globalContexts = [];\n  var useContext = (context) => {\n    return context.values.at(-1);\n  };\n\n  // ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/hono@4.7.11/node_modules/hono/dist/jsx/dom/render.js\n  var HONO_PORTAL_ELEMENT = \"_hp\";\n  var eventAliasMap = {\n    Change: \"Input\",\n    DoubleClick: \"DblClick\"\n  };\n  var nameSpaceMap = {\n    svg: \"2000/svg\",\n    math: \"1998/Math/MathML\"\n  };\n  var buildDataStack = [];\n  var refCleanupMap = /* @__PURE__ */ new WeakMap();\n  var nameSpaceContext = void 0;\n  var getNameSpaceContext2 = () => nameSpaceContext;\n  var isNodeString = (node) => \"t\" in node;\n  var eventCache = {\n    onClick: [\"click\", false]\n  };\n  var getEventSpec = (key) => {\n    if (!key.startsWith(\"on\")) {\n      return void 0;\n    }\n    if (eventCache[key]) {\n      return eventCache[key];\n    }\n    const match = key.match(/^on([A-Z][a-zA-Z]+?(?:PointerCapture)?)(Capture)?$/);\n    if (match) {\n      const [, eventName, capture] = match;\n      return eventCache[key] = [(eventAliasMap[eventName] || eventName).toLowerCase(), !!capture];\n    }\n    return void 0;\n  };\n  var toAttributeName = (element, key) => nameSpaceContext && element instanceof SVGElement && /[A-Z]/.test(key) && (key in element.style || key.match(/^(?:o|pai|str|u|ve)/)) ? key.replace(/([A-Z])/g, \"-$1\").toLowerCase() : key;\n  var applyProps = (container, attributes, oldAttributes) => {\n    attributes ||= {};\n    for (let key in attributes) {\n      const value = attributes[key];\n      if (key !== \"children\" && (!oldAttributes || oldAttributes[key] !== value)) {\n        key = normalizeIntrinsicElementKey(key);\n        const eventSpec = getEventSpec(key);\n        if (eventSpec) {\n          if (oldAttributes?.[key] !== value) {\n            if (oldAttributes) {\n              container.removeEventListener(eventSpec[0], oldAttributes[key], eventSpec[1]);\n            }\n            if (value != null) {\n              if (typeof value !== \"function\") {\n                throw new Error(`Event handler for \"${key}\" is not a function`);\n              }\n              container.addEventListener(eventSpec[0], value, eventSpec[1]);\n            }\n          }\n        } else if (key === \"dangerouslySetInnerHTML\" && value) {\n          container.innerHTML = value.__html;\n        } else if (key === \"ref\") {\n          let cleanup;\n          if (typeof value === \"function\") {\n            cleanup = value(container) || (() => value(null));\n          } else if (value && \"current\" in value) {\n            value.current = container;\n            cleanup = () => value.current = null;\n          }\n          refCleanupMap.set(container, cleanup);\n        } else if (key === \"style\") {\n          const style2 = container.style;\n          if (typeof value === \"string\") {\n            style2.cssText = value;\n          } else {\n            style2.cssText = \"\";\n            if (value != null) {\n              styleObjectForEach(value, style2.setProperty.bind(style2));\n            }\n          }\n        } else {\n          if (key === \"value\") {\n            const nodeName = container.nodeName;\n            if (nodeName === \"INPUT\" || nodeName === \"TEXTAREA\" || nodeName === \"SELECT\") {\n              ;\n              container.value = value === null || value === void 0 || value === false ? null : value;\n              if (nodeName === \"TEXTAREA\") {\n                container.textContent = value;\n                continue;\n              } else if (nodeName === \"SELECT\") {\n                if (container.selectedIndex === -1) {\n                  ;\n                  container.selectedIndex = 0;\n                }\n                continue;\n              }\n            }\n          } else if (key === \"checked\" && container.nodeName === \"INPUT\" || key === \"selected\" && container.nodeName === \"OPTION\") {\n            ;\n            container[key] = value;\n          }\n          const k = toAttributeName(container, key);\n          if (value === null || value === void 0 || value === false) {\n            container.removeAttribute(k);\n          } else if (value === true) {\n            container.setAttribute(k, \"\");\n          } else if (typeof value === \"string\" || typeof value === \"number\") {\n            container.setAttribute(k, value);\n          } else {\n            container.setAttribute(k, value.toString());\n          }\n        }\n      }\n    }\n    if (oldAttributes) {\n      for (let key in oldAttributes) {\n        const value = oldAttributes[key];\n        if (key !== \"children\" && !(key in attributes)) {\n          key = normalizeIntrinsicElementKey(key);\n          const eventSpec = getEventSpec(key);\n          if (eventSpec) {\n            container.removeEventListener(eventSpec[0], value, eventSpec[1]);\n          } else if (key === \"ref\") {\n            refCleanupMap.get(container)?.();\n          } else {\n            container.removeAttribute(toAttributeName(container, key));\n          }\n        }\n      }\n    }\n  };\n  var invokeTag = (context, node) => {\n    node[DOM_STASH][0] = 0;\n    buildDataStack.push([context, node]);\n    const func = node.tag[DOM_RENDERER] || node.tag;\n    const props = func.defaultProps ? {\n      ...func.defaultProps,\n      ...node.props\n    } : node.props;\n    try {\n      return [func.call(null, props)];\n    } finally {\n      buildDataStack.pop();\n    }\n  };\n  var getNextChildren = (node, container, nextChildren, childrenToRemove, callbacks) => {\n    if (node.vR?.length) {\n      childrenToRemove.push(...node.vR);\n      delete node.vR;\n    }\n    if (typeof node.tag === \"function\") {\n      node[DOM_STASH][1][STASH_EFFECT]?.forEach((data) => callbacks.push(data));\n    }\n    node.vC.forEach((child) => {\n      if (isNodeString(child)) {\n        nextChildren.push(child);\n      } else {\n        if (typeof child.tag === \"function\" || child.tag === \"\") {\n          child.c = container;\n          const currentNextChildrenIndex = nextChildren.length;\n          getNextChildren(child, container, nextChildren, childrenToRemove, callbacks);\n          if (child.s) {\n            for (let i = currentNextChildrenIndex; i < nextChildren.length; i++) {\n              nextChildren[i].s = true;\n            }\n            child.s = false;\n          }\n        } else {\n          nextChildren.push(child);\n          if (child.vR?.length) {\n            childrenToRemove.push(...child.vR);\n            delete child.vR;\n          }\n        }\n      }\n    });\n  };\n  var findInsertBefore = (node) => {\n    for (; ; node = node.tag === HONO_PORTAL_ELEMENT || !node.vC || !node.pP ? node.nN : node.vC[0]) {\n      if (!node) {\n        return null;\n      }\n      if (node.tag !== HONO_PORTAL_ELEMENT && node.e) {\n        return node.e;\n      }\n    }\n  };\n  var removeNode = (node) => {\n    if (!isNodeString(node)) {\n      node[DOM_STASH]?.[1][STASH_EFFECT]?.forEach((data) => data[2]?.());\n      refCleanupMap.get(node.e)?.();\n      if (node.p === 2) {\n        node.vC?.forEach((n) => n.p = 2);\n      }\n      node.vC?.forEach(removeNode);\n    }\n    if (!node.p) {\n      node.e?.remove();\n      delete node.e;\n    }\n    if (typeof node.tag === \"function\") {\n      updateMap.delete(node);\n      fallbackUpdateFnArrayMap.delete(node);\n      delete node[DOM_STASH][3];\n      node.a = true;\n    }\n  };\n  var apply = (node, container, isNew) => {\n    node.c = container;\n    applyNodeObject(node, container, isNew);\n  };\n  var findChildNodeIndex = (childNodes, child) => {\n    if (!child) {\n      return;\n    }\n    for (let i = 0, len = childNodes.length; i < len; i++) {\n      if (childNodes[i] === child) {\n        return i;\n      }\n    }\n    return;\n  };\n  var cancelBuild = Symbol();\n  var applyNodeObject = (node, container, isNew) => {\n    const next = [];\n    const remove = [];\n    const callbacks = [];\n    getNextChildren(node, container, next, remove, callbacks);\n    remove.forEach(removeNode);\n    const childNodes = isNew ? void 0 : container.childNodes;\n    let offset;\n    let insertBeforeNode = null;\n    if (isNew) {\n      offset = -1;\n    } else if (!childNodes.length) {\n      offset = 0;\n    } else {\n      const offsetByNextNode = findChildNodeIndex(childNodes, findInsertBefore(node.nN));\n      if (offsetByNextNode !== void 0) {\n        insertBeforeNode = childNodes[offsetByNextNode];\n        offset = offsetByNextNode;\n      } else {\n        offset = findChildNodeIndex(childNodes, next.find((n) => n.tag !== HONO_PORTAL_ELEMENT && n.e)?.e) ?? -1;\n      }\n      if (offset === -1) {\n        isNew = true;\n      }\n    }\n    for (let i = 0, len = next.length; i < len; i++, offset++) {\n      const child = next[i];\n      let el;\n      if (child.s && child.e) {\n        el = child.e;\n        child.s = false;\n      } else {\n        const isNewLocal = isNew || !child.e;\n        if (isNodeString(child)) {\n          if (child.e && child.d) {\n            child.e.textContent = child.t;\n          }\n          child.d = false;\n          el = child.e ||= document.createTextNode(child.t);\n        } else {\n          el = child.e ||= child.n ? document.createElementNS(child.n, child.tag) : document.createElement(child.tag);\n          applyProps(el, child.props, child.pP);\n          applyNodeObject(child, el, isNewLocal);\n        }\n      }\n      if (child.tag === HONO_PORTAL_ELEMENT) {\n        offset--;\n      } else if (isNew) {\n        if (!el.parentNode) {\n          container.appendChild(el);\n        }\n      } else if (childNodes[offset] !== el && childNodes[offset - 1] !== el) {\n        if (childNodes[offset + 1] === el) {\n          container.appendChild(childNodes[offset]);\n        } else {\n          container.insertBefore(el, insertBeforeNode || childNodes[offset] || null);\n        }\n      }\n    }\n    if (node.pP) {\n      delete node.pP;\n    }\n    if (callbacks.length) {\n      const useLayoutEffectCbs = [];\n      const useEffectCbs = [];\n      callbacks.forEach(([, useLayoutEffectCb, , useEffectCb, useInsertionEffectCb]) => {\n        if (useLayoutEffectCb) {\n          useLayoutEffectCbs.push(useLayoutEffectCb);\n        }\n        if (useEffectCb) {\n          useEffectCbs.push(useEffectCb);\n        }\n        useInsertionEffectCb?.();\n      });\n      useLayoutEffectCbs.forEach((cb) => cb());\n      if (useEffectCbs.length) {\n        requestAnimationFrame(() => {\n          useEffectCbs.forEach((cb) => cb());\n        });\n      }\n    }\n  };\n  var isSameContext = (oldContexts, newContexts) => !!(oldContexts && oldContexts.length === newContexts.length && oldContexts.every((ctx, i) => ctx[1] === newContexts[i][1]));\n  var fallbackUpdateFnArrayMap = /* @__PURE__ */ new WeakMap();\n  var build = (context, node, children) => {\n    const buildWithPreviousChildren = !children && node.pC;\n    if (children) {\n      node.pC ||= node.vC;\n    }\n    let foundErrorHandler;\n    try {\n      children ||= typeof node.tag == \"function\" ? invokeTag(context, node) : toArray(node.props.children);\n      if (children[0]?.tag === \"\" && children[0][DOM_ERROR_HANDLER]) {\n        foundErrorHandler = children[0][DOM_ERROR_HANDLER];\n        context[5].push([context, foundErrorHandler, node]);\n      }\n      const oldVChildren = buildWithPreviousChildren ? [...node.pC] : node.vC ? [...node.vC] : void 0;\n      const vChildren = [];\n      let prevNode;\n      for (let i = 0; i < children.length; i++) {\n        if (Array.isArray(children[i])) {\n          children.splice(i, 1, ...children[i].flat());\n        }\n        let child = buildNode(children[i]);\n        if (child) {\n          if (typeof child.tag === \"function\" && !child.tag[DOM_INTERNAL_TAG]) {\n            if (globalContexts.length > 0) {\n              child[DOM_STASH][2] = globalContexts.map((c) => [c, c.values.at(-1)]);\n            }\n            if (context[5]?.length) {\n              child[DOM_STASH][3] = context[5].at(-1);\n            }\n          }\n          let oldChild;\n          if (oldVChildren && oldVChildren.length) {\n            const i2 = oldVChildren.findIndex(\n              isNodeString(child) ? (c) => isNodeString(c) : child.key !== void 0 ? (c) => c.key === child.key && c.tag === child.tag : (c) => c.tag === child.tag\n            );\n            if (i2 !== -1) {\n              oldChild = oldVChildren[i2];\n              oldVChildren.splice(i2, 1);\n            }\n          }\n          if (oldChild) {\n            if (isNodeString(child)) {\n              if (oldChild.t !== child.t) {\n                ;\n                oldChild.t = child.t;\n                oldChild.d = true;\n              }\n              child = oldChild;\n            } else {\n              const pP = oldChild.pP = oldChild.props;\n              oldChild.props = child.props;\n              oldChild.f ||= child.f || node.f;\n              if (typeof child.tag === \"function\") {\n                const oldContexts = oldChild[DOM_STASH][2];\n                oldChild[DOM_STASH][2] = child[DOM_STASH][2] || [];\n                oldChild[DOM_STASH][3] = child[DOM_STASH][3];\n                if (!oldChild.f && ((oldChild.o || oldChild) === child.o || oldChild.tag[DOM_MEMO]?.(pP, oldChild.props)) && isSameContext(oldContexts, oldChild[DOM_STASH][2])) {\n                  oldChild.s = true;\n                }\n              }\n              child = oldChild;\n            }\n          } else if (!isNodeString(child) && nameSpaceContext) {\n            const ns = useContext(nameSpaceContext);\n            if (ns) {\n              child.n = ns;\n            }\n          }\n          if (!isNodeString(child) && !child.s) {\n            build(context, child);\n            delete child.f;\n          }\n          vChildren.push(child);\n          if (prevNode && !prevNode.s && !child.s) {\n            for (let p = prevNode; p && !isNodeString(p); p = p.vC?.at(-1)) {\n              p.nN = child;\n            }\n          }\n          prevNode = child;\n        }\n      }\n      node.vR = buildWithPreviousChildren ? [...node.vC, ...oldVChildren || []] : oldVChildren || [];\n      node.vC = vChildren;\n      if (buildWithPreviousChildren) {\n        delete node.pC;\n      }\n    } catch (e) {\n      node.f = true;\n      if (e === cancelBuild) {\n        if (foundErrorHandler) {\n          return;\n        } else {\n          throw e;\n        }\n      }\n      const [errorHandlerContext, errorHandler, errorHandlerNode] = node[DOM_STASH]?.[3] || [];\n      if (errorHandler) {\n        const fallbackUpdateFn = () => update([0, false, context[2]], errorHandlerNode);\n        const fallbackUpdateFnArray = fallbackUpdateFnArrayMap.get(errorHandlerNode) || [];\n        fallbackUpdateFnArray.push(fallbackUpdateFn);\n        fallbackUpdateFnArrayMap.set(errorHandlerNode, fallbackUpdateFnArray);\n        const fallback = errorHandler(e, () => {\n          const fnArray = fallbackUpdateFnArrayMap.get(errorHandlerNode);\n          if (fnArray) {\n            const i = fnArray.indexOf(fallbackUpdateFn);\n            if (i !== -1) {\n              fnArray.splice(i, 1);\n              return fallbackUpdateFn();\n            }\n          }\n        });\n        if (fallback) {\n          if (context[0] === 1) {\n            context[1] = true;\n          } else {\n            build(context, errorHandlerNode, [fallback]);\n            if ((errorHandler.length === 1 || context !== errorHandlerContext) && errorHandlerNode.c) {\n              apply(errorHandlerNode, errorHandlerNode.c, false);\n              return;\n            }\n          }\n          throw cancelBuild;\n        }\n      }\n      throw e;\n    } finally {\n      if (foundErrorHandler) {\n        context[5].pop();\n      }\n    }\n  };\n  var buildNode = (node) => {\n    if (node === void 0 || node === null || typeof node === \"boolean\") {\n      return void 0;\n    } else if (typeof node === \"string\" || typeof node === \"number\") {\n      return { t: node.toString(), d: true };\n    } else {\n      if (\"vR\" in node) {\n        node = {\n          tag: node.tag,\n          props: node.props,\n          key: node.key,\n          f: node.f,\n          type: node.tag,\n          ref: node.props.ref,\n          o: node.o || node\n        };\n      }\n      if (typeof node.tag === \"function\") {\n        ;\n        node[DOM_STASH] = [0, []];\n      } else {\n        const ns = nameSpaceMap[node.tag];\n        if (ns) {\n          nameSpaceContext ||= createContext2(\"\");\n          node.props.children = [\n            {\n              tag: nameSpaceContext,\n              props: {\n                value: node.n = `http://www.w3.org/${ns}`,\n                children: node.props.children\n              }\n            }\n          ];\n        }\n      }\n      return node;\n    }\n  };\n  var replaceContainer = (node, from, to) => {\n    if (node.c === from) {\n      node.c = to;\n      node.vC.forEach((child) => replaceContainer(child, from, to));\n    }\n  };\n  var updateSync = (context, node) => {\n    node[DOM_STASH][2]?.forEach(([c, v]) => {\n      c.values.push(v);\n    });\n    try {\n      build(context, node, void 0);\n    } catch {\n      return;\n    }\n    if (node.a) {\n      delete node.a;\n      return;\n    }\n    node[DOM_STASH][2]?.forEach(([c]) => {\n      c.values.pop();\n    });\n    if (context[0] !== 1 || !context[1]) {\n      apply(node, node.c, false);\n    }\n  };\n  var updateMap = /* @__PURE__ */ new WeakMap();\n  var currentUpdateSets = [];\n  var update = async (context, node) => {\n    context[5] ||= [];\n    const existing = updateMap.get(node);\n    if (existing) {\n      existing[0](void 0);\n    }\n    let resolve;\n    const promise = new Promise((r) => resolve = r);\n    updateMap.set(node, [\n      resolve,\n      () => {\n        if (context[2]) {\n          context[2](context, node, (context2) => {\n            updateSync(context2, node);\n          }).then(() => resolve(node));\n        } else {\n          updateSync(context, node);\n          resolve(node);\n        }\n      }\n    ]);\n    if (currentUpdateSets.length) {\n      ;\n      currentUpdateSets.at(-1).add(node);\n    } else {\n      await Promise.resolve();\n      const latest = updateMap.get(node);\n      if (latest) {\n        updateMap.delete(node);\n        latest[1]();\n      }\n    }\n    return promise;\n  };\n  var renderNode = (node, container) => {\n    const context = [];\n    context[5] = [];\n    context[4] = true;\n    build(context, node, void 0);\n    context[4] = false;\n    const fragment = document.createDocumentFragment();\n    apply(node, fragment, true);\n    replaceContainer(node, fragment, container);\n    container.replaceChildren(fragment);\n  };\n  var render = (jsxNode, container) => {\n    renderNode(buildNode({ tag: \"\", props: { children: jsxNode } }), container);\n  };\n  var createPortal = (children, container, key) => ({\n    tag: HONO_PORTAL_ELEMENT,\n    props: {\n      children\n    },\n    key,\n    e: container,\n    p: 1\n  });\n\n  // ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/hono@4.7.11/node_modules/hono/dist/jsx/hooks/index.js\n  var STASH_SATE = 0;\n  var STASH_EFFECT = 1;\n  var STASH_CALLBACK = 2;\n  var STASH_MEMO = 3;\n  var STASH_REF = 4;\n  var resolvedPromiseValueMap = /* @__PURE__ */ new WeakMap();\n  var isDepsChanged = (prevDeps, deps) => !prevDeps || !deps || prevDeps.length !== deps.length || deps.some((dep, i) => dep !== prevDeps[i]);\n  var updateHook = void 0;\n  var pendingStack = [];\n  var useState = (initialState) => {\n    const resolveInitialState = () => typeof initialState === \"function\" ? initialState() : initialState;\n    const buildData = buildDataStack.at(-1);\n    if (!buildData) {\n      return [resolveInitialState(), () => {\n      }];\n    }\n    const [, node] = buildData;\n    const stateArray = node[DOM_STASH][1][STASH_SATE] ||= [];\n    const hookIndex = node[DOM_STASH][0]++;\n    return stateArray[hookIndex] ||= [\n      resolveInitialState(),\n      (newState) => {\n        const localUpdateHook = updateHook;\n        const stateData = stateArray[hookIndex];\n        if (typeof newState === \"function\") {\n          newState = newState(stateData[0]);\n        }\n        if (!Object.is(newState, stateData[0])) {\n          stateData[0] = newState;\n          if (pendingStack.length) {\n            const [pendingType, pendingPromise] = pendingStack.at(-1);\n            Promise.all([\n              pendingType === 3 ? node : update([pendingType, false, localUpdateHook], node),\n              pendingPromise\n            ]).then(([node2]) => {\n              if (!node2 || !(pendingType === 2 || pendingType === 3)) {\n                return;\n              }\n              const lastVC = node2.vC;\n              const addUpdateTask = () => {\n                setTimeout(() => {\n                  if (lastVC !== node2.vC) {\n                    return;\n                  }\n                  update([pendingType === 3 ? 1 : 0, false, localUpdateHook], node2);\n                });\n              };\n              requestAnimationFrame(addUpdateTask);\n            });\n          } else {\n            update([0, false, localUpdateHook], node);\n          }\n        }\n      }\n    ];\n  };\n  var useEffectCommon = (index, effect, deps) => {\n    const buildData = buildDataStack.at(-1);\n    if (!buildData) {\n      return;\n    }\n    const [, node] = buildData;\n    const effectDepsArray = node[DOM_STASH][1][STASH_EFFECT] ||= [];\n    const hookIndex = node[DOM_STASH][0]++;\n    const [prevDeps, , prevCleanup] = effectDepsArray[hookIndex] ||= [];\n    if (isDepsChanged(prevDeps, deps)) {\n      if (prevCleanup) {\n        prevCleanup();\n      }\n      const runner = () => {\n        data[index] = void 0;\n        data[2] = effect();\n      };\n      const data = [deps, void 0, void 0, void 0, void 0];\n      data[index] = runner;\n      effectDepsArray[hookIndex] = data;\n    }\n  };\n  var useEffect = (effect, deps) => useEffectCommon(3, effect, deps);\n  var useCallback = (callback, deps) => {\n    const buildData = buildDataStack.at(-1);\n    if (!buildData) {\n      return callback;\n    }\n    const [, node] = buildData;\n    const callbackArray = node[DOM_STASH][1][STASH_CALLBACK] ||= [];\n    const hookIndex = node[DOM_STASH][0]++;\n    const prevDeps = callbackArray[hookIndex];\n    if (isDepsChanged(prevDeps?.[1], deps)) {\n      callbackArray[hookIndex] = [callback, deps];\n    } else {\n      callback = callbackArray[hookIndex][0];\n    }\n    return callback;\n  };\n  var useRef = (initialValue) => {\n    const buildData = buildDataStack.at(-1);\n    if (!buildData) {\n      return { current: initialValue };\n    }\n    const [, node] = buildData;\n    const refArray = node[DOM_STASH][1][STASH_REF] ||= [];\n    const hookIndex = node[DOM_STASH][0]++;\n    return refArray[hookIndex] ||= { current: initialValue };\n  };\n  var use = (promise) => {\n    const cachedRes = resolvedPromiseValueMap.get(promise);\n    if (cachedRes) {\n      if (cachedRes.length === 2) {\n        throw cachedRes[1];\n      }\n      return cachedRes[0];\n    }\n    promise.then(\n      (res) => resolvedPromiseValueMap.set(promise, [res]),\n      (e) => resolvedPromiseValueMap.set(promise, [void 0, e])\n    );\n    throw promise;\n  };\n  var useMemo = (factory, deps) => {\n    const buildData = buildDataStack.at(-1);\n    if (!buildData) {\n      return factory();\n    }\n    const [, node] = buildData;\n    const memoArray = node[DOM_STASH][1][STASH_MEMO] ||= [];\n    const hookIndex = node[DOM_STASH][0]++;\n    const prevDeps = memoArray[hookIndex];\n    if (isDepsChanged(prevDeps?.[1], deps)) {\n      memoArray[hookIndex] = [factory(), deps];\n    }\n    return memoArray[hookIndex][0];\n  };\n\n  // ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/hono@4.7.11/node_modules/hono/dist/jsx/dom/hooks/index.js\n  var FormContext = createContext2({\n    pending: false,\n    data: null,\n    method: null,\n    action: null\n  });\n  var actions = /* @__PURE__ */ new Set();\n  var registerAction = (action) => {\n    actions.add(action);\n    action.finally(() => actions.delete(action));\n  };\n\n  // ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/hono@4.7.11/node_modules/hono/dist/jsx/dom/intrinsic-element/components.js\n  var clearCache = () => {\n    blockingPromiseMap = /* @__PURE__ */ Object.create(null);\n    createdElements = /* @__PURE__ */ Object.create(null);\n  };\n  var composeRef = (ref, cb) => {\n    return useMemo(\n      () => (e) => {\n        let refCleanup;\n        if (ref) {\n          if (typeof ref === \"function\") {\n            refCleanup = ref(e) || (() => {\n              ref(null);\n            });\n          } else if (ref && \"current\" in ref) {\n            ref.current = e;\n            refCleanup = () => {\n              ref.current = null;\n            };\n          }\n        }\n        const cbCleanup = cb(e);\n        return () => {\n          cbCleanup?.();\n          refCleanup?.();\n        };\n      },\n      [ref]\n    );\n  };\n  var blockingPromiseMap = /* @__PURE__ */ Object.create(null);\n  var createdElements = /* @__PURE__ */ Object.create(null);\n  var documentMetadataTag = (tag, props, preserveNodeType, supportSort, supportBlocking) => {\n    if (props?.itemProp) {\n      return {\n        tag,\n        props,\n        type: tag,\n        ref: props.ref\n      };\n    }\n    const head = document.head;\n    let { onLoad, onError, precedence, blocking, ...restProps } = props;\n    let element = null;\n    let created = false;\n    const deDupeKeys = deDupeKeyMap[tag];\n    let existingElements = void 0;\n    if (deDupeKeys.length > 0) {\n      const tags = head.querySelectorAll(tag);\n      LOOP:\n        for (const e of tags) {\n          for (const key of deDupeKeyMap[tag]) {\n            if (e.getAttribute(key) === props[key]) {\n              element = e;\n              break LOOP;\n            }\n          }\n        }\n      if (!element) {\n        const cacheKey = deDupeKeys.reduce(\n          (acc, key) => props[key] === void 0 ? acc : `${acc}-${key}-${props[key]}`,\n          tag\n        );\n        created = !createdElements[cacheKey];\n        element = createdElements[cacheKey] ||= (() => {\n          const e = document.createElement(tag);\n          for (const key of deDupeKeys) {\n            if (props[key] !== void 0) {\n              e.setAttribute(key, props[key]);\n            }\n            if (props.rel) {\n              e.setAttribute(\"rel\", props.rel);\n            }\n          }\n          return e;\n        })();\n      }\n    } else {\n      existingElements = head.querySelectorAll(tag);\n    }\n    precedence = supportSort ? precedence ?? \"\" : void 0;\n    if (supportSort) {\n      restProps[dataPrecedenceAttr] = precedence;\n    }\n    const insert = useCallback(\n      (e) => {\n        if (deDupeKeys.length > 0) {\n          let found = false;\n          for (const existingElement of head.querySelectorAll(tag)) {\n            if (found && existingElement.getAttribute(dataPrecedenceAttr) !== precedence) {\n              head.insertBefore(e, existingElement);\n              return;\n            }\n            if (existingElement.getAttribute(dataPrecedenceAttr) === precedence) {\n              found = true;\n            }\n          }\n          head.appendChild(e);\n        } else if (existingElements) {\n          let found = false;\n          for (const existingElement of existingElements) {\n            if (existingElement === e) {\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            head.insertBefore(\n              e,\n              head.contains(existingElements[0]) ? existingElements[0] : head.querySelector(tag)\n            );\n          }\n          existingElements = void 0;\n        }\n      },\n      [precedence]\n    );\n    const ref = composeRef(props.ref, (e) => {\n      const key = deDupeKeys[0];\n      if (preserveNodeType === 2) {\n        e.innerHTML = \"\";\n      }\n      if (created || existingElements) {\n        insert(e);\n      }\n      if (!onError && !onLoad) {\n        return;\n      }\n      let promise = blockingPromiseMap[e.getAttribute(key)] ||= new Promise(\n        (resolve, reject) => {\n          e.addEventListener(\"load\", resolve);\n          e.addEventListener(\"error\", reject);\n        }\n      );\n      if (onLoad) {\n        promise = promise.then(onLoad);\n      }\n      if (onError) {\n        promise = promise.catch(onError);\n      }\n      promise.catch(() => {\n      });\n    });\n    if (supportBlocking && blocking === \"render\") {\n      const key = deDupeKeyMap[tag][0];\n      if (props[key]) {\n        const value = props[key];\n        const promise = blockingPromiseMap[value] ||= new Promise((resolve, reject) => {\n          insert(element);\n          element.addEventListener(\"load\", resolve);\n          element.addEventListener(\"error\", reject);\n        });\n        use(promise);\n      }\n    }\n    const jsxNode = {\n      tag,\n      type: tag,\n      props: {\n        ...restProps,\n        ref\n      },\n      ref\n    };\n    jsxNode.p = preserveNodeType;\n    if (element) {\n      jsxNode.e = element;\n    }\n    return createPortal(\n      jsxNode,\n      head\n    );\n  };\n  var title = (props) => {\n    const nameSpaceContext2 = getNameSpaceContext2();\n    const ns = nameSpaceContext2 && useContext(nameSpaceContext2);\n    if (ns?.endsWith(\"svg\")) {\n      return {\n        tag: \"title\",\n        props,\n        type: \"title\",\n        ref: props.ref\n      };\n    }\n    return documentMetadataTag(\"title\", props, void 0, false, false);\n  };\n  var script = (props) => {\n    if (!props || [\"src\", \"async\"].some((k) => !props[k])) {\n      return {\n        tag: \"script\",\n        props,\n        type: \"script\",\n        ref: props.ref\n      };\n    }\n    return documentMetadataTag(\"script\", props, 1, false, true);\n  };\n  var style = (props) => {\n    if (!props || ![\"href\", \"precedence\"].every((k) => k in props)) {\n      return {\n        tag: \"style\",\n        props,\n        type: \"style\",\n        ref: props.ref\n      };\n    }\n    props[\"data-href\"] = props.href;\n    delete props.href;\n    return documentMetadataTag(\"style\", props, 2, true, true);\n  };\n  var link = (props) => {\n    if (!props || [\"onLoad\", \"onError\"].some((k) => k in props) || props.rel === \"stylesheet\" && (!(\"precedence\" in props) || \"disabled\" in props)) {\n      return {\n        tag: \"link\",\n        props,\n        type: \"link\",\n        ref: props.ref\n      };\n    }\n    return documentMetadataTag(\"link\", props, 1, \"precedence\" in props, true);\n  };\n  var meta = (props) => {\n    return documentMetadataTag(\"meta\", props, void 0, false, false);\n  };\n  var customEventFormAction = Symbol();\n  var form = (props) => {\n    const { action, ...restProps } = props;\n    if (typeof action !== \"function\") {\n      ;\n      restProps.action = action;\n    }\n    const [state, setState] = useState([null, false]);\n    const onSubmit = useCallback(\n      async (ev) => {\n        const currentAction = ev.isTrusted ? action : ev.detail[customEventFormAction];\n        if (typeof currentAction !== \"function\") {\n          return;\n        }\n        ev.preventDefault();\n        const formData = new FormData(ev.target);\n        setState([formData, true]);\n        const actionRes = currentAction(formData);\n        if (actionRes instanceof Promise) {\n          registerAction(actionRes);\n          await actionRes;\n        }\n        setState([null, true]);\n      },\n      []\n    );\n    const ref = composeRef(props.ref, (el) => {\n      el.addEventListener(\"submit\", onSubmit);\n      return () => {\n        el.removeEventListener(\"submit\", onSubmit);\n      };\n    });\n    const [data, isDirty] = state;\n    state[1] = false;\n    return {\n      tag: FormContext,\n      props: {\n        value: {\n          pending: data !== null,\n          data,\n          method: data ? \"post\" : null,\n          action: data ? action : null\n        },\n        children: {\n          tag: \"form\",\n          props: {\n            ...restProps,\n            ref\n          },\n          type: \"form\",\n          ref\n        }\n      },\n      f: isDirty\n    };\n  };\n  var formActionableElement = (tag, {\n    formAction,\n    ...props\n  }) => {\n    if (typeof formAction === \"function\") {\n      const onClick = useCallback((ev) => {\n        ev.preventDefault();\n        ev.currentTarget.form.dispatchEvent(\n          new CustomEvent(\"submit\", { detail: { [customEventFormAction]: formAction } })\n        );\n      }, []);\n      props.ref = composeRef(props.ref, (el) => {\n        el.addEventListener(\"click\", onClick);\n        return () => {\n          el.removeEventListener(\"click\", onClick);\n        };\n      });\n    }\n    return {\n      tag,\n      props,\n      type: tag,\n      ref: props.ref\n    };\n  };\n  var input = (props) => formActionableElement(\"input\", props);\n  var button = (props) => formActionableElement(\"button\", props);\n  Object.assign(domRenderers, {\n    title,\n    script,\n    style,\n    link,\n    meta,\n    form,\n    input,\n    button\n  });\n\n  // ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/hono@4.7.11/node_modules/hono/dist/jsx/dom/jsx-dev-runtime.js\n  var jsxDEV = (tag, props, key) => {\n    if (typeof tag === \"string\" && components_exports2[tag]) {\n      tag = components_exports2[tag];\n    }\n    return {\n      tag,\n      type: tag,\n      props,\n      key,\n      ref: props.ref\n    };\n  };\n  var Fragment = (props) => jsxDEV(\"\", props, void 0);\n\n  // client/app.tsx\n  var App = ({\n    state,\n    setState,\n    onOpenCreateAccountDialog: signUp,\n    onOpenSigninDialog: login\n  }) => {\n    return /* @__PURE__ */ jsxDEV(\n      \"div\",\n      {\n        style: {\n          display: \"grid\",\n          gap: 16\n        },\n        children: [\n          /* @__PURE__ */ jsxDEV(\n            \"h1\",\n            {\n              style: {\n                margin: 0,\n                padding: 16\n              },\n              children: \"definy\"\n            }\n          ),\n          /* @__PURE__ */ jsxDEV(\n            \"button\",\n            {\n              type: \"button\",\n              onClick: () => {\n                setState((prev) => prev + 1);\n              },\n              children: [\n                \"count: \",\n                state\n              ]\n            }\n          ),\n          /* @__PURE__ */ jsxDEV(\"button\", { type: \"button\", onClick: signUp, children: \"Create Account\" }),\n          /* @__PURE__ */ jsxDEV(\"button\", { type: \"button\", onClick: login, children: \"Log in\" })\n        ]\n      }\n    );\n  };\n\n  // https://jsr.io/@noble/secp256k1/2.2.3/index.ts\n  var B256 = 2n ** 256n;\n  var P = B256 - 0x1000003d1n;\n  var N = B256 - 0x14551231950b75fc4402da1732fc9bebfn;\n  var Gx = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n;\n  var Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n;\n  var CURVE = {\n    p: P,\n    n: N,\n    a: 0n,\n    b: 7n,\n    Gx,\n    Gy\n  };\n  var fLen = 32;\n  var curve = (x) => M(M(x * x) * x + CURVE.b);\n  var err = (m = \"\") => {\n    throw new Error(m);\n  };\n  var isB = (n) => typeof n === \"bigint\";\n  var isS = (s) => typeof s === \"string\";\n  var fe = (n) => isB(n) && 0n < n && n < P;\n  var ge = (n) => isB(n) && 0n < n && n < N;\n  var isu8 = (a) => a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n  var au8 = (a, l) => (\n    // assert is Uint8Array (of specific length)\n    !isu8(a) || typeof l === \"number\" && l > 0 && a.length !== l ? err(\"Uint8Array expected\") : a\n  );\n  var u8n = (data) => new Uint8Array(data);\n  var toU8 = (a, len) => au8(isS(a) ? h2b(a) : u8n(au8(a)), len);\n  var M = (a, b = P) => {\n    const r = a % b;\n    return r >= 0n ? r : b + r;\n  };\n  var aPoint = (p) => p instanceof Point ? p : err(\"Point expected\");\n  var Point = class _Point {\n    constructor(px, py, pz) {\n      this.px = px;\n      this.py = py;\n      this.pz = pz;\n      Object.freeze(this);\n    }\n    /** Generator / base point */\n    static BASE = new _Point(Gx, Gy, 1n);\n    /** Identity / zero point */\n    static ZERO = new _Point(0n, 1n, 0n);\n    /** Create 3d xyz point from 2d xy. (0, 0) => (0, 1, 0), not (0, 0, 1) */\n    static fromAffine(p) {\n      return p.x === 0n && p.y === 0n ? I : new _Point(p.x, p.y, 1n);\n    }\n    /** Convert Uint8Array or hex string to Point. */\n    static fromHex(hex) {\n      hex = toU8(hex);\n      let p = void 0;\n      const head = hex[0], tail = hex.subarray(1);\n      const x = slc(tail, 0, fLen), len = hex.length;\n      if (len === 33 && [2, 3].includes(head)) {\n        if (!fe(x)) err(\"Point hex invalid: x not FE\");\n        let y = sqrt(curve(x));\n        const isYOdd = (y & 1n) === 1n;\n        const headOdd = (head & 1) === 1;\n        if (headOdd !== isYOdd) y = M(-y);\n        p = new _Point(x, y, 1n);\n      }\n      if (len === 65 && head === 4) p = new _Point(x, slc(tail, fLen, 2 * fLen), 1n);\n      return p ? p.ok() : err(\"Point invalid: not on curve\");\n    }\n    /** Create point from a private key. */\n    static fromPrivateKey(k) {\n      return G.mul(toPriv(k));\n    }\n    get x() {\n      return this.aff().x;\n    }\n    // .x, .y will call expensive toAffine:\n    get y() {\n      return this.aff().y;\n    }\n    // should be used with care.\n    /** Equality check: compare points P&Q. */\n    equals(other) {\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = aPoint(other);\n      const X1Z2 = M(X1 * Z2), X2Z1 = M(X2 * Z1);\n      const Y1Z2 = M(Y1 * Z2), Y2Z1 = M(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    /** Flip point over y coordinate. */\n    negate() {\n      return new _Point(this.px, M(-this.py), this.pz);\n    }\n    /** Point doubling: P+P, complete formula. */\n    double() {\n      return this.add(this);\n    }\n    /**\n     * Point addition: P+Q, complete, exception-free formula\n     * (Renes-Costello-Batina, algo 1 of [2015/1060](https://eprint.iacr.org/2015/1060)).\n     * Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n     */\n    add(other) {\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = aPoint(other);\n      const { a, b } = CURVE;\n      let X3 = 0n, Y3 = 0n, Z3 = 0n;\n      const b3 = M(b * 3n);\n      let t0 = M(X1 * X2), t1 = M(Y1 * Y2), t2 = M(Z1 * Z2), t3 = M(X1 + Y1);\n      let t4 = M(X2 + Y2);\n      t3 = M(t3 * t4);\n      t4 = M(t0 + t1);\n      t3 = M(t3 - t4);\n      t4 = M(X1 + Z1);\n      let t5 = M(X2 + Z2);\n      t4 = M(t4 * t5);\n      t5 = M(t0 + t2);\n      t4 = M(t4 - t5);\n      t5 = M(Y1 + Z1);\n      X3 = M(Y2 + Z2);\n      t5 = M(t5 * X3);\n      X3 = M(t1 + t2);\n      t5 = M(t5 - X3);\n      Z3 = M(a * t4);\n      X3 = M(b3 * t2);\n      Z3 = M(X3 + Z3);\n      X3 = M(t1 - Z3);\n      Z3 = M(t1 + Z3);\n      Y3 = M(X3 * Z3);\n      t1 = M(t0 + t0);\n      t1 = M(t1 + t0);\n      t2 = M(a * t2);\n      t4 = M(b3 * t4);\n      t1 = M(t1 + t2);\n      t2 = M(t0 - t2);\n      t2 = M(a * t2);\n      t4 = M(t4 + t2);\n      t0 = M(t1 * t4);\n      Y3 = M(Y3 + t0);\n      t0 = M(t5 * t4);\n      X3 = M(t3 * X3);\n      X3 = M(X3 - t0);\n      t0 = M(t3 * t1);\n      Z3 = M(t5 * Z3);\n      Z3 = M(Z3 + t0);\n      return new _Point(X3, Y3, Z3);\n    }\n    mul(n, safe = true) {\n      if (!safe && n === 0n) return I;\n      if (!ge(n)) err(\"scalar invalid\");\n      if (this.equals(G)) return wNAF(n).p;\n      let p = I, f = G;\n      for (let d = this; n > 0n; d = d.double(), n >>= 1n) {\n        if (n & 1n) p = p.add(d);\n        else if (safe) f = f.add(d);\n      }\n      return p;\n    }\n    mulAddQUns(R, u1, u2) {\n      return this.mul(u1, false).add(R.mul(u2, false)).ok();\n    }\n    // to private keys. Doesn't use Shamir trick\n    /** Convert point to 2d xy affine point. (x, y, z) ∋ (x=x/z, y=y/z) */\n    toAffine() {\n      const { px: x, py: y, pz: z } = this;\n      if (this.equals(I)) return { x: 0n, y: 0n };\n      if (z === 1n) return { x, y };\n      const iz = inv(z, P);\n      if (M(z * iz) !== 1n) err(\"inverse invalid\");\n      return { x: M(x * iz), y: M(y * iz) };\n    }\n    /** Checks if the point is valid and on-curve. */\n    assertValidity() {\n      const { x, y } = this.aff();\n      if (!fe(x) || !fe(y)) err(\"Point invalid: x or y\");\n      return M(y * y) === curve(x) ? (\n        // y² = x³ + ax + b, must be equal\n        this\n      ) : err(\"Point invalid: not on curve\");\n    }\n    multiply(n) {\n      return this.mul(n);\n    }\n    // Aliases to compress code\n    aff() {\n      return this.toAffine();\n    }\n    ok() {\n      return this.assertValidity();\n    }\n    toHex(isCompressed = true) {\n      const { x, y } = this.aff();\n      const head = isCompressed ? (y & 1n) === 0n ? \"02\" : \"03\" : \"04\";\n      return head + n2h(x) + (isCompressed ? \"\" : n2h(y));\n    }\n    toRawBytes(isCompressed = true) {\n      return h2b(this.toHex(isCompressed));\n    }\n  };\n  var { BASE: G, ZERO: I } = Point;\n  var padh = (n, pad) => n.toString(16).padStart(pad, \"0\");\n  var b2h = (b) => Array.from(au8(b)).map((e) => padh(e, 2)).join(\"\");\n  var C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\n  var _ch = (ch) => {\n    if (ch >= C._0 && ch <= C._9) return ch - C._0;\n    if (ch >= C.A && ch <= C.F) return ch - (C.A - 10);\n    if (ch >= C.a && ch <= C.f) return ch - (C.a - 10);\n    return;\n  };\n  var h2b = (hex) => {\n    const e = \"hex invalid\";\n    if (!isS(hex)) return err(e);\n    const hl = hex.length, al = hl / 2;\n    if (hl % 2) return err(e);\n    const array = u8n(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n      const n1 = _ch(hex.charCodeAt(hi));\n      const n2 = _ch(hex.charCodeAt(hi + 1));\n      if (n1 === void 0 || n2 === void 0) return err(e);\n      array[ai] = n1 * 16 + n2;\n    }\n    return array;\n  };\n  var b2n = (b) => BigInt(\"0x\" + (b2h(b) || \"0\"));\n  var slc = (b, from, to) => b2n(b.slice(from, to));\n  var n2b = (num) => {\n    return isB(num) && num >= 0n && num < B256 ? h2b(padh(num, 2 * fLen)) : err(\"bigint expected\");\n  };\n  var n2h = (num) => b2h(n2b(num));\n  var concatB = (...arrs) => {\n    const r = u8n(arrs.reduce((sum, a) => sum + au8(a).length, 0));\n    let pad = 0;\n    arrs.forEach((a) => {\n      r.set(a, pad);\n      pad += a.length;\n    });\n    return r;\n  };\n  var inv = (num, md) => {\n    if (num === 0n || md <= 0n) err(\"no inverse n=\" + num + \" mod=\" + md);\n    let a = M(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;\n    while (a !== 0n) {\n      const q = b / a, r = b % a;\n      const m = x - u * q, n = y - v * q;\n      b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    return b === 1n ? M(x, md) : err(\"no inverse\");\n  };\n  var sqrt = (n) => {\n    let r = 1n;\n    for (let num = n, e = (P + 1n) / 4n; e > 0n; e >>= 1n) {\n      if (e & 1n) r = r * num % P;\n      num = num * num % P;\n    }\n    return M(r * r) === n ? r : err(\"sqrt invalid\");\n  };\n  var toPriv = (p) => {\n    if (!isB(p)) p = b2n(toU8(p, fLen));\n    return ge(p) ? p : err(\"private key invalid 3\");\n  };\n  var cr = () => (\n    // We support: 1) browsers 2) node.js 19+ 3) deno, other envs with crypto\n    typeof globalThis === \"object\" && \"crypto\" in globalThis ? globalThis.crypto : void 0\n  );\n  var _hmacSync;\n  var hashToPrivateKey = (hash) => {\n    hash = toU8(hash);\n    if (hash.length < fLen + 8 || hash.length > 1024) err(\"expected 40-1024b\");\n    const num = M(b2n(hash), N - 1n);\n    return n2b(num + 1n);\n  };\n  var etc = {\n    hexToBytes: h2b,\n    bytesToHex: b2h,\n    concatBytes: concatB,\n    bytesToNumberBE: b2n,\n    numberToBytesBE: n2b,\n    mod: M,\n    invert: inv,\n    // math utilities\n    hmacSha256Async: async (key, ...msgs) => {\n      const c = cr();\n      const s = c && c.subtle;\n      if (!s) return err(\"etc.hmacSha256Async or crypto.subtle must be defined\");\n      const k = await s.importKey(\"raw\", key, { name: \"HMAC\", hash: { name: \"SHA-256\" } }, false, [\"sign\"]);\n      return u8n(await s.sign(\"HMAC\", k, concatB(...msgs)));\n    },\n    hmacSha256Sync: _hmacSync,\n    // For TypeScript. Actual logic is below\n    hashToPrivateKey,\n    randomBytes: (len = 32) => {\n      const crypto = cr();\n      if (!crypto || !crypto.getRandomValues) err(\"crypto.getRandomValues must be defined\");\n      return crypto.getRandomValues(u8n(len));\n    }\n  };\n  var utils = {\n    // utilities\n    normPrivateKeyToScalar: toPriv,\n    isValidPrivateKey: (key) => {\n      try {\n        return !!toPriv(key);\n      } catch (e) {\n        return false;\n      }\n    },\n    randomPrivateKey: () => hashToPrivateKey(etc.randomBytes(fLen + 16)),\n    // FIPS 186 B.4.1.\n    precompute: (w = 8, p = G) => {\n      p.multiply(3n);\n      w;\n      return p;\n    }\n    // no-op\n  };\n  Object.defineProperties(etc, { hmacSha256Sync: {\n    // Allow setting it once, ignore then\n    configurable: false,\n    get() {\n      return _hmacSync;\n    },\n    set(f) {\n      if (!_hmacSync) _hmacSync = f;\n    }\n  } });\n  var W = 8;\n  var precompute = () => {\n    const points = [];\n    const windows = 256 / W + 1;\n    let p = G, b = p;\n    for (let w = 0; w < windows; w++) {\n      b = p;\n      points.push(b);\n      for (let i = 1; i < 2 ** (W - 1); i++) {\n        b = b.add(p);\n        points.push(b);\n      }\n      p = b.double();\n    }\n    return points;\n  };\n  var Gpows = void 0;\n  var wNAF = (n) => {\n    const comp = Gpows || (Gpows = precompute());\n    const neg = (cnd, p2) => {\n      let n2 = p2.negate();\n      return cnd ? n2 : p2;\n    };\n    let p = I, f = G;\n    const windows = 1 + 256 / W;\n    const wsize = 2 ** (W - 1);\n    const mask = BigInt(2 ** W - 1);\n    const maxNum = 2 ** W;\n    const shiftBy = BigInt(W);\n    for (let w = 0; w < windows; w++) {\n      const off = w * wsize;\n      let wbits = Number(n & mask);\n      n >>= shiftBy;\n      if (wbits > wsize) {\n        wbits -= maxNum;\n        n += 1n;\n      }\n      const off1 = off, off2 = off + Math.abs(wbits) - 1;\n      const cnd1 = w % 2 !== 0, cnd2 = wbits < 0;\n      if (wbits === 0) {\n        f = f.add(neg(cnd1, comp[off1]));\n      } else {\n        p = p.add(neg(cnd2, comp[off2]));\n      }\n    }\n    return { p, f };\n  };\n\n  // https://jsr.io/@std/encoding/1.0.10/_common64.ts\n  var padding = \"=\".charCodeAt(0);\n  var alphabet = {\n    base64: new TextEncoder().encode(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"),\n    base64url: new TextEncoder().encode(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\")\n  };\n  var rAlphabet = {\n    base64: new Uint8Array(128).fill(64),\n    // alphabet.base64.length\n    base64url: new Uint8Array(128).fill(64)\n  };\n  alphabet.base64.forEach((byte, i) => rAlphabet.base64[byte] = i);\n  alphabet.base64url.forEach((byte, i) => rAlphabet.base64url[byte] = i);\n  function calcSizeBase64(originalSize) {\n    return ((originalSize + 2) / 3 | 0) * 4;\n  }\n  function encode(buffer, i, o, alphabet3, padding3) {\n    i += 2;\n    for (; i < buffer.length; i += 3) {\n      const x = buffer[i - 2] << 16 | buffer[i - 1] << 8 | buffer[i];\n      buffer[o++] = alphabet3[x >> 18];\n      buffer[o++] = alphabet3[x >> 12 & 63];\n      buffer[o++] = alphabet3[x >> 6 & 63];\n      buffer[o++] = alphabet3[x & 63];\n    }\n    switch (i) {\n      case buffer.length + 1: {\n        const x = buffer[i - 2] << 16;\n        buffer[o++] = alphabet3[x >> 18];\n        buffer[o++] = alphabet3[x >> 12 & 63];\n        buffer[o++] = padding3;\n        buffer[o++] = padding3;\n        break;\n      }\n      case buffer.length: {\n        const x = buffer[i - 2] << 16 | buffer[i - 1] << 8;\n        buffer[o++] = alphabet3[x >> 18];\n        buffer[o++] = alphabet3[x >> 12 & 63];\n        buffer[o++] = alphabet3[x >> 6 & 63];\n        buffer[o++] = padding3;\n        break;\n      }\n    }\n    return o;\n  }\n\n  // https://jsr.io/@std/encoding/1.0.10/_common_detach.ts\n  function detach(buffer, maxSize) {\n    const originalSize = buffer.length;\n    if (buffer.byteOffset) {\n      const b = new Uint8Array(buffer.buffer);\n      b.set(buffer);\n      buffer = b.subarray(0, originalSize);\n    }\n    buffer = new Uint8Array(buffer.buffer.transfer(maxSize));\n    buffer.set(buffer.subarray(0, originalSize), maxSize - originalSize);\n    return [buffer, maxSize - originalSize];\n  }\n\n  // https://jsr.io/@std/encoding/1.0.10/base64url.ts\n  var padding2 = \"=\".charCodeAt(0);\n  var alphabet2 = new TextEncoder().encode(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\");\n  var rAlphabet2 = new Uint8Array(128).fill(64);\n  alphabet2.forEach((byte, i) => rAlphabet2[byte] = i);\n  function encodeBase64Url(data) {\n    if (typeof data === \"string\") {\n      data = new TextEncoder().encode(data);\n    } else if (data instanceof ArrayBuffer) data = new Uint8Array(data).slice();\n    else data = data.slice();\n    const [output, i] = detach(\n      data,\n      calcSizeBase64(data.length)\n    );\n    let o = encode(output, i, 0, alphabet2, padding2);\n    o = output.indexOf(padding2, o - 2);\n    return new TextDecoder().decode(\n      // deno-lint-ignore no-explicit-any\n      o > 0 ? new Uint8Array(output.buffer.transfer(o)) : output\n    );\n  }\n\n  // ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/hono@4.7.11/node_modules/hono/dist/jsx/dom/components.js\n  var ErrorBoundary = ({ children, fallback, fallbackRender, onError }) => {\n    const res = Fragment({ children });\n    res[DOM_ERROR_HANDLER] = (err2) => {\n      if (err2 instanceof Promise) {\n        throw err2;\n      }\n      onError?.(err2);\n      return fallbackRender?.(err2) || fallback;\n    };\n    return res;\n  };\n  var Suspense = ({\n    children,\n    fallback\n  }) => {\n    const res = Fragment({ children });\n    res[DOM_ERROR_HANDLER] = (err2, retry) => {\n      if (!(err2 instanceof Promise)) {\n        throw err2;\n      }\n      err2.finally(retry);\n      return fallback;\n    };\n    return res;\n  };\n\n  // ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/hono@4.7.11/node_modules/hono/dist/jsx/components.js\n  var errorBoundaryCounter = 0;\n  var childrenToString = async (children) => {\n    try {\n      return children.flat().map((c) => c == null || typeof c === \"boolean\" ? \"\" : c.toString());\n    } catch (e) {\n      if (e instanceof Promise) {\n        await e;\n        return childrenToString(children);\n      } else {\n        throw e;\n      }\n    }\n  };\n  var ErrorBoundary2 = async ({ children, fallback, fallbackRender, onError }) => {\n    if (!children) {\n      return raw(\"\");\n    }\n    if (!Array.isArray(children)) {\n      children = [children];\n    }\n    let fallbackStr;\n    const fallbackRes = (error) => {\n      onError?.(error);\n      return (fallbackStr || fallbackRender?.(error) || \"\").toString();\n    };\n    let resArray = [];\n    try {\n      resArray = children.map(\n        (c) => c == null || typeof c === \"boolean\" ? \"\" : c.toString()\n      );\n    } catch (e) {\n      fallbackStr = await fallback?.toString();\n      if (e instanceof Promise) {\n        resArray = [\n          e.then(() => childrenToString(children)).catch((e2) => fallbackRes(e2))\n        ];\n      } else {\n        resArray = [fallbackRes(e)];\n      }\n    }\n    if (resArray.some((res) => res instanceof Promise)) {\n      fallbackStr ||= await fallback?.toString();\n      const index = errorBoundaryCounter++;\n      const replaceRe = RegExp(`(<template id=\"E:${index}\"></template>.*?)(.*?)(<!--E:${index}-->)`);\n      const caught = false;\n      const catchCallback = ({ error: error2, buffer }) => {\n        if (caught) {\n          return \"\";\n        }\n        const fallbackResString = fallbackRes(error2);\n        if (buffer) {\n          buffer[0] = buffer[0].replace(replaceRe, fallbackResString);\n        }\n        return buffer ? \"\" : `<template data-hono-target=\"E:${index}\">${fallbackResString}</template><script>\n((d,c,n) => {\nc=d.currentScript.previousSibling\nd=d.getElementById('E:${index}')\nif(!d)return\ndo{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='E:${index}')\nd.replaceWith(c.content)\n})(document)\n<\\/script>`;\n      };\n      let error;\n      const promiseAll = Promise.all(resArray).catch((e) => error = e);\n      return raw(`<template id=\"E:${index}\"></template><!--E:${index}-->`, [\n        ({ phase, buffer, context }) => {\n          if (phase === HtmlEscapedCallbackPhase.BeforeStream) {\n            return;\n          }\n          return promiseAll.then(async (htmlArray) => {\n            if (error) {\n              throw error;\n            }\n            htmlArray = htmlArray.flat();\n            const content = htmlArray.join(\"\");\n            let html = buffer ? \"\" : `<template data-hono-target=\"E:${index}\">${content}</template><script>\n((d,c) => {\nc=d.currentScript.previousSibling\nd=d.getElementById('E:${index}')\nif(!d)return\nd.parentElement.insertBefore(c.content,d.nextSibling)\n})(document)\n<\\/script>`;\n            if (htmlArray.every((html2) => !html2.callbacks?.length)) {\n              if (buffer) {\n                buffer[0] = buffer[0].replace(replaceRe, content);\n              }\n              return html;\n            }\n            if (buffer) {\n              buffer[0] = buffer[0].replace(\n                replaceRe,\n                (_all, pre, _, post) => `${pre}${content}${post}`\n              );\n            }\n            const callbacks = htmlArray.map((html2) => html2.callbacks || []).flat();\n            if (phase === HtmlEscapedCallbackPhase.Stream) {\n              html = await resolveCallback(\n                html,\n                HtmlEscapedCallbackPhase.BeforeStream,\n                true,\n                context\n              );\n            }\n            let resolvedCount = 0;\n            const promises = callbacks.map(\n              (c) => (...args) => c(...args)?.then((content2) => {\n                resolvedCount++;\n                if (buffer) {\n                  if (resolvedCount === callbacks.length) {\n                    buffer[0] = buffer[0].replace(replaceRe, (_all, _pre, content3) => content3);\n                  }\n                  buffer[0] += content2;\n                  return raw(\"\", content2.callbacks);\n                }\n                return raw(\n                  content2 + (resolvedCount !== callbacks.length ? \"\" : `<script>\n((d,c,n) => {\nd=d.getElementById('E:${index}')\nif(!d)return\nn=d.nextSibling\nwhile(n.nodeType!=8||n.nodeValue!='E:${index}'){n=n.nextSibling}\nn.remove()\nd.remove()\n})(document)\n<\\/script>`),\n                  content2.callbacks\n                );\n              }).catch((error2) => catchCallback({ error: error2, buffer }))\n            );\n            return raw(html, promises);\n          }).catch((error2) => catchCallback({ error: error2, buffer }));\n        }\n      ]);\n    } else {\n      return raw(resArray.join(\"\"));\n    }\n  };\n  ErrorBoundary2[DOM_RENDERER] = ErrorBoundary;\n\n  // ../../../AppData/Local/deno/deno_esbuild/registry.npmjs.org/hono@4.7.11/node_modules/hono/dist/jsx/streaming.js\n  var suspenseCounter = 0;\n  var Suspense2 = async ({\n    children,\n    fallback\n  }) => {\n    if (!children) {\n      return fallback.toString();\n    }\n    if (!Array.isArray(children)) {\n      children = [children];\n    }\n    let resArray = [];\n    const stackNode = { [DOM_STASH]: [0, []] };\n    const popNodeStack = (value) => {\n      buildDataStack.pop();\n      return value;\n    };\n    try {\n      stackNode[DOM_STASH][0] = 0;\n      buildDataStack.push([[], stackNode]);\n      resArray = children.map(\n        (c) => c == null || typeof c === \"boolean\" ? \"\" : c.toString()\n      );\n    } catch (e) {\n      if (e instanceof Promise) {\n        resArray = [\n          e.then(() => {\n            stackNode[DOM_STASH][0] = 0;\n            buildDataStack.push([[], stackNode]);\n            return childrenToString(children).then(popNodeStack);\n          })\n        ];\n      } else {\n        throw e;\n      }\n    } finally {\n      popNodeStack();\n    }\n    if (resArray.some((res) => res instanceof Promise)) {\n      const index = suspenseCounter++;\n      const fallbackStr = await fallback.toString();\n      return raw(`<template id=\"H:${index}\"></template>${fallbackStr}<!--/$-->`, [\n        ...fallbackStr.callbacks || [],\n        ({ phase, buffer, context }) => {\n          if (phase === HtmlEscapedCallbackPhase.BeforeStream) {\n            return;\n          }\n          return Promise.all(resArray).then(async (htmlArray) => {\n            htmlArray = htmlArray.flat();\n            const content = htmlArray.join(\"\");\n            if (buffer) {\n              buffer[0] = buffer[0].replace(\n                new RegExp(`<template id=\"H:${index}\"></template>.*?<!--/\\\\$-->`),\n                content\n              );\n            }\n            let html = buffer ? \"\" : `<template data-hono-target=\"H:${index}\">${content}</template><script>\n((d,c,n) => {\nc=d.currentScript.previousSibling\nd=d.getElementById('H:${index}')\nif(!d)return\ndo{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')\nd.replaceWith(c.content)\n})(document)\n<\\/script>`;\n            const callbacks = htmlArray.map((html2) => html2.callbacks || []).flat();\n            if (!callbacks.length) {\n              return html;\n            }\n            if (phase === HtmlEscapedCallbackPhase.Stream) {\n              html = await resolveCallback(html, HtmlEscapedCallbackPhase.BeforeStream, true, context);\n            }\n            return raw(html, callbacks);\n          });\n        }\n      ]);\n    } else {\n      return raw(resArray.join(\"\"));\n    }\n  };\n  Suspense2[DOM_RENDERER] = Suspense;\n  var textEncoder = new TextEncoder();\n\n  // client/Dialog.tsx\n  var Dialog = (props) => {\n    const ref = useRef(null);\n    useEffect(() => {\n      ref.current?.addEventListener(\"close\", props.onClose);\n      const clickHandler = (event) => {\n        if (event.target instanceof HTMLElement) {\n          if (event.target.closest(\"form\") === null) {\n            props.onClose();\n          }\n        }\n      };\n      ref.current?.addEventListener(\"click\", clickHandler);\n      return () => {\n        ref.current?.removeEventListener(\"close\", props.onClose);\n        ref.current?.removeEventListener(\"click\", clickHandler);\n      };\n    }, [props.onClose, ref.current]);\n    useEffect(() => {\n      if (props.isOpen) {\n        ref.current?.showModal();\n      } else {\n        ref.current?.close();\n      }\n    }, [props.isOpen]);\n    if (!props.isOpen) {\n      return null;\n    }\n    return /* @__PURE__ */ jsxDEV(\n      \"dialog\",\n      {\n        ref,\n        style: {\n          width: \"80%\",\n          boxShadow: \"0px 20px 36px 0px rgba(0, 0, 0, 0.6)\"\n        },\n        children: props.children\n      }\n    );\n  };\n\n  // client/CreateAccountDialog.tsx\n  var SignUpDialog = (props) => {\n    return /* @__PURE__ */ jsxDEV(\n      Dialog,\n      {\n        isOpen: props.privateKey !== null,\n        onClose: props.onClose,\n        children: /* @__PURE__ */ jsxDEV(\n          \"form\",\n          {\n            method: \"dialog\",\n            style: {\n              display: \"grid\",\n              gap: 16\n            },\n            children: [\n              /* @__PURE__ */ jsxDEV(\n                \"div\",\n                {\n                  style: {\n                    display: \"flex\"\n                  },\n                  children: [\n                    /* @__PURE__ */ jsxDEV(\n                      \"h2\",\n                      {\n                        style: {\n                          margin: 0,\n                          flexGrow: 1\n                        },\n                        children: \"Sign up\"\n                      }\n                    ),\n                    /* @__PURE__ */ jsxDEV(\"button\", { type: \"button\", onClick: props.onClose, children: \"x\" })\n                  ]\n                }\n              ),\n              /* @__PURE__ */ jsxDEV(\"label\", { children: [\n                /* @__PURE__ */ jsxDEV(\"div\", { children: \"Username\" }),\n                /* @__PURE__ */ jsxDEV(\"input\", { type: \"text\", required: true })\n              ] }),\n              /* @__PURE__ */ jsxDEV(\"label\", { children: [\n                /* @__PURE__ */ jsxDEV(\"div\", { children: \"Password (auto created. If you lose this password, you will not be able to log in.)\" }),\n                /* @__PURE__ */ jsxDEV(\n                  \"input\",\n                  {\n                    type: \"password\",\n                    value: encodeBase64Url(props.privateKey),\n                    readOnly: true,\n                    autoComplete: \"new-password\"\n                  }\n                ),\n                /* @__PURE__ */ jsxDEV(\"button\", { type: \"button\", onClick: props.copyPassword, children: \"copy password\" })\n              ] }),\n              /* @__PURE__ */ jsxDEV(\"button\", { type: \"submit\", children: \"Sign up\" })\n            ]\n          }\n        )\n      }\n    );\n  };\n\n  // client/SigInDialog.tsx\n  var SigInDialog = ({ onClose }) => {\n    return /* @__PURE__ */ jsxDEV(\n      Dialog,\n      {\n        isOpen: true,\n        onClose,\n        children: /* @__PURE__ */ jsxDEV(\n          \"form\",\n          {\n            method: \"dialog\",\n            style: {\n              display: \"grid\",\n              gap: 16\n            },\n            children: [\n              /* @__PURE__ */ jsxDEV(\n                \"div\",\n                {\n                  style: {\n                    display: \"flex\"\n                  },\n                  children: [\n                    /* @__PURE__ */ jsxDEV(\n                      \"h2\",\n                      {\n                        style: {\n                          margin: 0,\n                          flexGrow: 1\n                        },\n                        children: \"Log in\"\n                      }\n                    ),\n                    /* @__PURE__ */ jsxDEV(\"button\", { type: \"button\", onClick: onClose, children: \"x\" })\n                  ]\n                }\n              ),\n              /* @__PURE__ */ jsxDEV(\"label\", { children: [\n                /* @__PURE__ */ jsxDEV(\"div\", { children: \"Username\" }),\n                /* @__PURE__ */ jsxDEV(\"input\", { type: \"text\", required: true })\n              ] }),\n              /* @__PURE__ */ jsxDEV(\"label\", { children: [\n                /* @__PURE__ */ jsxDEV(\"div\", { children: \"Password\" }),\n                /* @__PURE__ */ jsxDEV(\n                  \"input\",\n                  {\n                    type: \"password\",\n                    autoComplete: \"current-password\"\n                  }\n                )\n              ] }),\n              /* @__PURE__ */ jsxDEV(\"button\", { type: \"submit\", children: \"Log in\" })\n            ]\n          }\n        )\n      }\n    );\n  };\n\n  // client/start.tsx\n  var AppWithState = () => {\n    const [state, setState] = useState(0);\n    const [dialogOpenState, setDialogOpenState] = useState(null);\n    return /* @__PURE__ */ jsxDEV(\"div\", { children: [\n      /* @__PURE__ */ jsxDEV(\n        App,\n        {\n          state,\n          setState,\n          onOpenCreateAccountDialog: () => {\n            setDialogOpenState({\n              type: \"createAccount\",\n              privateKey: utils.randomPrivateKey()\n            });\n          },\n          onOpenSigninDialog: () => {\n            setDialogOpenState({\n              type: \"login\"\n            });\n          }\n        }\n      ),\n      dialogOpenState?.type === \"createAccount\" && /* @__PURE__ */ jsxDEV(\n        SignUpDialog,\n        {\n          privateKey: dialogOpenState.privateKey,\n          copyPassword: () => {\n            if (dialogOpenState === null) {\n              return;\n            }\n            navigator.clipboard.writeText(\n              encodeBase64Url(dialogOpenState.privateKey)\n            );\n          },\n          onClose: () => setDialogOpenState(null)\n        }\n      ),\n      dialogOpenState?.type === \"login\" && /* @__PURE__ */ jsxDEV(SigInDialog, { onClose: () => setDialogOpenState(null) })\n    ] });\n  };\n  render(/* @__PURE__ */ jsxDEV(AppWithState, {}), document.body);\n})();\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\n","clientJavaScriptHash":"ae7e1d2a499df63d162635045567ee759f3efcbd65b493e750c916406a8f6e8d"}