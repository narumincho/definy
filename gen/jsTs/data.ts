/* eslint-disable */
/* generated by js-ts-code-generator. Do not edit! */

/**
 * UserId, ProjectIdなどのIdをバイナリ形式にエンコードする
 */
export const encodeId = (value: string): ReadonlyArray<number> =>
  Array.from({ length: 16 }, (_: undefined, i: number): number =>
    Number.parseInt(value.slice(i * 2, i * 2 + 2), 16)
  );

/**
 * バイナリ形式をUserId, ProjectIdなどのIdにデコードする
 * @param index バイナリを読み込み開始位置
 * @param binary バイナリ
 */
export const decodeId = (
  index: number,
  binary: Uint8Array
): { readonly result: string; readonly nextIndex: number } => ({
  result: [...binary.slice(index, index + 16)]
    .map((n: number): string => n.toString(16).padStart(2, "0"))
    .join(""),
  nextIndex: index + 16,
});

/**
 * ImageTokenなどのTokenをバイナリ形式にエンコードする
 */
export const encodeToken = (value: string): ReadonlyArray<number> =>
  Array.from({ length: 32 }, (_: undefined, i: number): number =>
    Number.parseInt(value.slice(i * 2, i * 2 + 2), 16)
  );

/**
 * バイナリ形式をImageTokenなどのTokenにエンコードする
 * @param index バイナリを読み込み開始位置
 * @param binary バイナリ
 */
export const decodeToken = (
  index: number,
  binary: Uint8Array
): { readonly result: string; readonly nextIndex: number } => ({
  result: [...binary.slice(index, index + 32)]
    .map((n: number): string => n.toString(16).padStart(2, "0"))
    .join(""),
  nextIndex: index + 32,
});

/**
 * バイナリと相互変換するための関数
 */
export type Codec<T extends unknown> = {
  readonly encode: (a: T) => ReadonlyArray<number>;
  readonly decode: (
    a: number,
    b: Uint8Array
  ) => { readonly result: T; readonly nextIndex: number };
};

/**
 * 外部に公開する定義
 * @typePartId 0c8b854b812290a054877ca5de6c4daf
 */
export type ExportDefinition =
  | { readonly _: "TypeAlias"; readonly typeAlias: TypeAlias }
  | { readonly _: "Function"; readonly function: Function }
  | { readonly _: "Variable"; readonly variable: Variable };

/**
 * 単項演算子と適用される式
 * @typePartId 0cb0a34b3953e57b30f4a5c8f9d305da
 */
export type UnaryOperatorExpr = {
  /**
   * 単項演算子
   */
  readonly operator: UnaryOperator;
  /**
   * 適用される式
   */
  readonly expr: Expr;
};

/**
 * プロジェクトの識別子
 * @typePartId 0cd913118a2ad1469d656146a08c5f76
 */
export type ProjectId = string & { readonly _projectId: never };

/**
 * 英語,日本語,エスペラント語などの言語
 * @typePartId 0d9510723f4d34605e41f3a47a8b0ea7
 */
export type Language = "Japanese" | "English" | "Esperanto";

/**
 * -2 147 483 648 ～ 2 147 483 647. 32bit 符号付き整数. JavaScriptのnumberとして扱える. numberの32bit符号あり整数をSigned Leb128のバイナリに変換する
 * @typePartId 16c2d8602e3e5e2d38b9215bd0c44d8d
 */
export type Int32 = number;

/**
 * @typePartId 1835ebdc909b0fa93d11ae0ed93d0606
 */
export type Type =
  | { readonly _: "Number" }
  | { readonly _: "String" }
  | { readonly _: "Boolean" }
  | { readonly _: "Undefined" }
  | { readonly _: "Null" }
  | { readonly _: "Never" }
  | { readonly _: "Void" }
  | { readonly _: "Object"; readonly memberTypeList: List<MemberType> }
  | { readonly _: "Function"; readonly functionType: FunctionType }
  | {
      readonly _: "WithTypeParameter";
      readonly typeWithTypeParameter: TypeWithTypeParameter;
    }
  | { readonly _: "Union"; readonly typeList: List<Type> }
  | { readonly _: "Intersection"; readonly intersectionType: IntersectionType }
  | { readonly _: "ImportedType"; readonly importedType: ImportedType }
  | { readonly _: "ScopeInFile"; readonly identifer: Identifer }
  | { readonly _: "ScopeInGlobal"; readonly identifer: Identifer }
  | { readonly _: "StringLiteral"; readonly string: String };

/**
 * Unit. 1つの値しかない型. JavaScriptのundefinedで扱う
 * @typePartId 217263d8cdca613c2d1ba77e19d4cbb0
 */
export type Unit = undefined;

/**
 * パラメーター付きの型
 * @typePartId 23fa0e8b66c9d093d4c18579ffefaaa3
 */
export type TypeWithTypeParameter = {
  /**
   * パラメーターをつけられる型
   */
  readonly type: Type;
  /**
   * パラメーターに指定する型. なにも要素を入れなけければ T<>ではなく T の形式で出力される
   */
  readonly typeParameterList: List<Type>;
};

/**
 * TypeScriptの識別子として使える文字
 * @typePartId 2a75ad7c7ccc58ba56f6c8545c8150d1
 */
export type Identifer = { readonly _: "Identifer"; readonly string: String };

/**
 * Maybe. nullableのようなもの. 今後はRustのstd::Optionに出力するために属性をつけよう (確信)
 * @typePartId 304f21ae8208a21d08731aa6d183742d
 */
export type Maybe<value extends unknown> =
  | { readonly _: "Just"; readonly value: value }
  | { readonly _: "Nothing" };

/**
 * 配列リテラルの要素
 * @typePartId 35f7e442c0838f9982e6b49da398d97f
 */
export type ArrayItem = {
  /**
   * 式
   */
  readonly expr: Expr;
  /**
   * スプレッド ...a のようにするか
   */
  readonly spread: Bool;
};

/**
 * バイナリ. JavaScriptのUint8Arrayで扱える. 最初にLED128でバイト数, その次にバイナリそのまま
 * @typePartId 3e2f740c88923b0393a1ef93d92f157b
 */
export type Binary = Uint8Array;

/**
 * 2項演算子
 * @typePartId 4953938f040aefdaa5f2601e2a78d43b
 */
export type BinaryOperator =
  | "Exponentiation"
  | "Multiplication"
  | "Division"
  | "Remainder"
  | "Addition"
  | "Subtraction"
  | "LeftShift"
  | "SignedRightShift"
  | "UnsignedRightShift"
  | "LessThan"
  | "LessThanOrEqual"
  | "Equal"
  | "NotEqual"
  | "BitwiseAnd"
  | "BitwiseXOr"
  | "BitwiseOr"
  | "LogicalAnd"
  | "LogicalOr";

/**
 * 型アサーション
 * @typePartId 49f05a756bd75da670fa5b64ed8bf1ae
 */
export type TypeAssertion = {
  /**
   * 型アサーションを受ける式
   */
  readonly expr: Expr;
  /**
   * 型
   */
  readonly type: Type;
};

/**
 * JavaScriptの単項演算子
 * @typePartId 4b4c3f8f34d1c05bb9d7d1b930bc9c9a
 */
export type UnaryOperator = "Minus" | "BitwiseNot" | "LogicalNot";

/**
 * 関数のパラメーター. パラメーター名, 型
 * @typePartId 5433bade7738da21e7663ff043f588d5
 */
export type Parameter = {
  /**
   * パラメーター名
   */
  readonly name: Identifer;
  /**
   * パラメーターの型
   */
  readonly type: Type;
};

/**
 * パーツの識別子
 * @typePartId 5880cd7c0b6f0205c739a06181898d03
 */
export type PartId = string & { readonly _partId: never };

/**
 * タグの識別子. タグは直和型に使うもの.
 * @typePartId 5ec292c48424e5e9ee8cc2d672830ecd
 */
export type TagId = string & { readonly _tagId: never };

/**
 * switch文のcase "text": { statementList } の部分
 * @typePartId 6126431def47ecba239b3add7f472b19
 */
export type Pattern = {
  /**
   * case に使う文字列
   */
  readonly caseString: String;
  /**
   * マッチしたときに実行する部分
   */
  readonly statementList: List<Statement>;
};

/**
 * 文字列. JavaScriptのstringで扱う. バイナリ形式はUTF-8. 不正な文字が入っている可能性がある
 * @typePartId 666361c9ae68ab64f273c47f3feb8c73
 */
export type String = string;

/**
 * 代入文
 * @typePartId 6a5a7886b0f117a50d9d7b11ffe87c9f
 */
export type SetStatement = {
  /**
   * 対象となる式. 指定の仕方によってはJSのSyntaxErrorになる
   */
  readonly target: Expr;
  /**
   * 演算子を=の左につける
   */
  readonly operatorMaybe: Maybe<BinaryOperator>;
  /**
   * 式
   */
  readonly expr: Expr;
};

/**
 * ドキュメント付きの関数のパラメーター. パラメーター名, ドキュメント, 型
 * @typePartId 6b05e33009ade6b4decd452e8fd4bff1
 */
export type ParameterWithDocument = {
  /**
   * パラメーター名
   */
  readonly name: Identifer;
  /**
   * ドキュメント
   */
  readonly document: String;
  /**
   * パラメーターの型
   */
  readonly type: Type;
};

/**
 * 型パーツの識別子
 * @typePartId 6e3cff317f8bfbbd1391c0afb9ad6b72
 */
export type TypePartId = string & { readonly _typePartId: never };

/**
 * 成功と失敗を表す型. 今後はRustのstd::Resultに出力するために属性をつける?
 * @typePartId 6f937e46fce1cf70d29c54780f132c18
 */
export type Result<ok extends unknown, error extends unknown> =
  | { readonly _: "Ok"; readonly ok: ok }
  | { readonly _: "Error"; readonly error: error };

/**
 * デバッグモードかどうか,言語とページの場所. URLとして表現されるデータ. Googleなどの検索エンジンの都合( https://support.google.com/webmasters/answer/182192?hl=ja )で,URLにページの言語を入れて,言語ごとに別のURLである必要がある. デバッグ時のホスト名は http://localhost になる
 * @typePartId 7210f04a85c5f0f58f7aa20826d67f05
 */
export type UrlData = {
  /**
   * 場所
   */
  readonly location: Location;
};

/**
 * switch文
 * @typePartId 725f84ef82e6c3b5b5f6fd5208977dd8
 */
export type SwitchStatement = {
  /**
   * switch(a) {} の a
   */
  readonly expr: Expr;
  /**
   * case "text": { statementList }
   */
  readonly patternList: List<Pattern>;
};

/**
 * ローカル変数定義
 * @typePartId 7277cf2483388ee2f5ad7a7fc8585d98
 */
export type VariableDefinitionStatement = {
  /**
   * 変数名
   */
  readonly name: Identifer;
  /**
   * 変数の型
   */
  readonly type: Type;
  /**
   * 式
   */
  readonly expr: Expr;
  /**
   * constかどうか. falseはlet
   */
  readonly isConst: Bool;
};

/**
 * JavaScript の 文
 * @typePartId 7c957d411f448a03764f16d43e6e5008
 */
export type Statement =
  | { readonly _: "EvaluateExpr"; readonly expr: Expr }
  | { readonly _: "Set"; readonly setStatement: SetStatement }
  | { readonly _: "If"; readonly ifStatement: IfStatement }
  | { readonly _: "ThrowError"; readonly expr: Expr }
  | { readonly _: "Return"; readonly expr: Expr }
  | { readonly _: "ReturnVoid" }
  | { readonly _: "Continue" }
  | {
      readonly _: "VariableDefinition";
      readonly variableDefinitionStatement: VariableDefinitionStatement;
    }
  | {
      readonly _: "FunctionDefinition";
      readonly functionDefinitionStatement: FunctionDefinitionStatement;
    }
  | { readonly _: "For"; readonly forStatement: ForStatement }
  | { readonly _: "ForOf"; readonly forOfStatement: ForOfStatement }
  | { readonly _: "WhileTrue"; readonly statementList: List<Statement> }
  | { readonly _: "Break" }
  | { readonly _: "Switch"; readonly switchStatement: SwitchStatement };

/**
 * 日時. 0001-01-01T00:00:00.000Z to 9999-12-31T23:59:59.999Z 最小単位はミリ秒. ミリ秒の求め方は day*1000*60*60*24 + millisecond
 * @typePartId 7d91f0f70643799692aa144ee51a62b1
 */
export type Time = {
  /**
   * 1970-01-01からの経過日数. マイナスになることもある
   */
  readonly day: Int32;
  /**
   * 日にちの中のミリ秒. 0 to 86399999 (=1000*60*60*24-1)
   */
  readonly millisecond: Int32;
};

/**
 * インポートした変数
 * @typePartId 8150e2833dc1f2a77715aa1bb7b2baad
 */
export type ImportedVariable = {
  /**
   * モジュール名, 使うときにはnamedインポートされ, そのモジュール識別子は自動的につけられる
   */
  readonly moduleName: String;
  /**
   * 変数名
   */
  readonly name: Identifer;
};

/**
 * "ソーシャルログインを提供するプロバイダー (例: Google, GitHub)
 * @typePartId 84597034eb252267ce1a599ab7a0b543
 */
export type OpenIdConnectProvider = "Google" | "GitHub";

/**
 * JavaScript の 式
 * @typePartId 8b0bdbeae05df3badac2ee69bf22011f
 */
export type Expr =
  | { readonly _: "NumberLiteral"; readonly int32: Int32 }
  | { readonly _: "StringLiteral"; readonly string: String }
  | { readonly _: "BooleanLiteral"; readonly bool: Bool }
  | { readonly _: "NullLiteral" }
  | { readonly _: "UndefinedLiteral" }
  | {
      readonly _: "UnaryOperator";
      readonly unaryOperatorExpr: UnaryOperatorExpr;
    }
  | {
      readonly _: "BinaryOperator";
      readonly binaryOperatorExpr: BinaryOperatorExpr;
    }
  | {
      readonly _: "ConditionalOperator";
      readonly conditionalOperatorExpr: ConditionalOperatorExpr;
    }
  | { readonly _: "ArrayLiteral"; readonly arrayItemList: List<ArrayItem> }
  | { readonly _: "ObjectLiteral"; readonly memberList: List<Member> }
  | { readonly _: "Lambda"; readonly lambdaExpr: LambdaExpr }
  | { readonly _: "Variable"; readonly identifer: Identifer }
  | { readonly _: "GlobalObjects"; readonly identifer: Identifer }
  | {
      readonly _: "ImportedVariable";
      readonly importedVariable: ImportedVariable;
    }
  | { readonly _: "Get"; readonly getExpr: GetExpr }
  | { readonly _: "Call"; readonly callExpr: CallExpr }
  | { readonly _: "New"; readonly callExpr: CallExpr }
  | { readonly _: "TypeAssertion"; readonly typeAssertion: TypeAssertion };

/**
 * forOf文
 * @typePartId 8be8db4404f302dd36c8a2c6c6e37e7c
 */
export type ForOfStatement = {
  /**
   * 要素の変数名
   */
  readonly elementVariableName: Identifer;
  /**
   * 繰り返す対象
   */
  readonly iterableExpr: Expr;
  /**
   * 繰り返す文
   */
  readonly statementList: List<Statement>;
};

/**
 * TypeScriptやJavaScriptのコードを表現する. TypeScriptでも出力できるように型情報をつける必要がある
 * @typePartId 92ea504049ca5b7e2227a95195fe74eb
 */
export type JsTsCode = {
  /**
   * 外部に公開する定義
   */
  readonly exportDefinitionList: List<ExportDefinition>;
  /**
   * 定義した後に実行するコード
   */
  readonly statementList: List<Statement>;
};

/**
 * 関数の型
 * @typePartId 98904215e50e04fa2197a7a96df8f646
 */
export type FunctionType = {
  /**
   * 型パラメーターのリスト
   */
  readonly typeParameterList: List<Identifer>;
  /**
   * パラメーターの型. 意味のない引数名は適当に付く
   */
  readonly parameterList: List<Type>;
  /**
   * 戻り値の型
   */
  readonly return: Type;
};

/**
 * 式と呼ぶパラメーター
 * @typePartId a1f71188b7c3ab2a21954471f3ac67f1
 */
export type CallExpr = {
  /**
   * 呼ばれる式
   */
  readonly expr: Expr;
  /**
   * パラメーター
   */
  readonly parameterList: List<Expr>;
};

/**
 * @typePartId a2580a29c047f54d635c4456696bbef3
 */
export type Variable = {
  /**
   * 変数の名前
   */
  readonly name: Identifer;
  /**
   * ドキュメント
   */
  readonly document: String;
  /**
   * 変数の型
   */
  readonly type: Type;
  /**
   * 変数の式
   */
  readonly expr: Expr;
};

/**
 * プロパティアクセス
 * @typePartId a9ce526a22f09800aa3773a1614cce89
 */
export type GetExpr = {
  /**
   * 式
   */
  readonly expr: Expr;
  /**
   * プロパティの式
   */
  readonly propertyExpr: Expr;
};

/**
 * インポートされた型
 * @typePartId b44289bc65640d4ad0ad79a5a627ef78
 */
export type ImportedType = {
  /**
   * モジュール名. namedImportされるがその識別子は自動的に作成される
   */
  readonly moduleName: String;
  /**
   * 型の名前
   */
  readonly name: Identifer;
};

/**
 * DefinyWebアプリ内での場所を示すもの. URLから求められる. URLに変換できる
 * @typePartId bbcb8e43df8afff9fe24b001c66fb065
 */
export type Location =
  | { readonly _: "Home" }
  | { readonly _: "CreateProject" }
  | { readonly _: "Project"; readonly projectId: ProjectId }
  | { readonly _: "Account"; readonly accountId: AccountId }
  | { readonly _: "Setting" }
  | { readonly _: "About" }
  | { readonly _: "Debug" };

/**
 * TypeAlias. `export type T = {}`
 * @typePartId bf69f7e46f5e4949fe801c234fc3ad15
 */
export type TypeAlias = {
  /**
   * 型の名前
   */
  readonly name: Identifer;
  /**
   * 型パラメーターのリスト
   */
  readonly typeParameterList: List<Identifer>;
  /**
   * ドキュメント
   */
  readonly document: String;
  /**
   * 型本体
   */
  readonly type: Type;
};

/**
 * アカウントの識別子
 * @typePartId c1a17b07e8e664ca80217833ff2ad3f1
 */
export type AccountId = string & { readonly _accountId: never };

/**
 * 文字列のkeyと式のvalue
 * @typePartId c2428cbcd62b33ce2c904a200b876863
 */
export type KeyValue = {
  /**
   * key
   */
  readonly key: String;
  /**
   * value
   */
  readonly value: Expr;
};

/**
 * リスト. JavaScriptのArrayで扱う
 * @typePartId c3fc2a6cea61086db59e11dc2bef0eee
 */
export type List<element extends unknown> = ReadonlyArray<element>;

/**
 * for文
 * @typePartId c53be8bcaf56ff90080cf7a75f1e4815
 */
export type ForStatement = {
  /**
   * カウンタ変数名
   */
  readonly counterVariableName: Identifer;
  /**
   * ループの上限の式
   */
  readonly untilExpr: Expr;
  /**
   * 繰り返す文
   */
  readonly statementList: List<Statement>;
};

/**
 * オブジェクトのメンバーの型
 * @typePartId c68bac5afb1a1d35af096bf317d09339
 */
export type MemberType = {
  /**
   * プロパティ名
   */
  readonly name: String;
  /**
   * 必須かどうか falseの場合 ? がつく
   */
  readonly required: Bool;
  /**
   * 型
   */
  readonly type: Type;
  /**
   * ドキュメント
   */
  readonly document: String;
};

/**
 * 条件演算子
 * @typePartId c7a771f770f0f92690faeb59eaff6268
 */
export type ConditionalOperatorExpr = {
  /**
   * 条件の式
   */
  readonly condition: Expr;
  /**
   * 条件がtrueのときに評価される式
   */
  readonly thenExpr: Expr;
  /**
   * 条件がfalseのときに評価される式
   */
  readonly elseExpr: Expr;
};

/**
 * if文
 * @typePartId cd325760f992e47a8438ae78ca9b1529
 */
export type IfStatement = {
  /**
   * 条件の式
   */
  readonly condition: Expr;
  /**
   * 条件がtrueのときに実行する文
   */
  readonly thenStatementList: List<Statement>;
};

/**
 * 交差型
 * @typePartId d82150857d0f2e78c1df0f418ba9b01a
 */
export type IntersectionType = {
  /**
   * 左に指定する型
   */
  readonly left: Type;
  /**
   * 右に指定する型
   */
  readonly right: Type;
};

/**
 * Bool. 真か偽. JavaScriptのbooleanで扱える. true: 1, false: 0. (1byte)としてバイナリに変換する
 * @typePartId db57caf129f60db969b5b5224a72b937
 */
export type Bool = boolean;

/**
 * 外部に公開する関数
 * @typePartId dd3366ce7254327c85732d2932ff219b
 */
export type Function = {
  /**
   * 外部に公開する関数の名前
   */
  readonly name: Identifer;
  /**
   * ドキュメント
   */
  readonly document: String;
  /**
   * 型パラメーターのリスト
   */
  readonly typeParameterList: List<Identifer>;
  /**
   * パラメーター
   */
  readonly parameterList: List<ParameterWithDocument>;
  /**
   * 戻り値の型
   */
  readonly returnType: Type;
  /**
   * 関数の本体
   */
  readonly statementList: List<Statement>;
};

/**
 * アカウントトークン. アカウントトークンを持っていればアクセストークンをDefinyのサーバーにリクエストした際に得られるIDのアカウントを保有していると証明できる. サーバーにハッシュ化したものを保存している. これが盗まれた場合,不正に得た人はアカウントを乗っ取ることができる. 有効期限はなし, 最後に発行したアカウントトークン以外は無効になる
 * @typePartId deb01f82879754c03aa4d244e136e59d
 */
export type AccountToken = string & { readonly _accountToken: never };

/**
 * ローカル関数定義
 * @typePartId df5c5388248252a92864ceb219628b8e
 */
export type FunctionDefinitionStatement = {
  /**
   * 変数名
   */
  readonly name: Identifer;
  /**
   * 型パラメーターのリスト
   */
  readonly typeParameterList: List<Identifer>;
  /**
   * パラメーターのリスト
   */
  readonly parameterList: List<ParameterWithDocument>;
  /**
   * 戻り値の型
   */
  readonly returnType: Type;
  /**
   * 関数本体
   */
  readonly statementList: List<Statement>;
};

/**
 * 画像から求められるトークン.キャッシュのキーとして使われる.1つのトークンに対して永久に1つの画像データしか表さない. キャッシュを更新する必要はない
 * @typePartId e71e15a15b0883940a75e58367151d1a
 */
export type ImageHash = string & { readonly _imageHash: never };

/**
 * デベロップモードか, リリースモード
 * @typePartId ee0590e764618611ffa8e1a0a2e22f79
 */
export type ClientMode = "Develop" | "Release";

/**
 * 2項演算子と左右の式
 * @typePartId eec2dab74fbcd3237bfa1c773f9b9d21
 */
export type BinaryOperatorExpr = {
  /**
   * 2項演算子
   */
  readonly operator: BinaryOperator;
  /**
   * 左の式
   */
  readonly left: Expr;
  /**
   * 右の式
   */
  readonly right: Expr;
};

/**
 * 出力するコードの種類
 * @typePartId eedf73c97f9dd61159572322f6d7e0a5
 */
export type CodeType = "JavaScript" | "TypeScript";

/**
 * ラムダ式
 * @typePartId eeeef818144e5a42460c4efdaa221460
 */
export type LambdaExpr = {
  /**
   * パラメーターのリスト
   */
  readonly parameterList: List<Parameter>;
  /**
   * 型パラメーターのリスト
   */
  readonly typeParameterList: List<Identifer>;
  /**
   * 戻り値の型
   */
  readonly returnType: Type;
  /**
   * ラムダ式本体
   */
  readonly statementList: List<Statement>;
};

/**
 * ログインのURLを発行するために必要なデータ
 * @typePartId f03ea5331c1a3adcde80a04054d35e07
 */
export type RequestLogInUrlRequestData = {
  /**
   * ログインに使用するプロバイダー
   */
  readonly openIdConnectProvider: OpenIdConnectProvider;
  /**
   * ログインした後に返ってくるURLに必要なデータ
   */
  readonly urlData: UrlData;
};

/**
 * JavaScriptのオブジェクトリテラルの要素
 * @typePartId fddd2a65994fae205dd636f3a6b9f1ea
 */
export type Member =
  | { readonly _: "Spread"; readonly expr: Expr }
  | { readonly _: "KeyValue"; readonly keyValue: KeyValue };

/**
 * 外部に公開する定義
 * @typePartId 0c8b854b812290a054877ca5de6c4daf
 */
export const ExportDefinition: {
  /**
   * TypeAlias
   */
  readonly TypeAlias: (a: TypeAlias) => ExportDefinition;
  /**
   * Function
   */
  readonly Function: (a: Function) => ExportDefinition;
  /**
   * Variable
   */
  readonly Variable: (a: Variable) => ExportDefinition;
  readonly codec: Codec<ExportDefinition>;
} = {
  TypeAlias: (typeAlias: TypeAlias): ExportDefinition => ({
    _: "TypeAlias",
    typeAlias,
  }),
  Function: (function_: Function): ExportDefinition => ({
    _: "Function",
    function: function_,
  }),
  Variable: (variable: Variable): ExportDefinition => ({
    _: "Variable",
    variable,
  }),
  codec: {
    encode: (value: ExportDefinition): ReadonlyArray<number> => {
      switch (value._) {
        case "TypeAlias": {
          return [0].concat(TypeAlias.codec.encode(value.typeAlias));
        }
        case "Function": {
          return [1].concat(Function.codec.encode(value.function));
        }
        case "Variable": {
          return [2].concat(Variable.codec.encode(value.variable));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ExportDefinition; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: TypeAlias;
          readonly nextIndex: number;
        } = TypeAlias.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ExportDefinition.TypeAlias(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: Function;
          readonly nextIndex: number;
        } = Function.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ExportDefinition.Function(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: Variable;
          readonly nextIndex: number;
        } = Variable.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: ExportDefinition.Variable(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 単項演算子と適用される式
 * @typePartId 0cb0a34b3953e57b30f4a5c8f9d305da
 */
export const UnaryOperatorExpr: {
  readonly codec: Codec<UnaryOperatorExpr>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: UnaryOperatorExpr) => UnaryOperatorExpr;
} = {
  helper: (unaryOperatorExpr: UnaryOperatorExpr): UnaryOperatorExpr =>
    unaryOperatorExpr,
  codec: {
    encode: (value: UnaryOperatorExpr): ReadonlyArray<number> =>
      UnaryOperator.codec
        .encode(value.operator)
        .concat(Expr.codec.encode(value.expr)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: UnaryOperatorExpr; readonly nextIndex: number } => {
      const operatorAndNextIndex: {
        readonly result: UnaryOperator;
        readonly nextIndex: number;
      } = UnaryOperator.codec.decode(index, binary);
      const exprAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(operatorAndNextIndex.nextIndex, binary);
      return {
        result: {
          operator: operatorAndNextIndex.result,
          expr: exprAndNextIndex.result,
        },
        nextIndex: exprAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * プロジェクトの識別子
 * @typePartId 0cd913118a2ad1469d656146a08c5f76
 */
export const ProjectId: { readonly codec: Codec<ProjectId> } = {
  codec: {
    encode: (value: ProjectId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ProjectId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: ProjectId;
        readonly nextIndex: number;
      },
  },
};

/**
 * 英語,日本語,エスペラント語などの言語
 * @typePartId 0d9510723f4d34605e41f3a47a8b0ea7
 */
export const Language: {
  /**
   * 日本語
   */
  readonly Japanese: Language;
  /**
   * 英語
   */
  readonly English: Language;
  /**
   * エスペラント語
   */
  readonly Esperanto: Language;
  readonly codec: Codec<Language>;
} = {
  Japanese: "Japanese",
  English: "English",
  Esperanto: "Esperanto",
  codec: {
    encode: (value: Language): ReadonlyArray<number> => {
      switch (value) {
        case "Japanese": {
          return [0];
        }
        case "English": {
          return [1];
        }
        case "Esperanto": {
          return [2];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Language; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: Language.Japanese, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return { result: Language.English, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 2) {
        return {
          result: Language.Esperanto,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * -2 147 483 648 ～ 2 147 483 647. 32bit 符号付き整数. JavaScriptのnumberとして扱える. numberの32bit符号あり整数をSigned Leb128のバイナリに変換する
 * @typePartId 16c2d8602e3e5e2d38b9215bd0c44d8d
 */
export const Int32: { readonly codec: Codec<Int32> } = {
  codec: {
    encode: (value: Int32): ReadonlyArray<number> => {
      let rest: number = value | 0;
      const result: Array<number> = [];
      while (true) {
        const byte: number = rest & 127;
        rest >>= 7;
        if (
          (rest === 0 && (byte & 64) === 0) ||
          (rest === -1 && (byte & 64) !== 0)
        ) {
          result.push(byte);
          return result;
        }
        result.push(byte | 128);
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Int32; readonly nextIndex: number } => {
      let result: number = 0;
      let offset: number = 0;
      while (true) {
        const byte: number | undefined = binary[index + offset];
        if (byte === undefined) {
          throw new Error("invalid byte in decode int32");
        }
        result |= (byte & 127) << (offset * 7);
        offset += 1;
        if ((128 & byte) === 0) {
          if (offset * 7 < 32 && (byte & 64) !== 0) {
            return {
              result: result | (~0 << (offset * 7)),
              nextIndex: index + offset,
            };
          }
          return { result, nextIndex: index + offset };
        }
      }
    },
  },
};

/**
 * @typePartId 1835ebdc909b0fa93d11ae0ed93d0606
 */
export const Type: {
  /**
   * プリミティブの型のnumber
   */
  readonly Number: Type;
  /**
   * プリミティブの型のstring
   */
  readonly String: Type;
  /**
   * プリミティブの型のboolean
   */
  readonly Boolean: Type;
  /**
   * プリミティブの型のundefined
   */
  readonly Undefined: Type;
  /**
   * プリミティブの型のnull
   */
  readonly Null: Type;
  /**
   * never型
   */
  readonly Never: Type;
  /**
   * void型
   */
  readonly Void: Type;
  /**
   * オブジェクト
   */
  readonly Object: (a: List<MemberType>) => Type;
  /**
   * 関数 `(parameter: parameter) => returnType`
   */
  readonly Function: (a: FunctionType) => Type;
  /**
   * 型パラメータ付きの型 `Promise<number>` `ReadonlyArray<string>`
   */
  readonly WithTypeParameter: (a: TypeWithTypeParameter) => Type;
  /**
   * ユニオン型 `a | b`
   */
  readonly Union: (a: List<Type>) => Type;
  /**
   * "交差型 `left & right`
   */
  readonly Intersection: (a: IntersectionType) => Type;
  /**
   * インポートされた外部の型
   */
  readonly ImportedType: (a: ImportedType) => Type;
  /**
   * ファイル内で定義された型
   */
  readonly ScopeInFile: (a: Identifer) => Type;
  /**
   * グローバル空間の型
   */
  readonly ScopeInGlobal: (a: Identifer) => Type;
  /**
   * 文字列リテラル型
   */
  readonly StringLiteral: (a: String) => Type;
  readonly codec: Codec<Type>;
} = {
  Number: { _: "Number" },
  String: { _: "String" },
  Boolean: { _: "Boolean" },
  Undefined: { _: "Undefined" },
  Null: { _: "Null" },
  Never: { _: "Never" },
  Void: { _: "Void" },
  Object: (memberTypeList: List<MemberType>): Type => ({
    _: "Object",
    memberTypeList,
  }),
  Function: (functionType: FunctionType): Type => ({
    _: "Function",
    functionType,
  }),
  WithTypeParameter: (typeWithTypeParameter: TypeWithTypeParameter): Type => ({
    _: "WithTypeParameter",
    typeWithTypeParameter,
  }),
  Union: (typeList: List<Type>): Type => ({ _: "Union", typeList }),
  Intersection: (intersectionType: IntersectionType): Type => ({
    _: "Intersection",
    intersectionType,
  }),
  ImportedType: (importedType: ImportedType): Type => ({
    _: "ImportedType",
    importedType,
  }),
  ScopeInFile: (identifer: Identifer): Type => ({
    _: "ScopeInFile",
    identifer,
  }),
  ScopeInGlobal: (identifer: Identifer): Type => ({
    _: "ScopeInGlobal",
    identifer,
  }),
  StringLiteral: (string_: String): Type => ({
    _: "StringLiteral",
    string: string_,
  }),
  codec: {
    encode: (value: Type): ReadonlyArray<number> => {
      switch (value._) {
        case "Number": {
          return [0];
        }
        case "String": {
          return [1];
        }
        case "Boolean": {
          return [2];
        }
        case "Undefined": {
          return [3];
        }
        case "Null": {
          return [4];
        }
        case "Never": {
          return [5];
        }
        case "Void": {
          return [6];
        }
        case "Object": {
          return [7].concat(
            List.codec(MemberType.codec).encode(value.memberTypeList)
          );
        }
        case "Function": {
          return [8].concat(FunctionType.codec.encode(value.functionType));
        }
        case "WithTypeParameter": {
          return [9].concat(
            TypeWithTypeParameter.codec.encode(value.typeWithTypeParameter)
          );
        }
        case "Union": {
          return [10].concat(List.codec(Type.codec).encode(value.typeList));
        }
        case "Intersection": {
          return [11].concat(
            IntersectionType.codec.encode(value.intersectionType)
          );
        }
        case "ImportedType": {
          return [12].concat(ImportedType.codec.encode(value.importedType));
        }
        case "ScopeInFile": {
          return [13].concat(Identifer.codec.encode(value.identifer));
        }
        case "ScopeInGlobal": {
          return [14].concat(Identifer.codec.encode(value.identifer));
        }
        case "StringLiteral": {
          return [15].concat(String.codec.encode(value.string));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Type; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: Type.Number, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return { result: Type.String, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 2) {
        return { result: Type.Boolean, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 3) {
        return { result: Type.Undefined, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 4) {
        return { result: Type.Null, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 5) {
        return { result: Type.Never, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 6) {
        return { result: Type.Void, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 7) {
        const result: {
          readonly result: List<MemberType>;
          readonly nextIndex: number;
        } = List.codec(MemberType.codec).decode(patternIndex.nextIndex, binary);
        return {
          result: Type.Object(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 8) {
        const result: {
          readonly result: FunctionType;
          readonly nextIndex: number;
        } = FunctionType.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Type.Function(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 9) {
        const result: {
          readonly result: TypeWithTypeParameter;
          readonly nextIndex: number;
        } = TypeWithTypeParameter.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Type.WithTypeParameter(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 10) {
        const result: {
          readonly result: List<Type>;
          readonly nextIndex: number;
        } = List.codec(Type.codec).decode(patternIndex.nextIndex, binary);
        return {
          result: Type.Union(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 11) {
        const result: {
          readonly result: IntersectionType;
          readonly nextIndex: number;
        } = IntersectionType.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Type.Intersection(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 12) {
        const result: {
          readonly result: ImportedType;
          readonly nextIndex: number;
        } = ImportedType.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Type.ImportedType(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 13) {
        const result: {
          readonly result: Identifer;
          readonly nextIndex: number;
        } = Identifer.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Type.ScopeInFile(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 14) {
        const result: {
          readonly result: Identifer;
          readonly nextIndex: number;
        } = Identifer.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Type.ScopeInGlobal(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 15) {
        const result: {
          readonly result: String;
          readonly nextIndex: number;
        } = String.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Type.StringLiteral(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * Unit. 1つの値しかない型. JavaScriptのundefinedで扱う
 * @typePartId 217263d8cdca613c2d1ba77e19d4cbb0
 */
export const Unit: {
  /**
   * Unit型にある.唯一の値
   */
  readonly UnitValue: Unit;
  readonly codec: Codec<Unit>;
} = {
  UnitValue: undefined,
  codec: {
    encode: (value: Unit): ReadonlyArray<number> => [],
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Unit; readonly nextIndex: number } => ({
      result: Unit.UnitValue,
      nextIndex: index,
    }),
  },
};

/**
 * パラメーター付きの型
 * @typePartId 23fa0e8b66c9d093d4c18579ffefaaa3
 */
export const TypeWithTypeParameter: {
  readonly codec: Codec<TypeWithTypeParameter>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: TypeWithTypeParameter) => TypeWithTypeParameter;
} = {
  helper: (
    typeWithTypeParameter: TypeWithTypeParameter
  ): TypeWithTypeParameter => typeWithTypeParameter,
  codec: {
    encode: (value: TypeWithTypeParameter): ReadonlyArray<number> =>
      Type.codec
        .encode(value.type)
        .concat(List.codec(Type.codec).encode(value.typeParameterList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: TypeWithTypeParameter;
      readonly nextIndex: number;
    } => {
      const typeAndNextIndex: {
        readonly result: Type;
        readonly nextIndex: number;
      } = Type.codec.decode(index, binary);
      const typeParameterListAndNextIndex: {
        readonly result: List<Type>;
        readonly nextIndex: number;
      } = List.codec(Type.codec).decode(typeAndNextIndex.nextIndex, binary);
      return {
        result: {
          type: typeAndNextIndex.result,
          typeParameterList: typeParameterListAndNextIndex.result,
        },
        nextIndex: typeParameterListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * TypeScriptの識別子として使える文字
 * @typePartId 2a75ad7c7ccc58ba56f6c8545c8150d1
 */
export const Identifer: {
  /**
   * **直接 Identifer.Identifer("name") と指定してはいけない!! TypeScriptの識別子として使える文字としてチェックできないため**
   */
  readonly Identifer: (a: String) => Identifer;
  readonly codec: Codec<Identifer>;
} = {
  Identifer: (string_: String): Identifer => ({
    _: "Identifer",
    string: string_,
  }),
  codec: {
    encode: (value: Identifer): ReadonlyArray<number> => {
      switch (value._) {
        case "Identifer": {
          return [0].concat(String.codec.encode(value.string));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Identifer; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: String;
          readonly nextIndex: number;
        } = String.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Identifer.Identifer(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * Maybe. nullableのようなもの. 今後はRustのstd::Optionに出力するために属性をつけよう (確信)
 * @typePartId 304f21ae8208a21d08731aa6d183742d
 */
export const Maybe: {
  /**
   * 値があるということ
   */
  readonly Just: <value extends unknown>(a: value) => Maybe<value>;
  /**
   * 値がないということ
   */
  readonly Nothing: <value extends unknown>() => Maybe<value>;
  readonly codec: <value extends unknown>(
    a: Codec<value>
  ) => Codec<Maybe<value>>;
} = {
  Just: <value extends unknown>(value: value): Maybe<value> => ({
    _: "Just",
    value,
  }),
  Nothing: <value extends unknown>(): Maybe<value> => ({ _: "Nothing" }),
  codec: <value extends unknown>(
    valueCodec: Codec<value>
  ): Codec<Maybe<value>> => ({
    encode: (value: Maybe<value>): ReadonlyArray<number> => {
      switch (value._) {
        case "Just": {
          return [0].concat(valueCodec.encode(value.value));
        }
        case "Nothing": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Maybe<value>; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: value;
          readonly nextIndex: number;
        } = valueCodec.decode(patternIndex.nextIndex, binary);
        return {
          result: Maybe.Just(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return { result: Maybe.Nothing(), nextIndex: patternIndex.nextIndex };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  }),
};

/**
 * 配列リテラルの要素
 * @typePartId 35f7e442c0838f9982e6b49da398d97f
 */
export const ArrayItem: {
  readonly codec: Codec<ArrayItem>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ArrayItem) => ArrayItem;
} = {
  helper: (arrayItem: ArrayItem): ArrayItem => arrayItem,
  codec: {
    encode: (value: ArrayItem): ReadonlyArray<number> =>
      Expr.codec.encode(value.expr).concat(Bool.codec.encode(value.spread)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ArrayItem; readonly nextIndex: number } => {
      const exprAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(index, binary);
      const spreadAndNextIndex: {
        readonly result: Bool;
        readonly nextIndex: number;
      } = Bool.codec.decode(exprAndNextIndex.nextIndex, binary);
      return {
        result: {
          expr: exprAndNextIndex.result,
          spread: spreadAndNextIndex.result,
        },
        nextIndex: spreadAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * バイナリ. JavaScriptのUint8Arrayで扱える. 最初にLED128でバイト数, その次にバイナリそのまま
 * @typePartId 3e2f740c88923b0393a1ef93d92f157b
 */
export const Binary: { readonly codec: Codec<Binary> } = {
  codec: {
    encode: (value: Binary): ReadonlyArray<number> =>
      Int32.codec.encode(value.length).concat([...value]),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Binary; readonly nextIndex: number } => {
      const length: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      const nextIndex: number = length.nextIndex + length.result;
      return { result: binary.slice(length.nextIndex, nextIndex), nextIndex };
    },
  },
};

/**
 * 2項演算子
 * @typePartId 4953938f040aefdaa5f2601e2a78d43b
 */
export const BinaryOperator: {
  /**
   * べき乗 `a ** b`
   */
  readonly Exponentiation: BinaryOperator;
  /**
   * 数値の掛け算 `a * b`
   */
  readonly Multiplication: BinaryOperator;
  /**
   * 数値の割り算 `a / b`
   */
  readonly Division: BinaryOperator;
  /**
   * 剰余演算 `a % b`
   */
  readonly Remainder: BinaryOperator;
  /**
   * 数値の足し算, 文字列の結合 `a + b`
   */
  readonly Addition: BinaryOperator;
  /**
   * 数値の引き算 `a - b`
   */
  readonly Subtraction: BinaryOperator;
  /**
   * 左シフト `a << b`
   */
  readonly LeftShift: BinaryOperator;
  /**
   * 符号を維持する右シフト `a >> b`
   */
  readonly SignedRightShift: BinaryOperator;
  /**
   * 符号を維持しない(0埋め)右シフト `a >>> b`
   */
  readonly UnsignedRightShift: BinaryOperator;
  /**
   * 未満 `a < b`
   */
  readonly LessThan: BinaryOperator;
  /**
   * 以下 `a <= b`
   */
  readonly LessThanOrEqual: BinaryOperator;
  /**
   * 等号 `a === b`
   */
  readonly Equal: BinaryOperator;
  /**
   * 不等号 `a !== b`
   */
  readonly NotEqual: BinaryOperator;
  /**
   * ビットAND `a & b`
   */
  readonly BitwiseAnd: BinaryOperator;
  /**
   * ビットXOR `a ^ b`
   */
  readonly BitwiseXOr: BinaryOperator;
  /**
   * ビットOR `a | b`
   */
  readonly BitwiseOr: BinaryOperator;
  /**
   * 論理AND `a && b`
   */
  readonly LogicalAnd: BinaryOperator;
  /**
   * 論理OR `a || b`
   */
  readonly LogicalOr: BinaryOperator;
  readonly codec: Codec<BinaryOperator>;
} = {
  Exponentiation: "Exponentiation",
  Multiplication: "Multiplication",
  Division: "Division",
  Remainder: "Remainder",
  Addition: "Addition",
  Subtraction: "Subtraction",
  LeftShift: "LeftShift",
  SignedRightShift: "SignedRightShift",
  UnsignedRightShift: "UnsignedRightShift",
  LessThan: "LessThan",
  LessThanOrEqual: "LessThanOrEqual",
  Equal: "Equal",
  NotEqual: "NotEqual",
  BitwiseAnd: "BitwiseAnd",
  BitwiseXOr: "BitwiseXOr",
  BitwiseOr: "BitwiseOr",
  LogicalAnd: "LogicalAnd",
  LogicalOr: "LogicalOr",
  codec: {
    encode: (value: BinaryOperator): ReadonlyArray<number> => {
      switch (value) {
        case "Exponentiation": {
          return [0];
        }
        case "Multiplication": {
          return [1];
        }
        case "Division": {
          return [2];
        }
        case "Remainder": {
          return [3];
        }
        case "Addition": {
          return [4];
        }
        case "Subtraction": {
          return [5];
        }
        case "LeftShift": {
          return [6];
        }
        case "SignedRightShift": {
          return [7];
        }
        case "UnsignedRightShift": {
          return [8];
        }
        case "LessThan": {
          return [9];
        }
        case "LessThanOrEqual": {
          return [10];
        }
        case "Equal": {
          return [11];
        }
        case "NotEqual": {
          return [12];
        }
        case "BitwiseAnd": {
          return [13];
        }
        case "BitwiseXOr": {
          return [14];
        }
        case "BitwiseOr": {
          return [15];
        }
        case "LogicalAnd": {
          return [16];
        }
        case "LogicalOr": {
          return [17];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: BinaryOperator; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: BinaryOperator.Exponentiation,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: BinaryOperator.Multiplication,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        return {
          result: BinaryOperator.Division,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        return {
          result: BinaryOperator.Remainder,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 4) {
        return {
          result: BinaryOperator.Addition,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 5) {
        return {
          result: BinaryOperator.Subtraction,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 6) {
        return {
          result: BinaryOperator.LeftShift,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 7) {
        return {
          result: BinaryOperator.SignedRightShift,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 8) {
        return {
          result: BinaryOperator.UnsignedRightShift,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 9) {
        return {
          result: BinaryOperator.LessThan,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 10) {
        return {
          result: BinaryOperator.LessThanOrEqual,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 11) {
        return {
          result: BinaryOperator.Equal,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 12) {
        return {
          result: BinaryOperator.NotEqual,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 13) {
        return {
          result: BinaryOperator.BitwiseAnd,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 14) {
        return {
          result: BinaryOperator.BitwiseXOr,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 15) {
        return {
          result: BinaryOperator.BitwiseOr,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 16) {
        return {
          result: BinaryOperator.LogicalAnd,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 17) {
        return {
          result: BinaryOperator.LogicalOr,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 型アサーション
 * @typePartId 49f05a756bd75da670fa5b64ed8bf1ae
 */
export const TypeAssertion: {
  readonly codec: Codec<TypeAssertion>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: TypeAssertion) => TypeAssertion;
} = {
  helper: (typeAssertion: TypeAssertion): TypeAssertion => typeAssertion,
  codec: {
    encode: (value: TypeAssertion): ReadonlyArray<number> =>
      Expr.codec.encode(value.expr).concat(Type.codec.encode(value.type)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypeAssertion; readonly nextIndex: number } => {
      const exprAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(index, binary);
      const typeAndNextIndex: {
        readonly result: Type;
        readonly nextIndex: number;
      } = Type.codec.decode(exprAndNextIndex.nextIndex, binary);
      return {
        result: {
          expr: exprAndNextIndex.result,
          type: typeAndNextIndex.result,
        },
        nextIndex: typeAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * JavaScriptの単項演算子
 * @typePartId 4b4c3f8f34d1c05bb9d7d1b930bc9c9a
 */
export const UnaryOperator: {
  /**
   * 単項マイナス演算子 `-a`
   */
  readonly Minus: UnaryOperator;
  /**
   * ビット否定 `~a`
   */
  readonly BitwiseNot: UnaryOperator;
  /**
   * 論理否定 `!a`
   */
  readonly LogicalNot: UnaryOperator;
  readonly codec: Codec<UnaryOperator>;
} = {
  Minus: "Minus",
  BitwiseNot: "BitwiseNot",
  LogicalNot: "LogicalNot",
  codec: {
    encode: (value: UnaryOperator): ReadonlyArray<number> => {
      switch (value) {
        case "Minus": {
          return [0];
        }
        case "BitwiseNot": {
          return [1];
        }
        case "LogicalNot": {
          return [2];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: UnaryOperator; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: UnaryOperator.Minus,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: UnaryOperator.BitwiseNot,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        return {
          result: UnaryOperator.LogicalNot,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 関数のパラメーター. パラメーター名, 型
 * @typePartId 5433bade7738da21e7663ff043f588d5
 */
export const Parameter: {
  readonly codec: Codec<Parameter>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: Parameter) => Parameter;
} = {
  helper: (parameter: Parameter): Parameter => parameter,
  codec: {
    encode: (value: Parameter): ReadonlyArray<number> =>
      Identifer.codec.encode(value.name).concat(Type.codec.encode(value.type)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Parameter; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: Identifer;
        readonly nextIndex: number;
      } = Identifer.codec.decode(index, binary);
      const typeAndNextIndex: {
        readonly result: Type;
        readonly nextIndex: number;
      } = Type.codec.decode(nameAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          type: typeAndNextIndex.result,
        },
        nextIndex: typeAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * パーツの識別子
 * @typePartId 5880cd7c0b6f0205c739a06181898d03
 */
export const PartId: { readonly codec: Codec<PartId> } = {
  codec: {
    encode: (value: PartId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: PartId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: PartId;
        readonly nextIndex: number;
      },
  },
};

/**
 * タグの識別子. タグは直和型に使うもの.
 * @typePartId 5ec292c48424e5e9ee8cc2d672830ecd
 */
export const TagId: { readonly codec: Codec<TagId> } = {
  codec: {
    encode: (value: TagId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TagId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: TagId;
        readonly nextIndex: number;
      },
  },
};

/**
 * switch文のcase "text": { statementList } の部分
 * @typePartId 6126431def47ecba239b3add7f472b19
 */
export const Pattern: {
  readonly codec: Codec<Pattern>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: Pattern) => Pattern;
} = {
  helper: (pattern: Pattern): Pattern => pattern,
  codec: {
    encode: (value: Pattern): ReadonlyArray<number> =>
      String.codec
        .encode(value.caseString)
        .concat(List.codec(Statement.codec).encode(value.statementList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Pattern; readonly nextIndex: number } => {
      const caseStringAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const statementListAndNextIndex: {
        readonly result: List<Statement>;
        readonly nextIndex: number;
      } = List.codec(Statement.codec).decode(
        caseStringAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          caseString: caseStringAndNextIndex.result,
          statementList: statementListAndNextIndex.result,
        },
        nextIndex: statementListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 文字列. JavaScriptのstringで扱う. バイナリ形式はUTF-8. 不正な文字が入っている可能性がある
 * @typePartId 666361c9ae68ab64f273c47f3feb8c73
 */
export const String: { readonly codec: Codec<String> } = {
  codec: {
    encode: (value: String): ReadonlyArray<number> => {
      const result: ReadonlyArray<number> = [
        ...new TextEncoder().encode(value),
      ];
      return Int32.codec.encode(result.length).concat(result);
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: String; readonly nextIndex: number } => {
      const length: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      const nextIndex: number = length.nextIndex + length.result;
      const textBinary: Uint8Array = binary.slice(length.nextIndex, nextIndex);
      return { result: new TextDecoder().decode(textBinary), nextIndex };
    },
  },
};

/**
 * 代入文
 * @typePartId 6a5a7886b0f117a50d9d7b11ffe87c9f
 */
export const SetStatement: {
  readonly codec: Codec<SetStatement>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: SetStatement) => SetStatement;
} = {
  helper: (setStatement: SetStatement): SetStatement => setStatement,
  codec: {
    encode: (value: SetStatement): ReadonlyArray<number> =>
      Expr.codec
        .encode(value.target)
        .concat(Maybe.codec(BinaryOperator.codec).encode(value.operatorMaybe))
        .concat(Expr.codec.encode(value.expr)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: SetStatement; readonly nextIndex: number } => {
      const targetAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(index, binary);
      const operatorMaybeAndNextIndex: {
        readonly result: Maybe<BinaryOperator>;
        readonly nextIndex: number;
      } = Maybe.codec(BinaryOperator.codec).decode(
        targetAndNextIndex.nextIndex,
        binary
      );
      const exprAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(operatorMaybeAndNextIndex.nextIndex, binary);
      return {
        result: {
          target: targetAndNextIndex.result,
          operatorMaybe: operatorMaybeAndNextIndex.result,
          expr: exprAndNextIndex.result,
        },
        nextIndex: exprAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * ドキュメント付きの関数のパラメーター. パラメーター名, ドキュメント, 型
 * @typePartId 6b05e33009ade6b4decd452e8fd4bff1
 */
export const ParameterWithDocument: {
  readonly codec: Codec<ParameterWithDocument>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ParameterWithDocument) => ParameterWithDocument;
} = {
  helper: (
    parameterWithDocument: ParameterWithDocument
  ): ParameterWithDocument => parameterWithDocument,
  codec: {
    encode: (value: ParameterWithDocument): ReadonlyArray<number> =>
      Identifer.codec
        .encode(value.name)
        .concat(String.codec.encode(value.document))
        .concat(Type.codec.encode(value.type)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: ParameterWithDocument;
      readonly nextIndex: number;
    } => {
      const nameAndNextIndex: {
        readonly result: Identifer;
        readonly nextIndex: number;
      } = Identifer.codec.decode(index, binary);
      const documentAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
      const typeAndNextIndex: {
        readonly result: Type;
        readonly nextIndex: number;
      } = Type.codec.decode(documentAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          document: documentAndNextIndex.result,
          type: typeAndNextIndex.result,
        },
        nextIndex: typeAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 型パーツの識別子
 * @typePartId 6e3cff317f8bfbbd1391c0afb9ad6b72
 */
export const TypePartId: { readonly codec: Codec<TypePartId> } = {
  codec: {
    encode: (value: TypePartId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypePartId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: TypePartId;
        readonly nextIndex: number;
      },
  },
};

/**
 * 成功と失敗を表す型. 今後はRustのstd::Resultに出力するために属性をつける?
 * @typePartId 6f937e46fce1cf70d29c54780f132c18
 */
export const Result: {
  /**
   * 成功
   */
  readonly Ok: <ok extends unknown, error extends unknown>(
    a: ok
  ) => Result<ok, error>;
  /**
   * 失敗
   */
  readonly Error: <ok extends unknown, error extends unknown>(
    a: error
  ) => Result<ok, error>;
  readonly codec: <ok extends unknown, error extends unknown>(
    a: Codec<ok>,
    b: Codec<error>
  ) => Codec<Result<ok, error>>;
} = {
  Ok: <ok extends unknown, error extends unknown>(
    ok: ok
  ): Result<ok, error> => ({ _: "Ok", ok }),
  Error: <ok extends unknown, error extends unknown>(
    error: error
  ): Result<ok, error> => ({ _: "Error", error }),
  codec: <ok extends unknown, error extends unknown>(
    okCodec: Codec<ok>,
    errorCodec: Codec<error>
  ): Codec<Result<ok, error>> => ({
    encode: (value: Result<ok, error>): ReadonlyArray<number> => {
      switch (value._) {
        case "Ok": {
          return [0].concat(okCodec.encode(value.ok));
        }
        case "Error": {
          return [1].concat(errorCodec.encode(value.error));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Result<ok, error>; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: ok;
          readonly nextIndex: number;
        } = okCodec.decode(patternIndex.nextIndex, binary);
        return {
          result: Result.Ok(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: error;
          readonly nextIndex: number;
        } = errorCodec.decode(patternIndex.nextIndex, binary);
        return {
          result: Result.Error(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  }),
};

/**
 * デバッグモードかどうか,言語とページの場所. URLとして表現されるデータ. Googleなどの検索エンジンの都合( https://support.google.com/webmasters/answer/182192?hl=ja )で,URLにページの言語を入れて,言語ごとに別のURLである必要がある. デバッグ時のホスト名は http://localhost になる
 * @typePartId 7210f04a85c5f0f58f7aa20826d67f05
 */
export const UrlData: {
  readonly codec: Codec<UrlData>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: UrlData) => UrlData;
} = {
  helper: (urlData: UrlData): UrlData => urlData,
  codec: {
    encode: (value: UrlData): ReadonlyArray<number> =>
      Location.codec.encode(value.location),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: UrlData; readonly nextIndex: number } => {
      const locationAndNextIndex: {
        readonly result: Location;
        readonly nextIndex: number;
      } = Location.codec.decode(index, binary);
      return {
        result: { location: locationAndNextIndex.result },
        nextIndex: locationAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * switch文
 * @typePartId 725f84ef82e6c3b5b5f6fd5208977dd8
 */
export const SwitchStatement: {
  readonly codec: Codec<SwitchStatement>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: SwitchStatement) => SwitchStatement;
} = {
  helper: (switchStatement: SwitchStatement): SwitchStatement =>
    switchStatement,
  codec: {
    encode: (value: SwitchStatement): ReadonlyArray<number> =>
      Expr.codec
        .encode(value.expr)
        .concat(List.codec(Pattern.codec).encode(value.patternList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: SwitchStatement; readonly nextIndex: number } => {
      const exprAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(index, binary);
      const patternListAndNextIndex: {
        readonly result: List<Pattern>;
        readonly nextIndex: number;
      } = List.codec(Pattern.codec).decode(exprAndNextIndex.nextIndex, binary);
      return {
        result: {
          expr: exprAndNextIndex.result,
          patternList: patternListAndNextIndex.result,
        },
        nextIndex: patternListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * ローカル変数定義
 * @typePartId 7277cf2483388ee2f5ad7a7fc8585d98
 */
export const VariableDefinitionStatement: {
  readonly codec: Codec<VariableDefinitionStatement>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (
    a: VariableDefinitionStatement
  ) => VariableDefinitionStatement;
} = {
  helper: (
    variableDefinitionStatement: VariableDefinitionStatement
  ): VariableDefinitionStatement => variableDefinitionStatement,
  codec: {
    encode: (value: VariableDefinitionStatement): ReadonlyArray<number> =>
      Identifer.codec
        .encode(value.name)
        .concat(Type.codec.encode(value.type))
        .concat(Expr.codec.encode(value.expr))
        .concat(Bool.codec.encode(value.isConst)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: VariableDefinitionStatement;
      readonly nextIndex: number;
    } => {
      const nameAndNextIndex: {
        readonly result: Identifer;
        readonly nextIndex: number;
      } = Identifer.codec.decode(index, binary);
      const typeAndNextIndex: {
        readonly result: Type;
        readonly nextIndex: number;
      } = Type.codec.decode(nameAndNextIndex.nextIndex, binary);
      const exprAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(typeAndNextIndex.nextIndex, binary);
      const isConstAndNextIndex: {
        readonly result: Bool;
        readonly nextIndex: number;
      } = Bool.codec.decode(exprAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          type: typeAndNextIndex.result,
          expr: exprAndNextIndex.result,
          isConst: isConstAndNextIndex.result,
        },
        nextIndex: isConstAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * JavaScript の 文
 * @typePartId 7c957d411f448a03764f16d43e6e5008
 */
export const Statement: {
  /**
   * 式を評価する
   */
  readonly EvaluateExpr: (a: Expr) => Statement;
  /**
   * 代入やプロパティの値を設定する
   */
  readonly Set: (a: SetStatement) => Statement;
  /**
   * if (condition) { thenStatementList }
   */
  readonly If: (a: IfStatement) => Statement;
  /**
   * throw new Error("エラーメッセージ");
   */
  readonly ThrowError: (a: Expr) => Statement;
  /**
   * return expr;
   */
  readonly Return: (a: Expr) => Statement;
  /**
   * 戻り値がvoidの関数を早く抜ける
   */
  readonly ReturnVoid: Statement;
  /**
   * forの繰り返しを次に進める
   */
  readonly Continue: Statement;
  /**
   * `const a: type_ = expr`\nローカル変数の定義
   */
  readonly VariableDefinition: (a: VariableDefinitionStatement) => Statement;
  /**
   * `const name = (parameterList): returnType => { statementList }`\nローカル関数の定義
   */
  readonly FunctionDefinition: (a: FunctionDefinitionStatement) => Statement;
  /**
   * for文. 繰り返し.
   */
  readonly For: (a: ForStatement) => Statement;
  /**
   * for文. 繰り返し.
   */
  readonly ForOf: (a: ForOfStatement) => Statement;
  /**
   * while (true) での無限ループ
   */
  readonly WhileTrue: (a: List<Statement>) => Statement;
  /**
   * whileのループから抜ける
   */
  readonly Break: Statement;
  /**
   * switch文
   */
  readonly Switch: (a: SwitchStatement) => Statement;
  readonly codec: Codec<Statement>;
} = {
  EvaluateExpr: (expr: Expr): Statement => ({ _: "EvaluateExpr", expr }),
  Set: (setStatement: SetStatement): Statement => ({ _: "Set", setStatement }),
  If: (ifStatement: IfStatement): Statement => ({ _: "If", ifStatement }),
  ThrowError: (expr: Expr): Statement => ({ _: "ThrowError", expr }),
  Return: (expr: Expr): Statement => ({ _: "Return", expr }),
  ReturnVoid: { _: "ReturnVoid" },
  Continue: { _: "Continue" },
  VariableDefinition: (
    variableDefinitionStatement: VariableDefinitionStatement
  ): Statement => ({ _: "VariableDefinition", variableDefinitionStatement }),
  FunctionDefinition: (
    functionDefinitionStatement: FunctionDefinitionStatement
  ): Statement => ({ _: "FunctionDefinition", functionDefinitionStatement }),
  For: (forStatement: ForStatement): Statement => ({ _: "For", forStatement }),
  ForOf: (forOfStatement: ForOfStatement): Statement => ({
    _: "ForOf",
    forOfStatement,
  }),
  WhileTrue: (statementList: List<Statement>): Statement => ({
    _: "WhileTrue",
    statementList,
  }),
  Break: { _: "Break" },
  Switch: (switchStatement: SwitchStatement): Statement => ({
    _: "Switch",
    switchStatement,
  }),
  codec: {
    encode: (value: Statement): ReadonlyArray<number> => {
      switch (value._) {
        case "EvaluateExpr": {
          return [0].concat(Expr.codec.encode(value.expr));
        }
        case "Set": {
          return [1].concat(SetStatement.codec.encode(value.setStatement));
        }
        case "If": {
          return [2].concat(IfStatement.codec.encode(value.ifStatement));
        }
        case "ThrowError": {
          return [3].concat(Expr.codec.encode(value.expr));
        }
        case "Return": {
          return [4].concat(Expr.codec.encode(value.expr));
        }
        case "ReturnVoid": {
          return [5];
        }
        case "Continue": {
          return [6];
        }
        case "VariableDefinition": {
          return [7].concat(
            VariableDefinitionStatement.codec.encode(
              value.variableDefinitionStatement
            )
          );
        }
        case "FunctionDefinition": {
          return [8].concat(
            FunctionDefinitionStatement.codec.encode(
              value.functionDefinitionStatement
            )
          );
        }
        case "For": {
          return [9].concat(ForStatement.codec.encode(value.forStatement));
        }
        case "ForOf": {
          return [10].concat(ForOfStatement.codec.encode(value.forOfStatement));
        }
        case "WhileTrue": {
          return [11].concat(
            List.codec(Statement.codec).encode(value.statementList)
          );
        }
        case "Break": {
          return [12];
        }
        case "Switch": {
          return [13].concat(
            SwitchStatement.codec.encode(value.switchStatement)
          );
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Statement; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: Expr;
          readonly nextIndex: number;
        } = Expr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.EvaluateExpr(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: SetStatement;
          readonly nextIndex: number;
        } = SetStatement.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.Set(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: IfStatement;
          readonly nextIndex: number;
        } = IfStatement.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.If(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        const result: {
          readonly result: Expr;
          readonly nextIndex: number;
        } = Expr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.ThrowError(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 4) {
        const result: {
          readonly result: Expr;
          readonly nextIndex: number;
        } = Expr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.Return(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 5) {
        return {
          result: Statement.ReturnVoid,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 6) {
        return {
          result: Statement.Continue,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 7) {
        const result: {
          readonly result: VariableDefinitionStatement;
          readonly nextIndex: number;
        } = VariableDefinitionStatement.codec.decode(
          patternIndex.nextIndex,
          binary
        );
        return {
          result: Statement.VariableDefinition(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 8) {
        const result: {
          readonly result: FunctionDefinitionStatement;
          readonly nextIndex: number;
        } = FunctionDefinitionStatement.codec.decode(
          patternIndex.nextIndex,
          binary
        );
        return {
          result: Statement.FunctionDefinition(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 9) {
        const result: {
          readonly result: ForStatement;
          readonly nextIndex: number;
        } = ForStatement.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.For(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 10) {
        const result: {
          readonly result: ForOfStatement;
          readonly nextIndex: number;
        } = ForOfStatement.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.ForOf(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 11) {
        const result: {
          readonly result: List<Statement>;
          readonly nextIndex: number;
        } = List.codec(Statement.codec).decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.WhileTrue(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 12) {
        return { result: Statement.Break, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 13) {
        const result: {
          readonly result: SwitchStatement;
          readonly nextIndex: number;
        } = SwitchStatement.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Statement.Switch(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 日時. 0001-01-01T00:00:00.000Z to 9999-12-31T23:59:59.999Z 最小単位はミリ秒. ミリ秒の求め方は day*1000*60*60*24 + millisecond
 * @typePartId 7d91f0f70643799692aa144ee51a62b1
 */
export const Time: {
  readonly codec: Codec<Time>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: Time) => Time;
} = {
  helper: (time: Time): Time => time,
  codec: {
    encode: (value: Time): ReadonlyArray<number> =>
      Int32.codec
        .encode(value.day)
        .concat(Int32.codec.encode(value.millisecond)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Time; readonly nextIndex: number } => {
      const dayAndNextIndex: {
        readonly result: Int32;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      const millisecondAndNextIndex: {
        readonly result: Int32;
        readonly nextIndex: number;
      } = Int32.codec.decode(dayAndNextIndex.nextIndex, binary);
      return {
        result: {
          day: dayAndNextIndex.result,
          millisecond: millisecondAndNextIndex.result,
        },
        nextIndex: millisecondAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * インポートした変数
 * @typePartId 8150e2833dc1f2a77715aa1bb7b2baad
 */
export const ImportedVariable: {
  readonly codec: Codec<ImportedVariable>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ImportedVariable) => ImportedVariable;
} = {
  helper: (importedVariable: ImportedVariable): ImportedVariable =>
    importedVariable,
  codec: {
    encode: (value: ImportedVariable): ReadonlyArray<number> =>
      String.codec
        .encode(value.moduleName)
        .concat(Identifer.codec.encode(value.name)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ImportedVariable; readonly nextIndex: number } => {
      const moduleNameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const nameAndNextIndex: {
        readonly result: Identifer;
        readonly nextIndex: number;
      } = Identifer.codec.decode(moduleNameAndNextIndex.nextIndex, binary);
      return {
        result: {
          moduleName: moduleNameAndNextIndex.result,
          name: nameAndNextIndex.result,
        },
        nextIndex: nameAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * "ソーシャルログインを提供するプロバイダー (例: Google, GitHub)
 * @typePartId 84597034eb252267ce1a599ab7a0b543
 */
export const OpenIdConnectProvider: {
  /**
   * Google ( https://developers.google.com/identity/sign-in/web/ )
   */
  readonly Google: OpenIdConnectProvider;
  /**
   * GitHub ( https://developer.github.com/v3/guides/basics-of-authentication/ )
   */
  readonly GitHub: OpenIdConnectProvider;
  readonly codec: Codec<OpenIdConnectProvider>;
} = {
  Google: "Google",
  GitHub: "GitHub",
  codec: {
    encode: (value: OpenIdConnectProvider): ReadonlyArray<number> => {
      switch (value) {
        case "Google": {
          return [0];
        }
        case "GitHub": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: OpenIdConnectProvider;
      readonly nextIndex: number;
    } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: OpenIdConnectProvider.Google,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: OpenIdConnectProvider.GitHub,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * JavaScript の 式
 * @typePartId 8b0bdbeae05df3badac2ee69bf22011f
 */
export const Expr: {
  /**
   * 数値リテラル `123`
   */
  readonly NumberLiteral: (a: Int32) => Expr;
  /**
   * 文字列リテラル `"text"`
   */
  readonly StringLiteral: (a: String) => Expr;
  /**
   * booleanリテラル
   */
  readonly BooleanLiteral: (a: Bool) => Expr;
  /**
   * `null`
   */
  readonly NullLiteral: Expr;
  /**
   * `undefined`
   */
  readonly UndefinedLiteral: Expr;
  /**
   * 単項演算子での式
   */
  readonly UnaryOperator: (a: UnaryOperatorExpr) => Expr;
  /**
   * 2項演算子での式
   */
  readonly BinaryOperator: (a: BinaryOperatorExpr) => Expr;
  /**
   * 条件演算子 `a ? b : c`
   */
  readonly ConditionalOperator: (a: ConditionalOperatorExpr) => Expr;
  /**
   * 配列リテラル `[1, 2, 3]`
   */
  readonly ArrayLiteral: (a: List<ArrayItem>) => Expr;
  /**
   * オブジェクトリテラル `{ data: 123, text: "sorena" }`
   */
  readonly ObjectLiteral: (a: List<Member>) => Expr;
  /**
   * ラムダ式 `() => {}`
   */
  readonly Lambda: (a: LambdaExpr) => Expr;
  /**
   * 変数. 変数が存在するかのチャックがされる
   */
  readonly Variable: (a: Identifer) => Expr;
  /**
   * グローバルオブジェクト
   */
  readonly GlobalObjects: (a: Identifer) => Expr;
  /**
   * インポートされた変数
   */
  readonly ImportedVariable: (a: ImportedVariable) => Expr;
  /**
   * プロパティの値を取得する `a.b a[12] data[f(2)]`
   */
  readonly Get: (a: GetExpr) => Expr;
  /**
   * 関数を呼ぶ f(x)",
   */
  readonly Call: (a: CallExpr) => Expr;
  /**
   * 式からインスタンスを作成する `new Date()`
   */
  readonly New: (a: CallExpr) => Expr;
  /**
   * 型アサーション `a as string`
   */
  readonly TypeAssertion: (a: TypeAssertion) => Expr;
  readonly codec: Codec<Expr>;
} = {
  NumberLiteral: (int32: Int32): Expr => ({ _: "NumberLiteral", int32 }),
  StringLiteral: (string_: String): Expr => ({
    _: "StringLiteral",
    string: string_,
  }),
  BooleanLiteral: (bool: Bool): Expr => ({ _: "BooleanLiteral", bool }),
  NullLiteral: { _: "NullLiteral" },
  UndefinedLiteral: { _: "UndefinedLiteral" },
  UnaryOperator: (unaryOperatorExpr: UnaryOperatorExpr): Expr => ({
    _: "UnaryOperator",
    unaryOperatorExpr,
  }),
  BinaryOperator: (binaryOperatorExpr: BinaryOperatorExpr): Expr => ({
    _: "BinaryOperator",
    binaryOperatorExpr,
  }),
  ConditionalOperator: (
    conditionalOperatorExpr: ConditionalOperatorExpr
  ): Expr => ({ _: "ConditionalOperator", conditionalOperatorExpr }),
  ArrayLiteral: (arrayItemList: List<ArrayItem>): Expr => ({
    _: "ArrayLiteral",
    arrayItemList,
  }),
  ObjectLiteral: (memberList: List<Member>): Expr => ({
    _: "ObjectLiteral",
    memberList,
  }),
  Lambda: (lambdaExpr: LambdaExpr): Expr => ({ _: "Lambda", lambdaExpr }),
  Variable: (identifer: Identifer): Expr => ({ _: "Variable", identifer }),
  GlobalObjects: (identifer: Identifer): Expr => ({
    _: "GlobalObjects",
    identifer,
  }),
  ImportedVariable: (importedVariable: ImportedVariable): Expr => ({
    _: "ImportedVariable",
    importedVariable,
  }),
  Get: (getExpr: GetExpr): Expr => ({ _: "Get", getExpr }),
  Call: (callExpr: CallExpr): Expr => ({ _: "Call", callExpr }),
  New: (callExpr: CallExpr): Expr => ({ _: "New", callExpr }),
  TypeAssertion: (typeAssertion: TypeAssertion): Expr => ({
    _: "TypeAssertion",
    typeAssertion,
  }),
  codec: {
    encode: (value: Expr): ReadonlyArray<number> => {
      switch (value._) {
        case "NumberLiteral": {
          return [0].concat(Int32.codec.encode(value.int32));
        }
        case "StringLiteral": {
          return [1].concat(String.codec.encode(value.string));
        }
        case "BooleanLiteral": {
          return [2].concat(Bool.codec.encode(value.bool));
        }
        case "NullLiteral": {
          return [3];
        }
        case "UndefinedLiteral": {
          return [4];
        }
        case "UnaryOperator": {
          return [5].concat(
            UnaryOperatorExpr.codec.encode(value.unaryOperatorExpr)
          );
        }
        case "BinaryOperator": {
          return [6].concat(
            BinaryOperatorExpr.codec.encode(value.binaryOperatorExpr)
          );
        }
        case "ConditionalOperator": {
          return [7].concat(
            ConditionalOperatorExpr.codec.encode(value.conditionalOperatorExpr)
          );
        }
        case "ArrayLiteral": {
          return [8].concat(
            List.codec(ArrayItem.codec).encode(value.arrayItemList)
          );
        }
        case "ObjectLiteral": {
          return [9].concat(List.codec(Member.codec).encode(value.memberList));
        }
        case "Lambda": {
          return [10].concat(LambdaExpr.codec.encode(value.lambdaExpr));
        }
        case "Variable": {
          return [11].concat(Identifer.codec.encode(value.identifer));
        }
        case "GlobalObjects": {
          return [12].concat(Identifer.codec.encode(value.identifer));
        }
        case "ImportedVariable": {
          return [13].concat(
            ImportedVariable.codec.encode(value.importedVariable)
          );
        }
        case "Get": {
          return [14].concat(GetExpr.codec.encode(value.getExpr));
        }
        case "Call": {
          return [15].concat(CallExpr.codec.encode(value.callExpr));
        }
        case "New": {
          return [16].concat(CallExpr.codec.encode(value.callExpr));
        }
        case "TypeAssertion": {
          return [17].concat(TypeAssertion.codec.encode(value.typeAssertion));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Expr; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: Int32;
          readonly nextIndex: number;
        } = Int32.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.NumberLiteral(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: String;
          readonly nextIndex: number;
        } = String.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.StringLiteral(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: Bool;
          readonly nextIndex: number;
        } = Bool.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.BooleanLiteral(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        return { result: Expr.NullLiteral, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 4) {
        return {
          result: Expr.UndefinedLiteral,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 5) {
        const result: {
          readonly result: UnaryOperatorExpr;
          readonly nextIndex: number;
        } = UnaryOperatorExpr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.UnaryOperator(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 6) {
        const result: {
          readonly result: BinaryOperatorExpr;
          readonly nextIndex: number;
        } = BinaryOperatorExpr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.BinaryOperator(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 7) {
        const result: {
          readonly result: ConditionalOperatorExpr;
          readonly nextIndex: number;
        } = ConditionalOperatorExpr.codec.decode(
          patternIndex.nextIndex,
          binary
        );
        return {
          result: Expr.ConditionalOperator(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 8) {
        const result: {
          readonly result: List<ArrayItem>;
          readonly nextIndex: number;
        } = List.codec(ArrayItem.codec).decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.ArrayLiteral(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 9) {
        const result: {
          readonly result: List<Member>;
          readonly nextIndex: number;
        } = List.codec(Member.codec).decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.ObjectLiteral(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 10) {
        const result: {
          readonly result: LambdaExpr;
          readonly nextIndex: number;
        } = LambdaExpr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.Lambda(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 11) {
        const result: {
          readonly result: Identifer;
          readonly nextIndex: number;
        } = Identifer.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.Variable(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 12) {
        const result: {
          readonly result: Identifer;
          readonly nextIndex: number;
        } = Identifer.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.GlobalObjects(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 13) {
        const result: {
          readonly result: ImportedVariable;
          readonly nextIndex: number;
        } = ImportedVariable.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.ImportedVariable(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 14) {
        const result: {
          readonly result: GetExpr;
          readonly nextIndex: number;
        } = GetExpr.codec.decode(patternIndex.nextIndex, binary);
        return { result: Expr.Get(result.result), nextIndex: result.nextIndex };
      }
      if (patternIndex.result === 15) {
        const result: {
          readonly result: CallExpr;
          readonly nextIndex: number;
        } = CallExpr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.Call(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 16) {
        const result: {
          readonly result: CallExpr;
          readonly nextIndex: number;
        } = CallExpr.codec.decode(patternIndex.nextIndex, binary);
        return { result: Expr.New(result.result), nextIndex: result.nextIndex };
      }
      if (patternIndex.result === 17) {
        const result: {
          readonly result: TypeAssertion;
          readonly nextIndex: number;
        } = TypeAssertion.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Expr.TypeAssertion(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * forOf文
 * @typePartId 8be8db4404f302dd36c8a2c6c6e37e7c
 */
export const ForOfStatement: {
  readonly codec: Codec<ForOfStatement>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ForOfStatement) => ForOfStatement;
} = {
  helper: (forOfStatement: ForOfStatement): ForOfStatement => forOfStatement,
  codec: {
    encode: (value: ForOfStatement): ReadonlyArray<number> =>
      Identifer.codec
        .encode(value.elementVariableName)
        .concat(Expr.codec.encode(value.iterableExpr))
        .concat(List.codec(Statement.codec).encode(value.statementList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ForOfStatement; readonly nextIndex: number } => {
      const elementVariableNameAndNextIndex: {
        readonly result: Identifer;
        readonly nextIndex: number;
      } = Identifer.codec.decode(index, binary);
      const iterableExprAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(elementVariableNameAndNextIndex.nextIndex, binary);
      const statementListAndNextIndex: {
        readonly result: List<Statement>;
        readonly nextIndex: number;
      } = List.codec(Statement.codec).decode(
        iterableExprAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          elementVariableName: elementVariableNameAndNextIndex.result,
          iterableExpr: iterableExprAndNextIndex.result,
          statementList: statementListAndNextIndex.result,
        },
        nextIndex: statementListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * TypeScriptやJavaScriptのコードを表現する. TypeScriptでも出力できるように型情報をつける必要がある
 * @typePartId 92ea504049ca5b7e2227a95195fe74eb
 */
export const JsTsCode: {
  readonly codec: Codec<JsTsCode>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: JsTsCode) => JsTsCode;
} = {
  helper: (jsTsCode: JsTsCode): JsTsCode => jsTsCode,
  codec: {
    encode: (value: JsTsCode): ReadonlyArray<number> =>
      List.codec(ExportDefinition.codec)
        .encode(value.exportDefinitionList)
        .concat(List.codec(Statement.codec).encode(value.statementList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: JsTsCode; readonly nextIndex: number } => {
      const exportDefinitionListAndNextIndex: {
        readonly result: List<ExportDefinition>;
        readonly nextIndex: number;
      } = List.codec(ExportDefinition.codec).decode(index, binary);
      const statementListAndNextIndex: {
        readonly result: List<Statement>;
        readonly nextIndex: number;
      } = List.codec(Statement.codec).decode(
        exportDefinitionListAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          exportDefinitionList: exportDefinitionListAndNextIndex.result,
          statementList: statementListAndNextIndex.result,
        },
        nextIndex: statementListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 関数の型
 * @typePartId 98904215e50e04fa2197a7a96df8f646
 */
export const FunctionType: {
  readonly codec: Codec<FunctionType>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: FunctionType) => FunctionType;
} = {
  helper: (functionType: FunctionType): FunctionType => functionType,
  codec: {
    encode: (value: FunctionType): ReadonlyArray<number> =>
      List.codec(Identifer.codec)
        .encode(value.typeParameterList)
        .concat(List.codec(Type.codec).encode(value.parameterList))
        .concat(Type.codec.encode(value.return)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: FunctionType; readonly nextIndex: number } => {
      const typeParameterListAndNextIndex: {
        readonly result: List<Identifer>;
        readonly nextIndex: number;
      } = List.codec(Identifer.codec).decode(index, binary);
      const parameterListAndNextIndex: {
        readonly result: List<Type>;
        readonly nextIndex: number;
      } = List.codec(Type.codec).decode(
        typeParameterListAndNextIndex.nextIndex,
        binary
      );
      const returnAndNextIndex: {
        readonly result: Type;
        readonly nextIndex: number;
      } = Type.codec.decode(parameterListAndNextIndex.nextIndex, binary);
      return {
        result: {
          typeParameterList: typeParameterListAndNextIndex.result,
          parameterList: parameterListAndNextIndex.result,
          return: returnAndNextIndex.result,
        },
        nextIndex: returnAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 式と呼ぶパラメーター
 * @typePartId a1f71188b7c3ab2a21954471f3ac67f1
 */
export const CallExpr: {
  readonly codec: Codec<CallExpr>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: CallExpr) => CallExpr;
} = {
  helper: (callExpr: CallExpr): CallExpr => callExpr,
  codec: {
    encode: (value: CallExpr): ReadonlyArray<number> =>
      Expr.codec
        .encode(value.expr)
        .concat(List.codec(Expr.codec).encode(value.parameterList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: CallExpr; readonly nextIndex: number } => {
      const exprAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(index, binary);
      const parameterListAndNextIndex: {
        readonly result: List<Expr>;
        readonly nextIndex: number;
      } = List.codec(Expr.codec).decode(exprAndNextIndex.nextIndex, binary);
      return {
        result: {
          expr: exprAndNextIndex.result,
          parameterList: parameterListAndNextIndex.result,
        },
        nextIndex: parameterListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * @typePartId a2580a29c047f54d635c4456696bbef3
 */
export const Variable: {
  readonly codec: Codec<Variable>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: Variable) => Variable;
} = {
  helper: (variable: Variable): Variable => variable,
  codec: {
    encode: (value: Variable): ReadonlyArray<number> =>
      Identifer.codec
        .encode(value.name)
        .concat(String.codec.encode(value.document))
        .concat(Type.codec.encode(value.type))
        .concat(Expr.codec.encode(value.expr)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Variable; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: Identifer;
        readonly nextIndex: number;
      } = Identifer.codec.decode(index, binary);
      const documentAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
      const typeAndNextIndex: {
        readonly result: Type;
        readonly nextIndex: number;
      } = Type.codec.decode(documentAndNextIndex.nextIndex, binary);
      const exprAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(typeAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          document: documentAndNextIndex.result,
          type: typeAndNextIndex.result,
          expr: exprAndNextIndex.result,
        },
        nextIndex: exprAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * プロパティアクセス
 * @typePartId a9ce526a22f09800aa3773a1614cce89
 */
export const GetExpr: {
  readonly codec: Codec<GetExpr>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: GetExpr) => GetExpr;
} = {
  helper: (getExpr: GetExpr): GetExpr => getExpr,
  codec: {
    encode: (value: GetExpr): ReadonlyArray<number> =>
      Expr.codec
        .encode(value.expr)
        .concat(Expr.codec.encode(value.propertyExpr)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: GetExpr; readonly nextIndex: number } => {
      const exprAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(index, binary);
      const propertyExprAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(exprAndNextIndex.nextIndex, binary);
      return {
        result: {
          expr: exprAndNextIndex.result,
          propertyExpr: propertyExprAndNextIndex.result,
        },
        nextIndex: propertyExprAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * インポートされた型
 * @typePartId b44289bc65640d4ad0ad79a5a627ef78
 */
export const ImportedType: {
  readonly codec: Codec<ImportedType>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ImportedType) => ImportedType;
} = {
  helper: (importedType: ImportedType): ImportedType => importedType,
  codec: {
    encode: (value: ImportedType): ReadonlyArray<number> =>
      String.codec
        .encode(value.moduleName)
        .concat(Identifer.codec.encode(value.name)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ImportedType; readonly nextIndex: number } => {
      const moduleNameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const nameAndNextIndex: {
        readonly result: Identifer;
        readonly nextIndex: number;
      } = Identifer.codec.decode(moduleNameAndNextIndex.nextIndex, binary);
      return {
        result: {
          moduleName: moduleNameAndNextIndex.result,
          name: nameAndNextIndex.result,
        },
        nextIndex: nameAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * DefinyWebアプリ内での場所を示すもの. URLから求められる. URLに変換できる
 * @typePartId bbcb8e43df8afff9fe24b001c66fb065
 */
export const Location: {
  /**
   * 最初のページ
   */
  readonly Home: Location;
  /**
   * プロジェクト作成画面
   */
  readonly CreateProject: Location;
  /**
   * プロジェクトの詳細ページ
   */
  readonly Project: (a: ProjectId) => Location;
  /**
   * アカウント詳細ページ
   */
  readonly Account: (a: AccountId) => Location;
  /**
   * 設定ページ
   */
  readonly Setting: Location;
  /**
   * Definyについて説明したページ
   */
  readonly About: Location;
  /**
   * デバッグページ
   */
  readonly Debug: Location;
  readonly codec: Codec<Location>;
} = {
  Home: { _: "Home" },
  CreateProject: { _: "CreateProject" },
  Project: (projectId: ProjectId): Location => ({ _: "Project", projectId }),
  Account: (accountId: AccountId): Location => ({ _: "Account", accountId }),
  Setting: { _: "Setting" },
  About: { _: "About" },
  Debug: { _: "Debug" },
  codec: {
    encode: (value: Location): ReadonlyArray<number> => {
      switch (value._) {
        case "Home": {
          return [0];
        }
        case "CreateProject": {
          return [1];
        }
        case "Project": {
          return [2].concat(ProjectId.codec.encode(value.projectId));
        }
        case "Account": {
          return [3].concat(AccountId.codec.encode(value.accountId));
        }
        case "Setting": {
          return [4];
        }
        case "About": {
          return [5];
        }
        case "Debug": {
          return [6];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Location; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: Location.Home, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return {
          result: Location.CreateProject,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: ProjectId;
          readonly nextIndex: number;
        } = ProjectId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Location.Project(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        const result: {
          readonly result: AccountId;
          readonly nextIndex: number;
        } = AccountId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Location.Account(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 4) {
        return { result: Location.Setting, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 5) {
        return { result: Location.About, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 6) {
        return { result: Location.Debug, nextIndex: patternIndex.nextIndex };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * TypeAlias. `export type T = {}`
 * @typePartId bf69f7e46f5e4949fe801c234fc3ad15
 */
export const TypeAlias: {
  readonly codec: Codec<TypeAlias>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: TypeAlias) => TypeAlias;
} = {
  helper: (typeAlias: TypeAlias): TypeAlias => typeAlias,
  codec: {
    encode: (value: TypeAlias): ReadonlyArray<number> =>
      Identifer.codec
        .encode(value.name)
        .concat(List.codec(Identifer.codec).encode(value.typeParameterList))
        .concat(String.codec.encode(value.document))
        .concat(Type.codec.encode(value.type)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypeAlias; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: Identifer;
        readonly nextIndex: number;
      } = Identifer.codec.decode(index, binary);
      const typeParameterListAndNextIndex: {
        readonly result: List<Identifer>;
        readonly nextIndex: number;
      } = List.codec(Identifer.codec).decode(
        nameAndNextIndex.nextIndex,
        binary
      );
      const documentAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(typeParameterListAndNextIndex.nextIndex, binary);
      const typeAndNextIndex: {
        readonly result: Type;
        readonly nextIndex: number;
      } = Type.codec.decode(documentAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          typeParameterList: typeParameterListAndNextIndex.result,
          document: documentAndNextIndex.result,
          type: typeAndNextIndex.result,
        },
        nextIndex: typeAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * アカウントの識別子
 * @typePartId c1a17b07e8e664ca80217833ff2ad3f1
 */
export const AccountId: { readonly codec: Codec<AccountId> } = {
  codec: {
    encode: (value: AccountId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: AccountId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: AccountId;
        readonly nextIndex: number;
      },
  },
};

/**
 * 文字列のkeyと式のvalue
 * @typePartId c2428cbcd62b33ce2c904a200b876863
 */
export const KeyValue: {
  readonly codec: Codec<KeyValue>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: KeyValue) => KeyValue;
} = {
  helper: (keyValue: KeyValue): KeyValue => keyValue,
  codec: {
    encode: (value: KeyValue): ReadonlyArray<number> =>
      String.codec.encode(value.key).concat(Expr.codec.encode(value.value)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: KeyValue; readonly nextIndex: number } => {
      const keyAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const valueAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(keyAndNextIndex.nextIndex, binary);
      return {
        result: {
          key: keyAndNextIndex.result,
          value: valueAndNextIndex.result,
        },
        nextIndex: valueAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * リスト. JavaScriptのArrayで扱う
 * @typePartId c3fc2a6cea61086db59e11dc2bef0eee
 */
export const List: {
  readonly codec: <element extends unknown>(
    a: Codec<element>
  ) => Codec<List<element>>;
} = {
  codec: <element extends unknown>(
    elementCodec: Codec<element>
  ): Codec<List<element>> => ({
    encode: (value: List<element>): ReadonlyArray<number> => {
      let result: Array<number> = Int32.codec.encode(
        value.length
      ) as Array<number>;
      for (const element of value) {
        result = result.concat(elementCodec.encode(element));
      }
      return result;
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: List<element>; readonly nextIndex: number } => {
      const lengthResult: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      let nextIndex: number = lengthResult.nextIndex;
      const result: Array<element> = [];
      for (let i = 0; i < lengthResult.result; i += 1) {
        const resultAndNextIndex: {
          readonly result: element;
          readonly nextIndex: number;
        } = elementCodec.decode(nextIndex, binary);
        result.push(resultAndNextIndex.result);
        nextIndex = resultAndNextIndex.nextIndex;
      }
      return { result, nextIndex };
    },
  }),
};

/**
 * for文
 * @typePartId c53be8bcaf56ff90080cf7a75f1e4815
 */
export const ForStatement: {
  readonly codec: Codec<ForStatement>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ForStatement) => ForStatement;
} = {
  helper: (forStatement: ForStatement): ForStatement => forStatement,
  codec: {
    encode: (value: ForStatement): ReadonlyArray<number> =>
      Identifer.codec
        .encode(value.counterVariableName)
        .concat(Expr.codec.encode(value.untilExpr))
        .concat(List.codec(Statement.codec).encode(value.statementList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ForStatement; readonly nextIndex: number } => {
      const counterVariableNameAndNextIndex: {
        readonly result: Identifer;
        readonly nextIndex: number;
      } = Identifer.codec.decode(index, binary);
      const untilExprAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(counterVariableNameAndNextIndex.nextIndex, binary);
      const statementListAndNextIndex: {
        readonly result: List<Statement>;
        readonly nextIndex: number;
      } = List.codec(Statement.codec).decode(
        untilExprAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          counterVariableName: counterVariableNameAndNextIndex.result,
          untilExpr: untilExprAndNextIndex.result,
          statementList: statementListAndNextIndex.result,
        },
        nextIndex: statementListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * オブジェクトのメンバーの型
 * @typePartId c68bac5afb1a1d35af096bf317d09339
 */
export const MemberType: {
  readonly codec: Codec<MemberType>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: MemberType) => MemberType;
} = {
  helper: (memberType: MemberType): MemberType => memberType,
  codec: {
    encode: (value: MemberType): ReadonlyArray<number> =>
      String.codec
        .encode(value.name)
        .concat(Bool.codec.encode(value.required))
        .concat(Type.codec.encode(value.type))
        .concat(String.codec.encode(value.document)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: MemberType; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(index, binary);
      const requiredAndNextIndex: {
        readonly result: Bool;
        readonly nextIndex: number;
      } = Bool.codec.decode(nameAndNextIndex.nextIndex, binary);
      const typeAndNextIndex: {
        readonly result: Type;
        readonly nextIndex: number;
      } = Type.codec.decode(requiredAndNextIndex.nextIndex, binary);
      const documentAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(typeAndNextIndex.nextIndex, binary);
      return {
        result: {
          name: nameAndNextIndex.result,
          required: requiredAndNextIndex.result,
          type: typeAndNextIndex.result,
          document: documentAndNextIndex.result,
        },
        nextIndex: documentAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 条件演算子
 * @typePartId c7a771f770f0f92690faeb59eaff6268
 */
export const ConditionalOperatorExpr: {
  readonly codec: Codec<ConditionalOperatorExpr>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: ConditionalOperatorExpr) => ConditionalOperatorExpr;
} = {
  helper: (
    conditionalOperatorExpr: ConditionalOperatorExpr
  ): ConditionalOperatorExpr => conditionalOperatorExpr,
  codec: {
    encode: (value: ConditionalOperatorExpr): ReadonlyArray<number> =>
      Expr.codec
        .encode(value.condition)
        .concat(Expr.codec.encode(value.thenExpr))
        .concat(Expr.codec.encode(value.elseExpr)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: ConditionalOperatorExpr;
      readonly nextIndex: number;
    } => {
      const conditionAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(index, binary);
      const thenExprAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(conditionAndNextIndex.nextIndex, binary);
      const elseExprAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(thenExprAndNextIndex.nextIndex, binary);
      return {
        result: {
          condition: conditionAndNextIndex.result,
          thenExpr: thenExprAndNextIndex.result,
          elseExpr: elseExprAndNextIndex.result,
        },
        nextIndex: elseExprAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * if文
 * @typePartId cd325760f992e47a8438ae78ca9b1529
 */
export const IfStatement: {
  readonly codec: Codec<IfStatement>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: IfStatement) => IfStatement;
} = {
  helper: (ifStatement: IfStatement): IfStatement => ifStatement,
  codec: {
    encode: (value: IfStatement): ReadonlyArray<number> =>
      Expr.codec
        .encode(value.condition)
        .concat(List.codec(Statement.codec).encode(value.thenStatementList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: IfStatement; readonly nextIndex: number } => {
      const conditionAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(index, binary);
      const thenStatementListAndNextIndex: {
        readonly result: List<Statement>;
        readonly nextIndex: number;
      } = List.codec(Statement.codec).decode(
        conditionAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          condition: conditionAndNextIndex.result,
          thenStatementList: thenStatementListAndNextIndex.result,
        },
        nextIndex: thenStatementListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 交差型
 * @typePartId d82150857d0f2e78c1df0f418ba9b01a
 */
export const IntersectionType: {
  readonly codec: Codec<IntersectionType>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: IntersectionType) => IntersectionType;
} = {
  helper: (intersectionType: IntersectionType): IntersectionType =>
    intersectionType,
  codec: {
    encode: (value: IntersectionType): ReadonlyArray<number> =>
      Type.codec.encode(value.left).concat(Type.codec.encode(value.right)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: IntersectionType; readonly nextIndex: number } => {
      const leftAndNextIndex: {
        readonly result: Type;
        readonly nextIndex: number;
      } = Type.codec.decode(index, binary);
      const rightAndNextIndex: {
        readonly result: Type;
        readonly nextIndex: number;
      } = Type.codec.decode(leftAndNextIndex.nextIndex, binary);
      return {
        result: {
          left: leftAndNextIndex.result,
          right: rightAndNextIndex.result,
        },
        nextIndex: rightAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * Bool. 真か偽. JavaScriptのbooleanで扱える. true: 1, false: 0. (1byte)としてバイナリに変換する
 * @typePartId db57caf129f60db969b5b5224a72b937
 */
export const Bool: {
  /**
   * 偽
   */
  readonly False: Bool;
  /**
   * 真
   */
  readonly True: Bool;
  readonly codec: Codec<Bool>;
} = {
  False: false,
  True: true,
  codec: {
    encode: (value: Bool): ReadonlyArray<number> => [value ? 1 : 0],
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Bool; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: Bool.False, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return { result: Bool.True, nextIndex: patternIndex.nextIndex };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 外部に公開する関数
 * @typePartId dd3366ce7254327c85732d2932ff219b
 */
export const Function: {
  readonly codec: Codec<Function>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: Function) => Function;
} = {
  helper: (function_: Function): Function => function_,
  codec: {
    encode: (value: Function): ReadonlyArray<number> =>
      Identifer.codec
        .encode(value.name)
        .concat(String.codec.encode(value.document))
        .concat(List.codec(Identifer.codec).encode(value.typeParameterList))
        .concat(
          List.codec(ParameterWithDocument.codec).encode(value.parameterList)
        )
        .concat(Type.codec.encode(value.returnType))
        .concat(List.codec(Statement.codec).encode(value.statementList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Function; readonly nextIndex: number } => {
      const nameAndNextIndex: {
        readonly result: Identifer;
        readonly nextIndex: number;
      } = Identifer.codec.decode(index, binary);
      const documentAndNextIndex: {
        readonly result: String;
        readonly nextIndex: number;
      } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
      const typeParameterListAndNextIndex: {
        readonly result: List<Identifer>;
        readonly nextIndex: number;
      } = List.codec(Identifer.codec).decode(
        documentAndNextIndex.nextIndex,
        binary
      );
      const parameterListAndNextIndex: {
        readonly result: List<ParameterWithDocument>;
        readonly nextIndex: number;
      } = List.codec(ParameterWithDocument.codec).decode(
        typeParameterListAndNextIndex.nextIndex,
        binary
      );
      const returnTypeAndNextIndex: {
        readonly result: Type;
        readonly nextIndex: number;
      } = Type.codec.decode(parameterListAndNextIndex.nextIndex, binary);
      const statementListAndNextIndex: {
        readonly result: List<Statement>;
        readonly nextIndex: number;
      } = List.codec(Statement.codec).decode(
        returnTypeAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          name: nameAndNextIndex.result,
          document: documentAndNextIndex.result,
          typeParameterList: typeParameterListAndNextIndex.result,
          parameterList: parameterListAndNextIndex.result,
          returnType: returnTypeAndNextIndex.result,
          statementList: statementListAndNextIndex.result,
        },
        nextIndex: statementListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * アカウントトークン. アカウントトークンを持っていればアクセストークンをDefinyのサーバーにリクエストした際に得られるIDのアカウントを保有していると証明できる. サーバーにハッシュ化したものを保存している. これが盗まれた場合,不正に得た人はアカウントを乗っ取ることができる. 有効期限はなし, 最後に発行したアカウントトークン以外は無効になる
 * @typePartId deb01f82879754c03aa4d244e136e59d
 */
export const AccountToken: { readonly codec: Codec<AccountToken> } = {
  codec: {
    encode: (value: AccountToken): ReadonlyArray<number> => encodeToken(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: AccountToken; readonly nextIndex: number } =>
      decodeToken(index, binary) as {
        readonly result: AccountToken;
        readonly nextIndex: number;
      },
  },
};

/**
 * ローカル関数定義
 * @typePartId df5c5388248252a92864ceb219628b8e
 */
export const FunctionDefinitionStatement: {
  readonly codec: Codec<FunctionDefinitionStatement>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (
    a: FunctionDefinitionStatement
  ) => FunctionDefinitionStatement;
} = {
  helper: (
    functionDefinitionStatement: FunctionDefinitionStatement
  ): FunctionDefinitionStatement => functionDefinitionStatement,
  codec: {
    encode: (value: FunctionDefinitionStatement): ReadonlyArray<number> =>
      Identifer.codec
        .encode(value.name)
        .concat(List.codec(Identifer.codec).encode(value.typeParameterList))
        .concat(
          List.codec(ParameterWithDocument.codec).encode(value.parameterList)
        )
        .concat(Type.codec.encode(value.returnType))
        .concat(List.codec(Statement.codec).encode(value.statementList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: FunctionDefinitionStatement;
      readonly nextIndex: number;
    } => {
      const nameAndNextIndex: {
        readonly result: Identifer;
        readonly nextIndex: number;
      } = Identifer.codec.decode(index, binary);
      const typeParameterListAndNextIndex: {
        readonly result: List<Identifer>;
        readonly nextIndex: number;
      } = List.codec(Identifer.codec).decode(
        nameAndNextIndex.nextIndex,
        binary
      );
      const parameterListAndNextIndex: {
        readonly result: List<ParameterWithDocument>;
        readonly nextIndex: number;
      } = List.codec(ParameterWithDocument.codec).decode(
        typeParameterListAndNextIndex.nextIndex,
        binary
      );
      const returnTypeAndNextIndex: {
        readonly result: Type;
        readonly nextIndex: number;
      } = Type.codec.decode(parameterListAndNextIndex.nextIndex, binary);
      const statementListAndNextIndex: {
        readonly result: List<Statement>;
        readonly nextIndex: number;
      } = List.codec(Statement.codec).decode(
        returnTypeAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          name: nameAndNextIndex.result,
          typeParameterList: typeParameterListAndNextIndex.result,
          parameterList: parameterListAndNextIndex.result,
          returnType: returnTypeAndNextIndex.result,
          statementList: statementListAndNextIndex.result,
        },
        nextIndex: statementListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 画像から求められるトークン.キャッシュのキーとして使われる.1つのトークンに対して永久に1つの画像データしか表さない. キャッシュを更新する必要はない
 * @typePartId e71e15a15b0883940a75e58367151d1a
 */
export const ImageHash: { readonly codec: Codec<ImageHash> } = {
  codec: {
    encode: (value: ImageHash): ReadonlyArray<number> => encodeToken(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ImageHash; readonly nextIndex: number } =>
      decodeToken(index, binary) as {
        readonly result: ImageHash;
        readonly nextIndex: number;
      },
  },
};

/**
 * デベロップモードか, リリースモード
 * @typePartId ee0590e764618611ffa8e1a0a2e22f79
 */
export const ClientMode: {
  /**
   * ローカルで開発するときのモード. オリジンは http://localshot:2520
   */
  readonly Develop: ClientMode;
  /**
   * リリースモード. オリジンは https://definy.app
   */
  readonly Release: ClientMode;
  readonly codec: Codec<ClientMode>;
} = {
  Develop: "Develop",
  Release: "Release",
  codec: {
    encode: (value: ClientMode): ReadonlyArray<number> => {
      switch (value) {
        case "Develop": {
          return [0];
        }
        case "Release": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ClientMode; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: ClientMode.Develop,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: ClientMode.Release,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * 2項演算子と左右の式
 * @typePartId eec2dab74fbcd3237bfa1c773f9b9d21
 */
export const BinaryOperatorExpr: {
  readonly codec: Codec<BinaryOperatorExpr>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: BinaryOperatorExpr) => BinaryOperatorExpr;
} = {
  helper: (binaryOperatorExpr: BinaryOperatorExpr): BinaryOperatorExpr =>
    binaryOperatorExpr,
  codec: {
    encode: (value: BinaryOperatorExpr): ReadonlyArray<number> =>
      BinaryOperator.codec
        .encode(value.operator)
        .concat(Expr.codec.encode(value.left))
        .concat(Expr.codec.encode(value.right)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: BinaryOperatorExpr; readonly nextIndex: number } => {
      const operatorAndNextIndex: {
        readonly result: BinaryOperator;
        readonly nextIndex: number;
      } = BinaryOperator.codec.decode(index, binary);
      const leftAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(operatorAndNextIndex.nextIndex, binary);
      const rightAndNextIndex: {
        readonly result: Expr;
        readonly nextIndex: number;
      } = Expr.codec.decode(leftAndNextIndex.nextIndex, binary);
      return {
        result: {
          operator: operatorAndNextIndex.result,
          left: leftAndNextIndex.result,
          right: rightAndNextIndex.result,
        },
        nextIndex: rightAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 出力するコードの種類
 * @typePartId eedf73c97f9dd61159572322f6d7e0a5
 */
export const CodeType: {
  /**
   * JavaScript
   */
  readonly JavaScript: CodeType;
  /**
   * TypeScript
   */
  readonly TypeScript: CodeType;
  readonly codec: Codec<CodeType>;
} = {
  JavaScript: "JavaScript",
  TypeScript: "TypeScript",
  codec: {
    encode: (value: CodeType): ReadonlyArray<number> => {
      switch (value) {
        case "JavaScript": {
          return [0];
        }
        case "TypeScript": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: CodeType; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: CodeType.JavaScript,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: CodeType.TypeScript,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * ラムダ式
 * @typePartId eeeef818144e5a42460c4efdaa221460
 */
export const LambdaExpr: {
  readonly codec: Codec<LambdaExpr>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (a: LambdaExpr) => LambdaExpr;
} = {
  helper: (lambdaExpr: LambdaExpr): LambdaExpr => lambdaExpr,
  codec: {
    encode: (value: LambdaExpr): ReadonlyArray<number> =>
      List.codec(Parameter.codec)
        .encode(value.parameterList)
        .concat(List.codec(Identifer.codec).encode(value.typeParameterList))
        .concat(Type.codec.encode(value.returnType))
        .concat(List.codec(Statement.codec).encode(value.statementList)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: LambdaExpr; readonly nextIndex: number } => {
      const parameterListAndNextIndex: {
        readonly result: List<Parameter>;
        readonly nextIndex: number;
      } = List.codec(Parameter.codec).decode(index, binary);
      const typeParameterListAndNextIndex: {
        readonly result: List<Identifer>;
        readonly nextIndex: number;
      } = List.codec(Identifer.codec).decode(
        parameterListAndNextIndex.nextIndex,
        binary
      );
      const returnTypeAndNextIndex: {
        readonly result: Type;
        readonly nextIndex: number;
      } = Type.codec.decode(typeParameterListAndNextIndex.nextIndex, binary);
      const statementListAndNextIndex: {
        readonly result: List<Statement>;
        readonly nextIndex: number;
      } = List.codec(Statement.codec).decode(
        returnTypeAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          parameterList: parameterListAndNextIndex.result,
          typeParameterList: typeParameterListAndNextIndex.result,
          returnType: returnTypeAndNextIndex.result,
          statementList: statementListAndNextIndex.result,
        },
        nextIndex: statementListAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * ログインのURLを発行するために必要なデータ
 * @typePartId f03ea5331c1a3adcde80a04054d35e07
 */
export const RequestLogInUrlRequestData: {
  readonly codec: Codec<RequestLogInUrlRequestData>;
  /**
   * 型を合わせる上で便利なヘルパー関数
   */
  readonly helper: (
    a: RequestLogInUrlRequestData
  ) => RequestLogInUrlRequestData;
} = {
  helper: (
    requestLogInUrlRequestData: RequestLogInUrlRequestData
  ): RequestLogInUrlRequestData => requestLogInUrlRequestData,
  codec: {
    encode: (value: RequestLogInUrlRequestData): ReadonlyArray<number> =>
      OpenIdConnectProvider.codec
        .encode(value.openIdConnectProvider)
        .concat(UrlData.codec.encode(value.urlData)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: RequestLogInUrlRequestData;
      readonly nextIndex: number;
    } => {
      const openIdConnectProviderAndNextIndex: {
        readonly result: OpenIdConnectProvider;
        readonly nextIndex: number;
      } = OpenIdConnectProvider.codec.decode(index, binary);
      const urlDataAndNextIndex: {
        readonly result: UrlData;
        readonly nextIndex: number;
      } = UrlData.codec.decode(
        openIdConnectProviderAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          openIdConnectProvider: openIdConnectProviderAndNextIndex.result,
          urlData: urlDataAndNextIndex.result,
        },
        nextIndex: urlDataAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * JavaScriptのオブジェクトリテラルの要素
 * @typePartId fddd2a65994fae205dd636f3a6b9f1ea
 */
export const Member: {
  /**
   * ...a のようにする
   */
  readonly Spread: (a: Expr) => Member;
  /**
   * a: b のようにする
   */
  readonly KeyValue: (a: KeyValue) => Member;
  readonly codec: Codec<Member>;
} = {
  Spread: (expr: Expr): Member => ({ _: "Spread", expr }),
  KeyValue: (keyValue: KeyValue): Member => ({ _: "KeyValue", keyValue }),
  codec: {
    encode: (value: Member): ReadonlyArray<number> => {
      switch (value._) {
        case "Spread": {
          return [0].concat(Expr.codec.encode(value.expr));
        }
        case "KeyValue": {
          return [1].concat(KeyValue.codec.encode(value.keyValue));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Member; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: Expr;
          readonly nextIndex: number;
        } = Expr.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Member.Spread(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: KeyValue;
          readonly nextIndex: number;
        } = KeyValue.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Member.KeyValue(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};
