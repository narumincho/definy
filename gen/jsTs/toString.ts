import * as d from "../../localData";
import { documentToString, typeParameterListToString } from "./toString/common";
import { exprToString, lambdaBodyToString } from "./toString/expr";
import { typeAnnotation, typeToString } from "./toString/type";
import { statementListToString } from "./toString/statement";

/**
 * コードを文字列にする
 * @param code コードを表すデータ
 * @param moduleMap モジュールの名をnamed importで使う名前
 * @param codeType JavaScriptかTypeScriptか
 */
export const toString = (
  code: d.JsTsCode,
  moduleMap: ReadonlyMap<string, d.TsIdentifer>,
  codeType: d.CodeType
): string => {
  const importCode =
    "/* eslint-disable */\n/* generated by definy. Do not edit! */\n\n" +
    [...moduleMap.entries()]
      .map(
        ([name, identifer]) =>
          "import * as " + identifer.string + ' from "' + name + '";'
      )
      .join("\n") +
    "\n";

  const definitionCode =
    code.exportDefinitionList
      .map((definition) => definitionToString(definition, moduleMap, codeType))
      .join("") + "\n";

  const statementCode = statementListToString(
    code.statementList,
    0,
    moduleMap,
    codeType
  );

  if (code.statementList.length === 0) {
    return importCode + definitionCode;
  }
  return importCode + definitionCode + statementCode;
};

const definitionToString = (
  definition: d.ExportDefinition,
  moduleMap: ReadonlyMap<string, d.TsIdentifer>,
  codeType: d.CodeType
): string => {
  switch (definition._) {
    case "TypeAlias":
      if (codeType === "JavaScript") {
        return "";
      }
      return typeAliasToString(definition.typeAlias, moduleMap);

    case "Function":
      return exportFunctionToString(definition.function, moduleMap, codeType);

    case "Variable":
      return exportVariableToString(definition.variable, moduleMap, codeType);
  }
};

const typeAliasToString = (
  typeAlias: d.TypeAlias,
  moduleMap: ReadonlyMap<string, d.TsIdentifer>
): string =>
  documentToString(typeAlias.document) +
  "export type " +
  typeAlias.name.string +
  typeParameterListToString(typeAlias.typeParameterList) +
  " = " +
  typeToString(typeAlias.type, moduleMap) +
  ";\n\n";

const exportFunctionToString = (
  function_: d.Function,
  moduleMap: ReadonlyMap<string, d.TsIdentifer>,
  codeType: d.CodeType
): string =>
  documentToString(
    function_.document + parameterListToDocument(function_.parameterList)
  ) +
  "export const " +
  function_.name.string +
  " = " +
  typeParameterListToString(function_.typeParameterList) +
  "(" +
  function_.parameterList
    .map(
      (parameter) =>
        parameter.name.string +
        typeAnnotation(parameter.type, codeType, moduleMap)
    )
    .join(", ") +
  ")" +
  typeAnnotation(function_.returnType, codeType, moduleMap) +
  " => " +
  lambdaBodyToString(function_.statementList, 0, moduleMap, codeType) +
  ";\n\n";

const exportVariableToString = (
  variable: d.Variable,
  moduleMap: ReadonlyMap<string, d.TsIdentifer>,
  codeType: d.CodeType
): string =>
  documentToString(variable.document) +
  "export const " +
  variable.name.string +
  typeAnnotation(variable.type, codeType, moduleMap) +
  " = " +
  exprToString(variable.expr, 0, moduleMap, codeType) +
  ";\n\n";

const parameterListToDocument = (
  parameterList: ReadonlyArray<d.ParameterWithDocument>
): string =>
  parameterList.length === 0
    ? ""
    : "\n" +
      parameterList
        .map((parameter) =>
          parameter.document === ""
            ? ""
            : "@param " + parameter.name.string + " " + parameter.document
        )
        .join("\n");
