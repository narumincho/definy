/* eslint-disable */
/* generated by js-ts-code-generator. Do not edit! */



/**
 * UserId, ProjectIdなどのIdをバイナリ形式にエンコードする
 */
 export const encodeId = (value: string): ReadonlyArray<number> => (Array.from({ length: 16 }, (_: undefined, i: number): number => (Number.parseInt(value.slice(i * 2, i * 2 + 2), 16))));


 /**
  * バイナリ形式をUserId, ProjectIdなどのIdにデコードする
  * @param index バイナリを読み込み開始位置
  * @param binary バイナリ
  */
 export const decodeId = (index: number, binary: Uint8Array): { readonly result: string; readonly nextIndex: number } => ({ result: [...binary.slice(index, index + 16)].map((n: number): string => (n.toString(16).padStart(2, "0"))).join(""), nextIndex: index + 16 });
 
 
 /**
  * ImageTokenなどのTokenをバイナリ形式にエンコードする
  */
 export const encodeToken = (value: string): ReadonlyArray<number> => (Array.from({ length: 32 }, (_: undefined, i: number): number => (Number.parseInt(value.slice(i * 2, i * 2 + 2), 16))));
 
 
 /**
  * バイナリ形式をImageTokenなどのTokenにエンコードする
  * @param index バイナリを読み込み開始位置
  * @param binary バイナリ
  */
 export const decodeToken = (index: number, binary: Uint8Array): { readonly result: string; readonly nextIndex: number } => ({ result: [...binary.slice(index, index + 32)].map((n: number): string => (n.toString(16).padStart(2, "0"))).join(""), nextIndex: index + 32 });
 
 
 /**
  * バイナリと相互変換するための関数
  */
 export type Codec<T extends unknown> = { readonly encode: (a: T) => ReadonlyArray<number>; readonly decode: (a: number, b: Uint8Array) => { readonly result: T; readonly nextIndex: number } };
 
 
 /**
  * 生徒やゲスト向けの招待トークンが含まれていないクラスの情報
  * @typePartId 067954ebc8a7f155be3a4ee196ccf99a
  */
 export type QClassStudentOrGuest = { 
 /**
  * クラス名
  */
 readonly name: String; 
 /**
  * クラスID
  */
 readonly id: QClassId; 
 /**
  * 作成したアカウントのID
  */
 readonly createAccountId: AccountId };
 
 
 /**
  * quest の ページの場所を表現する
  * @typePartId 0951f74f6309835e7ff412f105474aa7
  */
 export type QLocation = { readonly _: "Top" } | { readonly _: "Setting" } | { readonly _: "NewProgram" } | { readonly _: "Program"; readonly qProgramId: QProgramId } | { readonly _: "NewQuestion"; readonly qNewQuestionParameter: QNewQuestionParameter } | { readonly _: "Question"; readonly qQuestionId: QQuestionId } | { readonly _: "Class"; readonly qClassId: QClassId } | { readonly _: "NewClass"; readonly qProgramId: QProgramId } | { readonly _: "ClassInvitation"; readonly qClassInvitationToken: QClassInvitationToken } | { readonly _: "EditQuestion"; readonly qQuestionId: QQuestionId };
 
 
 /**
  * バリアント. 値コンストラクタ. タグ
  * @typePartId 0bc2e5ab2fd2caeb6e6c331573ae735f
  */
 export type ElmVariant = { 
 /**
  * バリアント名
  */
 readonly name: ElmVariantName; 
 /**
  * パラメーター
  */
 readonly parameter: List<ElmType> };
 
 
 /**
  * クラスの情報をクラスの招待トークンから取得するときのレスポンス
  * @typePartId 0bc48429266ac8dfe8f9f8f304938c88
  */
 export type GetClassAndRoleResult = { readonly _: "NotJoin"; readonly qClass: QClass } | { readonly _: "JoinedAsStudent"; readonly qClass: QClass } | { readonly _: "JoinedAsGuest"; readonly qClass: QClass };
 
 
 /**
  * 外部に公開する定義
  * @typePartId 0c8b854b812290a054877ca5de6c4daf
  */
 export type ExportDefinition = { readonly _: "TypeAlias"; readonly typeAlias: TypeAlias } | { readonly _: "Function"; readonly function: Function } | { readonly _: "Variable"; readonly variable: Variable };
 
 
 /**
  * 単項演算子と適用される式
  * @typePartId 0cb0a34b3953e57b30f4a5c8f9d305da
  */
 export type UnaryOperatorExpr = { 
 /**
  * 単項演算子
  */
 readonly operator: UnaryOperator; 
 /**
  * 適用される式
  */
 readonly expr: TsExpr };
 
 
 /**
  * プロジェクトの識別子
  * @typePartId 0cd913118a2ad1469d656146a08c5f76
  */
 export type ProjectId = string & { readonly _projectId: never };
 
 
 /**
  * 英語,日本語,エスペラント語
  *
  * ナルミンチョが使える? プログラミングじゃない言語
  * @typePartId 0d9510723f4d34605e41f3a47a8b0ea7
  */
 export type Language = "Japanese" | "English" | "Esperanto";
 
 
 /**
  * Elmで使う型の名前. Elmで使える型名ということを確認済み
  * @typePartId 13e52324ba81c7ffe655455ad739ea73
  */
 export type ElmTypeName = { readonly _: "ElmTypeName"; readonly string: String };
 
 
 /**
  * -2 147 483 648 ～ 2 147 483 647. 32bit 符号付き整数. JavaScriptのnumberとして扱える. numberの32bit符号あり整数をSigned Leb128のバイナリに変換する
  * @typePartId 16c2d8602e3e5e2d38b9215bd0c44d8d
  */
 export type Int32 = number;
 
 
 /**
  * Elm の 型
  * @typePartId 173f661790b059baf212043f816ba1a9
  */
 export type ElmType = { readonly _: "ImportedType"; readonly elmImportedType: ElmImportedType } | { readonly _: "TypeParameter"; readonly string: String } | { readonly _: "Function"; readonly elmFunctionType: ElmFunctionType } | { readonly _: "List"; readonly elmType: ElmType } | { readonly _: "Tuple0" } | { readonly _: "Tuple2"; readonly elmTuple2: ElmTuple2 } | { readonly _: "Tuple3"; readonly elmTuple3: ElmTuple3 } | { readonly _: "Record"; readonly elmFieldList: List<ElmField> } | { readonly _: "LocalType"; readonly elmLocalType: ElmLocalType };
 
 
 /**
  * @typePartId 1835ebdc909b0fa93d11ae0ed93d0606
  */
 export type TsType = { readonly _: "Number" } | { readonly _: "String" } | { readonly _: "Boolean" } | { readonly _: "Undefined" } | { readonly _: "Null" } | { readonly _: "Never" } | { readonly _: "Void" } | { readonly _: "Object"; readonly tsMemberTypeList: List<TsMemberType> } | { readonly _: "Function"; readonly functionType: FunctionType } | { readonly _: "WithTypeParameter"; readonly tsTypeWithTypeParameter: TsTypeWithTypeParameter } | { readonly _: "Union"; readonly tsTypeList: List<TsType> } | { readonly _: "Intersection"; readonly intersectionType: IntersectionType } | { readonly _: "ImportedType"; readonly importedType: ImportedType } | { readonly _: "ScopeInFile"; readonly tsIdentifer: TsIdentifer } | { readonly _: "ScopeInGlobal"; readonly tsIdentifer: TsIdentifer } | { readonly _: "StringLiteral"; readonly string: String };
 
 
 /**
  * Project, Account, TypePartなどのリソースの状態とデータ. 読み込み中だとか
  * @typePartId 18cbd2fa4bd72a0eacf3f0f44aeb6feb
  */
 export type ResourceState<data extends unknown> = { readonly _: "Loaded"; readonly dataWithTime: WithTime<data> } | { readonly _: "Deleted"; readonly time: Time } | { readonly _: "Unknown"; readonly time: Time } | { readonly _: "Requesting" };
 
 
 /**
  * quest で 生徒(質問を答え, フィードバックするひと) としてクラスに参加するためのパラメータ
  * @typePartId 1928498fae964eff3fc965142c9677dc
  */
 export type JoinClassAsStudentParameter = { 
 /**
  * 参加するアカウントのアカウントトークン
  */
 readonly accountToken: AccountToken; 
 /**
  * 招待トークン
  */
 readonly classInvitationToken: QClassInvitationToken };
 
 
 /**
  * definy.app のメッセージ
  * @typePartId 1c280bc21ab8d5ccc4455800650cf31b
  */
 export type AppMessage = { readonly _: "NoOp" } | { readonly _: "Jump"; readonly urlData: UrlData } | { readonly _: "RequestLogin"; readonly openIdConnectProvider: OpenIdConnectProvider } | { readonly _: "RespondLogInUrlTag"; readonly stringMaybe: Maybe<String> };
 
 
 /**
  * Unit. 1つの値しかない型. JavaScriptのundefinedで扱う
  * @typePartId 217263d8cdca613c2d1ba77e19d4cbb0
  */
 export type Unit = undefined;
 
 
 /**
  * コンパイラに向けた, 型のデータ形式をどうするかの情報
  * @typePartId 22d8f2d392c573a7aa54c39fa4c98ad0
  */
 export type TypeAttribute = "AsBoolean" | "AsUndefined";
 
 
 /**
  * @typePartId 2392b884a9c2238a65ecd272bd23a9cd
  */
 export type ElmField = { 
 /**
  * フィールド名
  */
 readonly name: ElmFieldName; 
 /**
  * 型
  */
 readonly type: ElmType };
 
 
 /**
  * パラメーター付きの型
  * @typePartId 23fa0e8b66c9d093d4c18579ffefaaa3
  */
 export type TsTypeWithTypeParameter = { 
 /**
  * パラメーターをつけられる型
  */
 readonly type: TsType; 
 /**
  * パラメーターに指定する型. なにも要素を入れなけければ T<>ではなく T の形式で出力される
  */
 readonly typeParameterList: List<TsType> };
 
 
 /**
  * 評価したときに失敗した原因を表すもの
  * @typePartId 25d0af5522da614f7617016ca7868edd
  */
 export type EvaluateExprError = { readonly _: "NeedPartDefinition"; readonly partId: PartId } | { readonly _: "Blank" } | { readonly _: "TypeError"; readonly string: String } | { readonly _: "NotSupported" };
 
 
 /**
  * TypeScriptの識別子として使える文字
  * @typePartId 2a75ad7c7ccc58ba56f6c8545c8150d1
  */
 export type TsIdentifer = { readonly _: "Identifer"; readonly string: String };
 
 
 /**
  * モジュール内の型
  * @typePartId 2b42264a878355f0257141fa013fed5c
  */
 export type ElmLocalType = { 
 /**
  * 型名
  */
 readonly typeName: ElmTypeName; 
 /**
  * 型パラメーター
  */
 readonly parameter: List<ElmType> };
 
 
 /**
  * 関数呼び出し
  * @typePartId 2f9784d2c41d0974487a1ca2b0a51ec5
  */
 export type FunctionCall = { 
 /**
  * 関数
  */
 readonly function: Expr; 
 /**
  * パラメーター
  */
 readonly parameter: Expr };
 
 
 /**
  * Maybe. nullableのようなもの. 今後はRustのstd::Optionに出力するために属性をつけよう (確信)
  * @typePartId 304f21ae8208a21d08731aa6d183742d
  */
 export type Maybe<value extends unknown> = { readonly _: "Just"; readonly value: value } | { readonly _: "Nothing" };
 
 
 /**
  * 配列リテラルの要素
  * @typePartId 35f7e442c0838f9982e6b49da398d97f
  */
 export type ArrayItem = { 
 /**
  * 式
  */
 readonly expr: TsExpr; 
 /**
  * スプレッド ...a のようにするか
  */
 readonly spread: Bool };
 
 
 /**
  * quest で ログインしている状態で, クラスの招待URLを受け取ったときに, クラスの情報と, クラスにすでに入っているかなどを取得する
  * @typePartId 37e7ea136171a7fd4e23be7a7385af6b
  */
 export type GetClassAndRoleParameter = { 
 /**
  * ログインするアカウントのアカウントトークン
  */
 readonly accountToken: AccountToken; 
 /**
  * クラスの招待トークン
  */
 readonly classInvitationToken: QClassInvitationToken };
 
 
 /**
  * 質問IDからプログラムに属する質問を取得する
  * @typePartId 38f8436dbd5f16407883acb3917cca49
  */
 export type GetQuestionListInProgramByQuestionIdParameter = { 
 /**
  * quest の アカウントトークン
  */
 readonly accountToken: AccountToken; 
 /**
  * 質問ID
  */
 readonly questionId: QQuestionId };
 
 
 /**
  * バイナリ. JavaScriptのUint8Arrayで扱える. 最初にLED128でバイト数, その次にバイナリそのまま
  * @typePartId 3e2f740c88923b0393a1ef93d92f157b
  */
 export type Binary = Uint8Array;
 
 
 /**
  * 3つの要素のタプルの型
  * @typePartId 42e5ab4936af4abf8673472ce96fd794
  */
 export type ElmTuple3 = { 
 /**
  * 左の型
  */
 readonly first: ElmType; 
 /**
  * 真ん中の型
  */
 readonly second: ElmType; 
 /**
  * 右の型
  */
 readonly third: ElmType };
 
 
 /**
  * 外部のモジュールの型
  * @typePartId 43aa21ed2225cacc4489c30113e87787
  */
 export type ElmImportedType = { 
 /**
  * モジュール名
  */
 readonly moduleName: String; 
 /**
  * 型名
  */
 readonly typeName: ElmTypeName; 
 /**
  * 型パラメーター
  */
 readonly parameter: List<ElmType> };
 
 
 /**
  * 2項演算子
  * @typePartId 4953938f040aefdaa5f2601e2a78d43b
  */
 export type BinaryOperator = "Exponentiation" | "Multiplication" | "Division" | "Remainder" | "Addition" | "Subtraction" | "LeftShift" | "SignedRightShift" | "UnsignedRightShift" | "LessThan" | "LessThanOrEqual" | "Equal" | "NotEqual" | "BitwiseAnd" | "BitwiseXOr" | "BitwiseOr" | "LogicalAnd" | "LogicalOr";
 
 
 /**
  * 型アサーション
  * @typePartId 49f05a756bd75da670fa5b64ed8bf1ae
  */
 export type TypeAssertion = { 
 /**
  * 型アサーションを受ける式
  */
 readonly expr: TsExpr; 
 /**
  * 型
  */
 readonly type: TsType };
 
 
 /**
  * JavaScriptの単項演算子
  * @typePartId 4b4c3f8f34d1c05bb9d7d1b930bc9c9a
  */
 export type UnaryOperator = "Minus" | "BitwiseNot" | "LogicalNot";
 
 
 /**
  * 型の定義本体
  * @typePartId 4c60c73d6b8f236d34281fbb9119a598
  */
 export type TypePartBody = { readonly _: "Product"; readonly memberList: List<Member> } | { readonly _: "Sum"; readonly patternList: List<Pattern> } | { readonly _: "Kernel"; readonly typePartBodyKernel: TypePartBodyKernel };
 
 
 /**
  * クラスを作成するためのパラメータ
  * @typePartId 4d9e178c23a42a4dc2e2b68270d50363
  */
 export type QCreateClassParameter = { 
 /**
  * クラスを作成するアカウントのアカウントトークン
  */
 readonly accountToken: AccountToken; 
 /**
  * プログラムID
  */
 readonly programId: QProgramId; 
 /**
  * クラス名
  */
 readonly className: String };
 
 
 /**
  * カスタム型の公開レベル
  * @typePartId 4e1cab8c9074c1a058d6ef3ffcf29ab0
  */
 export type ElmCustomTypeExportLevel = "NoExport" | "ExportTypeOnly" | "ExportTypeAndVariant";
 
 
 /**
  * quest の アカウント
  * @typePartId 4e6857a774597ae66e5c316642a8ae8b
  */
 export type QAccount = { 
 /**
  * アカウント名
  */
 readonly name: String; 
 /**
  * アイコン画像のハッシュ値
  */
 readonly iconHash: ImageHash; 
 /**
  * アカウントのID
  */
 readonly id: AccountId };
 
 
 /**
  * quest の プログラムのID
  * @typePartId 4fe2f5da0a887c2a6b33c16c5d52058f
  */
 export type QProgramId = string & { readonly _qProgramId: never };
 
 
 /**
  * クエストの質問 ID
  * @typePartId 5249c5510c734bbe48e63a23e4e202b3
  */
 export type QQuestionId = string & { readonly _qQuestionId: never };
 
 
 /**
  * 関数のパラメーター. パラメーター名, 型
  * @typePartId 5433bade7738da21e7663ff043f588d5
  */
 export type Parameter = { 
 /**
  * パラメーター名
  */
 readonly name: TsIdentifer; 
 /**
  * パラメーターの型
  */
 readonly type: TsType };
 
 
 /**
  * 辞書型. TypeScriptでは ReadonlyMap として扱う
  * @typePartId 5516d41d180b98b7f5a8950d4f43dfd6
  */
 export type Dict<key extends unknown, value extends unknown> = ReadonlyMap<key, value>;
 
 
 /**
  * 取得日時と任意のデータ
  * @typePartId 55d4de38cfb884b9008abd7f7f63325e
  */
 export type WithTime<data extends unknown> = { 
 /**
  * データベースから取得した日時
  */
 readonly getTime: Time; 
 /**
  * データ
  */
 readonly data: data };
 
 
 /**
  * 型エイリアス. 型に名前を付け, レコード型の場合, その名前の関数を作成する
  * @typePartId 57f429fd5c67eb2542447a2eaeb34497
  */
 export type ElmTypeAlias = { 
 /**
  * 型エイリアス名
  */
 readonly name: ElmTypeName; 
 /**
  * 外部に公開するか
  */
 readonly export: Bool; 
 /**
  * コメント
  */
 readonly comment: String; 
 /**
  * 型パラメーター
  */
 readonly parameter: List<String>; 
 /**
  * 別名を付ける型
  */
 readonly type: ElmType };
 
 
 /**
  * パーツの識別子
  * @typePartId 5880cd7c0b6f0205c739a06181898d03
  */
 export type PartId = string & { readonly _partId: never };
 
 
 /**
  * AccountToken と UserId
  * @typePartId 5d291325e9d7bc27ff35e907f59bde54
  */
 export type AccountTokenAndUserId = { 
 /**
  * accountToken
  */
 readonly accountToken: AccountToken; 
 /**
  * UserId
  */
 readonly userId: AccountId };
 
 
 /**
  * タグの識別子. タグは直和型に使うもの.
  *
  * 実行時に使わないことは確定しているが, コード内の形式としてタグにUUIDを使うべきかは考慮中. index で充分かと思ったが別に型の情報も必要になることが多い
  * @typePartId 5ec292c48424e5e9ee8cc2d672830ecd
  */
 export type TagId = string & { readonly _tagId: never };
 
 
 /**
  * 関数の型. 入力と出力
  * @typePartId 5ec9dae951d8d2b250c81185a259adca
  */
 export type ElmFunctionType = { 
 /**
  * 入力の型
  */
 readonly input: ElmType; 
 /**
  * 出力の型
  */
 readonly output: ElmType };
 
 
 /**
  * switch文のcase "text": { statementList } の部分
  * @typePartId 6126431def47ecba239b3add7f472b19
  */
 export type TsPattern = { 
 /**
  * case に使う文字列
  */
 readonly caseString: String; 
 /**
  * マッチしたときに実行する部分
  */
 readonly statementList: List<Statement> };
 
 
 /**
  * QUEST. クラスのID
  * @typePartId 624e37b7230f763e6318c627c2c728ec
  */
 export type QClassId = string & { readonly _qClassId: never };
 
 
 /**
  * 型パラメーター
  * @typePartId 627dc8fa15214481812af12268d97b6b
  */
 export type TypeParameter = { 
 /**
  * 型パラメーターの名前
  */
 readonly name: String; 
 /**
  * 型パラメーターの型ID
  */
 readonly typePartId: TypePartId };
 
 
 /**
  * Elmのコードを表現するもの
  * @typePartId 62923d32a2730114e665cef13f93ff13
  */
 export type ElmCode = { 
 /**
  * モジュール名
  */
 readonly moduleName: String; 
 /**
  * 型定義
  */
 readonly typeDeclarationList: List<ElmTypeDeclaration> };
 
 
 /**
  * Definyだけでは表現できないデータ型
  * @typePartId 657b5a5519b095480a21fdadd0f6fbd1
  */
 export type TypePartBodyKernel = "Function" | "Int32" | "String" | "Binary" | "Id" | "Token" | "List" | "Dict";
 
 
 /**
  * 文字列. JavaScriptのstringで扱う. バイナリ形式はUTF-8. 不正な文字が入っている可能性がある
  * @typePartId 666361c9ae68ab64f273c47f3feb8c73
  */
 export type String = string;
 
 
 /**
  * ユーザー名. 表示される名前. 他のユーザーとかぶっても良い. 絵文字も使える. 全角英数は半角英数,半角カタカナは全角カタカナ, (株)の合字を分解するなどのNFKCの正規化がされる. U+0000-U+0019 と U+007F-U+00A0 の範囲の文字は入らない. 前後に空白を含められない. 間の空白は2文字以上連続しない. 文字数のカウント方法は正規化されたあとのCodePoint単位. Twitterと同じ, 1文字以上50文字以下
  * @typePartId 67d4e3bc4f13e1132b6c5e81d5b74395
  */
 export type Account = { 
 /**
  * プロフィール画像
  */
 readonly imageHash: ImageHash; 
 /**
  * initMemberDescription
  */
 readonly introduction: String; 
 /**
  * Definyでユーザーが作成された日時
  */
 readonly createTime: Time; 
 /**
  * アカウント名. 表示される名前. 他のユーザーとかぶっても良い. 絵文字も使える. 全角英数は半角英数,半角カタカナは全角カタカナ, (株)の合字を分解するなどのNFKCの正規化がされる. U+0000-U+0019 と U+007F-U+00A0 の範囲の文字は入らない. 前後に空白を含められない. 間の空白は2文字以上連続しない. 文字数のカウント方法は正規化されたあとのCodePoint単位. Twitterと同じ, 1文字以上50文字以下
  */
 readonly name: String };
 
 
 /**
  * キーであるTokenによってデータが必ず1つに決まるもの. 絶対に更新されない. リソースがないということはデータが不正な状態になっているということ
  * @typePartId 68d925f7b35bab8f265cd9e5eb7ea3da
  */
 export type StaticResourceState<data extends unknown> = { readonly _: "Loaded"; readonly data: data } | { readonly _: "Unknown" } | { readonly _: "Loading" } | { readonly _: "Requesting" };
 
 
 /**
  * 代入文
  * @typePartId 6a5a7886b0f117a50d9d7b11ffe87c9f
  */
 export type SetStatement = { 
 /**
  * 対象となる式. 指定の仕方によってはJSのSyntaxErrorになる
  */
 readonly target: TsExpr; 
 /**
  * 演算子を=の左につける
  */
 readonly operatorMaybe: Maybe<BinaryOperator>; 
 /**
  * 式
  */
 readonly expr: TsExpr };
 
 
 /**
  * ドキュメント付きの関数のパラメーター. パラメーター名, ドキュメント, 型
  * @typePartId 6b05e33009ade6b4decd452e8fd4bff1
  */
 export type ParameterWithDocument = { 
 /**
  * パラメーター名
  */
 readonly name: TsIdentifer; 
 /**
  * ドキュメント
  */
 readonly document: String; 
 /**
  * パラメーターの型
  */
 readonly type: TsType };
 
 
 /**
  * 型パーツの識別子
  * @typePartId 6e3cff317f8bfbbd1391c0afb9ad6b72
  */
 export type TypePartId = string & { readonly _typePartId: never };
 
 
 /**
  * 成功と失敗を表す型. 今後はRustのstd::Resultに出力するために属性をつける?
  * @typePartId 6f937e46fce1cf70d29c54780f132c18
  */
 export type Result<ok extends unknown, error extends unknown> = { readonly _: "Ok"; readonly ok: ok } | { readonly _: "Error"; readonly error: error };
 
 
 /**
  * 言語とページの場所. URLとして表現されるデータ. Googleなどの検索エンジンの都合( https://support.google.com/webmasters/answer/182192?hl=ja )で,URLにページの言語を入れて,言語ごとに別のURLである必要がある.
  * @typePartId 7210f04a85c5f0f58f7aa20826d67f05
  */
 export type UrlData = { 
 /**
  * 場所
  */
 readonly location: Location; 
 /**
  * 言語
  */
 readonly language: Language };
 
 
 /**
  * switch文
  * @typePartId 725f84ef82e6c3b5b5f6fd5208977dd8
  */
 export type SwitchStatement = { 
 /**
  * switch(a) {} の a
  */
 readonly expr: TsExpr; 
 /**
  * case "text": { statementList }
  */
 readonly patternList: List<TsPattern> };
 
 
 /**
  * ローカル変数定義
  * @typePartId 7277cf2483388ee2f5ad7a7fc8585d98
  */
 export type VariableDefinitionStatement = { 
 /**
  * 変数名
  */
 readonly name: TsIdentifer; 
 /**
  * 変数の型
  */
 readonly type: TsType; 
 /**
  * 式
  */
 readonly expr: TsExpr; 
 /**
  * constかどうか. falseはlet
  */
 readonly isConst: Bool };
 
 
 /**
  * プロジェクト作成時に必要なパラメーター
  * @typePartId 7b987551cc112a64f5c9a8cb1647f4bd
  */
 export type CreateProjectParameter = { 
 /**
  * プロジェクトを作るときのアカウント
  */
 readonly accountToken: AccountToken; 
 /**
  * プロジェクト名
  */
 readonly projectName: String };
 
 
 /**
  * JavaScript の 文
  * @typePartId 7c957d411f448a03764f16d43e6e5008
  */
 export type Statement = { readonly _: "EvaluateExpr"; readonly tsExpr: TsExpr } | { readonly _: "Set"; readonly setStatement: SetStatement } | { readonly _: "If"; readonly ifStatement: IfStatement } | { readonly _: "ThrowError"; readonly tsExpr: TsExpr } | { readonly _: "Return"; readonly tsExpr: TsExpr } | { readonly _: "ReturnVoid" } | { readonly _: "Continue" } | { readonly _: "VariableDefinition"; readonly variableDefinitionStatement: VariableDefinitionStatement } | { readonly _: "FunctionDefinition"; readonly functionDefinitionStatement: FunctionDefinitionStatement } | { readonly _: "For"; readonly forStatement: ForStatement } | { readonly _: "ForOf"; readonly forOfStatement: ForOfStatement } | { readonly _: "WhileTrue"; readonly statementList: List<Statement> } | { readonly _: "Break" } | { readonly _: "Switch"; readonly switchStatement: SwitchStatement };
 
 
 /**
  * 日時. `0001-01-01T00:00:00.000Z to 9999-12-31T23:59:59.999Z` 最小単位はミリ秒. ミリ秒の求め方は `day*1000*60*60*24 + millisecond`
  * @typePartId 7d91f0f70643799692aa144ee51a62b1
  */
 export type Time = { 
 /**
  * `1970-01-01` からの経過日数. マイナスになることもある
  */
 readonly day: Int32; 
 /**
  * 日にちの中のミリ秒. `0 to 86399999 (=1000*60*60*24-1)`
  */
 readonly millisecond: Int32 };
 
 
 /**
  * アカウントトークンとプロジェクトID
  * @typePartId 7e4613f18e8e3bcfdfc00356654414d5
  */
 export type AccountTokenAndProjectId = { 
 /**
  * アカウントトークン
  */
 readonly accountToken: AccountToken; 
 /**
  * プロジェクトID
  */
 readonly projectId: ProjectId };
 
 
 /**
  * インポートした変数
  * @typePartId 8150e2833dc1f2a77715aa1bb7b2baad
  */
 export type ImportedVariable = { 
 /**
  * モジュール名, 使うときにはnamedインポートされ, そのモジュール識別子は自動的につけられる
  */
 readonly moduleName: String; 
 /**
  * 変数名
  */
 readonly name: TsIdentifer };
 
 
 /**
  * "ソーシャルログインを提供するプロバイダー (例: Google, GitHub)
  *
  * GitHub いらないかも (GitHubのアカウント作成するの分かりづらいので, 選択肢を減らしたい)
  * @typePartId 84597034eb252267ce1a599ab7a0b543
  */
 export type OpenIdConnectProvider = "Google" | "GitHub";
 
 
 /**
  * 型パーツ
  * @typePartId 87fc411d10f6986dd33e5dbaff6d06ae
  */
 export type TypePart = { 
 /**
  * 型パーツの名前
  */
 readonly name: String; 
 /**
  * 型パーツの説明
  */
 readonly description: String; 
 /**
  * 所属しているプロジェクトのID
  */
 readonly projectId: ProjectId; 
 /**
  * コンパイラに与える,この型を表現するのにどういう特殊な状態にするかという情報
  */
 readonly attribute: Maybe<TypeAttribute>; 
 /**
  * 型パラメーター
  */
 readonly typeParameterList: List<TypeParameter>; 
 /**
  * 定義本体
  */
 readonly body: TypePartBody };
 
 
 /**
  * 質問を作るページのパラメータ
  * @typePartId 8960809c7ca4954e9235c197f5d63cdf
  */
 export type QNewQuestionParameter = { 
 /**
  * 属するプログラム
  */
 readonly programId: QProgramId; 
 /**
  * 親にする質問
  */
 readonly parent: Maybe<QQuestionId>; 
 /**
  * 本文. 質問テンプレートにどうぞ
  */
 readonly text: String };
 
 
 /**
  * JavaScript の 式
  * @typePartId 8b0bdbeae05df3badac2ee69bf22011f
  */
 export type TsExpr = { readonly _: "NumberLiteral"; readonly int32: Int32 } | { readonly _: "StringLiteral"; readonly string: String } | { readonly _: "BooleanLiteral"; readonly bool: Bool } | { readonly _: "NullLiteral" } | { readonly _: "UndefinedLiteral" } | { readonly _: "UnaryOperator"; readonly unaryOperatorExpr: UnaryOperatorExpr } | { readonly _: "BinaryOperator"; readonly binaryOperatorExpr: BinaryOperatorExpr } | { readonly _: "ConditionalOperator"; readonly conditionalOperatorExpr: ConditionalOperatorExpr } | { readonly _: "ArrayLiteral"; readonly arrayItemList: List<ArrayItem> } | { readonly _: "ObjectLiteral"; readonly tsMemberList: List<TsMember> } | { readonly _: "Lambda"; readonly lambdaExpr: LambdaExpr } | { readonly _: "Variable"; readonly tsIdentifer: TsIdentifer } | { readonly _: "GlobalObjects"; readonly tsIdentifer: TsIdentifer } | { readonly _: "ImportedVariable"; readonly importedVariable: ImportedVariable } | { readonly _: "Get"; readonly getExpr: GetExpr } | { readonly _: "Call"; readonly callExpr: CallExpr } | { readonly _: "New"; readonly callExpr: CallExpr } | { readonly _: "TypeAssertion"; readonly typeAssertion: TypeAssertion };
 
 
 /**
  * 2つの要素のタプルの型
  * @typePartId 8b479d8726bb494ac76d529fbf03908c
  */
 export type ElmTuple2 = { 
 /**
  * 左の型
  */
 readonly first: ElmType; 
 /**
  * 右の型
  */
 readonly second: ElmType };
 
 
 /**
  * Definy の プロジェクト
  * @typePartId 8bc81fa2a15bdbd8c2414d22f3e1b462
  */
 export type Project = { 
 /**
  * プロジェクト名
  */
 readonly name: String; 
 /**
  * プロジェクトのアイコン画像
  */
 readonly iconHash: ImageHash; 
 /**
  * initMemberDescription
  */
 readonly imageHash: ImageHash; 
 /**
  * initMemberDescription
  */
 readonly createTime: Time; 
 /**
  * プロジェクトを作成したアカウント
  */
 readonly createAccountId: AccountId; 
 /**
  * 更新日時
  */
 readonly updateTime: Time };
 
 
 /**
  * forOf文
  * @typePartId 8be8db4404f302dd36c8a2c6c6e37e7c
  */
 export type ForOfStatement = { 
 /**
  * 要素の変数名
  */
 readonly elementVariableName: TsIdentifer; 
 /**
  * 繰り返す対象
  */
 readonly iterableExpr: TsExpr; 
 /**
  * 繰り返す文
  */
 readonly statementList: List<Statement> };
 
 
 /**
  * TypeScriptやJavaScriptのコードを表現する. TypeScriptでも出力できるように型情報をつける必要がある
  * @typePartId 92ea504049ca5b7e2227a95195fe74eb
  */
 export type JsTsCode = { 
 /**
  * 外部に公開する定義
  */
 readonly exportDefinitionList: List<ExportDefinition>; 
 /**
  * 定義した後に実行するコード
  */
 readonly statementList: List<Statement> };
 
 
 /**
  * 直積型のメンバー
  * @typePartId 9481ceae2c3e2765243f5c7ce7eb76c7
  */
 export type Member = { 
 /**
  * メンバー名
  */
 readonly name: String; 
 /**
  * メンバーの説明
  */
 readonly description: String; 
 /**
  * メンバー値の型
  */
 readonly type: Type };
 
 
 /**
  * アカウントの情報
  * @typePartId 94aa0a477dfb8362d00aaac05b29b79c
  */
 export type QAccountData = { 
 /**
  * アカウント情報
  */
 readonly account: QAccount; 
 /**
  * 作成したプログラム
  */
 readonly createdProgramList: List<QProgram>; 
 /**
  * 作成したクラス
  */
 readonly createdClassList: List<QClass>; 
 /**
  * 参加したクラス
  */
 readonly joinedClassList: List<Tuple2<QClassStudentOrGuest, QRole>> };
 
 
 /**
  * Elm の 式
  * @typePartId 94e53139b3a82087777ea3e001b2adb4
  */
 export type ElmExpr = { readonly _: "StringLiteral"; readonly string: String } | { readonly _: "IntLiteral"; readonly int32: Int32 } | { readonly _: "LocalVariant" } | { readonly _: "ImportedVariant" } | { readonly _: "List"; readonly elmExprList: List<ElmExpr> } | { readonly _: "Op" } | { readonly _: "Negate"; readonly elmExpr: ElmExpr } | { readonly _: "Binops" } | { readonly _: "Lambda" } | { readonly _: "Call" } | { readonly _: "If" } | { readonly _: "Let" } | { readonly _: "Case" } | { readonly _: "Accessor"; readonly string: String } | { readonly _: "Access" } | { readonly _: "Update" } | { readonly _: "Record" } | { readonly _: "Unit" } | { readonly _: "Tuple2" } | { readonly _: "Tuple3" };
 
 
 /**
  * 関数の型
  * @typePartId 98904215e50e04fa2197a7a96df8f646
  */
 export type FunctionType = { 
 /**
  * 型パラメーターのリスト
  */
 readonly typeParameterList: List<TsIdentifer>; 
 /**
  * パラメーターの型. 意味のない引数名は適当に付く
  */
 readonly parameterList: List<TsType>; 
 /**
  * 戻り値の型
  */
 readonly return: TsType };
 
 
 /**
  * 質問を編集する
  * @typePartId 98bc46a897ffdb9d86782890776c9221
  */
 export type QEditQuestion = { 
 /**
  * accountToken
  */
 readonly accountToken: AccountToken; 
 /**
  * questionId
  */
 readonly questionId: QQuestionId; 
 /**
  * 新たな質問文
  */
 readonly name: String; 
 /**
  * 親の質問
  */
 readonly parentId: Maybe<QQuestionId> };
 
 
 /**
  * 2つの値を持つ型
  * @typePartId 9b55e2a5ed07246355fbeba998eaf5fe
  */
 export type Tuple2<first extends unknown, second extends unknown> = { 
 /**
  * 0番目の値
  */
 readonly first: first; 
 /**
  * 1番目の値
  */
 readonly second: second };
 
 
 /**
  * カスタム型. 代数的データ型
  * @typePartId a0cee28e982f5fbcae6b2c7bd1e27e2a
  */
 export type ElmCustomType = { 
 /**
  * カスタム型名
  */
 readonly name: ElmTypeName; 
 /**
  * 外部に公開するレベル
  */
 readonly export: ElmCustomTypeExportLevel; 
 /**
  * コメント
  */
 readonly comment: String; 
 /**
  * 型パラメーター
  */
 readonly parameter: List<String>; 
 /**
  * バリアントのリスト. 値コンストラクタ. タグ
  */
 readonly variantList: List<ElmVariant> };
 
 
 /**
  * 式と呼ぶパラメーター
  * @typePartId a1f71188b7c3ab2a21954471f3ac67f1
  */
 export type CallExpr = { 
 /**
  * 呼ばれる式
  */
 readonly expr: TsExpr; 
 /**
  * パラメーター
  */
 readonly parameterList: List<TsExpr> };
 
 
 /**
  * @typePartId a2580a29c047f54d635c4456696bbef3
  */
 export type Variable = { 
 /**
  * 変数の名前
  */
 readonly name: TsIdentifer; 
 /**
  * ドキュメント
  */
 readonly document: String; 
 /**
  * 変数の型
  */
 readonly type: TsType; 
 /**
  * 変数の式
  */
 readonly expr: TsExpr };
 
 
 /**
  * データを識別するIdとデータ
  * @typePartId a541cb9bb64930be40dc83bf8870f36b
  */
 export type IdAndData<id extends unknown, data extends unknown> = { 
 /**
  * ID
  */
 readonly id: id; 
 /**
  * データ
  */
 readonly data: data };
 
 
 /**
  * questのクラス招待トークン
  * @typePartId a5f14e3ce94846347dc38bc1fb29ba7f
  */
 export type QClassInvitationToken = string & { readonly _qClassInvitationToken: never };
 
 
 /**
  * quest で プログラムを作るときに必要になるパラメータ
  * @typePartId a86e36ceeff2a4fefb8d9147c232dbb6
  */
 export type QCreateProgramParameter = { 
 /**
  * プログラム名
  */
 readonly programName: String; 
 /**
  * アカウントトークン
  */
 readonly accountToken: AccountToken };
 
 
 /**
  * 複数の引数が必要な内部関数の部分呼び出し
  * @typePartId a8c830bd6b3473f2fac7a62ede58ecf0
  */
 export type KernelCall = { 
 /**
  * 関数
  */
 readonly kernel: KernelExpr; 
 /**
  * 呼び出すパラメーター
  */
 readonly expr: EvaluatedExpr };
 
 
 /**
  * プロパティアクセス
  * @typePartId a9ce526a22f09800aa3773a1614cce89
  */
 export type GetExpr = { 
 /**
  * 式
  */
 readonly expr: TsExpr; 
 /**
  * プロパティの式
  */
 readonly propertyExpr: TsExpr };
 
 
 /**
  * 質問を作成するときのパラメータ
  * @typePartId aa65c956d46bd985c325c3567ad65abb
  */
 export type QCreateQuestionParamter = { 
 /**
  * アカウントトークン
  */
 readonly accountToken: AccountToken; 
 /**
  * プログラムID
  */
 readonly programId: QProgramId; 
 /**
  * 親の質問ID
  */
 readonly parent: Maybe<QQuestionId>; 
 /**
  * 質問文
  */
 readonly questionText: String };
 
 
 /**
  * 質問
  * @typePartId ab9150e30802a0e39f7fdca3703da3ab
  */
 export type QQuestion = { 
 /**
  * 質問
  */
 readonly name: String; 
 /**
  * 親の質問
  */
 readonly parent: Maybe<QQuestionId>; 
 /**
  * 所属するプログラム
  */
 readonly programId: QProgramId; 
 /**
  * 質問を識別するID
  */
 readonly id: QQuestionId };
 
 
 /**
  * Definy の 型. 式に対してつけるし, つく. 型パーツの定義にも使う
  * @typePartId b3b36f39469d23321ed01b92f048ccc0
  */
 export type Type = { 
 /**
  * 型の参照
  */
 readonly typePartId: TypePartId; 
 /**
  * 型のパラメーター
  */
 readonly parameter: List<Type> };
 
 
 /**
  * インポートされた型
  * @typePartId b44289bc65640d4ad0ad79a5a627ef78
  */
 export type ImportedType = { 
 /**
  * モジュール名. namedImportされるがその識別子は自動的に作成される
  */
 readonly moduleName: String; 
 /**
  * 型の名前
  */
 readonly name: TsIdentifer };
 
 
 /**
  * アカウントトークンのハッシュ値. データベースに保存する用
  * @typePartId b553ab17ca45f4975d9fe17fe1a63ac4
  */
 export type AccountTokenHash = string & { readonly _accountTokenHash: never };
 
 
 /**
  * Definyだけでは表現できない式
  * @typePartId b6eef263a982482747a8ad0bc9f05e21
  */
 export type KernelExpr = "Int32Add" | "Int32Sub" | "Int32Mul";
 
 
 /**
  * 型パーツのリストを保存, 変更する
  * @typePartId b8bf6c22e275c06c7dc42300c332b47d
  */
 export type SetTypePartListParameter = { 
 /**
  * アカウントトークン
  */
 readonly accountToken: AccountToken; 
 /**
  * プロジェクトID
  */
 readonly projectId: ProjectId; 
 /**
  * 型パーツのリスト
  */
 readonly typePartList: List<IdAndData<TypePartId, TypePart>> };
 
 
 /**
  * DefinyWebアプリ内での場所を示すもの. URLから求められる. URLに変換できる
  * @typePartId bbcb8e43df8afff9fe24b001c66fb065
  */
 export type Location = { readonly _: "Home" } | { readonly _: "CreateProject" } | { readonly _: "Project"; readonly projectId: ProjectId } | { readonly _: "Account"; readonly accountId: AccountId } | { readonly _: "Setting" } | { readonly _: "About" } | { readonly _: "TypePart"; readonly typePartId: TypePartId } | { readonly _: "Part"; readonly partId: PartId };
 
 
 /**
  * TypeAlias. `export type T = {}`
  * @typePartId bf69f7e46f5e4949fe801c234fc3ad15
  */
 export type TypeAlias = { 
 /**
  * 型の名前
  */
 readonly name: TsIdentifer; 
 /**
  * 型パラメーターのリスト
  */
 readonly typeParameterList: List<TsIdentifer>; 
 /**
  * ドキュメント
  */
 readonly document: String; 
 /**
  * 型本体
  */
 readonly type: TsType };
 
 
 /**
  * アカウントを識別するためのID
  * @typePartId c1a17b07e8e664ca80217833ff2ad3f1
  */
 export type AccountId = string & { readonly _accountId: never };
 
 
 /**
  * 文字列のkeyと式のvalue
  * @typePartId c2428cbcd62b33ce2c904a200b876863
  */
 export type KeyValue = { 
 /**
  * key
  */
 readonly key: String; 
 /**
  * value
  */
 readonly value: TsExpr };
 
 
 /**
  * リスト. JavaScriptのArrayで扱う
  * @typePartId c3fc2a6cea61086db59e11dc2bef0eee
  */
 export type List<element extends unknown> = ReadonlyArray<element>;
 
 
 /**
  * definy.app の ログイン状態
  * @typePartId c4b574e3ca8bad17022054d5e77fd3d0
  */
 export type LogInState = { readonly _: "LoadingAccountTokenFromIndexedDB" } | { readonly _: "Guest" } | { readonly _: "RequestingLogInUrl"; readonly openIdConnectProvider: OpenIdConnectProvider } | { readonly _: "JumpingToLogInPage" } | { readonly _: "VerifyingAccountToken"; readonly accountToken: AccountToken } | { readonly _: "LoggedIn"; readonly accountTokenAndUserId: AccountTokenAndUserId };
 
 
 /**
  * for文
  * @typePartId c53be8bcaf56ff90080cf7a75f1e4815
  */
 export type ForStatement = { 
 /**
  * カウンタ変数名
  */
 readonly counterVariableName: TsIdentifer; 
 /**
  * ループの上限の式
  */
 readonly untilExpr: TsExpr; 
 /**
  * 繰り返す文
  */
 readonly statementList: List<Statement> };
 
 
 /**
  * オブジェクトのメンバーの型
  * @typePartId c68bac5afb1a1d35af096bf317d09339
  */
 export type TsMemberType = { 
 /**
  * プロパティ名
  */
 readonly name: String; 
 /**
  * 必須かどうか falseの場合 ? がつく
  */
 readonly required: Bool; 
 /**
  * 型
  */
 readonly type: TsType; 
 /**
  * ドキュメント
  */
 readonly document: String };
 
 
 /**
  * 条件演算子
  * @typePartId c7a771f770f0f92690faeb59eaff6268
  */
 export type ConditionalOperatorExpr = { 
 /**
  * 条件の式
  */
 readonly condition: TsExpr; 
 /**
  * 条件がtrueのときに評価される式
  */
 readonly thenExpr: TsExpr; 
 /**
  * 条件がfalseのときに評価される式
  */
 readonly elseExpr: TsExpr };
 
 
 /**
  * if文
  * @typePartId cd325760f992e47a8438ae78ca9b1529
  */
 export type IfStatement = { 
 /**
  * 条件の式
  */
 readonly condition: TsExpr; 
 /**
  * 条件がtrueのときに実行する文
  */
 readonly thenStatementList: List<Statement> };
 
 
 /**
  * クラスに生徒として入っているか, ゲストとして入っているか
  * @typePartId ce031774e68409c72ea855cf929f2293
  */
 export type QRole = "Student" | "Guest";
 
 
 /**
  * questの クラス
  * @typePartId cf779792c0201a3874f77765b063b64b
  */
 export type QClass = { 
 /**
  * クラスID
  */
 readonly id: QClassId; 
 /**
  * クラス名
  */
 readonly name: String; 
 /**
  * 属するプログラムID
  */
 readonly programId: QProgramId; 
 /**
  * 招待トークン
  */
 readonly invitationToken: QClassInvitationToken; 
 /**
  * クラスの作成者
  */
 readonly createAccountId: AccountId };
 
 
 /**
  * フィールド名
  * @typePartId d256109676f834b74931495891b61d1b
  */
 export type ElmFieldName = { readonly _: "FieldName"; readonly string: String };
 
 
 /**
  * 質問を作成するプログラム. 複数のクラスを開催できる.
  * @typePartId d59eabf90cfeb709b136e1c832b4f5d4
  */
 export type QProgram = { 
 /**
  * プログラムを識別するID
  */
 readonly id: QProgramId; 
 /**
  * プログラム名
  */
 readonly name: String; 
 /**
  * プログラム作成者
  */
 readonly createAccountId: AccountId };
 
 
 /**
  * バリアント名
  * @typePartId d77f1f967b892c739a1555f74d2ff9fd
  */
 export type ElmVariantName = { readonly _: "VariantName"; readonly string: String };
 
 
 /**
  * 交差型
  * @typePartId d82150857d0f2e78c1df0f418ba9b01a
  */
 export type IntersectionType = { 
 /**
  * 左に指定する型
  */
 readonly left: TsType; 
 /**
  * 右に指定する型
  */
 readonly right: TsType };
 
 
 /**
  * パーツの定義. 他のプログラミング言語でいう関数や, 変数のこと
  * @typePartId d8bccc70252cee9ce70784bf5dfa493b
  */
 export type Part = { 
 /**
  * パーツの名前
  */
 readonly name: String; 
 /**
  * パーツの説明
  */
 readonly description: String; 
 /**
  * パーツの型
  */
 readonly type: Type; 
 /**
  * パーツの式
  */
 readonly expr: Expr; 
 /**
  * 所属しているプロジェクトのID
  */
 readonly projectId: ProjectId };
 
 
 /**
  * Definyの評価しきった式
  * @typePartId daa9bf22c3f2e52ff92edcdd896d6a6d
  */
 export type EvaluatedExpr = { readonly _: "Kernel"; readonly kernelExpr: KernelExpr } | { readonly _: "Int32"; readonly int32: Int32 } | { readonly _: "TagReference"; readonly tagReference: TagReference } | { readonly _: "KernelCall"; readonly kernelCall: KernelCall };
 
 
 /**
  * 1つの型パーツを保存するために指定するパラメーター
  * @typePartId dac038758a5c45f762de388bb5193fb8
  */
 export type SetTypePartParameter = { 
 /**
  * アカウントトークン
  */
 readonly accountToken: AccountToken; 
 /**
  * 型パーツのID
  */
 readonly typePartId: TypePartId; 
 /**
  * 型パーツ
  */
 readonly typePart: TypePart };
 
 
 /**
  * Bool. 真か偽. JavaScriptのbooleanで扱える. true: 1, false: 0. (1byte)としてバイナリに変換する
  * @typePartId db57caf129f60db969b5b5224a72b937
  */
 export type Bool = boolean;
 
 
 /**
  * Elmの関数の定義. 引数がない関数(定数)も含まれる
  * @typePartId db8b9f83d99ef58fd206acca4e56d098
  */
 export type ElmDefinition = { 
 /**
  * 関数名
  */
 readonly name: String; 
 /**
  * 型
  */
 readonly type: ElmType; 
 /**
  * 式
  */
 readonly expr: ElmType; 
 /**
  * コメント
  */
 readonly comment: String };
 
 
 /**
  * 外部に公開する関数
  * @typePartId dd3366ce7254327c85732d2932ff219b
  */
 export type Function = { 
 /**
  * 外部に公開する関数の名前
  */
 readonly name: TsIdentifer; 
 /**
  * ドキュメント
  */
 readonly document: String; 
 /**
  * 型パラメーターのリスト
  */
 readonly typeParameterList: List<TsIdentifer>; 
 /**
  * パラメーター
  */
 readonly parameterList: List<ParameterWithDocument>; 
 /**
  * 戻り値の型
  */
 readonly returnType: TsType; 
 /**
  * 関数の本体
  */
 readonly statementList: List<Statement> };
 
 
 /**
  * アカウントトークン. アカウントトークンを持っていればアクセストークンをDefinyのサーバーにリクエストした際に得られるIDのアカウントを保有していると証明できる. サーバーにハッシュ化したものを保存している. これが盗まれた場合,不正に得た人はアカウントを乗っ取ることができる. 有効期限はなし, 最後に発行したアカウントトークン以外は無効になる
  * @typePartId deb01f82879754c03aa4d244e136e59d
  */
 export type AccountToken = string & { readonly _accountToken: never };
 
 
 /**
  * ローカル関数定義
  * @typePartId df5c5388248252a92864ceb219628b8e
  */
 export type FunctionDefinitionStatement = { 
 /**
  * 変数名
  */
 readonly name: TsIdentifer; 
 /**
  * 型パラメーターのリスト
  */
 readonly typeParameterList: List<TsIdentifer>; 
 /**
  * パラメーターのリスト
  */
 readonly parameterList: List<ParameterWithDocument>; 
 /**
  * 戻り値の型
  */
 readonly returnType: TsType; 
 /**
  * 関数本体
  */
 readonly statementList: List<Statement> };
 
 
 /**
  * 直積型のパターン
  * @typePartId e4ef8a0713aceb0eaa7606cd516ad847
  */
 export type Pattern = { 
 /**
  * タグ名
  */
 readonly name: String; 
 /**
  * パターンの説明
  */
 readonly description: String; 
 /**
  * そのパターンにつけるデータの型
  */
 readonly parameter: Maybe<Type> };
 
 
 /**
  * 画像から求められるトークン.キャッシュのキーとして使われる.1つのトークンに対して永久に1つの画像データしか表さない. キャッシュを更新する必要はない
  * @typePartId e71e15a15b0883940a75e58367151d1a
  */
 export type ImageHash = string & { readonly _imageHash: never };
 
 
 /**
  * Definy の 式
  * @typePartId ed9a046b5f121f6e54ac7f3834cbc644
  */
 export type Expr = { readonly _: "Kernel"; readonly kernelExpr: KernelExpr } | { readonly _: "Int32Literal"; readonly int32: Int32 } | { readonly _: "PartReference"; readonly partId: PartId } | { readonly _: "TagReference"; readonly tagReference: TagReference } | { readonly _: "FunctionCall"; readonly functionCall: FunctionCall };
 
 
 /**
  * タグの参照を表す
  * @typePartId edd59bd2ab4852c149f6ce5917767908
  */
 export type TagReference = { 
 /**
  * 型ID. タグIDがあれば, 型を導出できそうだが……
  */
 readonly typePartId: TypePartId; 
 /**
  * タグID
  */
 readonly tagId: TagId };
 
 
 /**
  * definy.app を開発する上での動作モード. デベロップモード(http://localhost:2520)か, リリースモード(https://definy.app)
  * @typePartId ee0590e764618611ffa8e1a0a2e22f79
  */
 export type Mode = "Develop" | "Release";
 
 
 /**
  * 2項演算子と左右の式
  * @typePartId eec2dab74fbcd3237bfa1c773f9b9d21
  */
 export type BinaryOperatorExpr = { 
 /**
  * 2項演算子
  */
 readonly operator: BinaryOperator; 
 /**
  * 左の式
  */
 readonly left: TsExpr; 
 /**
  * 右の式
  */
 readonly right: TsExpr };
 
 
 /**
  * 出力するコードの種類
  * @typePartId eedf73c97f9dd61159572322f6d7e0a5
  */
 export type CodeType = "JavaScript" | "TypeScript";
 
 
 /**
  * ラムダ式
  * @typePartId eeeef818144e5a42460c4efdaa221460
  */
 export type LambdaExpr = { 
 /**
  * パラメーターのリスト
  */
 readonly parameterList: List<Parameter>; 
 /**
  * 型パラメーターのリスト
  */
 readonly typeParameterList: List<TsIdentifer>; 
 /**
  * 戻り値の型
  */
 readonly returnType: TsType; 
 /**
  * ラムダ式本体
  */
 readonly statementList: List<Statement> };
 
 
 /**
  * ログインのURLを発行するために必要なデータ
  * @typePartId f03ea5331c1a3adcde80a04054d35e07
  */
 export type RequestLogInUrlRequestData = { 
 /**
  * ログインに使用するプロバイダー
  */
 readonly openIdConnectProvider: OpenIdConnectProvider; 
 /**
  * ログインした後に返ってくるURLに必要なデータ
  */
 readonly urlData: UrlData };
 
 
 /**
  * プロジェクトに属する質問や, クラスを取得するときに必要なパラメータ
  * @typePartId f26bc98a33011dd4892a7cdcfb4ccade
  */
 export type QAccountTokenAndProgramId = { 
 /**
  * アカウントトークン
  */
 readonly accountToken: AccountToken; 
 /**
  * プログラムID
  */
 readonly programId: QProgramId };
 
 
 /**
  * Elmの型定義
  * @typePartId f4bed793b657b39db5a579c9e158eba5
  */
 export type ElmTypeDeclaration = { readonly _: "TypeAlias"; readonly elmTypeAlias: ElmTypeAlias } | { readonly _: "CustomType"; readonly elmCustomType: ElmCustomType };
 
 
 /**
  * JavaScriptのオブジェクトリテラルの要素
  * @typePartId fddd2a65994fae205dd636f3a6b9f1ea
  */
 export type TsMember = { readonly _: "Spread"; readonly tsExpr: TsExpr } | { readonly _: "KeyValue"; readonly keyValue: KeyValue };
 
 
 /**
  * 生徒やゲスト向けの招待トークンが含まれていないクラスの情報
  * @typePartId 067954ebc8a7f155be3a4ee196ccf99a
  */
 export const QClassStudentOrGuest: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QClassStudentOrGuest>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: QClassStudentOrGuest) => QClassStudentOrGuest } = { typePartId: "067954ebc8a7f155be3a4ee196ccf99a" as TypePartId, helper: (qClassStudentOrGuest: QClassStudentOrGuest): QClassStudentOrGuest => qClassStudentOrGuest, codec: { encode: (value: QClassStudentOrGuest): ReadonlyArray<number> => (String.codec.encode(value.name).concat(QClassId.codec.encode(value.id)).concat(AccountId.codec.encode(value.createAccountId))), decode: (index: number, binary: Uint8Array): { readonly result: QClassStudentOrGuest; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const idAndNextIndex: { readonly result: QClassId; readonly nextIndex: number } = QClassId.codec.decode(nameAndNextIndex.nextIndex, binary);
   const createAccountIdAndNextIndex: { readonly result: AccountId; readonly nextIndex: number } = AccountId.codec.decode(idAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, id: idAndNextIndex.result, createAccountId: createAccountIdAndNextIndex.result }, nextIndex: createAccountIdAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * quest の ページの場所を表現する
  * @typePartId 0951f74f6309835e7ff412f105474aa7
  */
 export const QLocation: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QLocation>; 
 /**
  * トップページ. アカウントの状態に応じて表示が変わる
  */
 readonly Top: QLocation; 
 /**
  * 設定ページ. アカウントの情報やログアウトできる
  */
 readonly Setting: QLocation; 
 /**
  * プログラム作成ページ
  */
 readonly NewProgram: QLocation; 
 /**
  * プログラム詳細ページ
  */
 readonly Program: (a: QProgramId) => QLocation; 
 /**
  * 質問作成ページ
  */
 readonly NewQuestion: (a: QNewQuestionParameter) => QLocation; 
 /**
  * 質問ページ
  */
 readonly Question: (a: QQuestionId) => QLocation; 
 /**
  * クラス詳細ページ
  */
 readonly Class: (a: QClassId) => QLocation; 
 /**
  * クラス作成ページ
  */
 readonly NewClass: (a: QProgramId) => QLocation; 
 /**
  * クラスの招待URL
  */
 readonly ClassInvitation: (a: QClassInvitationToken) => QLocation; 
 /**
  * 質問編集画面
  */
 readonly EditQuestion: (a: QQuestionId) => QLocation } = { Top: { _: "Top" }, Setting: { _: "Setting" }, NewProgram: { _: "NewProgram" }, Program: (qProgramId: QProgramId): QLocation => ({ _: "Program", qProgramId }), NewQuestion: (qNewQuestionParameter: QNewQuestionParameter): QLocation => ({ _: "NewQuestion", qNewQuestionParameter }), Question: (qQuestionId: QQuestionId): QLocation => ({ _: "Question", qQuestionId }), Class: (qClassId: QClassId): QLocation => ({ _: "Class", qClassId }), NewClass: (qProgramId: QProgramId): QLocation => ({ _: "NewClass", qProgramId }), ClassInvitation: (qClassInvitationToken: QClassInvitationToken): QLocation => ({ _: "ClassInvitation", qClassInvitationToken }), EditQuestion: (qQuestionId: QQuestionId): QLocation => ({ _: "EditQuestion", qQuestionId }), typePartId: "0951f74f6309835e7ff412f105474aa7" as TypePartId, codec: { encode: (value: QLocation): ReadonlyArray<number> => {
   switch (value._) {
     case "Top": {
       return [0];
     }
     case "Setting": {
       return [1];
     }
     case "NewProgram": {
       return [2];
     }
     case "Program": {
       return [3].concat(QProgramId.codec.encode(value.qProgramId));
     }
     case "NewQuestion": {
       return [4].concat(QNewQuestionParameter.codec.encode(value.qNewQuestionParameter));
     }
     case "Question": {
       return [5].concat(QQuestionId.codec.encode(value.qQuestionId));
     }
     case "Class": {
       return [6].concat(QClassId.codec.encode(value.qClassId));
     }
     case "NewClass": {
       return [7].concat(QProgramId.codec.encode(value.qProgramId));
     }
     case "ClassInvitation": {
       return [8].concat(QClassInvitationToken.codec.encode(value.qClassInvitationToken));
     }
     case "EditQuestion": {
       return [9].concat(QQuestionId.codec.encode(value.qQuestionId));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: QLocation; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     return { result: QLocation.Top, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: QLocation.Setting, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 2) {
     return { result: QLocation.NewProgram, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 3) {
     const result: { readonly result: QProgramId; readonly nextIndex: number } = QProgramId.codec.decode(patternIndex.nextIndex, binary);
     return { result: QLocation.Program(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 4) {
     const result: { readonly result: QNewQuestionParameter; readonly nextIndex: number } = QNewQuestionParameter.codec.decode(patternIndex.nextIndex, binary);
     return { result: QLocation.NewQuestion(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 5) {
     const result: { readonly result: QQuestionId; readonly nextIndex: number } = QQuestionId.codec.decode(patternIndex.nextIndex, binary);
     return { result: QLocation.Question(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 6) {
     const result: { readonly result: QClassId; readonly nextIndex: number } = QClassId.codec.decode(patternIndex.nextIndex, binary);
     return { result: QLocation.Class(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 7) {
     const result: { readonly result: QProgramId; readonly nextIndex: number } = QProgramId.codec.decode(patternIndex.nextIndex, binary);
     return { result: QLocation.NewClass(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 8) {
     const result: { readonly result: QClassInvitationToken; readonly nextIndex: number } = QClassInvitationToken.codec.decode(patternIndex.nextIndex, binary);
     return { result: QLocation.ClassInvitation(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 9) {
     const result: { readonly result: QQuestionId; readonly nextIndex: number } = QQuestionId.codec.decode(patternIndex.nextIndex, binary);
     return { result: QLocation.EditQuestion(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * バリアント. 値コンストラクタ. タグ
  * @typePartId 0bc2e5ab2fd2caeb6e6c331573ae735f
  */
 export const ElmVariant: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmVariant>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ElmVariant) => ElmVariant } = { typePartId: "0bc2e5ab2fd2caeb6e6c331573ae735f" as TypePartId, helper: (elmVariant: ElmVariant): ElmVariant => elmVariant, codec: { encode: (value: ElmVariant): ReadonlyArray<number> => (ElmVariantName.codec.encode(value.name).concat(List.codec(ElmType.codec).encode(value.parameter))), decode: (index: number, binary: Uint8Array): { readonly result: ElmVariant; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: ElmVariantName; readonly nextIndex: number } = ElmVariantName.codec.decode(index, binary);
   const parameterAndNextIndex: { readonly result: List<ElmType>; readonly nextIndex: number } = List.codec(ElmType.codec).decode(nameAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, parameter: parameterAndNextIndex.result }, nextIndex: parameterAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * クラスの情報をクラスの招待トークンから取得するときのレスポンス
  * @typePartId 0bc48429266ac8dfe8f9f8f304938c88
  */
 export const GetClassAndRoleResult: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<GetClassAndRoleResult>; 
 /**
  * クラスに参加していない
  */
 readonly NotJoin: (a: QClass) => GetClassAndRoleResult; 
 /**
  * すでに生徒として参加している
  */
 readonly JoinedAsStudent: (a: QClass) => GetClassAndRoleResult; 
 /**
  * すでにゲストとして参加している
  */
 readonly JoinedAsGuest: (a: QClass) => GetClassAndRoleResult } = { NotJoin: (qClass: QClass): GetClassAndRoleResult => ({ _: "NotJoin", qClass }), JoinedAsStudent: (qClass: QClass): GetClassAndRoleResult => ({ _: "JoinedAsStudent", qClass }), JoinedAsGuest: (qClass: QClass): GetClassAndRoleResult => ({ _: "JoinedAsGuest", qClass }), typePartId: "0bc48429266ac8dfe8f9f8f304938c88" as TypePartId, codec: { encode: (value: GetClassAndRoleResult): ReadonlyArray<number> => {
   switch (value._) {
     case "NotJoin": {
       return [0].concat(QClass.codec.encode(value.qClass));
     }
     case "JoinedAsStudent": {
       return [1].concat(QClass.codec.encode(value.qClass));
     }
     case "JoinedAsGuest": {
       return [2].concat(QClass.codec.encode(value.qClass));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: GetClassAndRoleResult; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: QClass; readonly nextIndex: number } = QClass.codec.decode(patternIndex.nextIndex, binary);
     return { result: GetClassAndRoleResult.NotJoin(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 1) {
     const result: { readonly result: QClass; readonly nextIndex: number } = QClass.codec.decode(patternIndex.nextIndex, binary);
     return { result: GetClassAndRoleResult.JoinedAsStudent(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 2) {
     const result: { readonly result: QClass; readonly nextIndex: number } = QClass.codec.decode(patternIndex.nextIndex, binary);
     return { result: GetClassAndRoleResult.JoinedAsGuest(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * 外部に公開する定義
  * @typePartId 0c8b854b812290a054877ca5de6c4daf
  */
 export const ExportDefinition: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ExportDefinition>; 
 /**
  * TypeAlias
  */
 readonly TypeAlias: (a: TypeAlias) => ExportDefinition; 
 /**
  * Function
  */
 readonly Function: (a: Function) => ExportDefinition; 
 /**
  * Variable
  */
 readonly Variable: (a: Variable) => ExportDefinition } = { TypeAlias: (typeAlias: TypeAlias): ExportDefinition => ({ _: "TypeAlias", typeAlias }), Function: (function_: Function): ExportDefinition => ({ _: "Function", function: function_ }), Variable: (variable: Variable): ExportDefinition => ({ _: "Variable", variable }), typePartId: "0c8b854b812290a054877ca5de6c4daf" as TypePartId, codec: { encode: (value: ExportDefinition): ReadonlyArray<number> => {
   switch (value._) {
     case "TypeAlias": {
       return [0].concat(TypeAlias.codec.encode(value.typeAlias));
     }
     case "Function": {
       return [1].concat(Function.codec.encode(value.function));
     }
     case "Variable": {
       return [2].concat(Variable.codec.encode(value.variable));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: ExportDefinition; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: TypeAlias; readonly nextIndex: number } = TypeAlias.codec.decode(patternIndex.nextIndex, binary);
     return { result: ExportDefinition.TypeAlias(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 1) {
     const result: { readonly result: Function; readonly nextIndex: number } = Function.codec.decode(patternIndex.nextIndex, binary);
     return { result: ExportDefinition.Function(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 2) {
     const result: { readonly result: Variable; readonly nextIndex: number } = Variable.codec.decode(patternIndex.nextIndex, binary);
     return { result: ExportDefinition.Variable(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * 単項演算子と適用される式
  * @typePartId 0cb0a34b3953e57b30f4a5c8f9d305da
  */
 export const UnaryOperatorExpr: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<UnaryOperatorExpr>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: UnaryOperatorExpr) => UnaryOperatorExpr } = { typePartId: "0cb0a34b3953e57b30f4a5c8f9d305da" as TypePartId, helper: (unaryOperatorExpr: UnaryOperatorExpr): UnaryOperatorExpr => unaryOperatorExpr, codec: { encode: (value: UnaryOperatorExpr): ReadonlyArray<number> => (UnaryOperator.codec.encode(value.operator).concat(TsExpr.codec.encode(value.expr))), decode: (index: number, binary: Uint8Array): { readonly result: UnaryOperatorExpr; readonly nextIndex: number } => {
   const operatorAndNextIndex: { readonly result: UnaryOperator; readonly nextIndex: number } = UnaryOperator.codec.decode(index, binary);
   const exprAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(operatorAndNextIndex.nextIndex, binary);
   return { result: { operator: operatorAndNextIndex.result, expr: exprAndNextIndex.result }, nextIndex: exprAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * プロジェクトの識別子
  * @typePartId 0cd913118a2ad1469d656146a08c5f76
  */
 export const ProjectId: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ProjectId> } = { typePartId: "0cd913118a2ad1469d656146a08c5f76" as TypePartId, codec: { encode: (value: ProjectId): ReadonlyArray<number> => (encodeId(value)), decode: (index: number, binary: Uint8Array): { readonly result: ProjectId; readonly nextIndex: number } => (decodeId(index, binary) as { readonly result: ProjectId; readonly nextIndex: number }) } };
 
 
 /**
  * 英語,日本語,エスペラント語
  *
  * ナルミンチョが使える? プログラミングじゃない言語
  * @typePartId 0d9510723f4d34605e41f3a47a8b0ea7
  */
 export const Language: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Language>; 
 /**
  * 日本語
  */
 readonly Japanese: Language; 
 /**
  * 英語
  */
 readonly English: Language; 
 /**
  * エスペラント語
  */
 readonly Esperanto: Language } = { Japanese: "Japanese", English: "English", Esperanto: "Esperanto", typePartId: "0d9510723f4d34605e41f3a47a8b0ea7" as TypePartId, codec: { encode: (value: Language): ReadonlyArray<number> => {
   switch (value) {
     case "Japanese": {
       return [0];
     }
     case "English": {
       return [1];
     }
     case "Esperanto": {
       return [2];
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: Language; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     return { result: Language.Japanese, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: Language.English, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 2) {
     return { result: Language.Esperanto, nextIndex: patternIndex.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * Elmで使う型の名前. Elmで使える型名ということを確認済み
  * @typePartId 13e52324ba81c7ffe655455ad739ea73
  */
 export const ElmTypeName: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmTypeName>; 
 /**
  * **直接 ElmTypeName.ElmTypeName("Int") と指定してはいけない!! Elmの識別子として使える文字としてチェックできないため**
  */
 readonly ElmTypeName: (a: String) => ElmTypeName } = { ElmTypeName: (string_: String): ElmTypeName => ({ _: "ElmTypeName", string: string_ }), typePartId: "13e52324ba81c7ffe655455ad739ea73" as TypePartId, codec: { encode: (value: ElmTypeName): ReadonlyArray<number> => {
   switch (value._) {
     case "ElmTypeName": {
       return [0].concat(String.codec.encode(value.string));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: ElmTypeName; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: String; readonly nextIndex: number } = String.codec.decode(patternIndex.nextIndex, binary);
     return { result: ElmTypeName.ElmTypeName(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * -2 147 483 648 ～ 2 147 483 647. 32bit 符号付き整数. JavaScriptのnumberとして扱える. numberの32bit符号あり整数をSigned Leb128のバイナリに変換する
  * @typePartId 16c2d8602e3e5e2d38b9215bd0c44d8d
  */
 export const Int32: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Int32> } = { typePartId: "16c2d8602e3e5e2d38b9215bd0c44d8d" as TypePartId, codec: { encode: (value: Int32): ReadonlyArray<number> => {
   let rest: number = value | 0;
   const result: Array<number> = [];
   while (true) {
     const byte: number = rest & 127;
     rest >>= 7;
     if (rest === 0 && (byte & 64) === 0 || rest === -1 && (byte & 64) !== 0) {
       result.push(byte);
       return result;
     }
     result.push(byte | 128);
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: Int32; readonly nextIndex: number } => {
   let result: number = 0;
   let offset: number = 0;
   while (true) {
     const byte: number | undefined = binary[index + offset];
     if (byte === undefined) {
       throw new Error("invalid byte in decode int32");
     }
     result |= (byte & 127) << offset * 7;
     offset += 1;
     if ((128 & byte) === 0) {
       if (offset * 7 < 32 && (byte & 64) !== 0) {
         return { result: result | ~0 << offset * 7, nextIndex: index + offset };
       }
       return { result, nextIndex: index + offset };
     }
   }
 } } };
 
 
 /**
  * Elm の 型
  * @typePartId 173f661790b059baf212043f816ba1a9
  */
 export const ElmType: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmType>; 
 /**
  * インポートした型
  */
 readonly ImportedType: (a: ElmImportedType) => ElmType; 
 /**
  * 型パラメーター
  */
 readonly TypeParameter: (a: String) => ElmType; 
 /**
  * 関数
  */
 readonly Function: (a: ElmFunctionType) => ElmType; 
 /**
  * List リスト
  */
 readonly List: (a: ElmType) => ElmType; 
 /**
  * () 1種類の値だけ持つ型. Unit
  */
 readonly Tuple0: ElmType; 
 /**
  * (a, b)
  */
 readonly Tuple2: (a: ElmTuple2) => ElmType; 
 /**
  * (a, b, c)
  */
 readonly Tuple3: (a: ElmTuple3) => ElmType; 
 /**
  * { name: String, age: Int } レコード型
  */
 readonly Record: (a: List<ElmField>) => ElmType; 
 /**
  * モジュール内にある型
  */
 readonly LocalType: (a: ElmLocalType) => ElmType } = { ImportedType: (elmImportedType: ElmImportedType): ElmType => ({ _: "ImportedType", elmImportedType }), TypeParameter: (string_: String): ElmType => ({ _: "TypeParameter", string: string_ }), Function: (elmFunctionType: ElmFunctionType): ElmType => ({ _: "Function", elmFunctionType }), List: (elmType: ElmType): ElmType => ({ _: "List", elmType }), Tuple0: { _: "Tuple0" }, Tuple2: (elmTuple2: ElmTuple2): ElmType => ({ _: "Tuple2", elmTuple2 }), Tuple3: (elmTuple3: ElmTuple3): ElmType => ({ _: "Tuple3", elmTuple3 }), Record: (elmFieldList: List<ElmField>): ElmType => ({ _: "Record", elmFieldList }), LocalType: (elmLocalType: ElmLocalType): ElmType => ({ _: "LocalType", elmLocalType }), typePartId: "173f661790b059baf212043f816ba1a9" as TypePartId, codec: { encode: (value: ElmType): ReadonlyArray<number> => {
   switch (value._) {
     case "ImportedType": {
       return [0].concat(ElmImportedType.codec.encode(value.elmImportedType));
     }
     case "TypeParameter": {
       return [1].concat(String.codec.encode(value.string));
     }
     case "Function": {
       return [2].concat(ElmFunctionType.codec.encode(value.elmFunctionType));
     }
     case "List": {
       return [3].concat(ElmType.codec.encode(value.elmType));
     }
     case "Tuple0": {
       return [4];
     }
     case "Tuple2": {
       return [5].concat(ElmTuple2.codec.encode(value.elmTuple2));
     }
     case "Tuple3": {
       return [6].concat(ElmTuple3.codec.encode(value.elmTuple3));
     }
     case "Record": {
       return [7].concat(List.codec(ElmField.codec).encode(value.elmFieldList));
     }
     case "LocalType": {
       return [8].concat(ElmLocalType.codec.encode(value.elmLocalType));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: ElmType; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: ElmImportedType; readonly nextIndex: number } = ElmImportedType.codec.decode(patternIndex.nextIndex, binary);
     return { result: ElmType.ImportedType(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 1) {
     const result: { readonly result: String; readonly nextIndex: number } = String.codec.decode(patternIndex.nextIndex, binary);
     return { result: ElmType.TypeParameter(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 2) {
     const result: { readonly result: ElmFunctionType; readonly nextIndex: number } = ElmFunctionType.codec.decode(patternIndex.nextIndex, binary);
     return { result: ElmType.Function(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 3) {
     const result: { readonly result: ElmType; readonly nextIndex: number } = ElmType.codec.decode(patternIndex.nextIndex, binary);
     return { result: ElmType.List(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 4) {
     return { result: ElmType.Tuple0, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 5) {
     const result: { readonly result: ElmTuple2; readonly nextIndex: number } = ElmTuple2.codec.decode(patternIndex.nextIndex, binary);
     return { result: ElmType.Tuple2(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 6) {
     const result: { readonly result: ElmTuple3; readonly nextIndex: number } = ElmTuple3.codec.decode(patternIndex.nextIndex, binary);
     return { result: ElmType.Tuple3(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 7) {
     const result: { readonly result: List<ElmField>; readonly nextIndex: number } = List.codec(ElmField.codec).decode(patternIndex.nextIndex, binary);
     return { result: ElmType.Record(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 8) {
     const result: { readonly result: ElmLocalType; readonly nextIndex: number } = ElmLocalType.codec.decode(patternIndex.nextIndex, binary);
     return { result: ElmType.LocalType(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * @typePartId 1835ebdc909b0fa93d11ae0ed93d0606
  */
 export const TsType: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<TsType>; 
 /**
  * プリミティブの型のnumber
  */
 readonly Number: TsType; 
 /**
  * プリミティブの型のstring
  */
 readonly String: TsType; 
 /**
  * プリミティブの型のboolean
  */
 readonly Boolean: TsType; 
 /**
  * プリミティブの型のundefined
  */
 readonly Undefined: TsType; 
 /**
  * プリミティブの型のnull
  */
 readonly Null: TsType; 
 /**
  * never型
  */
 readonly Never: TsType; 
 /**
  * void型
  */
 readonly Void: TsType; 
 /**
  * オブジェクト
  */
 readonly Object: (a: List<TsMemberType>) => TsType; 
 /**
  * 関数 `(parameter: parameter) => returnType`
  */
 readonly Function: (a: FunctionType) => TsType; 
 /**
  * 型パラメータ付きの型 `Promise<number>` `ReadonlyArray<string>`
  */
 readonly WithTypeParameter: (a: TsTypeWithTypeParameter) => TsType; 
 /**
  * ユニオン型 `a | b`
  */
 readonly Union: (a: List<TsType>) => TsType; 
 /**
  * "交差型 `left & right`
  */
 readonly Intersection: (a: IntersectionType) => TsType; 
 /**
  * インポートされた外部の型
  */
 readonly ImportedType: (a: ImportedType) => TsType; 
 /**
  * ファイル内で定義された型
  */
 readonly ScopeInFile: (a: TsIdentifer) => TsType; 
 /**
  * グローバル空間の型
  */
 readonly ScopeInGlobal: (a: TsIdentifer) => TsType; 
 /**
  * 文字列リテラル型
  */
 readonly StringLiteral: (a: String) => TsType } = { Number: { _: "Number" }, String: { _: "String" }, Boolean: { _: "Boolean" }, Undefined: { _: "Undefined" }, Null: { _: "Null" }, Never: { _: "Never" }, Void: { _: "Void" }, Object: (tsMemberTypeList: List<TsMemberType>): TsType => ({ _: "Object", tsMemberTypeList }), Function: (functionType: FunctionType): TsType => ({ _: "Function", functionType }), WithTypeParameter: (tsTypeWithTypeParameter: TsTypeWithTypeParameter): TsType => ({ _: "WithTypeParameter", tsTypeWithTypeParameter }), Union: (tsTypeList: List<TsType>): TsType => ({ _: "Union", tsTypeList }), Intersection: (intersectionType: IntersectionType): TsType => ({ _: "Intersection", intersectionType }), ImportedType: (importedType: ImportedType): TsType => ({ _: "ImportedType", importedType }), ScopeInFile: (tsIdentifer: TsIdentifer): TsType => ({ _: "ScopeInFile", tsIdentifer }), ScopeInGlobal: (tsIdentifer: TsIdentifer): TsType => ({ _: "ScopeInGlobal", tsIdentifer }), StringLiteral: (string_: String): TsType => ({ _: "StringLiteral", string: string_ }), typePartId: "1835ebdc909b0fa93d11ae0ed93d0606" as TypePartId, codec: { encode: (value: TsType): ReadonlyArray<number> => {
   switch (value._) {
     case "Number": {
       return [0];
     }
     case "String": {
       return [1];
     }
     case "Boolean": {
       return [2];
     }
     case "Undefined": {
       return [3];
     }
     case "Null": {
       return [4];
     }
     case "Never": {
       return [5];
     }
     case "Void": {
       return [6];
     }
     case "Object": {
       return [7].concat(List.codec(TsMemberType.codec).encode(value.tsMemberTypeList));
     }
     case "Function": {
       return [8].concat(FunctionType.codec.encode(value.functionType));
     }
     case "WithTypeParameter": {
       return [9].concat(TsTypeWithTypeParameter.codec.encode(value.tsTypeWithTypeParameter));
     }
     case "Union": {
       return [10].concat(List.codec(TsType.codec).encode(value.tsTypeList));
     }
     case "Intersection": {
       return [11].concat(IntersectionType.codec.encode(value.intersectionType));
     }
     case "ImportedType": {
       return [12].concat(ImportedType.codec.encode(value.importedType));
     }
     case "ScopeInFile": {
       return [13].concat(TsIdentifer.codec.encode(value.tsIdentifer));
     }
     case "ScopeInGlobal": {
       return [14].concat(TsIdentifer.codec.encode(value.tsIdentifer));
     }
     case "StringLiteral": {
       return [15].concat(String.codec.encode(value.string));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: TsType; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     return { result: TsType.Number, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: TsType.String, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 2) {
     return { result: TsType.Boolean, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 3) {
     return { result: TsType.Undefined, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 4) {
     return { result: TsType.Null, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 5) {
     return { result: TsType.Never, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 6) {
     return { result: TsType.Void, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 7) {
     const result: { readonly result: List<TsMemberType>; readonly nextIndex: number } = List.codec(TsMemberType.codec).decode(patternIndex.nextIndex, binary);
     return { result: TsType.Object(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 8) {
     const result: { readonly result: FunctionType; readonly nextIndex: number } = FunctionType.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsType.Function(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 9) {
     const result: { readonly result: TsTypeWithTypeParameter; readonly nextIndex: number } = TsTypeWithTypeParameter.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsType.WithTypeParameter(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 10) {
     const result: { readonly result: List<TsType>; readonly nextIndex: number } = List.codec(TsType.codec).decode(patternIndex.nextIndex, binary);
     return { result: TsType.Union(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 11) {
     const result: { readonly result: IntersectionType; readonly nextIndex: number } = IntersectionType.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsType.Intersection(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 12) {
     const result: { readonly result: ImportedType; readonly nextIndex: number } = ImportedType.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsType.ImportedType(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 13) {
     const result: { readonly result: TsIdentifer; readonly nextIndex: number } = TsIdentifer.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsType.ScopeInFile(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 14) {
     const result: { readonly result: TsIdentifer; readonly nextIndex: number } = TsIdentifer.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsType.ScopeInGlobal(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 15) {
     const result: { readonly result: String; readonly nextIndex: number } = String.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsType.StringLiteral(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * Project, Account, TypePartなどのリソースの状態とデータ. 読み込み中だとか
  * @typePartId 18cbd2fa4bd72a0eacf3f0f44aeb6feb
  */
 export const ResourceState: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: <data extends unknown>(a: Codec<data>) => Codec<ResourceState<data>>; 
 /**
  * 読み込み済み
  */
 readonly Loaded: <data extends unknown>(a: WithTime<data>) => ResourceState<data>; 
 /**
  * 削除されたか, 存在しない
  */
 readonly Deleted: <data extends unknown>(a: Time) => ResourceState<data>; 
 /**
  * 削除されたか, 存在しない
  */
 readonly Unknown: <data extends unknown>(a: Time) => ResourceState<data>; 
 /**
  * サーバに問い合わせ中
  */
 readonly Requesting: <data extends unknown>() => ResourceState<data> } = { Loaded: <data extends unknown>(dataWithTime: WithTime<data>): ResourceState<data> => ({ _: "Loaded", dataWithTime }), Deleted: <data extends unknown>(time: Time): ResourceState<data> => ({ _: "Deleted", time }), Unknown: <data extends unknown>(time: Time): ResourceState<data> => ({ _: "Unknown", time }), Requesting: <data extends unknown>(): ResourceState<data> => ({ _: "Requesting" }), typePartId: "18cbd2fa4bd72a0eacf3f0f44aeb6feb" as TypePartId, codec: <data extends unknown>(dataCodec: Codec<data>): Codec<ResourceState<data>> => ({ encode: (value: ResourceState<data>): ReadonlyArray<number> => {
   switch (value._) {
     case "Loaded": {
       return [0].concat(WithTime.codec(dataCodec).encode(value.dataWithTime));
     }
     case "Deleted": {
       return [1].concat(Time.codec.encode(value.time));
     }
     case "Unknown": {
       return [2].concat(Time.codec.encode(value.time));
     }
     case "Requesting": {
       return [3];
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: ResourceState<data>; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: WithTime<data>; readonly nextIndex: number } = WithTime.codec(dataCodec).decode(patternIndex.nextIndex, binary);
     return { result: ResourceState.Loaded(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 1) {
     const result: { readonly result: Time; readonly nextIndex: number } = Time.codec.decode(patternIndex.nextIndex, binary);
     return { result: ResourceState.Deleted(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 2) {
     const result: { readonly result: Time; readonly nextIndex: number } = Time.codec.decode(patternIndex.nextIndex, binary);
     return { result: ResourceState.Unknown(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 3) {
     return { result: ResourceState.Requesting(), nextIndex: patternIndex.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } }) };
 
 
 /**
  * quest で 生徒(質問を答え, フィードバックするひと) としてクラスに参加するためのパラメータ
  * @typePartId 1928498fae964eff3fc965142c9677dc
  */
 export const JoinClassAsStudentParameter: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<JoinClassAsStudentParameter>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: JoinClassAsStudentParameter) => JoinClassAsStudentParameter } = { typePartId: "1928498fae964eff3fc965142c9677dc" as TypePartId, helper: (joinClassAsStudentParameter: JoinClassAsStudentParameter): JoinClassAsStudentParameter => joinClassAsStudentParameter, codec: { encode: (value: JoinClassAsStudentParameter): ReadonlyArray<number> => (AccountToken.codec.encode(value.accountToken).concat(QClassInvitationToken.codec.encode(value.classInvitationToken))), decode: (index: number, binary: Uint8Array): { readonly result: JoinClassAsStudentParameter; readonly nextIndex: number } => {
   const accountTokenAndNextIndex: { readonly result: AccountToken; readonly nextIndex: number } = AccountToken.codec.decode(index, binary);
   const classInvitationTokenAndNextIndex: { readonly result: QClassInvitationToken; readonly nextIndex: number } = QClassInvitationToken.codec.decode(accountTokenAndNextIndex.nextIndex, binary);
   return { result: { accountToken: accountTokenAndNextIndex.result, classInvitationToken: classInvitationTokenAndNextIndex.result }, nextIndex: classInvitationTokenAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * definy.app のメッセージ
  * @typePartId 1c280bc21ab8d5ccc4455800650cf31b
  */
 export const AppMessage: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<AppMessage>; 
 /**
  * 何もしない
  */
 readonly NoOp: AppMessage; 
 /**
  * 指定したページへジャンプ
  */
 readonly Jump: (a: UrlData) => AppMessage; 
 /**
  * ログインURLをリクエストする
  */
 readonly RequestLogin: (a: OpenIdConnectProvider) => AppMessage; 
 /**
  * ログインURLを受け取った
  */
 readonly RespondLogInUrlTag: (a: Maybe<String>) => AppMessage } = { NoOp: { _: "NoOp" }, Jump: (urlData: UrlData): AppMessage => ({ _: "Jump", urlData }), RequestLogin: (openIdConnectProvider: OpenIdConnectProvider): AppMessage => ({ _: "RequestLogin", openIdConnectProvider }), RespondLogInUrlTag: (stringMaybe: Maybe<String>): AppMessage => ({ _: "RespondLogInUrlTag", stringMaybe }), typePartId: "1c280bc21ab8d5ccc4455800650cf31b" as TypePartId, codec: { encode: (value: AppMessage): ReadonlyArray<number> => {
   switch (value._) {
     case "NoOp": {
       return [0];
     }
     case "Jump": {
       return [1].concat(UrlData.codec.encode(value.urlData));
     }
     case "RequestLogin": {
       return [2].concat(OpenIdConnectProvider.codec.encode(value.openIdConnectProvider));
     }
     case "RespondLogInUrlTag": {
       return [3].concat(Maybe.codec(String.codec).encode(value.stringMaybe));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: AppMessage; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     return { result: AppMessage.NoOp, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 1) {
     const result: { readonly result: UrlData; readonly nextIndex: number } = UrlData.codec.decode(patternIndex.nextIndex, binary);
     return { result: AppMessage.Jump(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 2) {
     const result: { readonly result: OpenIdConnectProvider; readonly nextIndex: number } = OpenIdConnectProvider.codec.decode(patternIndex.nextIndex, binary);
     return { result: AppMessage.RequestLogin(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 3) {
     const result: { readonly result: Maybe<String>; readonly nextIndex: number } = Maybe.codec(String.codec).decode(patternIndex.nextIndex, binary);
     return { result: AppMessage.RespondLogInUrlTag(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * Unit. 1つの値しかない型. JavaScriptのundefinedで扱う
  * @typePartId 217263d8cdca613c2d1ba77e19d4cbb0
  */
 export const Unit: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Unit>; 
 /**
  * Unit型にある.唯一の値
  */
 readonly UnitValue: Unit } = { UnitValue: undefined, typePartId: "217263d8cdca613c2d1ba77e19d4cbb0" as TypePartId, codec: { encode: (value: Unit): ReadonlyArray<number> => [], decode: (index: number, binary: Uint8Array): { readonly result: Unit; readonly nextIndex: number } => ({ result: Unit.UnitValue, nextIndex: index }) } };
 
 
 /**
  * コンパイラに向けた, 型のデータ形式をどうするかの情報
  * @typePartId 22d8f2d392c573a7aa54c39fa4c98ad0
  */
 export const TypeAttribute: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<TypeAttribute>; 
 /**
  * JavaScript, TypeScript で boolean として扱うように指示する. 定義が2つのパターンで両方パラメーターなし false, trueの順である必要がある
  */
 readonly AsBoolean: TypeAttribute; 
 /**
  * cription:             "JavaScript, TypeScript で undefined として扱うように指示する. 定義が1つのパターンでパラメーターなしである必要がある
  */
 readonly AsUndefined: TypeAttribute } = { AsBoolean: "AsBoolean", AsUndefined: "AsUndefined", typePartId: "22d8f2d392c573a7aa54c39fa4c98ad0" as TypePartId, codec: { encode: (value: TypeAttribute): ReadonlyArray<number> => {
   switch (value) {
     case "AsBoolean": {
       return [0];
     }
     case "AsUndefined": {
       return [1];
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: TypeAttribute; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     return { result: TypeAttribute.AsBoolean, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: TypeAttribute.AsUndefined, nextIndex: patternIndex.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * @typePartId 2392b884a9c2238a65ecd272bd23a9cd
  */
 export const ElmField: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmField>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ElmField) => ElmField } = { typePartId: "2392b884a9c2238a65ecd272bd23a9cd" as TypePartId, helper: (elmField: ElmField): ElmField => elmField, codec: { encode: (value: ElmField): ReadonlyArray<number> => (ElmFieldName.codec.encode(value.name).concat(ElmType.codec.encode(value.type))), decode: (index: number, binary: Uint8Array): { readonly result: ElmField; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: ElmFieldName; readonly nextIndex: number } = ElmFieldName.codec.decode(index, binary);
   const typeAndNextIndex: { readonly result: ElmType; readonly nextIndex: number } = ElmType.codec.decode(nameAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, type: typeAndNextIndex.result }, nextIndex: typeAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * パラメーター付きの型
  * @typePartId 23fa0e8b66c9d093d4c18579ffefaaa3
  */
 export const TsTypeWithTypeParameter: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<TsTypeWithTypeParameter>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: TsTypeWithTypeParameter) => TsTypeWithTypeParameter } = { typePartId: "23fa0e8b66c9d093d4c18579ffefaaa3" as TypePartId, helper: (tsTypeWithTypeParameter: TsTypeWithTypeParameter): TsTypeWithTypeParameter => tsTypeWithTypeParameter, codec: { encode: (value: TsTypeWithTypeParameter): ReadonlyArray<number> => (TsType.codec.encode(value.type).concat(List.codec(TsType.codec).encode(value.typeParameterList))), decode: (index: number, binary: Uint8Array): { readonly result: TsTypeWithTypeParameter; readonly nextIndex: number } => {
   const typeAndNextIndex: { readonly result: TsType; readonly nextIndex: number } = TsType.codec.decode(index, binary);
   const typeParameterListAndNextIndex: { readonly result: List<TsType>; readonly nextIndex: number } = List.codec(TsType.codec).decode(typeAndNextIndex.nextIndex, binary);
   return { result: { type: typeAndNextIndex.result, typeParameterList: typeParameterListAndNextIndex.result }, nextIndex: typeParameterListAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 評価したときに失敗した原因を表すもの
  * @typePartId 25d0af5522da614f7617016ca7868edd
  */
 export const EvaluateExprError: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<EvaluateExprError>; 
 /**
  * 式を評価するには,このパーツの定義が必要だと言っている
  */
 readonly NeedPartDefinition: (a: PartId) => EvaluateExprError; 
 /**
  * 計算結果にblankが含まれている
  */
 readonly Blank: EvaluateExprError; 
 /**
  * 型が合わない
  */
 readonly TypeError: (a: String) => EvaluateExprError; 
 /**
  * まだサポートしていないものが含まれている
  */
 readonly NotSupported: EvaluateExprError } = { NeedPartDefinition: (partId: PartId): EvaluateExprError => ({ _: "NeedPartDefinition", partId }), Blank: { _: "Blank" }, TypeError: (string_: String): EvaluateExprError => ({ _: "TypeError", string: string_ }), NotSupported: { _: "NotSupported" }, typePartId: "25d0af5522da614f7617016ca7868edd" as TypePartId, codec: { encode: (value: EvaluateExprError): ReadonlyArray<number> => {
   switch (value._) {
     case "NeedPartDefinition": {
       return [0].concat(PartId.codec.encode(value.partId));
     }
     case "Blank": {
       return [1];
     }
     case "TypeError": {
       return [2].concat(String.codec.encode(value.string));
     }
     case "NotSupported": {
       return [3];
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: EvaluateExprError; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: PartId; readonly nextIndex: number } = PartId.codec.decode(patternIndex.nextIndex, binary);
     return { result: EvaluateExprError.NeedPartDefinition(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: EvaluateExprError.Blank, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 2) {
     const result: { readonly result: String; readonly nextIndex: number } = String.codec.decode(patternIndex.nextIndex, binary);
     return { result: EvaluateExprError.TypeError(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 3) {
     return { result: EvaluateExprError.NotSupported, nextIndex: patternIndex.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * TypeScriptの識別子として使える文字
  * @typePartId 2a75ad7c7ccc58ba56f6c8545c8150d1
  */
 export const TsIdentifer: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<TsIdentifer>; 
 /**
  * **直接 Identifer.Identifer("name") と指定してはいけない!! TypeScriptの識別子として使える文字としてチェックできないため**
  */
 readonly Identifer: (a: String) => TsIdentifer } = { Identifer: (string_: String): TsIdentifer => ({ _: "Identifer", string: string_ }), typePartId: "2a75ad7c7ccc58ba56f6c8545c8150d1" as TypePartId, codec: { encode: (value: TsIdentifer): ReadonlyArray<number> => {
   switch (value._) {
     case "Identifer": {
       return [0].concat(String.codec.encode(value.string));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: TsIdentifer; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: String; readonly nextIndex: number } = String.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsIdentifer.Identifer(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * モジュール内の型
  * @typePartId 2b42264a878355f0257141fa013fed5c
  */
 export const ElmLocalType: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmLocalType>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ElmLocalType) => ElmLocalType } = { typePartId: "2b42264a878355f0257141fa013fed5c" as TypePartId, helper: (elmLocalType: ElmLocalType): ElmLocalType => elmLocalType, codec: { encode: (value: ElmLocalType): ReadonlyArray<number> => (ElmTypeName.codec.encode(value.typeName).concat(List.codec(ElmType.codec).encode(value.parameter))), decode: (index: number, binary: Uint8Array): { readonly result: ElmLocalType; readonly nextIndex: number } => {
   const typeNameAndNextIndex: { readonly result: ElmTypeName; readonly nextIndex: number } = ElmTypeName.codec.decode(index, binary);
   const parameterAndNextIndex: { readonly result: List<ElmType>; readonly nextIndex: number } = List.codec(ElmType.codec).decode(typeNameAndNextIndex.nextIndex, binary);
   return { result: { typeName: typeNameAndNextIndex.result, parameter: parameterAndNextIndex.result }, nextIndex: parameterAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 関数呼び出し
  * @typePartId 2f9784d2c41d0974487a1ca2b0a51ec5
  */
 export const FunctionCall: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<FunctionCall>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: FunctionCall) => FunctionCall } = { typePartId: "2f9784d2c41d0974487a1ca2b0a51ec5" as TypePartId, helper: (functionCall: FunctionCall): FunctionCall => functionCall, codec: { encode: (value: FunctionCall): ReadonlyArray<number> => (Expr.codec.encode(value.function).concat(Expr.codec.encode(value.parameter))), decode: (index: number, binary: Uint8Array): { readonly result: FunctionCall; readonly nextIndex: number } => {
   const functionAndNextIndex: { readonly result: Expr; readonly nextIndex: number } = Expr.codec.decode(index, binary);
   const parameterAndNextIndex: { readonly result: Expr; readonly nextIndex: number } = Expr.codec.decode(functionAndNextIndex.nextIndex, binary);
   return { result: { function: functionAndNextIndex.result, parameter: parameterAndNextIndex.result }, nextIndex: parameterAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * Maybe. nullableのようなもの. 今後はRustのstd::Optionに出力するために属性をつけよう (確信)
  * @typePartId 304f21ae8208a21d08731aa6d183742d
  */
 export const Maybe: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: <value extends unknown>(a: Codec<value>) => Codec<Maybe<value>>; 
 /**
  * 値があるということ
  */
 readonly Just: <value extends unknown>(a: value) => Maybe<value>; 
 /**
  * 値がないということ
  */
 readonly Nothing: <value extends unknown>() => Maybe<value> } = { Just: <value extends unknown>(value: value): Maybe<value> => ({ _: "Just", value }), Nothing: <value extends unknown>(): Maybe<value> => ({ _: "Nothing" }), typePartId: "304f21ae8208a21d08731aa6d183742d" as TypePartId, codec: <value extends unknown>(valueCodec: Codec<value>): Codec<Maybe<value>> => ({ encode: (value: Maybe<value>): ReadonlyArray<number> => {
   switch (value._) {
     case "Just": {
       return [0].concat(valueCodec.encode(value.value));
     }
     case "Nothing": {
       return [1];
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: Maybe<value>; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: value; readonly nextIndex: number } = valueCodec.decode(patternIndex.nextIndex, binary);
     return { result: Maybe.Just(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: Maybe.Nothing(), nextIndex: patternIndex.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } }) };
 
 
 /**
  * 配列リテラルの要素
  * @typePartId 35f7e442c0838f9982e6b49da398d97f
  */
 export const ArrayItem: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ArrayItem>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ArrayItem) => ArrayItem } = { typePartId: "35f7e442c0838f9982e6b49da398d97f" as TypePartId, helper: (arrayItem: ArrayItem): ArrayItem => arrayItem, codec: { encode: (value: ArrayItem): ReadonlyArray<number> => (TsExpr.codec.encode(value.expr).concat(Bool.codec.encode(value.spread))), decode: (index: number, binary: Uint8Array): { readonly result: ArrayItem; readonly nextIndex: number } => {
   const exprAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(index, binary);
   const spreadAndNextIndex: { readonly result: Bool; readonly nextIndex: number } = Bool.codec.decode(exprAndNextIndex.nextIndex, binary);
   return { result: { expr: exprAndNextIndex.result, spread: spreadAndNextIndex.result }, nextIndex: spreadAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * quest で ログインしている状態で, クラスの招待URLを受け取ったときに, クラスの情報と, クラスにすでに入っているかなどを取得する
  * @typePartId 37e7ea136171a7fd4e23be7a7385af6b
  */
 export const GetClassAndRoleParameter: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<GetClassAndRoleParameter>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: GetClassAndRoleParameter) => GetClassAndRoleParameter } = { typePartId: "37e7ea136171a7fd4e23be7a7385af6b" as TypePartId, helper: (getClassAndRoleParameter: GetClassAndRoleParameter): GetClassAndRoleParameter => getClassAndRoleParameter, codec: { encode: (value: GetClassAndRoleParameter): ReadonlyArray<number> => (AccountToken.codec.encode(value.accountToken).concat(QClassInvitationToken.codec.encode(value.classInvitationToken))), decode: (index: number, binary: Uint8Array): { readonly result: GetClassAndRoleParameter; readonly nextIndex: number } => {
   const accountTokenAndNextIndex: { readonly result: AccountToken; readonly nextIndex: number } = AccountToken.codec.decode(index, binary);
   const classInvitationTokenAndNextIndex: { readonly result: QClassInvitationToken; readonly nextIndex: number } = QClassInvitationToken.codec.decode(accountTokenAndNextIndex.nextIndex, binary);
   return { result: { accountToken: accountTokenAndNextIndex.result, classInvitationToken: classInvitationTokenAndNextIndex.result }, nextIndex: classInvitationTokenAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 質問IDからプログラムに属する質問を取得する
  * @typePartId 38f8436dbd5f16407883acb3917cca49
  */
 export const GetQuestionListInProgramByQuestionIdParameter: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<GetQuestionListInProgramByQuestionIdParameter>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: GetQuestionListInProgramByQuestionIdParameter) => GetQuestionListInProgramByQuestionIdParameter } = { typePartId: "38f8436dbd5f16407883acb3917cca49" as TypePartId, helper: (getQuestionListInProgramByQuestionIdParameter: GetQuestionListInProgramByQuestionIdParameter): GetQuestionListInProgramByQuestionIdParameter => getQuestionListInProgramByQuestionIdParameter, codec: { encode: (value: GetQuestionListInProgramByQuestionIdParameter): ReadonlyArray<number> => (AccountToken.codec.encode(value.accountToken).concat(QQuestionId.codec.encode(value.questionId))), decode: (index: number, binary: Uint8Array): { readonly result: GetQuestionListInProgramByQuestionIdParameter; readonly nextIndex: number } => {
   const accountTokenAndNextIndex: { readonly result: AccountToken; readonly nextIndex: number } = AccountToken.codec.decode(index, binary);
   const questionIdAndNextIndex: { readonly result: QQuestionId; readonly nextIndex: number } = QQuestionId.codec.decode(accountTokenAndNextIndex.nextIndex, binary);
   return { result: { accountToken: accountTokenAndNextIndex.result, questionId: questionIdAndNextIndex.result }, nextIndex: questionIdAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * バイナリ. JavaScriptのUint8Arrayで扱える. 最初にLED128でバイト数, その次にバイナリそのまま
  * @typePartId 3e2f740c88923b0393a1ef93d92f157b
  */
 export const Binary: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Binary> } = { typePartId: "3e2f740c88923b0393a1ef93d92f157b" as TypePartId, codec: { encode: (value: Binary): ReadonlyArray<number> => (Int32.codec.encode(value.length).concat([...value])), decode: (index: number, binary: Uint8Array): { readonly result: Binary; readonly nextIndex: number } => {
   const length: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   const nextIndex: number = length.nextIndex + length.result;
   return { result: binary.slice(length.nextIndex, nextIndex), nextIndex };
 } } };
 
 
 /**
  * 3つの要素のタプルの型
  * @typePartId 42e5ab4936af4abf8673472ce96fd794
  */
 export const ElmTuple3: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmTuple3>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ElmTuple3) => ElmTuple3 } = { typePartId: "42e5ab4936af4abf8673472ce96fd794" as TypePartId, helper: (elmTuple3: ElmTuple3): ElmTuple3 => elmTuple3, codec: { encode: (value: ElmTuple3): ReadonlyArray<number> => (ElmType.codec.encode(value.first).concat(ElmType.codec.encode(value.second)).concat(ElmType.codec.encode(value.third))), decode: (index: number, binary: Uint8Array): { readonly result: ElmTuple3; readonly nextIndex: number } => {
   const firstAndNextIndex: { readonly result: ElmType; readonly nextIndex: number } = ElmType.codec.decode(index, binary);
   const secondAndNextIndex: { readonly result: ElmType; readonly nextIndex: number } = ElmType.codec.decode(firstAndNextIndex.nextIndex, binary);
   const thirdAndNextIndex: { readonly result: ElmType; readonly nextIndex: number } = ElmType.codec.decode(secondAndNextIndex.nextIndex, binary);
   return { result: { first: firstAndNextIndex.result, second: secondAndNextIndex.result, third: thirdAndNextIndex.result }, nextIndex: thirdAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 外部のモジュールの型
  * @typePartId 43aa21ed2225cacc4489c30113e87787
  */
 export const ElmImportedType: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmImportedType>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ElmImportedType) => ElmImportedType } = { typePartId: "43aa21ed2225cacc4489c30113e87787" as TypePartId, helper: (elmImportedType: ElmImportedType): ElmImportedType => elmImportedType, codec: { encode: (value: ElmImportedType): ReadonlyArray<number> => (String.codec.encode(value.moduleName).concat(ElmTypeName.codec.encode(value.typeName)).concat(List.codec(ElmType.codec).encode(value.parameter))), decode: (index: number, binary: Uint8Array): { readonly result: ElmImportedType; readonly nextIndex: number } => {
   const moduleNameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const typeNameAndNextIndex: { readonly result: ElmTypeName; readonly nextIndex: number } = ElmTypeName.codec.decode(moduleNameAndNextIndex.nextIndex, binary);
   const parameterAndNextIndex: { readonly result: List<ElmType>; readonly nextIndex: number } = List.codec(ElmType.codec).decode(typeNameAndNextIndex.nextIndex, binary);
   return { result: { moduleName: moduleNameAndNextIndex.result, typeName: typeNameAndNextIndex.result, parameter: parameterAndNextIndex.result }, nextIndex: parameterAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 2項演算子
  * @typePartId 4953938f040aefdaa5f2601e2a78d43b
  */
 export const BinaryOperator: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<BinaryOperator>; 
 /**
  * べき乗 `a ** b`
  */
 readonly Exponentiation: BinaryOperator; 
 /**
  * 数値の掛け算 `a * b`
  */
 readonly Multiplication: BinaryOperator; 
 /**
  * 数値の割り算 `a / b`
  */
 readonly Division: BinaryOperator; 
 /**
  * 剰余演算 `a % b`
  */
 readonly Remainder: BinaryOperator; 
 /**
  * 数値の足し算, 文字列の結合 `a + b`
  */
 readonly Addition: BinaryOperator; 
 /**
  * 数値の引き算 `a - b`
  */
 readonly Subtraction: BinaryOperator; 
 /**
  * 左シフト `a << b`
  */
 readonly LeftShift: BinaryOperator; 
 /**
  * 符号を維持する右シフト `a >> b`
  */
 readonly SignedRightShift: BinaryOperator; 
 /**
  * 符号を維持しない(0埋め)右シフト `a >>> b`
  */
 readonly UnsignedRightShift: BinaryOperator; 
 /**
  * 未満 `a < b`
  */
 readonly LessThan: BinaryOperator; 
 /**
  * 以下 `a <= b`
  */
 readonly LessThanOrEqual: BinaryOperator; 
 /**
  * 等号 `a === b`
  */
 readonly Equal: BinaryOperator; 
 /**
  * 不等号 `a !== b`
  */
 readonly NotEqual: BinaryOperator; 
 /**
  * ビットAND `a & b`
  */
 readonly BitwiseAnd: BinaryOperator; 
 /**
  * ビットXOR `a ^ b`
  */
 readonly BitwiseXOr: BinaryOperator; 
 /**
  * ビットOR `a | b`
  */
 readonly BitwiseOr: BinaryOperator; 
 /**
  * 論理AND `a && b`
  */
 readonly LogicalAnd: BinaryOperator; 
 /**
  * 論理OR `a || b`
  */
 readonly LogicalOr: BinaryOperator } = { Exponentiation: "Exponentiation", Multiplication: "Multiplication", Division: "Division", Remainder: "Remainder", Addition: "Addition", Subtraction: "Subtraction", LeftShift: "LeftShift", SignedRightShift: "SignedRightShift", UnsignedRightShift: "UnsignedRightShift", LessThan: "LessThan", LessThanOrEqual: "LessThanOrEqual", Equal: "Equal", NotEqual: "NotEqual", BitwiseAnd: "BitwiseAnd", BitwiseXOr: "BitwiseXOr", BitwiseOr: "BitwiseOr", LogicalAnd: "LogicalAnd", LogicalOr: "LogicalOr", typePartId: "4953938f040aefdaa5f2601e2a78d43b" as TypePartId, codec: { encode: (value: BinaryOperator): ReadonlyArray<number> => {
   switch (value) {
     case "Exponentiation": {
       return [0];
     }
     case "Multiplication": {
       return [1];
     }
     case "Division": {
       return [2];
     }
     case "Remainder": {
       return [3];
     }
     case "Addition": {
       return [4];
     }
     case "Subtraction": {
       return [5];
     }
     case "LeftShift": {
       return [6];
     }
     case "SignedRightShift": {
       return [7];
     }
     case "UnsignedRightShift": {
       return [8];
     }
     case "LessThan": {
       return [9];
     }
     case "LessThanOrEqual": {
       return [10];
     }
     case "Equal": {
       return [11];
     }
     case "NotEqual": {
       return [12];
     }
     case "BitwiseAnd": {
       return [13];
     }
     case "BitwiseXOr": {
       return [14];
     }
     case "BitwiseOr": {
       return [15];
     }
     case "LogicalAnd": {
       return [16];
     }
     case "LogicalOr": {
       return [17];
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: BinaryOperator; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     return { result: BinaryOperator.Exponentiation, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: BinaryOperator.Multiplication, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 2) {
     return { result: BinaryOperator.Division, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 3) {
     return { result: BinaryOperator.Remainder, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 4) {
     return { result: BinaryOperator.Addition, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 5) {
     return { result: BinaryOperator.Subtraction, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 6) {
     return { result: BinaryOperator.LeftShift, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 7) {
     return { result: BinaryOperator.SignedRightShift, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 8) {
     return { result: BinaryOperator.UnsignedRightShift, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 9) {
     return { result: BinaryOperator.LessThan, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 10) {
     return { result: BinaryOperator.LessThanOrEqual, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 11) {
     return { result: BinaryOperator.Equal, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 12) {
     return { result: BinaryOperator.NotEqual, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 13) {
     return { result: BinaryOperator.BitwiseAnd, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 14) {
     return { result: BinaryOperator.BitwiseXOr, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 15) {
     return { result: BinaryOperator.BitwiseOr, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 16) {
     return { result: BinaryOperator.LogicalAnd, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 17) {
     return { result: BinaryOperator.LogicalOr, nextIndex: patternIndex.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * 型アサーション
  * @typePartId 49f05a756bd75da670fa5b64ed8bf1ae
  */
 export const TypeAssertion: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<TypeAssertion>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: TypeAssertion) => TypeAssertion } = { typePartId: "49f05a756bd75da670fa5b64ed8bf1ae" as TypePartId, helper: (typeAssertion: TypeAssertion): TypeAssertion => typeAssertion, codec: { encode: (value: TypeAssertion): ReadonlyArray<number> => (TsExpr.codec.encode(value.expr).concat(TsType.codec.encode(value.type))), decode: (index: number, binary: Uint8Array): { readonly result: TypeAssertion; readonly nextIndex: number } => {
   const exprAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(index, binary);
   const typeAndNextIndex: { readonly result: TsType; readonly nextIndex: number } = TsType.codec.decode(exprAndNextIndex.nextIndex, binary);
   return { result: { expr: exprAndNextIndex.result, type: typeAndNextIndex.result }, nextIndex: typeAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * JavaScriptの単項演算子
  * @typePartId 4b4c3f8f34d1c05bb9d7d1b930bc9c9a
  */
 export const UnaryOperator: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<UnaryOperator>; 
 /**
  * 単項マイナス演算子 `-a`
  */
 readonly Minus: UnaryOperator; 
 /**
  * ビット否定 `~a`
  */
 readonly BitwiseNot: UnaryOperator; 
 /**
  * 論理否定 `!a`
  */
 readonly LogicalNot: UnaryOperator } = { Minus: "Minus", BitwiseNot: "BitwiseNot", LogicalNot: "LogicalNot", typePartId: "4b4c3f8f34d1c05bb9d7d1b930bc9c9a" as TypePartId, codec: { encode: (value: UnaryOperator): ReadonlyArray<number> => {
   switch (value) {
     case "Minus": {
       return [0];
     }
     case "BitwiseNot": {
       return [1];
     }
     case "LogicalNot": {
       return [2];
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: UnaryOperator; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     return { result: UnaryOperator.Minus, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: UnaryOperator.BitwiseNot, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 2) {
     return { result: UnaryOperator.LogicalNot, nextIndex: patternIndex.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * 型の定義本体
  * @typePartId 4c60c73d6b8f236d34281fbb9119a598
  */
 export const TypePartBody: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<TypePartBody>; 
 /**
  * 直積型
  */
 readonly Product: (a: List<Member>) => TypePartBody; 
 /**
  * 直和型
  */
 readonly Sum: (a: List<Pattern>) => TypePartBody; 
 /**
  * Definyだけでは表現できないデータ型
  */
 readonly Kernel: (a: TypePartBodyKernel) => TypePartBody } = { Product: (memberList: List<Member>): TypePartBody => ({ _: "Product", memberList }), Sum: (patternList: List<Pattern>): TypePartBody => ({ _: "Sum", patternList }), Kernel: (typePartBodyKernel: TypePartBodyKernel): TypePartBody => ({ _: "Kernel", typePartBodyKernel }), typePartId: "4c60c73d6b8f236d34281fbb9119a598" as TypePartId, codec: { encode: (value: TypePartBody): ReadonlyArray<number> => {
   switch (value._) {
     case "Product": {
       return [0].concat(List.codec(Member.codec).encode(value.memberList));
     }
     case "Sum": {
       return [1].concat(List.codec(Pattern.codec).encode(value.patternList));
     }
     case "Kernel": {
       return [2].concat(TypePartBodyKernel.codec.encode(value.typePartBodyKernel));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: TypePartBody; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: List<Member>; readonly nextIndex: number } = List.codec(Member.codec).decode(patternIndex.nextIndex, binary);
     return { result: TypePartBody.Product(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 1) {
     const result: { readonly result: List<Pattern>; readonly nextIndex: number } = List.codec(Pattern.codec).decode(patternIndex.nextIndex, binary);
     return { result: TypePartBody.Sum(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 2) {
     const result: { readonly result: TypePartBodyKernel; readonly nextIndex: number } = TypePartBodyKernel.codec.decode(patternIndex.nextIndex, binary);
     return { result: TypePartBody.Kernel(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * クラスを作成するためのパラメータ
  * @typePartId 4d9e178c23a42a4dc2e2b68270d50363
  */
 export const QCreateClassParameter: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QCreateClassParameter>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: QCreateClassParameter) => QCreateClassParameter } = { typePartId: "4d9e178c23a42a4dc2e2b68270d50363" as TypePartId, helper: (qCreateClassParameter: QCreateClassParameter): QCreateClassParameter => qCreateClassParameter, codec: { encode: (value: QCreateClassParameter): ReadonlyArray<number> => (AccountToken.codec.encode(value.accountToken).concat(QProgramId.codec.encode(value.programId)).concat(String.codec.encode(value.className))), decode: (index: number, binary: Uint8Array): { readonly result: QCreateClassParameter; readonly nextIndex: number } => {
   const accountTokenAndNextIndex: { readonly result: AccountToken; readonly nextIndex: number } = AccountToken.codec.decode(index, binary);
   const programIdAndNextIndex: { readonly result: QProgramId; readonly nextIndex: number } = QProgramId.codec.decode(accountTokenAndNextIndex.nextIndex, binary);
   const classNameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(programIdAndNextIndex.nextIndex, binary);
   return { result: { accountToken: accountTokenAndNextIndex.result, programId: programIdAndNextIndex.result, className: classNameAndNextIndex.result }, nextIndex: classNameAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * カスタム型の公開レベル
  * @typePartId 4e1cab8c9074c1a058d6ef3ffcf29ab0
  */
 export const ElmCustomTypeExportLevel: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmCustomTypeExportLevel>; 
 /**
  * 公開しない
  */
 readonly NoExport: ElmCustomTypeExportLevel; 
 /**
  * 型の指定のみ公開. 外部のモジュールで値の構成とパターンマッチングの分岐がされることはない
  */
 readonly ExportTypeOnly: ElmCustomTypeExportLevel; 
 /**
  * 型とバリアントを公開する. 外部のモジュールで値の構成とパターンマッチングができる
  */
 readonly ExportTypeAndVariant: ElmCustomTypeExportLevel } = { NoExport: "NoExport", ExportTypeOnly: "ExportTypeOnly", ExportTypeAndVariant: "ExportTypeAndVariant", typePartId: "4e1cab8c9074c1a058d6ef3ffcf29ab0" as TypePartId, codec: { encode: (value: ElmCustomTypeExportLevel): ReadonlyArray<number> => {
   switch (value) {
     case "NoExport": {
       return [0];
     }
     case "ExportTypeOnly": {
       return [1];
     }
     case "ExportTypeAndVariant": {
       return [2];
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: ElmCustomTypeExportLevel; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     return { result: ElmCustomTypeExportLevel.NoExport, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: ElmCustomTypeExportLevel.ExportTypeOnly, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 2) {
     return { result: ElmCustomTypeExportLevel.ExportTypeAndVariant, nextIndex: patternIndex.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * quest の アカウント
  * @typePartId 4e6857a774597ae66e5c316642a8ae8b
  */
 export const QAccount: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QAccount>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: QAccount) => QAccount } = { typePartId: "4e6857a774597ae66e5c316642a8ae8b" as TypePartId, helper: (qAccount: QAccount): QAccount => qAccount, codec: { encode: (value: QAccount): ReadonlyArray<number> => (String.codec.encode(value.name).concat(ImageHash.codec.encode(value.iconHash)).concat(AccountId.codec.encode(value.id))), decode: (index: number, binary: Uint8Array): { readonly result: QAccount; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const iconHashAndNextIndex: { readonly result: ImageHash; readonly nextIndex: number } = ImageHash.codec.decode(nameAndNextIndex.nextIndex, binary);
   const idAndNextIndex: { readonly result: AccountId; readonly nextIndex: number } = AccountId.codec.decode(iconHashAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, iconHash: iconHashAndNextIndex.result, id: idAndNextIndex.result }, nextIndex: idAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * quest の プログラムのID
  * @typePartId 4fe2f5da0a887c2a6b33c16c5d52058f
  */
 export const QProgramId: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QProgramId> } = { typePartId: "4fe2f5da0a887c2a6b33c16c5d52058f" as TypePartId, codec: { encode: (value: QProgramId): ReadonlyArray<number> => (encodeId(value)), decode: (index: number, binary: Uint8Array): { readonly result: QProgramId; readonly nextIndex: number } => (decodeId(index, binary) as { readonly result: QProgramId; readonly nextIndex: number }) } };
 
 
 /**
  * クエストの質問 ID
  * @typePartId 5249c5510c734bbe48e63a23e4e202b3
  */
 export const QQuestionId: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QQuestionId> } = { typePartId: "5249c5510c734bbe48e63a23e4e202b3" as TypePartId, codec: { encode: (value: QQuestionId): ReadonlyArray<number> => (encodeId(value)), decode: (index: number, binary: Uint8Array): { readonly result: QQuestionId; readonly nextIndex: number } => (decodeId(index, binary) as { readonly result: QQuestionId; readonly nextIndex: number }) } };
 
 
 /**
  * 関数のパラメーター. パラメーター名, 型
  * @typePartId 5433bade7738da21e7663ff043f588d5
  */
 export const Parameter: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Parameter>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: Parameter) => Parameter } = { typePartId: "5433bade7738da21e7663ff043f588d5" as TypePartId, helper: (parameter: Parameter): Parameter => parameter, codec: { encode: (value: Parameter): ReadonlyArray<number> => (TsIdentifer.codec.encode(value.name).concat(TsType.codec.encode(value.type))), decode: (index: number, binary: Uint8Array): { readonly result: Parameter; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: TsIdentifer; readonly nextIndex: number } = TsIdentifer.codec.decode(index, binary);
   const typeAndNextIndex: { readonly result: TsType; readonly nextIndex: number } = TsType.codec.decode(nameAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, type: typeAndNextIndex.result }, nextIndex: typeAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 辞書型. TypeScriptでは ReadonlyMap として扱う
  * @typePartId 5516d41d180b98b7f5a8950d4f43dfd6
  */
 export const Dict: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: <key extends unknown, value extends unknown>(a: Codec<key>, b: Codec<value>) => Codec<Dict<key, value>> } = { typePartId: "5516d41d180b98b7f5a8950d4f43dfd6" as TypePartId, codec: <key extends unknown, value extends unknown>(keyCodec: Codec<key>, valueCodec: Codec<value>): Codec<Dict<key, value>> => ({ encode: (value: Dict<key, value>): ReadonlyArray<number> => {
   let result: Array<number> = Int32.codec.encode(value.size) as Array<number>;
   for (const element of value){
     result = [...result, ...keyCodec.encode(element[0]), ...valueCodec.encode(element[1])];
   }
   return result;
 }, decode: (index: number, binary: Uint8Array): { readonly result: Dict<key, value>; readonly nextIndex: number } => {
   const lengthResult: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   let nextIndex: number = lengthResult.nextIndex;
   const result: Map<key, value> = new Map([]);
   for (let i = 0; i < lengthResult.result; i += 1){
     const keyResult: { readonly result: key; readonly nextIndex: number } = keyCodec.decode(nextIndex, binary);
     const valueResult: { readonly result: value; readonly nextIndex: number } = valueCodec.decode(keyResult.nextIndex, binary);
     result.set(keyResult.result, valueResult.result);
     nextIndex = valueResult.nextIndex;
   }
   return { result, nextIndex };
 } }) };
 
 
 /**
  * 取得日時と任意のデータ
  * @typePartId 55d4de38cfb884b9008abd7f7f63325e
  */
 export const WithTime: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: <data extends unknown>(a: Codec<data>) => Codec<WithTime<data>>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: <data extends unknown>(a: WithTime<data>) => WithTime<data> } = { typePartId: "55d4de38cfb884b9008abd7f7f63325e" as TypePartId, helper: <data extends unknown>(withTime: WithTime<data>): WithTime<data> => withTime, codec: <data extends unknown>(dataCodec: Codec<data>): Codec<WithTime<data>> => ({ encode: (value: WithTime<data>): ReadonlyArray<number> => (Time.codec.encode(value.getTime).concat(dataCodec.encode(value.data))), decode: (index: number, binary: Uint8Array): { readonly result: WithTime<data>; readonly nextIndex: number } => {
   const getTimeAndNextIndex: { readonly result: Time; readonly nextIndex: number } = Time.codec.decode(index, binary);
   const dataAndNextIndex: { readonly result: data; readonly nextIndex: number } = dataCodec.decode(getTimeAndNextIndex.nextIndex, binary);
   return { result: { getTime: getTimeAndNextIndex.result, data: dataAndNextIndex.result }, nextIndex: dataAndNextIndex.nextIndex };
 } }) };
 
 
 /**
  * 型エイリアス. 型に名前を付け, レコード型の場合, その名前の関数を作成する
  * @typePartId 57f429fd5c67eb2542447a2eaeb34497
  */
 export const ElmTypeAlias: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmTypeAlias>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ElmTypeAlias) => ElmTypeAlias } = { typePartId: "57f429fd5c67eb2542447a2eaeb34497" as TypePartId, helper: (elmTypeAlias: ElmTypeAlias): ElmTypeAlias => elmTypeAlias, codec: { encode: (value: ElmTypeAlias): ReadonlyArray<number> => (ElmTypeName.codec.encode(value.name).concat(Bool.codec.encode(value.export)).concat(String.codec.encode(value.comment)).concat(List.codec(String.codec).encode(value.parameter)).concat(ElmType.codec.encode(value.type))), decode: (index: number, binary: Uint8Array): { readonly result: ElmTypeAlias; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: ElmTypeName; readonly nextIndex: number } = ElmTypeName.codec.decode(index, binary);
   const exportAndNextIndex: { readonly result: Bool; readonly nextIndex: number } = Bool.codec.decode(nameAndNextIndex.nextIndex, binary);
   const commentAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(exportAndNextIndex.nextIndex, binary);
   const parameterAndNextIndex: { readonly result: List<String>; readonly nextIndex: number } = List.codec(String.codec).decode(commentAndNextIndex.nextIndex, binary);
   const typeAndNextIndex: { readonly result: ElmType; readonly nextIndex: number } = ElmType.codec.decode(parameterAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, export: exportAndNextIndex.result, comment: commentAndNextIndex.result, parameter: parameterAndNextIndex.result, type: typeAndNextIndex.result }, nextIndex: typeAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * パーツの識別子
  * @typePartId 5880cd7c0b6f0205c739a06181898d03
  */
 export const PartId: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<PartId> } = { typePartId: "5880cd7c0b6f0205c739a06181898d03" as TypePartId, codec: { encode: (value: PartId): ReadonlyArray<number> => (encodeId(value)), decode: (index: number, binary: Uint8Array): { readonly result: PartId; readonly nextIndex: number } => (decodeId(index, binary) as { readonly result: PartId; readonly nextIndex: number }) } };
 
 
 /**
  * AccountToken と UserId
  * @typePartId 5d291325e9d7bc27ff35e907f59bde54
  */
 export const AccountTokenAndUserId: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<AccountTokenAndUserId>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: AccountTokenAndUserId) => AccountTokenAndUserId } = { typePartId: "5d291325e9d7bc27ff35e907f59bde54" as TypePartId, helper: (accountTokenAndUserId: AccountTokenAndUserId): AccountTokenAndUserId => accountTokenAndUserId, codec: { encode: (value: AccountTokenAndUserId): ReadonlyArray<number> => (AccountToken.codec.encode(value.accountToken).concat(AccountId.codec.encode(value.userId))), decode: (index: number, binary: Uint8Array): { readonly result: AccountTokenAndUserId; readonly nextIndex: number } => {
   const accountTokenAndNextIndex: { readonly result: AccountToken; readonly nextIndex: number } = AccountToken.codec.decode(index, binary);
   const userIdAndNextIndex: { readonly result: AccountId; readonly nextIndex: number } = AccountId.codec.decode(accountTokenAndNextIndex.nextIndex, binary);
   return { result: { accountToken: accountTokenAndNextIndex.result, userId: userIdAndNextIndex.result }, nextIndex: userIdAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * タグの識別子. タグは直和型に使うもの.
  *
  * 実行時に使わないことは確定しているが, コード内の形式としてタグにUUIDを使うべきかは考慮中. index で充分かと思ったが別に型の情報も必要になることが多い
  * @typePartId 5ec292c48424e5e9ee8cc2d672830ecd
  */
 export const TagId: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<TagId> } = { typePartId: "5ec292c48424e5e9ee8cc2d672830ecd" as TypePartId, codec: { encode: (value: TagId): ReadonlyArray<number> => (encodeId(value)), decode: (index: number, binary: Uint8Array): { readonly result: TagId; readonly nextIndex: number } => (decodeId(index, binary) as { readonly result: TagId; readonly nextIndex: number }) } };
 
 
 /**
  * 関数の型. 入力と出力
  * @typePartId 5ec9dae951d8d2b250c81185a259adca
  */
 export const ElmFunctionType: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmFunctionType>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ElmFunctionType) => ElmFunctionType } = { typePartId: "5ec9dae951d8d2b250c81185a259adca" as TypePartId, helper: (elmFunctionType: ElmFunctionType): ElmFunctionType => elmFunctionType, codec: { encode: (value: ElmFunctionType): ReadonlyArray<number> => (ElmType.codec.encode(value.input).concat(ElmType.codec.encode(value.output))), decode: (index: number, binary: Uint8Array): { readonly result: ElmFunctionType; readonly nextIndex: number } => {
   const inputAndNextIndex: { readonly result: ElmType; readonly nextIndex: number } = ElmType.codec.decode(index, binary);
   const outputAndNextIndex: { readonly result: ElmType; readonly nextIndex: number } = ElmType.codec.decode(inputAndNextIndex.nextIndex, binary);
   return { result: { input: inputAndNextIndex.result, output: outputAndNextIndex.result }, nextIndex: outputAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * switch文のcase "text": { statementList } の部分
  * @typePartId 6126431def47ecba239b3add7f472b19
  */
 export const TsPattern: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<TsPattern>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: TsPattern) => TsPattern } = { typePartId: "6126431def47ecba239b3add7f472b19" as TypePartId, helper: (tsPattern: TsPattern): TsPattern => tsPattern, codec: { encode: (value: TsPattern): ReadonlyArray<number> => (String.codec.encode(value.caseString).concat(List.codec(Statement.codec).encode(value.statementList))), decode: (index: number, binary: Uint8Array): { readonly result: TsPattern; readonly nextIndex: number } => {
   const caseStringAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const statementListAndNextIndex: { readonly result: List<Statement>; readonly nextIndex: number } = List.codec(Statement.codec).decode(caseStringAndNextIndex.nextIndex, binary);
   return { result: { caseString: caseStringAndNextIndex.result, statementList: statementListAndNextIndex.result }, nextIndex: statementListAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * QUEST. クラスのID
  * @typePartId 624e37b7230f763e6318c627c2c728ec
  */
 export const QClassId: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QClassId> } = { typePartId: "624e37b7230f763e6318c627c2c728ec" as TypePartId, codec: { encode: (value: QClassId): ReadonlyArray<number> => (encodeId(value)), decode: (index: number, binary: Uint8Array): { readonly result: QClassId; readonly nextIndex: number } => (decodeId(index, binary) as { readonly result: QClassId; readonly nextIndex: number }) } };
 
 
 /**
  * 型パラメーター
  * @typePartId 627dc8fa15214481812af12268d97b6b
  */
 export const TypeParameter: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<TypeParameter>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: TypeParameter) => TypeParameter } = { typePartId: "627dc8fa15214481812af12268d97b6b" as TypePartId, helper: (typeParameter: TypeParameter): TypeParameter => typeParameter, codec: { encode: (value: TypeParameter): ReadonlyArray<number> => (String.codec.encode(value.name).concat(TypePartId.codec.encode(value.typePartId))), decode: (index: number, binary: Uint8Array): { readonly result: TypeParameter; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const typePartIdAndNextIndex: { readonly result: TypePartId; readonly nextIndex: number } = TypePartId.codec.decode(nameAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, typePartId: typePartIdAndNextIndex.result }, nextIndex: typePartIdAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * Elmのコードを表現するもの
  * @typePartId 62923d32a2730114e665cef13f93ff13
  */
 export const ElmCode: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmCode>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ElmCode) => ElmCode } = { typePartId: "62923d32a2730114e665cef13f93ff13" as TypePartId, helper: (elmCode: ElmCode): ElmCode => elmCode, codec: { encode: (value: ElmCode): ReadonlyArray<number> => (String.codec.encode(value.moduleName).concat(List.codec(ElmTypeDeclaration.codec).encode(value.typeDeclarationList))), decode: (index: number, binary: Uint8Array): { readonly result: ElmCode; readonly nextIndex: number } => {
   const moduleNameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const typeDeclarationListAndNextIndex: { readonly result: List<ElmTypeDeclaration>; readonly nextIndex: number } = List.codec(ElmTypeDeclaration.codec).decode(moduleNameAndNextIndex.nextIndex, binary);
   return { result: { moduleName: moduleNameAndNextIndex.result, typeDeclarationList: typeDeclarationListAndNextIndex.result }, nextIndex: typeDeclarationListAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * Definyだけでは表現できないデータ型
  * @typePartId 657b5a5519b095480a21fdadd0f6fbd1
  */
 export const TypePartBodyKernel: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<TypePartBodyKernel>; 
 /**
  * 関数
  */
 readonly Function: TypePartBodyKernel; 
 /**
  * 32bit整数
  */
 readonly Int32: TypePartBodyKernel; 
 /**
  * 文字列. Definyだけで表現できるが, TypeScriptでstringとして扱うために必要
  */
 readonly String: TypePartBodyKernel; 
 /**
  * バイナリ型. TypeScriptではUint8Arrayとして扱う
  */
 readonly Binary: TypePartBodyKernel; 
 /**
  * UUID (16byte) を表現する. 内部表現はとりあえず0-f長さ32の文字列
  */
 readonly Id: TypePartBodyKernel; 
 /**
  * sha256などでハッシュ化したもの (32byte) を表現する. 内部表現はとりあえず0-f長さ64の文字列
  */
 readonly Token: TypePartBodyKernel; 
 /**
  * 配列型. TypeScriptではReadonlyArrayとして扱う
  */
 readonly List: TypePartBodyKernel; 
 /**
  * 辞書型. TypeScriptでは ReadonlyMapとして扱う
  */
 readonly Dict: TypePartBodyKernel } = { Function: "Function", Int32: "Int32", String: "String", Binary: "Binary", Id: "Id", Token: "Token", List: "List", Dict: "Dict", typePartId: "657b5a5519b095480a21fdadd0f6fbd1" as TypePartId, codec: { encode: (value: TypePartBodyKernel): ReadonlyArray<number> => {
   switch (value) {
     case "Function": {
       return [0];
     }
     case "Int32": {
       return [1];
     }
     case "String": {
       return [2];
     }
     case "Binary": {
       return [3];
     }
     case "Id": {
       return [4];
     }
     case "Token": {
       return [5];
     }
     case "List": {
       return [6];
     }
     case "Dict": {
       return [7];
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: TypePartBodyKernel; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     return { result: TypePartBodyKernel.Function, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: TypePartBodyKernel.Int32, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 2) {
     return { result: TypePartBodyKernel.String, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 3) {
     return { result: TypePartBodyKernel.Binary, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 4) {
     return { result: TypePartBodyKernel.Id, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 5) {
     return { result: TypePartBodyKernel.Token, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 6) {
     return { result: TypePartBodyKernel.List, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 7) {
     return { result: TypePartBodyKernel.Dict, nextIndex: patternIndex.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * 文字列. JavaScriptのstringで扱う. バイナリ形式はUTF-8. 不正な文字が入っている可能性がある
  * @typePartId 666361c9ae68ab64f273c47f3feb8c73
  */
 export const String: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<String> } = { typePartId: "666361c9ae68ab64f273c47f3feb8c73" as TypePartId, codec: { encode: (value: String): ReadonlyArray<number> => {
   const result: ReadonlyArray<number> = [...new TextEncoder().encode(value)];
   return Int32.codec.encode(result.length).concat(result);
 }, decode: (index: number, binary: Uint8Array): { readonly result: String; readonly nextIndex: number } => {
   const length: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   const nextIndex: number = length.nextIndex + length.result;
   const textBinary: Uint8Array = binary.slice(length.nextIndex, nextIndex);
   return { result: new TextDecoder().decode(textBinary), nextIndex };
 } } };
 
 
 /**
  * ユーザー名. 表示される名前. 他のユーザーとかぶっても良い. 絵文字も使える. 全角英数は半角英数,半角カタカナは全角カタカナ, (株)の合字を分解するなどのNFKCの正規化がされる. U+0000-U+0019 と U+007F-U+00A0 の範囲の文字は入らない. 前後に空白を含められない. 間の空白は2文字以上連続しない. 文字数のカウント方法は正規化されたあとのCodePoint単位. Twitterと同じ, 1文字以上50文字以下
  * @typePartId 67d4e3bc4f13e1132b6c5e81d5b74395
  */
 export const Account: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Account>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: Account) => Account } = { typePartId: "67d4e3bc4f13e1132b6c5e81d5b74395" as TypePartId, helper: (account: Account): Account => account, codec: { encode: (value: Account): ReadonlyArray<number> => (ImageHash.codec.encode(value.imageHash).concat(String.codec.encode(value.introduction)).concat(Time.codec.encode(value.createTime)).concat(String.codec.encode(value.name))), decode: (index: number, binary: Uint8Array): { readonly result: Account; readonly nextIndex: number } => {
   const imageHashAndNextIndex: { readonly result: ImageHash; readonly nextIndex: number } = ImageHash.codec.decode(index, binary);
   const introductionAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(imageHashAndNextIndex.nextIndex, binary);
   const createTimeAndNextIndex: { readonly result: Time; readonly nextIndex: number } = Time.codec.decode(introductionAndNextIndex.nextIndex, binary);
   const nameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(createTimeAndNextIndex.nextIndex, binary);
   return { result: { imageHash: imageHashAndNextIndex.result, introduction: introductionAndNextIndex.result, createTime: createTimeAndNextIndex.result, name: nameAndNextIndex.result }, nextIndex: nameAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * キーであるTokenによってデータが必ず1つに決まるもの. 絶対に更新されない. リソースがないということはデータが不正な状態になっているということ
  * @typePartId 68d925f7b35bab8f265cd9e5eb7ea3da
  */
 export const StaticResourceState: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: <data extends unknown>(a: Codec<data>) => Codec<StaticResourceState<data>>; 
 /**
  * 取得済み
  */
 readonly Loaded: <data extends unknown>(a: data) => StaticResourceState<data>; 
 /**
  * データを取得できなかった (サーバーの障害, オフライン)
  */
 readonly Unknown: <data extends unknown>() => StaticResourceState<data>; 
 /**
  * indexedDBにアクセス中
  */
 readonly Loading: <data extends unknown>() => StaticResourceState<data>; 
 /**
  * サーバに問い合わせ中
  */
 readonly Requesting: <data extends unknown>() => StaticResourceState<data> } = { Loaded: <data extends unknown>(data: data): StaticResourceState<data> => ({ _: "Loaded", data }), Unknown: <data extends unknown>(): StaticResourceState<data> => ({ _: "Unknown" }), Loading: <data extends unknown>(): StaticResourceState<data> => ({ _: "Loading" }), Requesting: <data extends unknown>(): StaticResourceState<data> => ({ _: "Requesting" }), typePartId: "68d925f7b35bab8f265cd9e5eb7ea3da" as TypePartId, codec: <data extends unknown>(dataCodec: Codec<data>): Codec<StaticResourceState<data>> => ({ encode: (value: StaticResourceState<data>): ReadonlyArray<number> => {
   switch (value._) {
     case "Loaded": {
       return [0].concat(dataCodec.encode(value.data));
     }
     case "Unknown": {
       return [1];
     }
     case "Loading": {
       return [2];
     }
     case "Requesting": {
       return [3];
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: StaticResourceState<data>; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: data; readonly nextIndex: number } = dataCodec.decode(patternIndex.nextIndex, binary);
     return { result: StaticResourceState.Loaded(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: StaticResourceState.Unknown(), nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 2) {
     return { result: StaticResourceState.Loading(), nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 3) {
     return { result: StaticResourceState.Requesting(), nextIndex: patternIndex.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } }) };
 
 
 /**
  * 代入文
  * @typePartId 6a5a7886b0f117a50d9d7b11ffe87c9f
  */
 export const SetStatement: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<SetStatement>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: SetStatement) => SetStatement } = { typePartId: "6a5a7886b0f117a50d9d7b11ffe87c9f" as TypePartId, helper: (setStatement: SetStatement): SetStatement => setStatement, codec: { encode: (value: SetStatement): ReadonlyArray<number> => (TsExpr.codec.encode(value.target).concat(Maybe.codec(BinaryOperator.codec).encode(value.operatorMaybe)).concat(TsExpr.codec.encode(value.expr))), decode: (index: number, binary: Uint8Array): { readonly result: SetStatement; readonly nextIndex: number } => {
   const targetAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(index, binary);
   const operatorMaybeAndNextIndex: { readonly result: Maybe<BinaryOperator>; readonly nextIndex: number } = Maybe.codec(BinaryOperator.codec).decode(targetAndNextIndex.nextIndex, binary);
   const exprAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(operatorMaybeAndNextIndex.nextIndex, binary);
   return { result: { target: targetAndNextIndex.result, operatorMaybe: operatorMaybeAndNextIndex.result, expr: exprAndNextIndex.result }, nextIndex: exprAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * ドキュメント付きの関数のパラメーター. パラメーター名, ドキュメント, 型
  * @typePartId 6b05e33009ade6b4decd452e8fd4bff1
  */
 export const ParameterWithDocument: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ParameterWithDocument>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ParameterWithDocument) => ParameterWithDocument } = { typePartId: "6b05e33009ade6b4decd452e8fd4bff1" as TypePartId, helper: (parameterWithDocument: ParameterWithDocument): ParameterWithDocument => parameterWithDocument, codec: { encode: (value: ParameterWithDocument): ReadonlyArray<number> => (TsIdentifer.codec.encode(value.name).concat(String.codec.encode(value.document)).concat(TsType.codec.encode(value.type))), decode: (index: number, binary: Uint8Array): { readonly result: ParameterWithDocument; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: TsIdentifer; readonly nextIndex: number } = TsIdentifer.codec.decode(index, binary);
   const documentAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
   const typeAndNextIndex: { readonly result: TsType; readonly nextIndex: number } = TsType.codec.decode(documentAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, document: documentAndNextIndex.result, type: typeAndNextIndex.result }, nextIndex: typeAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 型パーツの識別子
  * @typePartId 6e3cff317f8bfbbd1391c0afb9ad6b72
  */
 export const TypePartId: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<TypePartId> } = { typePartId: "6e3cff317f8bfbbd1391c0afb9ad6b72" as TypePartId, codec: { encode: (value: TypePartId): ReadonlyArray<number> => (encodeId(value)), decode: (index: number, binary: Uint8Array): { readonly result: TypePartId; readonly nextIndex: number } => (decodeId(index, binary) as { readonly result: TypePartId; readonly nextIndex: number }) } };
 
 
 /**
  * 成功と失敗を表す型. 今後はRustのstd::Resultに出力するために属性をつける?
  * @typePartId 6f937e46fce1cf70d29c54780f132c18
  */
 export const Result: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: <ok extends unknown, error extends unknown>(a: Codec<ok>, b: Codec<error>) => Codec<Result<ok, error>>; 
 /**
  * 成功
  */
 readonly Ok: <ok extends unknown, error extends unknown>(a: ok) => Result<ok, error>; 
 /**
  * 失敗
  */
 readonly Error: <ok extends unknown, error extends unknown>(a: error) => Result<ok, error> } = { Ok: <ok extends unknown, error extends unknown>(ok: ok): Result<ok, error> => ({ _: "Ok", ok }), Error: <ok extends unknown, error extends unknown>(error: error): Result<ok, error> => ({ _: "Error", error }), typePartId: "6f937e46fce1cf70d29c54780f132c18" as TypePartId, codec: <ok extends unknown, error extends unknown>(okCodec: Codec<ok>, errorCodec: Codec<error>): Codec<Result<ok, error>> => ({ encode: (value: Result<ok, error>): ReadonlyArray<number> => {
   switch (value._) {
     case "Ok": {
       return [0].concat(okCodec.encode(value.ok));
     }
     case "Error": {
       return [1].concat(errorCodec.encode(value.error));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: Result<ok, error>; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: ok; readonly nextIndex: number } = okCodec.decode(patternIndex.nextIndex, binary);
     return { result: Result.Ok(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 1) {
     const result: { readonly result: error; readonly nextIndex: number } = errorCodec.decode(patternIndex.nextIndex, binary);
     return { result: Result.Error(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } }) };
 
 
 /**
  * 言語とページの場所. URLとして表現されるデータ. Googleなどの検索エンジンの都合( https://support.google.com/webmasters/answer/182192?hl=ja )で,URLにページの言語を入れて,言語ごとに別のURLである必要がある.
  * @typePartId 7210f04a85c5f0f58f7aa20826d67f05
  */
 export const UrlData: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<UrlData>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: UrlData) => UrlData } = { typePartId: "7210f04a85c5f0f58f7aa20826d67f05" as TypePartId, helper: (urlData: UrlData): UrlData => urlData, codec: { encode: (value: UrlData): ReadonlyArray<number> => (Location.codec.encode(value.location).concat(Language.codec.encode(value.language))), decode: (index: number, binary: Uint8Array): { readonly result: UrlData; readonly nextIndex: number } => {
   const locationAndNextIndex: { readonly result: Location; readonly nextIndex: number } = Location.codec.decode(index, binary);
   const languageAndNextIndex: { readonly result: Language; readonly nextIndex: number } = Language.codec.decode(locationAndNextIndex.nextIndex, binary);
   return { result: { location: locationAndNextIndex.result, language: languageAndNextIndex.result }, nextIndex: languageAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * switch文
  * @typePartId 725f84ef82e6c3b5b5f6fd5208977dd8
  */
 export const SwitchStatement: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<SwitchStatement>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: SwitchStatement) => SwitchStatement } = { typePartId: "725f84ef82e6c3b5b5f6fd5208977dd8" as TypePartId, helper: (switchStatement: SwitchStatement): SwitchStatement => switchStatement, codec: { encode: (value: SwitchStatement): ReadonlyArray<number> => (TsExpr.codec.encode(value.expr).concat(List.codec(TsPattern.codec).encode(value.patternList))), decode: (index: number, binary: Uint8Array): { readonly result: SwitchStatement; readonly nextIndex: number } => {
   const exprAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(index, binary);
   const patternListAndNextIndex: { readonly result: List<TsPattern>; readonly nextIndex: number } = List.codec(TsPattern.codec).decode(exprAndNextIndex.nextIndex, binary);
   return { result: { expr: exprAndNextIndex.result, patternList: patternListAndNextIndex.result }, nextIndex: patternListAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * ローカル変数定義
  * @typePartId 7277cf2483388ee2f5ad7a7fc8585d98
  */
 export const VariableDefinitionStatement: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<VariableDefinitionStatement>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: VariableDefinitionStatement) => VariableDefinitionStatement } = { typePartId: "7277cf2483388ee2f5ad7a7fc8585d98" as TypePartId, helper: (variableDefinitionStatement: VariableDefinitionStatement): VariableDefinitionStatement => variableDefinitionStatement, codec: { encode: (value: VariableDefinitionStatement): ReadonlyArray<number> => (TsIdentifer.codec.encode(value.name).concat(TsType.codec.encode(value.type)).concat(TsExpr.codec.encode(value.expr)).concat(Bool.codec.encode(value.isConst))), decode: (index: number, binary: Uint8Array): { readonly result: VariableDefinitionStatement; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: TsIdentifer; readonly nextIndex: number } = TsIdentifer.codec.decode(index, binary);
   const typeAndNextIndex: { readonly result: TsType; readonly nextIndex: number } = TsType.codec.decode(nameAndNextIndex.nextIndex, binary);
   const exprAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(typeAndNextIndex.nextIndex, binary);
   const isConstAndNextIndex: { readonly result: Bool; readonly nextIndex: number } = Bool.codec.decode(exprAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, type: typeAndNextIndex.result, expr: exprAndNextIndex.result, isConst: isConstAndNextIndex.result }, nextIndex: isConstAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * プロジェクト作成時に必要なパラメーター
  * @typePartId 7b987551cc112a64f5c9a8cb1647f4bd
  */
 export const CreateProjectParameter: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<CreateProjectParameter>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: CreateProjectParameter) => CreateProjectParameter } = { typePartId: "7b987551cc112a64f5c9a8cb1647f4bd" as TypePartId, helper: (createProjectParameter: CreateProjectParameter): CreateProjectParameter => createProjectParameter, codec: { encode: (value: CreateProjectParameter): ReadonlyArray<number> => (AccountToken.codec.encode(value.accountToken).concat(String.codec.encode(value.projectName))), decode: (index: number, binary: Uint8Array): { readonly result: CreateProjectParameter; readonly nextIndex: number } => {
   const accountTokenAndNextIndex: { readonly result: AccountToken; readonly nextIndex: number } = AccountToken.codec.decode(index, binary);
   const projectNameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(accountTokenAndNextIndex.nextIndex, binary);
   return { result: { accountToken: accountTokenAndNextIndex.result, projectName: projectNameAndNextIndex.result }, nextIndex: projectNameAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * JavaScript の 文
  * @typePartId 7c957d411f448a03764f16d43e6e5008
  */
 export const Statement: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Statement>; 
 /**
  * 式を評価する
  */
 readonly EvaluateExpr: (a: TsExpr) => Statement; 
 /**
  * 代入やプロパティの値を設定する
  */
 readonly Set: (a: SetStatement) => Statement; 
 /**
  * if (condition) { thenStatementList }
  */
 readonly If: (a: IfStatement) => Statement; 
 /**
  * throw new Error("エラーメッセージ");
  */
 readonly ThrowError: (a: TsExpr) => Statement; 
 /**
  * return expr;
  */
 readonly Return: (a: TsExpr) => Statement; 
 /**
  * 戻り値がvoidの関数を早く抜ける
  */
 readonly ReturnVoid: Statement; 
 /**
  * forの繰り返しを次に進める
  */
 readonly Continue: Statement; 
 /**
  * `const a: type_ = expr`\nローカル変数の定義
  */
 readonly VariableDefinition: (a: VariableDefinitionStatement) => Statement; 
 /**
  * `const name = (parameterList): returnType => { statementList }`\nローカル関数の定義
  */
 readonly FunctionDefinition: (a: FunctionDefinitionStatement) => Statement; 
 /**
  * for文. 繰り返し.
  */
 readonly For: (a: ForStatement) => Statement; 
 /**
  * for文. 繰り返し.
  */
 readonly ForOf: (a: ForOfStatement) => Statement; 
 /**
  * while (true) での無限ループ
  */
 readonly WhileTrue: (a: List<Statement>) => Statement; 
 /**
  * whileのループから抜ける
  */
 readonly Break: Statement; 
 /**
  * switch文
  */
 readonly Switch: (a: SwitchStatement) => Statement } = { EvaluateExpr: (tsExpr: TsExpr): Statement => ({ _: "EvaluateExpr", tsExpr }), Set: (setStatement: SetStatement): Statement => ({ _: "Set", setStatement }), If: (ifStatement: IfStatement): Statement => ({ _: "If", ifStatement }), ThrowError: (tsExpr: TsExpr): Statement => ({ _: "ThrowError", tsExpr }), Return: (tsExpr: TsExpr): Statement => ({ _: "Return", tsExpr }), ReturnVoid: { _: "ReturnVoid" }, Continue: { _: "Continue" }, VariableDefinition: (variableDefinitionStatement: VariableDefinitionStatement): Statement => ({ _: "VariableDefinition", variableDefinitionStatement }), FunctionDefinition: (functionDefinitionStatement: FunctionDefinitionStatement): Statement => ({ _: "FunctionDefinition", functionDefinitionStatement }), For: (forStatement: ForStatement): Statement => ({ _: "For", forStatement }), ForOf: (forOfStatement: ForOfStatement): Statement => ({ _: "ForOf", forOfStatement }), WhileTrue: (statementList: List<Statement>): Statement => ({ _: "WhileTrue", statementList }), Break: { _: "Break" }, Switch: (switchStatement: SwitchStatement): Statement => ({ _: "Switch", switchStatement }), typePartId: "7c957d411f448a03764f16d43e6e5008" as TypePartId, codec: { encode: (value: Statement): ReadonlyArray<number> => {
   switch (value._) {
     case "EvaluateExpr": {
       return [0].concat(TsExpr.codec.encode(value.tsExpr));
     }
     case "Set": {
       return [1].concat(SetStatement.codec.encode(value.setStatement));
     }
     case "If": {
       return [2].concat(IfStatement.codec.encode(value.ifStatement));
     }
     case "ThrowError": {
       return [3].concat(TsExpr.codec.encode(value.tsExpr));
     }
     case "Return": {
       return [4].concat(TsExpr.codec.encode(value.tsExpr));
     }
     case "ReturnVoid": {
       return [5];
     }
     case "Continue": {
       return [6];
     }
     case "VariableDefinition": {
       return [7].concat(VariableDefinitionStatement.codec.encode(value.variableDefinitionStatement));
     }
     case "FunctionDefinition": {
       return [8].concat(FunctionDefinitionStatement.codec.encode(value.functionDefinitionStatement));
     }
     case "For": {
       return [9].concat(ForStatement.codec.encode(value.forStatement));
     }
     case "ForOf": {
       return [10].concat(ForOfStatement.codec.encode(value.forOfStatement));
     }
     case "WhileTrue": {
       return [11].concat(List.codec(Statement.codec).encode(value.statementList));
     }
     case "Break": {
       return [12];
     }
     case "Switch": {
       return [13].concat(SwitchStatement.codec.encode(value.switchStatement));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: Statement; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(patternIndex.nextIndex, binary);
     return { result: Statement.EvaluateExpr(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 1) {
     const result: { readonly result: SetStatement; readonly nextIndex: number } = SetStatement.codec.decode(patternIndex.nextIndex, binary);
     return { result: Statement.Set(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 2) {
     const result: { readonly result: IfStatement; readonly nextIndex: number } = IfStatement.codec.decode(patternIndex.nextIndex, binary);
     return { result: Statement.If(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 3) {
     const result: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(patternIndex.nextIndex, binary);
     return { result: Statement.ThrowError(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 4) {
     const result: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(patternIndex.nextIndex, binary);
     return { result: Statement.Return(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 5) {
     return { result: Statement.ReturnVoid, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 6) {
     return { result: Statement.Continue, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 7) {
     const result: { readonly result: VariableDefinitionStatement; readonly nextIndex: number } = VariableDefinitionStatement.codec.decode(patternIndex.nextIndex, binary);
     return { result: Statement.VariableDefinition(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 8) {
     const result: { readonly result: FunctionDefinitionStatement; readonly nextIndex: number } = FunctionDefinitionStatement.codec.decode(patternIndex.nextIndex, binary);
     return { result: Statement.FunctionDefinition(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 9) {
     const result: { readonly result: ForStatement; readonly nextIndex: number } = ForStatement.codec.decode(patternIndex.nextIndex, binary);
     return { result: Statement.For(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 10) {
     const result: { readonly result: ForOfStatement; readonly nextIndex: number } = ForOfStatement.codec.decode(patternIndex.nextIndex, binary);
     return { result: Statement.ForOf(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 11) {
     const result: { readonly result: List<Statement>; readonly nextIndex: number } = List.codec(Statement.codec).decode(patternIndex.nextIndex, binary);
     return { result: Statement.WhileTrue(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 12) {
     return { result: Statement.Break, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 13) {
     const result: { readonly result: SwitchStatement; readonly nextIndex: number } = SwitchStatement.codec.decode(patternIndex.nextIndex, binary);
     return { result: Statement.Switch(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * 日時. `0001-01-01T00:00:00.000Z to 9999-12-31T23:59:59.999Z` 最小単位はミリ秒. ミリ秒の求め方は `day*1000*60*60*24 + millisecond`
  * @typePartId 7d91f0f70643799692aa144ee51a62b1
  */
 export const Time: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Time>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: Time) => Time } = { typePartId: "7d91f0f70643799692aa144ee51a62b1" as TypePartId, helper: (time: Time): Time => time, codec: { encode: (value: Time): ReadonlyArray<number> => (Int32.codec.encode(value.day).concat(Int32.codec.encode(value.millisecond))), decode: (index: number, binary: Uint8Array): { readonly result: Time; readonly nextIndex: number } => {
   const dayAndNextIndex: { readonly result: Int32; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   const millisecondAndNextIndex: { readonly result: Int32; readonly nextIndex: number } = Int32.codec.decode(dayAndNextIndex.nextIndex, binary);
   return { result: { day: dayAndNextIndex.result, millisecond: millisecondAndNextIndex.result }, nextIndex: millisecondAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * アカウントトークンとプロジェクトID
  * @typePartId 7e4613f18e8e3bcfdfc00356654414d5
  */
 export const AccountTokenAndProjectId: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<AccountTokenAndProjectId>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: AccountTokenAndProjectId) => AccountTokenAndProjectId } = { typePartId: "7e4613f18e8e3bcfdfc00356654414d5" as TypePartId, helper: (accountTokenAndProjectId: AccountTokenAndProjectId): AccountTokenAndProjectId => accountTokenAndProjectId, codec: { encode: (value: AccountTokenAndProjectId): ReadonlyArray<number> => (AccountToken.codec.encode(value.accountToken).concat(ProjectId.codec.encode(value.projectId))), decode: (index: number, binary: Uint8Array): { readonly result: AccountTokenAndProjectId; readonly nextIndex: number } => {
   const accountTokenAndNextIndex: { readonly result: AccountToken; readonly nextIndex: number } = AccountToken.codec.decode(index, binary);
   const projectIdAndNextIndex: { readonly result: ProjectId; readonly nextIndex: number } = ProjectId.codec.decode(accountTokenAndNextIndex.nextIndex, binary);
   return { result: { accountToken: accountTokenAndNextIndex.result, projectId: projectIdAndNextIndex.result }, nextIndex: projectIdAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * インポートした変数
  * @typePartId 8150e2833dc1f2a77715aa1bb7b2baad
  */
 export const ImportedVariable: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ImportedVariable>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ImportedVariable) => ImportedVariable } = { typePartId: "8150e2833dc1f2a77715aa1bb7b2baad" as TypePartId, helper: (importedVariable: ImportedVariable): ImportedVariable => importedVariable, codec: { encode: (value: ImportedVariable): ReadonlyArray<number> => (String.codec.encode(value.moduleName).concat(TsIdentifer.codec.encode(value.name))), decode: (index: number, binary: Uint8Array): { readonly result: ImportedVariable; readonly nextIndex: number } => {
   const moduleNameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const nameAndNextIndex: { readonly result: TsIdentifer; readonly nextIndex: number } = TsIdentifer.codec.decode(moduleNameAndNextIndex.nextIndex, binary);
   return { result: { moduleName: moduleNameAndNextIndex.result, name: nameAndNextIndex.result }, nextIndex: nameAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * "ソーシャルログインを提供するプロバイダー (例: Google, GitHub)
  *
  * GitHub いらないかも (GitHubのアカウント作成するの分かりづらいので, 選択肢を減らしたい)
  * @typePartId 84597034eb252267ce1a599ab7a0b543
  */
 export const OpenIdConnectProvider: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<OpenIdConnectProvider>; 
 /**
  * Google ( https://developers.google.com/identity/sign-in/web/ )
  */
 readonly Google: OpenIdConnectProvider; 
 /**
  * GitHub ( https://developer.github.com/v3/guides/basics-of-authentication/ )
  */
 readonly GitHub: OpenIdConnectProvider } = { Google: "Google", GitHub: "GitHub", typePartId: "84597034eb252267ce1a599ab7a0b543" as TypePartId, codec: { encode: (value: OpenIdConnectProvider): ReadonlyArray<number> => {
   switch (value) {
     case "Google": {
       return [0];
     }
     case "GitHub": {
       return [1];
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: OpenIdConnectProvider; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     return { result: OpenIdConnectProvider.Google, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: OpenIdConnectProvider.GitHub, nextIndex: patternIndex.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * 型パーツ
  * @typePartId 87fc411d10f6986dd33e5dbaff6d06ae
  */
 export const TypePart: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<TypePart>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: TypePart) => TypePart } = { typePartId: "87fc411d10f6986dd33e5dbaff6d06ae" as TypePartId, helper: (typePart: TypePart): TypePart => typePart, codec: { encode: (value: TypePart): ReadonlyArray<number> => (String.codec.encode(value.name).concat(String.codec.encode(value.description)).concat(ProjectId.codec.encode(value.projectId)).concat(Maybe.codec(TypeAttribute.codec).encode(value.attribute)).concat(List.codec(TypeParameter.codec).encode(value.typeParameterList)).concat(TypePartBody.codec.encode(value.body))), decode: (index: number, binary: Uint8Array): { readonly result: TypePart; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const descriptionAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
   const projectIdAndNextIndex: { readonly result: ProjectId; readonly nextIndex: number } = ProjectId.codec.decode(descriptionAndNextIndex.nextIndex, binary);
   const attributeAndNextIndex: { readonly result: Maybe<TypeAttribute>; readonly nextIndex: number } = Maybe.codec(TypeAttribute.codec).decode(projectIdAndNextIndex.nextIndex, binary);
   const typeParameterListAndNextIndex: { readonly result: List<TypeParameter>; readonly nextIndex: number } = List.codec(TypeParameter.codec).decode(attributeAndNextIndex.nextIndex, binary);
   const bodyAndNextIndex: { readonly result: TypePartBody; readonly nextIndex: number } = TypePartBody.codec.decode(typeParameterListAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, description: descriptionAndNextIndex.result, projectId: projectIdAndNextIndex.result, attribute: attributeAndNextIndex.result, typeParameterList: typeParameterListAndNextIndex.result, body: bodyAndNextIndex.result }, nextIndex: bodyAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 質問を作るページのパラメータ
  * @typePartId 8960809c7ca4954e9235c197f5d63cdf
  */
 export const QNewQuestionParameter: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QNewQuestionParameter>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: QNewQuestionParameter) => QNewQuestionParameter } = { typePartId: "8960809c7ca4954e9235c197f5d63cdf" as TypePartId, helper: (qNewQuestionParameter: QNewQuestionParameter): QNewQuestionParameter => qNewQuestionParameter, codec: { encode: (value: QNewQuestionParameter): ReadonlyArray<number> => (QProgramId.codec.encode(value.programId).concat(Maybe.codec(QQuestionId.codec).encode(value.parent)).concat(String.codec.encode(value.text))), decode: (index: number, binary: Uint8Array): { readonly result: QNewQuestionParameter; readonly nextIndex: number } => {
   const programIdAndNextIndex: { readonly result: QProgramId; readonly nextIndex: number } = QProgramId.codec.decode(index, binary);
   const parentAndNextIndex: { readonly result: Maybe<QQuestionId>; readonly nextIndex: number } = Maybe.codec(QQuestionId.codec).decode(programIdAndNextIndex.nextIndex, binary);
   const textAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(parentAndNextIndex.nextIndex, binary);
   return { result: { programId: programIdAndNextIndex.result, parent: parentAndNextIndex.result, text: textAndNextIndex.result }, nextIndex: textAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * JavaScript の 式
  * @typePartId 8b0bdbeae05df3badac2ee69bf22011f
  */
 export const TsExpr: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<TsExpr>; 
 /**
  * 数値リテラル `123`
  */
 readonly NumberLiteral: (a: Int32) => TsExpr; 
 /**
  * 文字列リテラル `"text"`
  */
 readonly StringLiteral: (a: String) => TsExpr; 
 /**
  * booleanリテラル
  */
 readonly BooleanLiteral: (a: Bool) => TsExpr; 
 /**
  * `null`
  */
 readonly NullLiteral: TsExpr; 
 /**
  * `undefined`
  */
 readonly UndefinedLiteral: TsExpr; 
 /**
  * 単項演算子での式
  */
 readonly UnaryOperator: (a: UnaryOperatorExpr) => TsExpr; 
 /**
  * 2項演算子での式
  */
 readonly BinaryOperator: (a: BinaryOperatorExpr) => TsExpr; 
 /**
  * 条件演算子 `a ? b : c`
  */
 readonly ConditionalOperator: (a: ConditionalOperatorExpr) => TsExpr; 
 /**
  * 配列リテラル `[1, 2, 3]`
  */
 readonly ArrayLiteral: (a: List<ArrayItem>) => TsExpr; 
 /**
  * オブジェクトリテラル `{ data: 123, text: "sorena" }`
  */
 readonly ObjectLiteral: (a: List<TsMember>) => TsExpr; 
 /**
  * ラムダ式 `() => {}`
  */
 readonly Lambda: (a: LambdaExpr) => TsExpr; 
 /**
  * 変数. 変数が存在するかのチャックがされる
  */
 readonly Variable: (a: TsIdentifer) => TsExpr; 
 /**
  * グローバルオブジェクト
  */
 readonly GlobalObjects: (a: TsIdentifer) => TsExpr; 
 /**
  * インポートされた変数
  */
 readonly ImportedVariable: (a: ImportedVariable) => TsExpr; 
 /**
  * プロパティの値を取得する `a.b a[12] data[f(2)]`
  */
 readonly Get: (a: GetExpr) => TsExpr; 
 /**
  * 関数を呼ぶ f(x)",
  */
 readonly Call: (a: CallExpr) => TsExpr; 
 /**
  * 式からインスタンスを作成する `new Date()`
  */
 readonly New: (a: CallExpr) => TsExpr; 
 /**
  * 型アサーション `a as string`
  */
 readonly TypeAssertion: (a: TypeAssertion) => TsExpr } = { NumberLiteral: (int32: Int32): TsExpr => ({ _: "NumberLiteral", int32 }), StringLiteral: (string_: String): TsExpr => ({ _: "StringLiteral", string: string_ }), BooleanLiteral: (bool: Bool): TsExpr => ({ _: "BooleanLiteral", bool }), NullLiteral: { _: "NullLiteral" }, UndefinedLiteral: { _: "UndefinedLiteral" }, UnaryOperator: (unaryOperatorExpr: UnaryOperatorExpr): TsExpr => ({ _: "UnaryOperator", unaryOperatorExpr }), BinaryOperator: (binaryOperatorExpr: BinaryOperatorExpr): TsExpr => ({ _: "BinaryOperator", binaryOperatorExpr }), ConditionalOperator: (conditionalOperatorExpr: ConditionalOperatorExpr): TsExpr => ({ _: "ConditionalOperator", conditionalOperatorExpr }), ArrayLiteral: (arrayItemList: List<ArrayItem>): TsExpr => ({ _: "ArrayLiteral", arrayItemList }), ObjectLiteral: (tsMemberList: List<TsMember>): TsExpr => ({ _: "ObjectLiteral", tsMemberList }), Lambda: (lambdaExpr: LambdaExpr): TsExpr => ({ _: "Lambda", lambdaExpr }), Variable: (tsIdentifer: TsIdentifer): TsExpr => ({ _: "Variable", tsIdentifer }), GlobalObjects: (tsIdentifer: TsIdentifer): TsExpr => ({ _: "GlobalObjects", tsIdentifer }), ImportedVariable: (importedVariable: ImportedVariable): TsExpr => ({ _: "ImportedVariable", importedVariable }), Get: (getExpr: GetExpr): TsExpr => ({ _: "Get", getExpr }), Call: (callExpr: CallExpr): TsExpr => ({ _: "Call", callExpr }), New: (callExpr: CallExpr): TsExpr => ({ _: "New", callExpr }), TypeAssertion: (typeAssertion: TypeAssertion): TsExpr => ({ _: "TypeAssertion", typeAssertion }), typePartId: "8b0bdbeae05df3badac2ee69bf22011f" as TypePartId, codec: { encode: (value: TsExpr): ReadonlyArray<number> => {
   switch (value._) {
     case "NumberLiteral": {
       return [0].concat(Int32.codec.encode(value.int32));
     }
     case "StringLiteral": {
       return [1].concat(String.codec.encode(value.string));
     }
     case "BooleanLiteral": {
       return [2].concat(Bool.codec.encode(value.bool));
     }
     case "NullLiteral": {
       return [3];
     }
     case "UndefinedLiteral": {
       return [4];
     }
     case "UnaryOperator": {
       return [5].concat(UnaryOperatorExpr.codec.encode(value.unaryOperatorExpr));
     }
     case "BinaryOperator": {
       return [6].concat(BinaryOperatorExpr.codec.encode(value.binaryOperatorExpr));
     }
     case "ConditionalOperator": {
       return [7].concat(ConditionalOperatorExpr.codec.encode(value.conditionalOperatorExpr));
     }
     case "ArrayLiteral": {
       return [8].concat(List.codec(ArrayItem.codec).encode(value.arrayItemList));
     }
     case "ObjectLiteral": {
       return [9].concat(List.codec(TsMember.codec).encode(value.tsMemberList));
     }
     case "Lambda": {
       return [10].concat(LambdaExpr.codec.encode(value.lambdaExpr));
     }
     case "Variable": {
       return [11].concat(TsIdentifer.codec.encode(value.tsIdentifer));
     }
     case "GlobalObjects": {
       return [12].concat(TsIdentifer.codec.encode(value.tsIdentifer));
     }
     case "ImportedVariable": {
       return [13].concat(ImportedVariable.codec.encode(value.importedVariable));
     }
     case "Get": {
       return [14].concat(GetExpr.codec.encode(value.getExpr));
     }
     case "Call": {
       return [15].concat(CallExpr.codec.encode(value.callExpr));
     }
     case "New": {
       return [16].concat(CallExpr.codec.encode(value.callExpr));
     }
     case "TypeAssertion": {
       return [17].concat(TypeAssertion.codec.encode(value.typeAssertion));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: TsExpr; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: Int32; readonly nextIndex: number } = Int32.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsExpr.NumberLiteral(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 1) {
     const result: { readonly result: String; readonly nextIndex: number } = String.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsExpr.StringLiteral(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 2) {
     const result: { readonly result: Bool; readonly nextIndex: number } = Bool.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsExpr.BooleanLiteral(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 3) {
     return { result: TsExpr.NullLiteral, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 4) {
     return { result: TsExpr.UndefinedLiteral, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 5) {
     const result: { readonly result: UnaryOperatorExpr; readonly nextIndex: number } = UnaryOperatorExpr.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsExpr.UnaryOperator(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 6) {
     const result: { readonly result: BinaryOperatorExpr; readonly nextIndex: number } = BinaryOperatorExpr.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsExpr.BinaryOperator(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 7) {
     const result: { readonly result: ConditionalOperatorExpr; readonly nextIndex: number } = ConditionalOperatorExpr.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsExpr.ConditionalOperator(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 8) {
     const result: { readonly result: List<ArrayItem>; readonly nextIndex: number } = List.codec(ArrayItem.codec).decode(patternIndex.nextIndex, binary);
     return { result: TsExpr.ArrayLiteral(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 9) {
     const result: { readonly result: List<TsMember>; readonly nextIndex: number } = List.codec(TsMember.codec).decode(patternIndex.nextIndex, binary);
     return { result: TsExpr.ObjectLiteral(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 10) {
     const result: { readonly result: LambdaExpr; readonly nextIndex: number } = LambdaExpr.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsExpr.Lambda(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 11) {
     const result: { readonly result: TsIdentifer; readonly nextIndex: number } = TsIdentifer.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsExpr.Variable(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 12) {
     const result: { readonly result: TsIdentifer; readonly nextIndex: number } = TsIdentifer.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsExpr.GlobalObjects(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 13) {
     const result: { readonly result: ImportedVariable; readonly nextIndex: number } = ImportedVariable.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsExpr.ImportedVariable(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 14) {
     const result: { readonly result: GetExpr; readonly nextIndex: number } = GetExpr.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsExpr.Get(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 15) {
     const result: { readonly result: CallExpr; readonly nextIndex: number } = CallExpr.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsExpr.Call(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 16) {
     const result: { readonly result: CallExpr; readonly nextIndex: number } = CallExpr.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsExpr.New(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 17) {
     const result: { readonly result: TypeAssertion; readonly nextIndex: number } = TypeAssertion.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsExpr.TypeAssertion(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * 2つの要素のタプルの型
  * @typePartId 8b479d8726bb494ac76d529fbf03908c
  */
 export const ElmTuple2: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmTuple2>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ElmTuple2) => ElmTuple2 } = { typePartId: "8b479d8726bb494ac76d529fbf03908c" as TypePartId, helper: (elmTuple2: ElmTuple2): ElmTuple2 => elmTuple2, codec: { encode: (value: ElmTuple2): ReadonlyArray<number> => (ElmType.codec.encode(value.first).concat(ElmType.codec.encode(value.second))), decode: (index: number, binary: Uint8Array): { readonly result: ElmTuple2; readonly nextIndex: number } => {
   const firstAndNextIndex: { readonly result: ElmType; readonly nextIndex: number } = ElmType.codec.decode(index, binary);
   const secondAndNextIndex: { readonly result: ElmType; readonly nextIndex: number } = ElmType.codec.decode(firstAndNextIndex.nextIndex, binary);
   return { result: { first: firstAndNextIndex.result, second: secondAndNextIndex.result }, nextIndex: secondAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * Definy の プロジェクト
  * @typePartId 8bc81fa2a15bdbd8c2414d22f3e1b462
  */
 export const Project: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Project>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: Project) => Project } = { typePartId: "8bc81fa2a15bdbd8c2414d22f3e1b462" as TypePartId, helper: (project: Project): Project => project, codec: { encode: (value: Project): ReadonlyArray<number> => (String.codec.encode(value.name).concat(ImageHash.codec.encode(value.iconHash)).concat(ImageHash.codec.encode(value.imageHash)).concat(Time.codec.encode(value.createTime)).concat(AccountId.codec.encode(value.createAccountId)).concat(Time.codec.encode(value.updateTime))), decode: (index: number, binary: Uint8Array): { readonly result: Project; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const iconHashAndNextIndex: { readonly result: ImageHash; readonly nextIndex: number } = ImageHash.codec.decode(nameAndNextIndex.nextIndex, binary);
   const imageHashAndNextIndex: { readonly result: ImageHash; readonly nextIndex: number } = ImageHash.codec.decode(iconHashAndNextIndex.nextIndex, binary);
   const createTimeAndNextIndex: { readonly result: Time; readonly nextIndex: number } = Time.codec.decode(imageHashAndNextIndex.nextIndex, binary);
   const createAccountIdAndNextIndex: { readonly result: AccountId; readonly nextIndex: number } = AccountId.codec.decode(createTimeAndNextIndex.nextIndex, binary);
   const updateTimeAndNextIndex: { readonly result: Time; readonly nextIndex: number } = Time.codec.decode(createAccountIdAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, iconHash: iconHashAndNextIndex.result, imageHash: imageHashAndNextIndex.result, createTime: createTimeAndNextIndex.result, createAccountId: createAccountIdAndNextIndex.result, updateTime: updateTimeAndNextIndex.result }, nextIndex: updateTimeAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * forOf文
  * @typePartId 8be8db4404f302dd36c8a2c6c6e37e7c
  */
 export const ForOfStatement: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ForOfStatement>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ForOfStatement) => ForOfStatement } = { typePartId: "8be8db4404f302dd36c8a2c6c6e37e7c" as TypePartId, helper: (forOfStatement: ForOfStatement): ForOfStatement => forOfStatement, codec: { encode: (value: ForOfStatement): ReadonlyArray<number> => (TsIdentifer.codec.encode(value.elementVariableName).concat(TsExpr.codec.encode(value.iterableExpr)).concat(List.codec(Statement.codec).encode(value.statementList))), decode: (index: number, binary: Uint8Array): { readonly result: ForOfStatement; readonly nextIndex: number } => {
   const elementVariableNameAndNextIndex: { readonly result: TsIdentifer; readonly nextIndex: number } = TsIdentifer.codec.decode(index, binary);
   const iterableExprAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(elementVariableNameAndNextIndex.nextIndex, binary);
   const statementListAndNextIndex: { readonly result: List<Statement>; readonly nextIndex: number } = List.codec(Statement.codec).decode(iterableExprAndNextIndex.nextIndex, binary);
   return { result: { elementVariableName: elementVariableNameAndNextIndex.result, iterableExpr: iterableExprAndNextIndex.result, statementList: statementListAndNextIndex.result }, nextIndex: statementListAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * TypeScriptやJavaScriptのコードを表現する. TypeScriptでも出力できるように型情報をつける必要がある
  * @typePartId 92ea504049ca5b7e2227a95195fe74eb
  */
 export const JsTsCode: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<JsTsCode>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: JsTsCode) => JsTsCode } = { typePartId: "92ea504049ca5b7e2227a95195fe74eb" as TypePartId, helper: (jsTsCode: JsTsCode): JsTsCode => jsTsCode, codec: { encode: (value: JsTsCode): ReadonlyArray<number> => (List.codec(ExportDefinition.codec).encode(value.exportDefinitionList).concat(List.codec(Statement.codec).encode(value.statementList))), decode: (index: number, binary: Uint8Array): { readonly result: JsTsCode; readonly nextIndex: number } => {
   const exportDefinitionListAndNextIndex: { readonly result: List<ExportDefinition>; readonly nextIndex: number } = List.codec(ExportDefinition.codec).decode(index, binary);
   const statementListAndNextIndex: { readonly result: List<Statement>; readonly nextIndex: number } = List.codec(Statement.codec).decode(exportDefinitionListAndNextIndex.nextIndex, binary);
   return { result: { exportDefinitionList: exportDefinitionListAndNextIndex.result, statementList: statementListAndNextIndex.result }, nextIndex: statementListAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 直積型のメンバー
  * @typePartId 9481ceae2c3e2765243f5c7ce7eb76c7
  */
 export const Member: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Member>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: Member) => Member } = { typePartId: "9481ceae2c3e2765243f5c7ce7eb76c7" as TypePartId, helper: (member: Member): Member => member, codec: { encode: (value: Member): ReadonlyArray<number> => (String.codec.encode(value.name).concat(String.codec.encode(value.description)).concat(Type.codec.encode(value.type))), decode: (index: number, binary: Uint8Array): { readonly result: Member; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const descriptionAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
   const typeAndNextIndex: { readonly result: Type; readonly nextIndex: number } = Type.codec.decode(descriptionAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, description: descriptionAndNextIndex.result, type: typeAndNextIndex.result }, nextIndex: typeAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * アカウントの情報
  * @typePartId 94aa0a477dfb8362d00aaac05b29b79c
  */
 export const QAccountData: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QAccountData>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: QAccountData) => QAccountData } = { typePartId: "94aa0a477dfb8362d00aaac05b29b79c" as TypePartId, helper: (qAccountData: QAccountData): QAccountData => qAccountData, codec: { encode: (value: QAccountData): ReadonlyArray<number> => (QAccount.codec.encode(value.account).concat(List.codec(QProgram.codec).encode(value.createdProgramList)).concat(List.codec(QClass.codec).encode(value.createdClassList)).concat(List.codec(Tuple2.codec(QClassStudentOrGuest.codec, QRole.codec)).encode(value.joinedClassList))), decode: (index: number, binary: Uint8Array): { readonly result: QAccountData; readonly nextIndex: number } => {
   const accountAndNextIndex: { readonly result: QAccount; readonly nextIndex: number } = QAccount.codec.decode(index, binary);
   const createdProgramListAndNextIndex: { readonly result: List<QProgram>; readonly nextIndex: number } = List.codec(QProgram.codec).decode(accountAndNextIndex.nextIndex, binary);
   const createdClassListAndNextIndex: { readonly result: List<QClass>; readonly nextIndex: number } = List.codec(QClass.codec).decode(createdProgramListAndNextIndex.nextIndex, binary);
   const joinedClassListAndNextIndex: { readonly result: List<Tuple2<QClassStudentOrGuest, QRole>>; readonly nextIndex: number } = List.codec(Tuple2.codec(QClassStudentOrGuest.codec, QRole.codec)).decode(createdClassListAndNextIndex.nextIndex, binary);
   return { result: { account: accountAndNextIndex.result, createdProgramList: createdProgramListAndNextIndex.result, createdClassList: createdClassListAndNextIndex.result, joinedClassList: joinedClassListAndNextIndex.result }, nextIndex: joinedClassListAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * Elm の 式
  * @typePartId 94e53139b3a82087777ea3e001b2adb4
  */
 export const ElmExpr: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmExpr>; 
 /**
  * 文字列リテラル
  */
 readonly StringLiteral: (a: String) => ElmExpr; 
 /**
  * 整数リテラル
  */
 readonly IntLiteral: (a: Int32) => ElmExpr; 
 /**
  * ファイル内で定義したバリアント. 値コンストラクタ. タグ.
  */
 readonly LocalVariant: ElmExpr; 
 /**
  * インポートしたバリアント. 値コンストラクタ. タグ.
  */
 readonly ImportedVariant: ElmExpr; 
 /**
  * リストリテラル
  */
 readonly List: (a: List<ElmExpr>) => ElmExpr; 
 /**
  * ????
  */
 readonly Op: ElmExpr; 
 /**
  * 単行マイナス
  */
 readonly Negate: (a: ElmExpr) => ElmExpr; 
 /**
  * ????
  */
 readonly Binops: ElmExpr; 
 /**
  * ラムダ式. 関数リテラル
  */
 readonly Lambda: ElmExpr; 
 /**
  * 関数呼び出し
  */
 readonly Call: ElmExpr; 
 /**
  * if式. else ifも含めている
  */
 readonly If: ElmExpr; 
 /**
  * let式. ローカル関数定義
  */
 readonly Let: ElmExpr; 
 /**
  * case式
  */
 readonly Case: ElmExpr; 
 /**
  * アクセサ .name メンバーを取得する関数
  */
 readonly Accessor: (a: String) => ElmExpr; 
 /**
  * user.name メンバー取得
  */
 readonly Access: ElmExpr; 
 /**
  * { user | name = "新しい名前" }
  */
 readonly Update: ElmExpr; 
 /**
  * レコード. { name = "名前", age = 20 }
  */
 readonly Record: ElmExpr; 
 /**
  * Unit. ()
  */
 readonly Unit: ElmExpr; 
 /**
  * 2つの要素のタプル. (1, "あ")
  */
 readonly Tuple2: ElmExpr; 
 /**
  * 3つの要素のタプル. (1, "い", 3)
  */
 readonly Tuple3: ElmExpr } = { StringLiteral: (string_: String): ElmExpr => ({ _: "StringLiteral", string: string_ }), IntLiteral: (int32: Int32): ElmExpr => ({ _: "IntLiteral", int32 }), LocalVariant: { _: "LocalVariant" }, ImportedVariant: { _: "ImportedVariant" }, List: (elmExprList: List<ElmExpr>): ElmExpr => ({ _: "List", elmExprList }), Op: { _: "Op" }, Negate: (elmExpr: ElmExpr): ElmExpr => ({ _: "Negate", elmExpr }), Binops: { _: "Binops" }, Lambda: { _: "Lambda" }, Call: { _: "Call" }, If: { _: "If" }, Let: { _: "Let" }, Case: { _: "Case" }, Accessor: (string_: String): ElmExpr => ({ _: "Accessor", string: string_ }), Access: { _: "Access" }, Update: { _: "Update" }, Record: { _: "Record" }, Unit: { _: "Unit" }, Tuple2: { _: "Tuple2" }, Tuple3: { _: "Tuple3" }, typePartId: "94e53139b3a82087777ea3e001b2adb4" as TypePartId, codec: { encode: (value: ElmExpr): ReadonlyArray<number> => {
   switch (value._) {
     case "StringLiteral": {
       return [0].concat(String.codec.encode(value.string));
     }
     case "IntLiteral": {
       return [1].concat(Int32.codec.encode(value.int32));
     }
     case "LocalVariant": {
       return [2];
     }
     case "ImportedVariant": {
       return [3];
     }
     case "List": {
       return [4].concat(List.codec(ElmExpr.codec).encode(value.elmExprList));
     }
     case "Op": {
       return [5];
     }
     case "Negate": {
       return [6].concat(ElmExpr.codec.encode(value.elmExpr));
     }
     case "Binops": {
       return [7];
     }
     case "Lambda": {
       return [8];
     }
     case "Call": {
       return [9];
     }
     case "If": {
       return [10];
     }
     case "Let": {
       return [11];
     }
     case "Case": {
       return [12];
     }
     case "Accessor": {
       return [13].concat(String.codec.encode(value.string));
     }
     case "Access": {
       return [14];
     }
     case "Update": {
       return [15];
     }
     case "Record": {
       return [16];
     }
     case "Unit": {
       return [17];
     }
     case "Tuple2": {
       return [18];
     }
     case "Tuple3": {
       return [19];
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: ElmExpr; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: String; readonly nextIndex: number } = String.codec.decode(patternIndex.nextIndex, binary);
     return { result: ElmExpr.StringLiteral(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 1) {
     const result: { readonly result: Int32; readonly nextIndex: number } = Int32.codec.decode(patternIndex.nextIndex, binary);
     return { result: ElmExpr.IntLiteral(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 2) {
     return { result: ElmExpr.LocalVariant, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 3) {
     return { result: ElmExpr.ImportedVariant, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 4) {
     const result: { readonly result: List<ElmExpr>; readonly nextIndex: number } = List.codec(ElmExpr.codec).decode(patternIndex.nextIndex, binary);
     return { result: ElmExpr.List(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 5) {
     return { result: ElmExpr.Op, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 6) {
     const result: { readonly result: ElmExpr; readonly nextIndex: number } = ElmExpr.codec.decode(patternIndex.nextIndex, binary);
     return { result: ElmExpr.Negate(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 7) {
     return { result: ElmExpr.Binops, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 8) {
     return { result: ElmExpr.Lambda, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 9) {
     return { result: ElmExpr.Call, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 10) {
     return { result: ElmExpr.If, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 11) {
     return { result: ElmExpr.Let, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 12) {
     return { result: ElmExpr.Case, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 13) {
     const result: { readonly result: String; readonly nextIndex: number } = String.codec.decode(patternIndex.nextIndex, binary);
     return { result: ElmExpr.Accessor(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 14) {
     return { result: ElmExpr.Access, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 15) {
     return { result: ElmExpr.Update, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 16) {
     return { result: ElmExpr.Record, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 17) {
     return { result: ElmExpr.Unit, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 18) {
     return { result: ElmExpr.Tuple2, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 19) {
     return { result: ElmExpr.Tuple3, nextIndex: patternIndex.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * 関数の型
  * @typePartId 98904215e50e04fa2197a7a96df8f646
  */
 export const FunctionType: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<FunctionType>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: FunctionType) => FunctionType } = { typePartId: "98904215e50e04fa2197a7a96df8f646" as TypePartId, helper: (functionType: FunctionType): FunctionType => functionType, codec: { encode: (value: FunctionType): ReadonlyArray<number> => (List.codec(TsIdentifer.codec).encode(value.typeParameterList).concat(List.codec(TsType.codec).encode(value.parameterList)).concat(TsType.codec.encode(value.return))), decode: (index: number, binary: Uint8Array): { readonly result: FunctionType; readonly nextIndex: number } => {
   const typeParameterListAndNextIndex: { readonly result: List<TsIdentifer>; readonly nextIndex: number } = List.codec(TsIdentifer.codec).decode(index, binary);
   const parameterListAndNextIndex: { readonly result: List<TsType>; readonly nextIndex: number } = List.codec(TsType.codec).decode(typeParameterListAndNextIndex.nextIndex, binary);
   const returnAndNextIndex: { readonly result: TsType; readonly nextIndex: number } = TsType.codec.decode(parameterListAndNextIndex.nextIndex, binary);
   return { result: { typeParameterList: typeParameterListAndNextIndex.result, parameterList: parameterListAndNextIndex.result, return: returnAndNextIndex.result }, nextIndex: returnAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 質問を編集する
  * @typePartId 98bc46a897ffdb9d86782890776c9221
  */
 export const QEditQuestion: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QEditQuestion>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: QEditQuestion) => QEditQuestion } = { typePartId: "98bc46a897ffdb9d86782890776c9221" as TypePartId, helper: (qEditQuestion: QEditQuestion): QEditQuestion => qEditQuestion, codec: { encode: (value: QEditQuestion): ReadonlyArray<number> => (AccountToken.codec.encode(value.accountToken).concat(QQuestionId.codec.encode(value.questionId)).concat(String.codec.encode(value.name)).concat(Maybe.codec(QQuestionId.codec).encode(value.parentId))), decode: (index: number, binary: Uint8Array): { readonly result: QEditQuestion; readonly nextIndex: number } => {
   const accountTokenAndNextIndex: { readonly result: AccountToken; readonly nextIndex: number } = AccountToken.codec.decode(index, binary);
   const questionIdAndNextIndex: { readonly result: QQuestionId; readonly nextIndex: number } = QQuestionId.codec.decode(accountTokenAndNextIndex.nextIndex, binary);
   const nameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(questionIdAndNextIndex.nextIndex, binary);
   const parentIdAndNextIndex: { readonly result: Maybe<QQuestionId>; readonly nextIndex: number } = Maybe.codec(QQuestionId.codec).decode(nameAndNextIndex.nextIndex, binary);
   return { result: { accountToken: accountTokenAndNextIndex.result, questionId: questionIdAndNextIndex.result, name: nameAndNextIndex.result, parentId: parentIdAndNextIndex.result }, nextIndex: parentIdAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 2つの値を持つ型
  * @typePartId 9b55e2a5ed07246355fbeba998eaf5fe
  */
 export const Tuple2: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: <first extends unknown, second extends unknown>(a: Codec<first>, b: Codec<second>) => Codec<Tuple2<first, second>>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: <first extends unknown, second extends unknown>(a: Tuple2<first, second>) => Tuple2<first, second> } = { typePartId: "9b55e2a5ed07246355fbeba998eaf5fe" as TypePartId, helper: <first extends unknown, second extends unknown>(tuple2: Tuple2<first, second>): Tuple2<first, second> => tuple2, codec: <first extends unknown, second extends unknown>(firstCodec: Codec<first>, secondCodec: Codec<second>): Codec<Tuple2<first, second>> => ({ encode: (value: Tuple2<first, second>): ReadonlyArray<number> => (firstCodec.encode(value.first).concat(secondCodec.encode(value.second))), decode: (index: number, binary: Uint8Array): { readonly result: Tuple2<first, second>; readonly nextIndex: number } => {
   const firstAndNextIndex: { readonly result: first; readonly nextIndex: number } = firstCodec.decode(index, binary);
   const secondAndNextIndex: { readonly result: second; readonly nextIndex: number } = secondCodec.decode(firstAndNextIndex.nextIndex, binary);
   return { result: { first: firstAndNextIndex.result, second: secondAndNextIndex.result }, nextIndex: secondAndNextIndex.nextIndex };
 } }) };
 
 
 /**
  * カスタム型. 代数的データ型
  * @typePartId a0cee28e982f5fbcae6b2c7bd1e27e2a
  */
 export const ElmCustomType: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmCustomType>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ElmCustomType) => ElmCustomType } = { typePartId: "a0cee28e982f5fbcae6b2c7bd1e27e2a" as TypePartId, helper: (elmCustomType: ElmCustomType): ElmCustomType => elmCustomType, codec: { encode: (value: ElmCustomType): ReadonlyArray<number> => (ElmTypeName.codec.encode(value.name).concat(ElmCustomTypeExportLevel.codec.encode(value.export)).concat(String.codec.encode(value.comment)).concat(List.codec(String.codec).encode(value.parameter)).concat(List.codec(ElmVariant.codec).encode(value.variantList))), decode: (index: number, binary: Uint8Array): { readonly result: ElmCustomType; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: ElmTypeName; readonly nextIndex: number } = ElmTypeName.codec.decode(index, binary);
   const exportAndNextIndex: { readonly result: ElmCustomTypeExportLevel; readonly nextIndex: number } = ElmCustomTypeExportLevel.codec.decode(nameAndNextIndex.nextIndex, binary);
   const commentAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(exportAndNextIndex.nextIndex, binary);
   const parameterAndNextIndex: { readonly result: List<String>; readonly nextIndex: number } = List.codec(String.codec).decode(commentAndNextIndex.nextIndex, binary);
   const variantListAndNextIndex: { readonly result: List<ElmVariant>; readonly nextIndex: number } = List.codec(ElmVariant.codec).decode(parameterAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, export: exportAndNextIndex.result, comment: commentAndNextIndex.result, parameter: parameterAndNextIndex.result, variantList: variantListAndNextIndex.result }, nextIndex: variantListAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 式と呼ぶパラメーター
  * @typePartId a1f71188b7c3ab2a21954471f3ac67f1
  */
 export const CallExpr: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<CallExpr>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: CallExpr) => CallExpr } = { typePartId: "a1f71188b7c3ab2a21954471f3ac67f1" as TypePartId, helper: (callExpr: CallExpr): CallExpr => callExpr, codec: { encode: (value: CallExpr): ReadonlyArray<number> => (TsExpr.codec.encode(value.expr).concat(List.codec(TsExpr.codec).encode(value.parameterList))), decode: (index: number, binary: Uint8Array): { readonly result: CallExpr; readonly nextIndex: number } => {
   const exprAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(index, binary);
   const parameterListAndNextIndex: { readonly result: List<TsExpr>; readonly nextIndex: number } = List.codec(TsExpr.codec).decode(exprAndNextIndex.nextIndex, binary);
   return { result: { expr: exprAndNextIndex.result, parameterList: parameterListAndNextIndex.result }, nextIndex: parameterListAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * @typePartId a2580a29c047f54d635c4456696bbef3
  */
 export const Variable: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Variable>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: Variable) => Variable } = { typePartId: "a2580a29c047f54d635c4456696bbef3" as TypePartId, helper: (variable: Variable): Variable => variable, codec: { encode: (value: Variable): ReadonlyArray<number> => (TsIdentifer.codec.encode(value.name).concat(String.codec.encode(value.document)).concat(TsType.codec.encode(value.type)).concat(TsExpr.codec.encode(value.expr))), decode: (index: number, binary: Uint8Array): { readonly result: Variable; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: TsIdentifer; readonly nextIndex: number } = TsIdentifer.codec.decode(index, binary);
   const documentAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
   const typeAndNextIndex: { readonly result: TsType; readonly nextIndex: number } = TsType.codec.decode(documentAndNextIndex.nextIndex, binary);
   const exprAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(typeAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, document: documentAndNextIndex.result, type: typeAndNextIndex.result, expr: exprAndNextIndex.result }, nextIndex: exprAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * データを識別するIdとデータ
  * @typePartId a541cb9bb64930be40dc83bf8870f36b
  */
 export const IdAndData: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: <id extends unknown, data extends unknown>(a: Codec<id>, b: Codec<data>) => Codec<IdAndData<id, data>>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: <id extends unknown, data extends unknown>(a: IdAndData<id, data>) => IdAndData<id, data> } = { typePartId: "a541cb9bb64930be40dc83bf8870f36b" as TypePartId, helper: <id extends unknown, data extends unknown>(idAndData: IdAndData<id, data>): IdAndData<id, data> => idAndData, codec: <id extends unknown, data extends unknown>(idCodec: Codec<id>, dataCodec: Codec<data>): Codec<IdAndData<id, data>> => ({ encode: (value: IdAndData<id, data>): ReadonlyArray<number> => (idCodec.encode(value.id).concat(dataCodec.encode(value.data))), decode: (index: number, binary: Uint8Array): { readonly result: IdAndData<id, data>; readonly nextIndex: number } => {
   const idAndNextIndex: { readonly result: id; readonly nextIndex: number } = idCodec.decode(index, binary);
   const dataAndNextIndex: { readonly result: data; readonly nextIndex: number } = dataCodec.decode(idAndNextIndex.nextIndex, binary);
   return { result: { id: idAndNextIndex.result, data: dataAndNextIndex.result }, nextIndex: dataAndNextIndex.nextIndex };
 } }) };
 
 
 /**
  * questのクラス招待トークン
  * @typePartId a5f14e3ce94846347dc38bc1fb29ba7f
  */
 export const QClassInvitationToken: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QClassInvitationToken> } = { typePartId: "a5f14e3ce94846347dc38bc1fb29ba7f" as TypePartId, codec: { encode: (value: QClassInvitationToken): ReadonlyArray<number> => (encodeToken(value)), decode: (index: number, binary: Uint8Array): { readonly result: QClassInvitationToken; readonly nextIndex: number } => (decodeToken(index, binary) as { readonly result: QClassInvitationToken; readonly nextIndex: number }) } };
 
 
 /**
  * quest で プログラムを作るときに必要になるパラメータ
  * @typePartId a86e36ceeff2a4fefb8d9147c232dbb6
  */
 export const QCreateProgramParameter: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QCreateProgramParameter>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: QCreateProgramParameter) => QCreateProgramParameter } = { typePartId: "a86e36ceeff2a4fefb8d9147c232dbb6" as TypePartId, helper: (qCreateProgramParameter: QCreateProgramParameter): QCreateProgramParameter => qCreateProgramParameter, codec: { encode: (value: QCreateProgramParameter): ReadonlyArray<number> => (String.codec.encode(value.programName).concat(AccountToken.codec.encode(value.accountToken))), decode: (index: number, binary: Uint8Array): { readonly result: QCreateProgramParameter; readonly nextIndex: number } => {
   const programNameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const accountTokenAndNextIndex: { readonly result: AccountToken; readonly nextIndex: number } = AccountToken.codec.decode(programNameAndNextIndex.nextIndex, binary);
   return { result: { programName: programNameAndNextIndex.result, accountToken: accountTokenAndNextIndex.result }, nextIndex: accountTokenAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 複数の引数が必要な内部関数の部分呼び出し
  * @typePartId a8c830bd6b3473f2fac7a62ede58ecf0
  */
 export const KernelCall: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<KernelCall>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: KernelCall) => KernelCall } = { typePartId: "a8c830bd6b3473f2fac7a62ede58ecf0" as TypePartId, helper: (kernelCall: KernelCall): KernelCall => kernelCall, codec: { encode: (value: KernelCall): ReadonlyArray<number> => (KernelExpr.codec.encode(value.kernel).concat(EvaluatedExpr.codec.encode(value.expr))), decode: (index: number, binary: Uint8Array): { readonly result: KernelCall; readonly nextIndex: number } => {
   const kernelAndNextIndex: { readonly result: KernelExpr; readonly nextIndex: number } = KernelExpr.codec.decode(index, binary);
   const exprAndNextIndex: { readonly result: EvaluatedExpr; readonly nextIndex: number } = EvaluatedExpr.codec.decode(kernelAndNextIndex.nextIndex, binary);
   return { result: { kernel: kernelAndNextIndex.result, expr: exprAndNextIndex.result }, nextIndex: exprAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * プロパティアクセス
  * @typePartId a9ce526a22f09800aa3773a1614cce89
  */
 export const GetExpr: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<GetExpr>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: GetExpr) => GetExpr } = { typePartId: "a9ce526a22f09800aa3773a1614cce89" as TypePartId, helper: (getExpr: GetExpr): GetExpr => getExpr, codec: { encode: (value: GetExpr): ReadonlyArray<number> => (TsExpr.codec.encode(value.expr).concat(TsExpr.codec.encode(value.propertyExpr))), decode: (index: number, binary: Uint8Array): { readonly result: GetExpr; readonly nextIndex: number } => {
   const exprAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(index, binary);
   const propertyExprAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(exprAndNextIndex.nextIndex, binary);
   return { result: { expr: exprAndNextIndex.result, propertyExpr: propertyExprAndNextIndex.result }, nextIndex: propertyExprAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 質問を作成するときのパラメータ
  * @typePartId aa65c956d46bd985c325c3567ad65abb
  */
 export const QCreateQuestionParamter: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QCreateQuestionParamter>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: QCreateQuestionParamter) => QCreateQuestionParamter } = { typePartId: "aa65c956d46bd985c325c3567ad65abb" as TypePartId, helper: (qCreateQuestionParamter: QCreateQuestionParamter): QCreateQuestionParamter => qCreateQuestionParamter, codec: { encode: (value: QCreateQuestionParamter): ReadonlyArray<number> => (AccountToken.codec.encode(value.accountToken).concat(QProgramId.codec.encode(value.programId)).concat(Maybe.codec(QQuestionId.codec).encode(value.parent)).concat(String.codec.encode(value.questionText))), decode: (index: number, binary: Uint8Array): { readonly result: QCreateQuestionParamter; readonly nextIndex: number } => {
   const accountTokenAndNextIndex: { readonly result: AccountToken; readonly nextIndex: number } = AccountToken.codec.decode(index, binary);
   const programIdAndNextIndex: { readonly result: QProgramId; readonly nextIndex: number } = QProgramId.codec.decode(accountTokenAndNextIndex.nextIndex, binary);
   const parentAndNextIndex: { readonly result: Maybe<QQuestionId>; readonly nextIndex: number } = Maybe.codec(QQuestionId.codec).decode(programIdAndNextIndex.nextIndex, binary);
   const questionTextAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(parentAndNextIndex.nextIndex, binary);
   return { result: { accountToken: accountTokenAndNextIndex.result, programId: programIdAndNextIndex.result, parent: parentAndNextIndex.result, questionText: questionTextAndNextIndex.result }, nextIndex: questionTextAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 質問
  * @typePartId ab9150e30802a0e39f7fdca3703da3ab
  */
 export const QQuestion: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QQuestion>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: QQuestion) => QQuestion } = { typePartId: "ab9150e30802a0e39f7fdca3703da3ab" as TypePartId, helper: (qQuestion: QQuestion): QQuestion => qQuestion, codec: { encode: (value: QQuestion): ReadonlyArray<number> => (String.codec.encode(value.name).concat(Maybe.codec(QQuestionId.codec).encode(value.parent)).concat(QProgramId.codec.encode(value.programId)).concat(QQuestionId.codec.encode(value.id))), decode: (index: number, binary: Uint8Array): { readonly result: QQuestion; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const parentAndNextIndex: { readonly result: Maybe<QQuestionId>; readonly nextIndex: number } = Maybe.codec(QQuestionId.codec).decode(nameAndNextIndex.nextIndex, binary);
   const programIdAndNextIndex: { readonly result: QProgramId; readonly nextIndex: number } = QProgramId.codec.decode(parentAndNextIndex.nextIndex, binary);
   const idAndNextIndex: { readonly result: QQuestionId; readonly nextIndex: number } = QQuestionId.codec.decode(programIdAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, parent: parentAndNextIndex.result, programId: programIdAndNextIndex.result, id: idAndNextIndex.result }, nextIndex: idAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * Definy の 型. 式に対してつけるし, つく. 型パーツの定義にも使う
  * @typePartId b3b36f39469d23321ed01b92f048ccc0
  */
 export const Type: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Type>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: Type) => Type } = { typePartId: "b3b36f39469d23321ed01b92f048ccc0" as TypePartId, helper: (type_: Type): Type => type_, codec: { encode: (value: Type): ReadonlyArray<number> => (TypePartId.codec.encode(value.typePartId).concat(List.codec(Type.codec).encode(value.parameter))), decode: (index: number, binary: Uint8Array): { readonly result: Type; readonly nextIndex: number } => {
   const typePartIdAndNextIndex: { readonly result: TypePartId; readonly nextIndex: number } = TypePartId.codec.decode(index, binary);
   const parameterAndNextIndex: { readonly result: List<Type>; readonly nextIndex: number } = List.codec(Type.codec).decode(typePartIdAndNextIndex.nextIndex, binary);
   return { result: { typePartId: typePartIdAndNextIndex.result, parameter: parameterAndNextIndex.result }, nextIndex: parameterAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * インポートされた型
  * @typePartId b44289bc65640d4ad0ad79a5a627ef78
  */
 export const ImportedType: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ImportedType>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ImportedType) => ImportedType } = { typePartId: "b44289bc65640d4ad0ad79a5a627ef78" as TypePartId, helper: (importedType: ImportedType): ImportedType => importedType, codec: { encode: (value: ImportedType): ReadonlyArray<number> => (String.codec.encode(value.moduleName).concat(TsIdentifer.codec.encode(value.name))), decode: (index: number, binary: Uint8Array): { readonly result: ImportedType; readonly nextIndex: number } => {
   const moduleNameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const nameAndNextIndex: { readonly result: TsIdentifer; readonly nextIndex: number } = TsIdentifer.codec.decode(moduleNameAndNextIndex.nextIndex, binary);
   return { result: { moduleName: moduleNameAndNextIndex.result, name: nameAndNextIndex.result }, nextIndex: nameAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * アカウントトークンのハッシュ値. データベースに保存する用
  * @typePartId b553ab17ca45f4975d9fe17fe1a63ac4
  */
 export const AccountTokenHash: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<AccountTokenHash> } = { typePartId: "b553ab17ca45f4975d9fe17fe1a63ac4" as TypePartId, codec: { encode: (value: AccountTokenHash): ReadonlyArray<number> => (encodeToken(value)), decode: (index: number, binary: Uint8Array): { readonly result: AccountTokenHash; readonly nextIndex: number } => (decodeToken(index, binary) as { readonly result: AccountTokenHash; readonly nextIndex: number }) } };
 
 
 /**
  * Definyだけでは表現できない式
  * @typePartId b6eef263a982482747a8ad0bc9f05e21
  */
 export const KernelExpr: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<KernelExpr>; 
 /**
  * 32bit整数を足す関数
  */
 readonly Int32Add: KernelExpr; 
 /**
  * 32bit整数を引く関数
  */
 readonly Int32Sub: KernelExpr; 
 /**
  * 32bit整数をかける関数
  */
 readonly Int32Mul: KernelExpr } = { Int32Add: "Int32Add", Int32Sub: "Int32Sub", Int32Mul: "Int32Mul", typePartId: "b6eef263a982482747a8ad0bc9f05e21" as TypePartId, codec: { encode: (value: KernelExpr): ReadonlyArray<number> => {
   switch (value) {
     case "Int32Add": {
       return [0];
     }
     case "Int32Sub": {
       return [1];
     }
     case "Int32Mul": {
       return [2];
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: KernelExpr; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     return { result: KernelExpr.Int32Add, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: KernelExpr.Int32Sub, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 2) {
     return { result: KernelExpr.Int32Mul, nextIndex: patternIndex.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * 型パーツのリストを保存, 変更する
  * @typePartId b8bf6c22e275c06c7dc42300c332b47d
  */
 export const SetTypePartListParameter: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<SetTypePartListParameter>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: SetTypePartListParameter) => SetTypePartListParameter } = { typePartId: "b8bf6c22e275c06c7dc42300c332b47d" as TypePartId, helper: (setTypePartListParameter: SetTypePartListParameter): SetTypePartListParameter => setTypePartListParameter, codec: { encode: (value: SetTypePartListParameter): ReadonlyArray<number> => (AccountToken.codec.encode(value.accountToken).concat(ProjectId.codec.encode(value.projectId)).concat(List.codec(IdAndData.codec(TypePartId.codec, TypePart.codec)).encode(value.typePartList))), decode: (index: number, binary: Uint8Array): { readonly result: SetTypePartListParameter; readonly nextIndex: number } => {
   const accountTokenAndNextIndex: { readonly result: AccountToken; readonly nextIndex: number } = AccountToken.codec.decode(index, binary);
   const projectIdAndNextIndex: { readonly result: ProjectId; readonly nextIndex: number } = ProjectId.codec.decode(accountTokenAndNextIndex.nextIndex, binary);
   const typePartListAndNextIndex: { readonly result: List<IdAndData<TypePartId, TypePart>>; readonly nextIndex: number } = List.codec(IdAndData.codec(TypePartId.codec, TypePart.codec)).decode(projectIdAndNextIndex.nextIndex, binary);
   return { result: { accountToken: accountTokenAndNextIndex.result, projectId: projectIdAndNextIndex.result, typePartList: typePartListAndNextIndex.result }, nextIndex: typePartListAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * DefinyWebアプリ内での場所を示すもの. URLから求められる. URLに変換できる
  * @typePartId bbcb8e43df8afff9fe24b001c66fb065
  */
 export const Location: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Location>; 
 /**
  * 最初のページ
  */
 readonly Home: Location; 
 /**
  * プロジェクト作成画面
  */
 readonly CreateProject: Location; 
 /**
  * プロジェクトの詳細ページ
  */
 readonly Project: (a: ProjectId) => Location; 
 /**
  * アカウント詳細ページ
  */
 readonly Account: (a: AccountId) => Location; 
 /**
  * 設定ページ
  */
 readonly Setting: Location; 
 /**
  * Definyについて説明したページ
  */
 readonly About: Location; 
 /**
  * 型パーツ編集ページ
  */
 readonly TypePart: (a: TypePartId) => Location; 
 /**
  * パーツ編集ページ
  */
 readonly Part: (a: PartId) => Location } = { Home: { _: "Home" }, CreateProject: { _: "CreateProject" }, Project: (projectId: ProjectId): Location => ({ _: "Project", projectId }), Account: (accountId: AccountId): Location => ({ _: "Account", accountId }), Setting: { _: "Setting" }, About: { _: "About" }, TypePart: (typePartId: TypePartId): Location => ({ _: "TypePart", typePartId }), Part: (partId: PartId): Location => ({ _: "Part", partId }), typePartId: "bbcb8e43df8afff9fe24b001c66fb065" as TypePartId, codec: { encode: (value: Location): ReadonlyArray<number> => {
   switch (value._) {
     case "Home": {
       return [0];
     }
     case "CreateProject": {
       return [1];
     }
     case "Project": {
       return [2].concat(ProjectId.codec.encode(value.projectId));
     }
     case "Account": {
       return [3].concat(AccountId.codec.encode(value.accountId));
     }
     case "Setting": {
       return [4];
     }
     case "About": {
       return [5];
     }
     case "TypePart": {
       return [6].concat(TypePartId.codec.encode(value.typePartId));
     }
     case "Part": {
       return [7].concat(PartId.codec.encode(value.partId));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: Location; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     return { result: Location.Home, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: Location.CreateProject, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 2) {
     const result: { readonly result: ProjectId; readonly nextIndex: number } = ProjectId.codec.decode(patternIndex.nextIndex, binary);
     return { result: Location.Project(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 3) {
     const result: { readonly result: AccountId; readonly nextIndex: number } = AccountId.codec.decode(patternIndex.nextIndex, binary);
     return { result: Location.Account(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 4) {
     return { result: Location.Setting, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 5) {
     return { result: Location.About, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 6) {
     const result: { readonly result: TypePartId; readonly nextIndex: number } = TypePartId.codec.decode(patternIndex.nextIndex, binary);
     return { result: Location.TypePart(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 7) {
     const result: { readonly result: PartId; readonly nextIndex: number } = PartId.codec.decode(patternIndex.nextIndex, binary);
     return { result: Location.Part(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * TypeAlias. `export type T = {}`
  * @typePartId bf69f7e46f5e4949fe801c234fc3ad15
  */
 export const TypeAlias: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<TypeAlias>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: TypeAlias) => TypeAlias } = { typePartId: "bf69f7e46f5e4949fe801c234fc3ad15" as TypePartId, helper: (typeAlias: TypeAlias): TypeAlias => typeAlias, codec: { encode: (value: TypeAlias): ReadonlyArray<number> => (TsIdentifer.codec.encode(value.name).concat(List.codec(TsIdentifer.codec).encode(value.typeParameterList)).concat(String.codec.encode(value.document)).concat(TsType.codec.encode(value.type))), decode: (index: number, binary: Uint8Array): { readonly result: TypeAlias; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: TsIdentifer; readonly nextIndex: number } = TsIdentifer.codec.decode(index, binary);
   const typeParameterListAndNextIndex: { readonly result: List<TsIdentifer>; readonly nextIndex: number } = List.codec(TsIdentifer.codec).decode(nameAndNextIndex.nextIndex, binary);
   const documentAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(typeParameterListAndNextIndex.nextIndex, binary);
   const typeAndNextIndex: { readonly result: TsType; readonly nextIndex: number } = TsType.codec.decode(documentAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, typeParameterList: typeParameterListAndNextIndex.result, document: documentAndNextIndex.result, type: typeAndNextIndex.result }, nextIndex: typeAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * アカウントを識別するためのID
  * @typePartId c1a17b07e8e664ca80217833ff2ad3f1
  */
 export const AccountId: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<AccountId> } = { typePartId: "c1a17b07e8e664ca80217833ff2ad3f1" as TypePartId, codec: { encode: (value: AccountId): ReadonlyArray<number> => (encodeId(value)), decode: (index: number, binary: Uint8Array): { readonly result: AccountId; readonly nextIndex: number } => (decodeId(index, binary) as { readonly result: AccountId; readonly nextIndex: number }) } };
 
 
 /**
  * 文字列のkeyと式のvalue
  * @typePartId c2428cbcd62b33ce2c904a200b876863
  */
 export const KeyValue: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<KeyValue>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: KeyValue) => KeyValue } = { typePartId: "c2428cbcd62b33ce2c904a200b876863" as TypePartId, helper: (keyValue: KeyValue): KeyValue => keyValue, codec: { encode: (value: KeyValue): ReadonlyArray<number> => (String.codec.encode(value.key).concat(TsExpr.codec.encode(value.value))), decode: (index: number, binary: Uint8Array): { readonly result: KeyValue; readonly nextIndex: number } => {
   const keyAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const valueAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(keyAndNextIndex.nextIndex, binary);
   return { result: { key: keyAndNextIndex.result, value: valueAndNextIndex.result }, nextIndex: valueAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * リスト. JavaScriptのArrayで扱う
  * @typePartId c3fc2a6cea61086db59e11dc2bef0eee
  */
 export const List: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: <element extends unknown>(a: Codec<element>) => Codec<List<element>> } = { typePartId: "c3fc2a6cea61086db59e11dc2bef0eee" as TypePartId, codec: <element extends unknown>(elementCodec: Codec<element>): Codec<List<element>> => ({ encode: (value: List<element>): ReadonlyArray<number> => {
   let result: Array<number> = Int32.codec.encode(value.length) as Array<number>;
   for (const element of value){
     result = result.concat(elementCodec.encode(element));
   }
   return result;
 }, decode: (index: number, binary: Uint8Array): { readonly result: List<element>; readonly nextIndex: number } => {
   const lengthResult: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   let nextIndex: number = lengthResult.nextIndex;
   const result: Array<element> = [];
   for (let i = 0; i < lengthResult.result; i += 1){
     const resultAndNextIndex: { readonly result: element; readonly nextIndex: number } = elementCodec.decode(nextIndex, binary);
     result.push(resultAndNextIndex.result);
     nextIndex = resultAndNextIndex.nextIndex;
   }
   return { result, nextIndex };
 } }) };
 
 
 /**
  * definy.app の ログイン状態
  * @typePartId c4b574e3ca8bad17022054d5e77fd3d0
  */
 export const LogInState: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<LogInState>; 
 /**
  * アカウントトークンをindexedDBから読み取っている状態
  */
 readonly LoadingAccountTokenFromIndexedDB: LogInState; 
 /**
  * ログインしていない状態
  */
 readonly Guest: LogInState; 
 /**
  * ログインへの画面URLをリクエストした状態
  */
 readonly RequestingLogInUrl: (a: OpenIdConnectProvider) => LogInState; 
 /**
  * ログインURLを受け取り,ログイン画面へ移行中
  */
 readonly JumpingToLogInPage: LogInState; 
 /**
  * アカウントトークンの検証とログインしているユーザーの情報を取得している状態
  */
 readonly VerifyingAccountToken: (a: AccountToken) => LogInState; 
 /**
  * ログインしている状態
  */
 readonly LoggedIn: (a: AccountTokenAndUserId) => LogInState } = { LoadingAccountTokenFromIndexedDB: { _: "LoadingAccountTokenFromIndexedDB" }, Guest: { _: "Guest" }, RequestingLogInUrl: (openIdConnectProvider: OpenIdConnectProvider): LogInState => ({ _: "RequestingLogInUrl", openIdConnectProvider }), JumpingToLogInPage: { _: "JumpingToLogInPage" }, VerifyingAccountToken: (accountToken: AccountToken): LogInState => ({ _: "VerifyingAccountToken", accountToken }), LoggedIn: (accountTokenAndUserId: AccountTokenAndUserId): LogInState => ({ _: "LoggedIn", accountTokenAndUserId }), typePartId: "c4b574e3ca8bad17022054d5e77fd3d0" as TypePartId, codec: { encode: (value: LogInState): ReadonlyArray<number> => {
   switch (value._) {
     case "LoadingAccountTokenFromIndexedDB": {
       return [0];
     }
     case "Guest": {
       return [1];
     }
     case "RequestingLogInUrl": {
       return [2].concat(OpenIdConnectProvider.codec.encode(value.openIdConnectProvider));
     }
     case "JumpingToLogInPage": {
       return [3];
     }
     case "VerifyingAccountToken": {
       return [4].concat(AccountToken.codec.encode(value.accountToken));
     }
     case "LoggedIn": {
       return [5].concat(AccountTokenAndUserId.codec.encode(value.accountTokenAndUserId));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: LogInState; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     return { result: LogInState.LoadingAccountTokenFromIndexedDB, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: LogInState.Guest, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 2) {
     const result: { readonly result: OpenIdConnectProvider; readonly nextIndex: number } = OpenIdConnectProvider.codec.decode(patternIndex.nextIndex, binary);
     return { result: LogInState.RequestingLogInUrl(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 3) {
     return { result: LogInState.JumpingToLogInPage, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 4) {
     const result: { readonly result: AccountToken; readonly nextIndex: number } = AccountToken.codec.decode(patternIndex.nextIndex, binary);
     return { result: LogInState.VerifyingAccountToken(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 5) {
     const result: { readonly result: AccountTokenAndUserId; readonly nextIndex: number } = AccountTokenAndUserId.codec.decode(patternIndex.nextIndex, binary);
     return { result: LogInState.LoggedIn(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * for文
  * @typePartId c53be8bcaf56ff90080cf7a75f1e4815
  */
 export const ForStatement: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ForStatement>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ForStatement) => ForStatement } = { typePartId: "c53be8bcaf56ff90080cf7a75f1e4815" as TypePartId, helper: (forStatement: ForStatement): ForStatement => forStatement, codec: { encode: (value: ForStatement): ReadonlyArray<number> => (TsIdentifer.codec.encode(value.counterVariableName).concat(TsExpr.codec.encode(value.untilExpr)).concat(List.codec(Statement.codec).encode(value.statementList))), decode: (index: number, binary: Uint8Array): { readonly result: ForStatement; readonly nextIndex: number } => {
   const counterVariableNameAndNextIndex: { readonly result: TsIdentifer; readonly nextIndex: number } = TsIdentifer.codec.decode(index, binary);
   const untilExprAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(counterVariableNameAndNextIndex.nextIndex, binary);
   const statementListAndNextIndex: { readonly result: List<Statement>; readonly nextIndex: number } = List.codec(Statement.codec).decode(untilExprAndNextIndex.nextIndex, binary);
   return { result: { counterVariableName: counterVariableNameAndNextIndex.result, untilExpr: untilExprAndNextIndex.result, statementList: statementListAndNextIndex.result }, nextIndex: statementListAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * オブジェクトのメンバーの型
  * @typePartId c68bac5afb1a1d35af096bf317d09339
  */
 export const TsMemberType: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<TsMemberType>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: TsMemberType) => TsMemberType } = { typePartId: "c68bac5afb1a1d35af096bf317d09339" as TypePartId, helper: (tsMemberType: TsMemberType): TsMemberType => tsMemberType, codec: { encode: (value: TsMemberType): ReadonlyArray<number> => (String.codec.encode(value.name).concat(Bool.codec.encode(value.required)).concat(TsType.codec.encode(value.type)).concat(String.codec.encode(value.document))), decode: (index: number, binary: Uint8Array): { readonly result: TsMemberType; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const requiredAndNextIndex: { readonly result: Bool; readonly nextIndex: number } = Bool.codec.decode(nameAndNextIndex.nextIndex, binary);
   const typeAndNextIndex: { readonly result: TsType; readonly nextIndex: number } = TsType.codec.decode(requiredAndNextIndex.nextIndex, binary);
   const documentAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(typeAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, required: requiredAndNextIndex.result, type: typeAndNextIndex.result, document: documentAndNextIndex.result }, nextIndex: documentAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 条件演算子
  * @typePartId c7a771f770f0f92690faeb59eaff6268
  */
 export const ConditionalOperatorExpr: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ConditionalOperatorExpr>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ConditionalOperatorExpr) => ConditionalOperatorExpr } = { typePartId: "c7a771f770f0f92690faeb59eaff6268" as TypePartId, helper: (conditionalOperatorExpr: ConditionalOperatorExpr): ConditionalOperatorExpr => conditionalOperatorExpr, codec: { encode: (value: ConditionalOperatorExpr): ReadonlyArray<number> => (TsExpr.codec.encode(value.condition).concat(TsExpr.codec.encode(value.thenExpr)).concat(TsExpr.codec.encode(value.elseExpr))), decode: (index: number, binary: Uint8Array): { readonly result: ConditionalOperatorExpr; readonly nextIndex: number } => {
   const conditionAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(index, binary);
   const thenExprAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(conditionAndNextIndex.nextIndex, binary);
   const elseExprAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(thenExprAndNextIndex.nextIndex, binary);
   return { result: { condition: conditionAndNextIndex.result, thenExpr: thenExprAndNextIndex.result, elseExpr: elseExprAndNextIndex.result }, nextIndex: elseExprAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * if文
  * @typePartId cd325760f992e47a8438ae78ca9b1529
  */
 export const IfStatement: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<IfStatement>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: IfStatement) => IfStatement } = { typePartId: "cd325760f992e47a8438ae78ca9b1529" as TypePartId, helper: (ifStatement: IfStatement): IfStatement => ifStatement, codec: { encode: (value: IfStatement): ReadonlyArray<number> => (TsExpr.codec.encode(value.condition).concat(List.codec(Statement.codec).encode(value.thenStatementList))), decode: (index: number, binary: Uint8Array): { readonly result: IfStatement; readonly nextIndex: number } => {
   const conditionAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(index, binary);
   const thenStatementListAndNextIndex: { readonly result: List<Statement>; readonly nextIndex: number } = List.codec(Statement.codec).decode(conditionAndNextIndex.nextIndex, binary);
   return { result: { condition: conditionAndNextIndex.result, thenStatementList: thenStatementListAndNextIndex.result }, nextIndex: thenStatementListAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * クラスに生徒として入っているか, ゲストとして入っているか
  * @typePartId ce031774e68409c72ea855cf929f2293
  */
 export const QRole: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QRole>; 
 /**
  * 生徒, 質問を答えたり, フィードバックできる人
  */
 readonly Student: QRole; 
 /**
  * ゲスト
  */
 readonly Guest: QRole } = { Student: "Student", Guest: "Guest", typePartId: "ce031774e68409c72ea855cf929f2293" as TypePartId, codec: { encode: (value: QRole): ReadonlyArray<number> => {
   switch (value) {
     case "Student": {
       return [0];
     }
     case "Guest": {
       return [1];
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: QRole; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     return { result: QRole.Student, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: QRole.Guest, nextIndex: patternIndex.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * questの クラス
  * @typePartId cf779792c0201a3874f77765b063b64b
  */
 export const QClass: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QClass>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: QClass) => QClass } = { typePartId: "cf779792c0201a3874f77765b063b64b" as TypePartId, helper: (qClass: QClass): QClass => qClass, codec: { encode: (value: QClass): ReadonlyArray<number> => (QClassId.codec.encode(value.id).concat(String.codec.encode(value.name)).concat(QProgramId.codec.encode(value.programId)).concat(QClassInvitationToken.codec.encode(value.invitationToken)).concat(AccountId.codec.encode(value.createAccountId))), decode: (index: number, binary: Uint8Array): { readonly result: QClass; readonly nextIndex: number } => {
   const idAndNextIndex: { readonly result: QClassId; readonly nextIndex: number } = QClassId.codec.decode(index, binary);
   const nameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(idAndNextIndex.nextIndex, binary);
   const programIdAndNextIndex: { readonly result: QProgramId; readonly nextIndex: number } = QProgramId.codec.decode(nameAndNextIndex.nextIndex, binary);
   const invitationTokenAndNextIndex: { readonly result: QClassInvitationToken; readonly nextIndex: number } = QClassInvitationToken.codec.decode(programIdAndNextIndex.nextIndex, binary);
   const createAccountIdAndNextIndex: { readonly result: AccountId; readonly nextIndex: number } = AccountId.codec.decode(invitationTokenAndNextIndex.nextIndex, binary);
   return { result: { id: idAndNextIndex.result, name: nameAndNextIndex.result, programId: programIdAndNextIndex.result, invitationToken: invitationTokenAndNextIndex.result, createAccountId: createAccountIdAndNextIndex.result }, nextIndex: createAccountIdAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * フィールド名
  * @typePartId d256109676f834b74931495891b61d1b
  */
 export const ElmFieldName: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmFieldName>; 
 /**
  * **直接 FieldName.FieldName("name") と指定してはいけない!! Elmの識別子として使える文字としてチェックできないため**
  */
 readonly FieldName: (a: String) => ElmFieldName } = { FieldName: (string_: String): ElmFieldName => ({ _: "FieldName", string: string_ }), typePartId: "d256109676f834b74931495891b61d1b" as TypePartId, codec: { encode: (value: ElmFieldName): ReadonlyArray<number> => {
   switch (value._) {
     case "FieldName": {
       return [0].concat(String.codec.encode(value.string));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: ElmFieldName; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: String; readonly nextIndex: number } = String.codec.decode(patternIndex.nextIndex, binary);
     return { result: ElmFieldName.FieldName(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * 質問を作成するプログラム. 複数のクラスを開催できる.
  * @typePartId d59eabf90cfeb709b136e1c832b4f5d4
  */
 export const QProgram: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QProgram>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: QProgram) => QProgram } = { typePartId: "d59eabf90cfeb709b136e1c832b4f5d4" as TypePartId, helper: (qProgram: QProgram): QProgram => qProgram, codec: { encode: (value: QProgram): ReadonlyArray<number> => (QProgramId.codec.encode(value.id).concat(String.codec.encode(value.name)).concat(AccountId.codec.encode(value.createAccountId))), decode: (index: number, binary: Uint8Array): { readonly result: QProgram; readonly nextIndex: number } => {
   const idAndNextIndex: { readonly result: QProgramId; readonly nextIndex: number } = QProgramId.codec.decode(index, binary);
   const nameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(idAndNextIndex.nextIndex, binary);
   const createAccountIdAndNextIndex: { readonly result: AccountId; readonly nextIndex: number } = AccountId.codec.decode(nameAndNextIndex.nextIndex, binary);
   return { result: { id: idAndNextIndex.result, name: nameAndNextIndex.result, createAccountId: createAccountIdAndNextIndex.result }, nextIndex: createAccountIdAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * バリアント名
  * @typePartId d77f1f967b892c739a1555f74d2ff9fd
  */
 export const ElmVariantName: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmVariantName>; 
 /**
  * **直接 VariantName.VariantName("Loading") と指定してはいけない!! Elmの識別子として使える文字としてチェックできないため**
  */
 readonly VariantName: (a: String) => ElmVariantName } = { VariantName: (string_: String): ElmVariantName => ({ _: "VariantName", string: string_ }), typePartId: "d77f1f967b892c739a1555f74d2ff9fd" as TypePartId, codec: { encode: (value: ElmVariantName): ReadonlyArray<number> => {
   switch (value._) {
     case "VariantName": {
       return [0].concat(String.codec.encode(value.string));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: ElmVariantName; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: String; readonly nextIndex: number } = String.codec.decode(patternIndex.nextIndex, binary);
     return { result: ElmVariantName.VariantName(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * 交差型
  * @typePartId d82150857d0f2e78c1df0f418ba9b01a
  */
 export const IntersectionType: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<IntersectionType>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: IntersectionType) => IntersectionType } = { typePartId: "d82150857d0f2e78c1df0f418ba9b01a" as TypePartId, helper: (intersectionType: IntersectionType): IntersectionType => intersectionType, codec: { encode: (value: IntersectionType): ReadonlyArray<number> => (TsType.codec.encode(value.left).concat(TsType.codec.encode(value.right))), decode: (index: number, binary: Uint8Array): { readonly result: IntersectionType; readonly nextIndex: number } => {
   const leftAndNextIndex: { readonly result: TsType; readonly nextIndex: number } = TsType.codec.decode(index, binary);
   const rightAndNextIndex: { readonly result: TsType; readonly nextIndex: number } = TsType.codec.decode(leftAndNextIndex.nextIndex, binary);
   return { result: { left: leftAndNextIndex.result, right: rightAndNextIndex.result }, nextIndex: rightAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * パーツの定義. 他のプログラミング言語でいう関数や, 変数のこと
  * @typePartId d8bccc70252cee9ce70784bf5dfa493b
  */
 export const Part: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Part>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: Part) => Part } = { typePartId: "d8bccc70252cee9ce70784bf5dfa493b" as TypePartId, helper: (part: Part): Part => part, codec: { encode: (value: Part): ReadonlyArray<number> => (String.codec.encode(value.name).concat(String.codec.encode(value.description)).concat(Type.codec.encode(value.type)).concat(Expr.codec.encode(value.expr)).concat(ProjectId.codec.encode(value.projectId))), decode: (index: number, binary: Uint8Array): { readonly result: Part; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const descriptionAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
   const typeAndNextIndex: { readonly result: Type; readonly nextIndex: number } = Type.codec.decode(descriptionAndNextIndex.nextIndex, binary);
   const exprAndNextIndex: { readonly result: Expr; readonly nextIndex: number } = Expr.codec.decode(typeAndNextIndex.nextIndex, binary);
   const projectIdAndNextIndex: { readonly result: ProjectId; readonly nextIndex: number } = ProjectId.codec.decode(exprAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, description: descriptionAndNextIndex.result, type: typeAndNextIndex.result, expr: exprAndNextIndex.result, projectId: projectIdAndNextIndex.result }, nextIndex: projectIdAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * Definyの評価しきった式
  * @typePartId daa9bf22c3f2e52ff92edcdd896d6a6d
  */
 export const EvaluatedExpr: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<EvaluatedExpr>; 
 /**
  * Definyだけでは表現できない式
  */
 readonly Kernel: (a: KernelExpr) => EvaluatedExpr; 
 /**
  * 32bit整数
  */
 readonly Int32: (a: Int32) => EvaluatedExpr; 
 /**
  * タグを参照
  */
 readonly TagReference: (a: TagReference) => EvaluatedExpr; 
 /**
  * 内部関数呼び出し
  */
 readonly KernelCall: (a: KernelCall) => EvaluatedExpr } = { Kernel: (kernelExpr: KernelExpr): EvaluatedExpr => ({ _: "Kernel", kernelExpr }), Int32: (int32: Int32): EvaluatedExpr => ({ _: "Int32", int32 }), TagReference: (tagReference: TagReference): EvaluatedExpr => ({ _: "TagReference", tagReference }), KernelCall: (kernelCall: KernelCall): EvaluatedExpr => ({ _: "KernelCall", kernelCall }), typePartId: "daa9bf22c3f2e52ff92edcdd896d6a6d" as TypePartId, codec: { encode: (value: EvaluatedExpr): ReadonlyArray<number> => {
   switch (value._) {
     case "Kernel": {
       return [0].concat(KernelExpr.codec.encode(value.kernelExpr));
     }
     case "Int32": {
       return [1].concat(Int32.codec.encode(value.int32));
     }
     case "TagReference": {
       return [2].concat(TagReference.codec.encode(value.tagReference));
     }
     case "KernelCall": {
       return [3].concat(KernelCall.codec.encode(value.kernelCall));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: EvaluatedExpr; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: KernelExpr; readonly nextIndex: number } = KernelExpr.codec.decode(patternIndex.nextIndex, binary);
     return { result: EvaluatedExpr.Kernel(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 1) {
     const result: { readonly result: Int32; readonly nextIndex: number } = Int32.codec.decode(patternIndex.nextIndex, binary);
     return { result: EvaluatedExpr.Int32(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 2) {
     const result: { readonly result: TagReference; readonly nextIndex: number } = TagReference.codec.decode(patternIndex.nextIndex, binary);
     return { result: EvaluatedExpr.TagReference(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 3) {
     const result: { readonly result: KernelCall; readonly nextIndex: number } = KernelCall.codec.decode(patternIndex.nextIndex, binary);
     return { result: EvaluatedExpr.KernelCall(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * 1つの型パーツを保存するために指定するパラメーター
  * @typePartId dac038758a5c45f762de388bb5193fb8
  */
 export const SetTypePartParameter: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<SetTypePartParameter>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: SetTypePartParameter) => SetTypePartParameter } = { typePartId: "dac038758a5c45f762de388bb5193fb8" as TypePartId, helper: (setTypePartParameter: SetTypePartParameter): SetTypePartParameter => setTypePartParameter, codec: { encode: (value: SetTypePartParameter): ReadonlyArray<number> => (AccountToken.codec.encode(value.accountToken).concat(TypePartId.codec.encode(value.typePartId)).concat(TypePart.codec.encode(value.typePart))), decode: (index: number, binary: Uint8Array): { readonly result: SetTypePartParameter; readonly nextIndex: number } => {
   const accountTokenAndNextIndex: { readonly result: AccountToken; readonly nextIndex: number } = AccountToken.codec.decode(index, binary);
   const typePartIdAndNextIndex: { readonly result: TypePartId; readonly nextIndex: number } = TypePartId.codec.decode(accountTokenAndNextIndex.nextIndex, binary);
   const typePartAndNextIndex: { readonly result: TypePart; readonly nextIndex: number } = TypePart.codec.decode(typePartIdAndNextIndex.nextIndex, binary);
   return { result: { accountToken: accountTokenAndNextIndex.result, typePartId: typePartIdAndNextIndex.result, typePart: typePartAndNextIndex.result }, nextIndex: typePartAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * Bool. 真か偽. JavaScriptのbooleanで扱える. true: 1, false: 0. (1byte)としてバイナリに変換する
  * @typePartId db57caf129f60db969b5b5224a72b937
  */
 export const Bool: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Bool>; 
 /**
  * 偽
  */
 readonly False: Bool; 
 /**
  * 真
  */
 readonly True: Bool } = { False: false, True: true, typePartId: "db57caf129f60db969b5b5224a72b937" as TypePartId, codec: { encode: (value: Bool): ReadonlyArray<number> => [value?1:0], decode: (index: number, binary: Uint8Array): { readonly result: Bool; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     return { result: Bool.False, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: Bool.True, nextIndex: patternIndex.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * Elmの関数の定義. 引数がない関数(定数)も含まれる
  * @typePartId db8b9f83d99ef58fd206acca4e56d098
  */
 export const ElmDefinition: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmDefinition>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: ElmDefinition) => ElmDefinition } = { typePartId: "db8b9f83d99ef58fd206acca4e56d098" as TypePartId, helper: (elmDefinition: ElmDefinition): ElmDefinition => elmDefinition, codec: { encode: (value: ElmDefinition): ReadonlyArray<number> => (String.codec.encode(value.name).concat(ElmType.codec.encode(value.type)).concat(ElmType.codec.encode(value.expr)).concat(String.codec.encode(value.comment))), decode: (index: number, binary: Uint8Array): { readonly result: ElmDefinition; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const typeAndNextIndex: { readonly result: ElmType; readonly nextIndex: number } = ElmType.codec.decode(nameAndNextIndex.nextIndex, binary);
   const exprAndNextIndex: { readonly result: ElmType; readonly nextIndex: number } = ElmType.codec.decode(typeAndNextIndex.nextIndex, binary);
   const commentAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(exprAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, type: typeAndNextIndex.result, expr: exprAndNextIndex.result, comment: commentAndNextIndex.result }, nextIndex: commentAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 外部に公開する関数
  * @typePartId dd3366ce7254327c85732d2932ff219b
  */
 export const Function: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Function>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: Function) => Function } = { typePartId: "dd3366ce7254327c85732d2932ff219b" as TypePartId, helper: (function_: Function): Function => function_, codec: { encode: (value: Function): ReadonlyArray<number> => (TsIdentifer.codec.encode(value.name).concat(String.codec.encode(value.document)).concat(List.codec(TsIdentifer.codec).encode(value.typeParameterList)).concat(List.codec(ParameterWithDocument.codec).encode(value.parameterList)).concat(TsType.codec.encode(value.returnType)).concat(List.codec(Statement.codec).encode(value.statementList))), decode: (index: number, binary: Uint8Array): { readonly result: Function; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: TsIdentifer; readonly nextIndex: number } = TsIdentifer.codec.decode(index, binary);
   const documentAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
   const typeParameterListAndNextIndex: { readonly result: List<TsIdentifer>; readonly nextIndex: number } = List.codec(TsIdentifer.codec).decode(documentAndNextIndex.nextIndex, binary);
   const parameterListAndNextIndex: { readonly result: List<ParameterWithDocument>; readonly nextIndex: number } = List.codec(ParameterWithDocument.codec).decode(typeParameterListAndNextIndex.nextIndex, binary);
   const returnTypeAndNextIndex: { readonly result: TsType; readonly nextIndex: number } = TsType.codec.decode(parameterListAndNextIndex.nextIndex, binary);
   const statementListAndNextIndex: { readonly result: List<Statement>; readonly nextIndex: number } = List.codec(Statement.codec).decode(returnTypeAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, document: documentAndNextIndex.result, typeParameterList: typeParameterListAndNextIndex.result, parameterList: parameterListAndNextIndex.result, returnType: returnTypeAndNextIndex.result, statementList: statementListAndNextIndex.result }, nextIndex: statementListAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * アカウントトークン. アカウントトークンを持っていればアクセストークンをDefinyのサーバーにリクエストした際に得られるIDのアカウントを保有していると証明できる. サーバーにハッシュ化したものを保存している. これが盗まれた場合,不正に得た人はアカウントを乗っ取ることができる. 有効期限はなし, 最後に発行したアカウントトークン以外は無効になる
  * @typePartId deb01f82879754c03aa4d244e136e59d
  */
 export const AccountToken: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<AccountToken> } = { typePartId: "deb01f82879754c03aa4d244e136e59d" as TypePartId, codec: { encode: (value: AccountToken): ReadonlyArray<number> => (encodeToken(value)), decode: (index: number, binary: Uint8Array): { readonly result: AccountToken; readonly nextIndex: number } => (decodeToken(index, binary) as { readonly result: AccountToken; readonly nextIndex: number }) } };
 
 
 /**
  * ローカル関数定義
  * @typePartId df5c5388248252a92864ceb219628b8e
  */
 export const FunctionDefinitionStatement: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<FunctionDefinitionStatement>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: FunctionDefinitionStatement) => FunctionDefinitionStatement } = { typePartId: "df5c5388248252a92864ceb219628b8e" as TypePartId, helper: (functionDefinitionStatement: FunctionDefinitionStatement): FunctionDefinitionStatement => functionDefinitionStatement, codec: { encode: (value: FunctionDefinitionStatement): ReadonlyArray<number> => (TsIdentifer.codec.encode(value.name).concat(List.codec(TsIdentifer.codec).encode(value.typeParameterList)).concat(List.codec(ParameterWithDocument.codec).encode(value.parameterList)).concat(TsType.codec.encode(value.returnType)).concat(List.codec(Statement.codec).encode(value.statementList))), decode: (index: number, binary: Uint8Array): { readonly result: FunctionDefinitionStatement; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: TsIdentifer; readonly nextIndex: number } = TsIdentifer.codec.decode(index, binary);
   const typeParameterListAndNextIndex: { readonly result: List<TsIdentifer>; readonly nextIndex: number } = List.codec(TsIdentifer.codec).decode(nameAndNextIndex.nextIndex, binary);
   const parameterListAndNextIndex: { readonly result: List<ParameterWithDocument>; readonly nextIndex: number } = List.codec(ParameterWithDocument.codec).decode(typeParameterListAndNextIndex.nextIndex, binary);
   const returnTypeAndNextIndex: { readonly result: TsType; readonly nextIndex: number } = TsType.codec.decode(parameterListAndNextIndex.nextIndex, binary);
   const statementListAndNextIndex: { readonly result: List<Statement>; readonly nextIndex: number } = List.codec(Statement.codec).decode(returnTypeAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, typeParameterList: typeParameterListAndNextIndex.result, parameterList: parameterListAndNextIndex.result, returnType: returnTypeAndNextIndex.result, statementList: statementListAndNextIndex.result }, nextIndex: statementListAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 直積型のパターン
  * @typePartId e4ef8a0713aceb0eaa7606cd516ad847
  */
 export const Pattern: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Pattern>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: Pattern) => Pattern } = { typePartId: "e4ef8a0713aceb0eaa7606cd516ad847" as TypePartId, helper: (pattern: Pattern): Pattern => pattern, codec: { encode: (value: Pattern): ReadonlyArray<number> => (String.codec.encode(value.name).concat(String.codec.encode(value.description)).concat(Maybe.codec(Type.codec).encode(value.parameter))), decode: (index: number, binary: Uint8Array): { readonly result: Pattern; readonly nextIndex: number } => {
   const nameAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(index, binary);
   const descriptionAndNextIndex: { readonly result: String; readonly nextIndex: number } = String.codec.decode(nameAndNextIndex.nextIndex, binary);
   const parameterAndNextIndex: { readonly result: Maybe<Type>; readonly nextIndex: number } = Maybe.codec(Type.codec).decode(descriptionAndNextIndex.nextIndex, binary);
   return { result: { name: nameAndNextIndex.result, description: descriptionAndNextIndex.result, parameter: parameterAndNextIndex.result }, nextIndex: parameterAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 画像から求められるトークン.キャッシュのキーとして使われる.1つのトークンに対して永久に1つの画像データしか表さない. キャッシュを更新する必要はない
  * @typePartId e71e15a15b0883940a75e58367151d1a
  */
 export const ImageHash: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ImageHash> } = { typePartId: "e71e15a15b0883940a75e58367151d1a" as TypePartId, codec: { encode: (value: ImageHash): ReadonlyArray<number> => (encodeToken(value)), decode: (index: number, binary: Uint8Array): { readonly result: ImageHash; readonly nextIndex: number } => (decodeToken(index, binary) as { readonly result: ImageHash; readonly nextIndex: number }) } };
 
 
 /**
  * Definy の 式
  * @typePartId ed9a046b5f121f6e54ac7f3834cbc644
  */
 export const Expr: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Expr>; 
 /**
  * Definyだけでは表現できない式
  */
 readonly Kernel: (a: KernelExpr) => Expr; 
 /**
  * 32bit整数
  */
 readonly Int32Literal: (a: Int32) => Expr; 
 /**
  * パーツの値を参照
  */
 readonly PartReference: (a: PartId) => Expr; 
 /**
  * タグを参照
  */
 readonly TagReference: (a: TagReference) => Expr; 
 /**
  * 関数呼び出し
  */
 readonly FunctionCall: (a: FunctionCall) => Expr } = { Kernel: (kernelExpr: KernelExpr): Expr => ({ _: "Kernel", kernelExpr }), Int32Literal: (int32: Int32): Expr => ({ _: "Int32Literal", int32 }), PartReference: (partId: PartId): Expr => ({ _: "PartReference", partId }), TagReference: (tagReference: TagReference): Expr => ({ _: "TagReference", tagReference }), FunctionCall: (functionCall: FunctionCall): Expr => ({ _: "FunctionCall", functionCall }), typePartId: "ed9a046b5f121f6e54ac7f3834cbc644" as TypePartId, codec: { encode: (value: Expr): ReadonlyArray<number> => {
   switch (value._) {
     case "Kernel": {
       return [0].concat(KernelExpr.codec.encode(value.kernelExpr));
     }
     case "Int32Literal": {
       return [1].concat(Int32.codec.encode(value.int32));
     }
     case "PartReference": {
       return [2].concat(PartId.codec.encode(value.partId));
     }
     case "TagReference": {
       return [3].concat(TagReference.codec.encode(value.tagReference));
     }
     case "FunctionCall": {
       return [4].concat(FunctionCall.codec.encode(value.functionCall));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: Expr; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: KernelExpr; readonly nextIndex: number } = KernelExpr.codec.decode(patternIndex.nextIndex, binary);
     return { result: Expr.Kernel(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 1) {
     const result: { readonly result: Int32; readonly nextIndex: number } = Int32.codec.decode(patternIndex.nextIndex, binary);
     return { result: Expr.Int32Literal(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 2) {
     const result: { readonly result: PartId; readonly nextIndex: number } = PartId.codec.decode(patternIndex.nextIndex, binary);
     return { result: Expr.PartReference(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 3) {
     const result: { readonly result: TagReference; readonly nextIndex: number } = TagReference.codec.decode(patternIndex.nextIndex, binary);
     return { result: Expr.TagReference(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 4) {
     const result: { readonly result: FunctionCall; readonly nextIndex: number } = FunctionCall.codec.decode(patternIndex.nextIndex, binary);
     return { result: Expr.FunctionCall(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * タグの参照を表す
  * @typePartId edd59bd2ab4852c149f6ce5917767908
  */
 export const TagReference: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<TagReference>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: TagReference) => TagReference } = { typePartId: "edd59bd2ab4852c149f6ce5917767908" as TypePartId, helper: (tagReference: TagReference): TagReference => tagReference, codec: { encode: (value: TagReference): ReadonlyArray<number> => (TypePartId.codec.encode(value.typePartId).concat(TagId.codec.encode(value.tagId))), decode: (index: number, binary: Uint8Array): { readonly result: TagReference; readonly nextIndex: number } => {
   const typePartIdAndNextIndex: { readonly result: TypePartId; readonly nextIndex: number } = TypePartId.codec.decode(index, binary);
   const tagIdAndNextIndex: { readonly result: TagId; readonly nextIndex: number } = TagId.codec.decode(typePartIdAndNextIndex.nextIndex, binary);
   return { result: { typePartId: typePartIdAndNextIndex.result, tagId: tagIdAndNextIndex.result }, nextIndex: tagIdAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * definy.app を開発する上での動作モード. デベロップモード(http://localhost:2520)か, リリースモード(https://definy.app)
  * @typePartId ee0590e764618611ffa8e1a0a2e22f79
  */
 export const Mode: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<Mode>; 
 /**
  * ローカルで開発するときのモード. オリジンは http://localshot:2520
  */
 readonly Develop: Mode; 
 /**
  * リリースモード. オリジンは https://definy.app
  */
 readonly Release: Mode } = { Develop: "Develop", Release: "Release", typePartId: "ee0590e764618611ffa8e1a0a2e22f79" as TypePartId, codec: { encode: (value: Mode): ReadonlyArray<number> => {
   switch (value) {
     case "Develop": {
       return [0];
     }
     case "Release": {
       return [1];
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: Mode; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     return { result: Mode.Develop, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: Mode.Release, nextIndex: patternIndex.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * 2項演算子と左右の式
  * @typePartId eec2dab74fbcd3237bfa1c773f9b9d21
  */
 export const BinaryOperatorExpr: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<BinaryOperatorExpr>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: BinaryOperatorExpr) => BinaryOperatorExpr } = { typePartId: "eec2dab74fbcd3237bfa1c773f9b9d21" as TypePartId, helper: (binaryOperatorExpr: BinaryOperatorExpr): BinaryOperatorExpr => binaryOperatorExpr, codec: { encode: (value: BinaryOperatorExpr): ReadonlyArray<number> => (BinaryOperator.codec.encode(value.operator).concat(TsExpr.codec.encode(value.left)).concat(TsExpr.codec.encode(value.right))), decode: (index: number, binary: Uint8Array): { readonly result: BinaryOperatorExpr; readonly nextIndex: number } => {
   const operatorAndNextIndex: { readonly result: BinaryOperator; readonly nextIndex: number } = BinaryOperator.codec.decode(index, binary);
   const leftAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(operatorAndNextIndex.nextIndex, binary);
   const rightAndNextIndex: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(leftAndNextIndex.nextIndex, binary);
   return { result: { operator: operatorAndNextIndex.result, left: leftAndNextIndex.result, right: rightAndNextIndex.result }, nextIndex: rightAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * 出力するコードの種類
  * @typePartId eedf73c97f9dd61159572322f6d7e0a5
  */
 export const CodeType: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<CodeType>; 
 /**
  * JavaScript
  */
 readonly JavaScript: CodeType; 
 /**
  * TypeScript
  */
 readonly TypeScript: CodeType } = { JavaScript: "JavaScript", TypeScript: "TypeScript", typePartId: "eedf73c97f9dd61159572322f6d7e0a5" as TypePartId, codec: { encode: (value: CodeType): ReadonlyArray<number> => {
   switch (value) {
     case "JavaScript": {
       return [0];
     }
     case "TypeScript": {
       return [1];
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: CodeType; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     return { result: CodeType.JavaScript, nextIndex: patternIndex.nextIndex };
   }
   if (patternIndex.result === 1) {
     return { result: CodeType.TypeScript, nextIndex: patternIndex.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * ラムダ式
  * @typePartId eeeef818144e5a42460c4efdaa221460
  */
 export const LambdaExpr: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<LambdaExpr>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: LambdaExpr) => LambdaExpr } = { typePartId: "eeeef818144e5a42460c4efdaa221460" as TypePartId, helper: (lambdaExpr: LambdaExpr): LambdaExpr => lambdaExpr, codec: { encode: (value: LambdaExpr): ReadonlyArray<number> => (List.codec(Parameter.codec).encode(value.parameterList).concat(List.codec(TsIdentifer.codec).encode(value.typeParameterList)).concat(TsType.codec.encode(value.returnType)).concat(List.codec(Statement.codec).encode(value.statementList))), decode: (index: number, binary: Uint8Array): { readonly result: LambdaExpr; readonly nextIndex: number } => {
   const parameterListAndNextIndex: { readonly result: List<Parameter>; readonly nextIndex: number } = List.codec(Parameter.codec).decode(index, binary);
   const typeParameterListAndNextIndex: { readonly result: List<TsIdentifer>; readonly nextIndex: number } = List.codec(TsIdentifer.codec).decode(parameterListAndNextIndex.nextIndex, binary);
   const returnTypeAndNextIndex: { readonly result: TsType; readonly nextIndex: number } = TsType.codec.decode(typeParameterListAndNextIndex.nextIndex, binary);
   const statementListAndNextIndex: { readonly result: List<Statement>; readonly nextIndex: number } = List.codec(Statement.codec).decode(returnTypeAndNextIndex.nextIndex, binary);
   return { result: { parameterList: parameterListAndNextIndex.result, typeParameterList: typeParameterListAndNextIndex.result, returnType: returnTypeAndNextIndex.result, statementList: statementListAndNextIndex.result }, nextIndex: statementListAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * ログインのURLを発行するために必要なデータ
  * @typePartId f03ea5331c1a3adcde80a04054d35e07
  */
 export const RequestLogInUrlRequestData: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<RequestLogInUrlRequestData>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: RequestLogInUrlRequestData) => RequestLogInUrlRequestData } = { typePartId: "f03ea5331c1a3adcde80a04054d35e07" as TypePartId, helper: (requestLogInUrlRequestData: RequestLogInUrlRequestData): RequestLogInUrlRequestData => requestLogInUrlRequestData, codec: { encode: (value: RequestLogInUrlRequestData): ReadonlyArray<number> => (OpenIdConnectProvider.codec.encode(value.openIdConnectProvider).concat(UrlData.codec.encode(value.urlData))), decode: (index: number, binary: Uint8Array): { readonly result: RequestLogInUrlRequestData; readonly nextIndex: number } => {
   const openIdConnectProviderAndNextIndex: { readonly result: OpenIdConnectProvider; readonly nextIndex: number } = OpenIdConnectProvider.codec.decode(index, binary);
   const urlDataAndNextIndex: { readonly result: UrlData; readonly nextIndex: number } = UrlData.codec.decode(openIdConnectProviderAndNextIndex.nextIndex, binary);
   return { result: { openIdConnectProvider: openIdConnectProviderAndNextIndex.result, urlData: urlDataAndNextIndex.result }, nextIndex: urlDataAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * プロジェクトに属する質問や, クラスを取得するときに必要なパラメータ
  * @typePartId f26bc98a33011dd4892a7cdcfb4ccade
  */
 export const QAccountTokenAndProgramId: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<QAccountTokenAndProgramId>; 
 /**
  * 型を合わせる上で便利なヘルパー関数
  */
 readonly helper: (a: QAccountTokenAndProgramId) => QAccountTokenAndProgramId } = { typePartId: "f26bc98a33011dd4892a7cdcfb4ccade" as TypePartId, helper: (qAccountTokenAndProgramId: QAccountTokenAndProgramId): QAccountTokenAndProgramId => qAccountTokenAndProgramId, codec: { encode: (value: QAccountTokenAndProgramId): ReadonlyArray<number> => (AccountToken.codec.encode(value.accountToken).concat(QProgramId.codec.encode(value.programId))), decode: (index: number, binary: Uint8Array): { readonly result: QAccountTokenAndProgramId; readonly nextIndex: number } => {
   const accountTokenAndNextIndex: { readonly result: AccountToken; readonly nextIndex: number } = AccountToken.codec.decode(index, binary);
   const programIdAndNextIndex: { readonly result: QProgramId; readonly nextIndex: number } = QProgramId.codec.decode(accountTokenAndNextIndex.nextIndex, binary);
   return { result: { accountToken: accountTokenAndNextIndex.result, programId: programIdAndNextIndex.result }, nextIndex: programIdAndNextIndex.nextIndex };
 } } };
 
 
 /**
  * Elmの型定義
  * @typePartId f4bed793b657b39db5a579c9e158eba5
  */
 export const ElmTypeDeclaration: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<ElmTypeDeclaration>; 
 /**
  * 型エイリアス. レコード型に名前を付ける
  */
 readonly TypeAlias: (a: ElmTypeAlias) => ElmTypeDeclaration; 
 /**
  * カスタム型. 代数的データ型
  */
 readonly CustomType: (a: ElmCustomType) => ElmTypeDeclaration } = { TypeAlias: (elmTypeAlias: ElmTypeAlias): ElmTypeDeclaration => ({ _: "TypeAlias", elmTypeAlias }), CustomType: (elmCustomType: ElmCustomType): ElmTypeDeclaration => ({ _: "CustomType", elmCustomType }), typePartId: "f4bed793b657b39db5a579c9e158eba5" as TypePartId, codec: { encode: (value: ElmTypeDeclaration): ReadonlyArray<number> => {
   switch (value._) {
     case "TypeAlias": {
       return [0].concat(ElmTypeAlias.codec.encode(value.elmTypeAlias));
     }
     case "CustomType": {
       return [1].concat(ElmCustomType.codec.encode(value.elmCustomType));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: ElmTypeDeclaration; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: ElmTypeAlias; readonly nextIndex: number } = ElmTypeAlias.codec.decode(patternIndex.nextIndex, binary);
     return { result: ElmTypeDeclaration.TypeAlias(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 1) {
     const result: { readonly result: ElmCustomType; readonly nextIndex: number } = ElmCustomType.codec.decode(patternIndex.nextIndex, binary);
     return { result: ElmTypeDeclaration.CustomType(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 /**
  * JavaScriptのオブジェクトリテラルの要素
  * @typePartId fddd2a65994fae205dd636f3a6b9f1ea
  */
 export const TsMember: { 
 /**
  * definy.app内 の 型パーツの Id
  */
 readonly typePartId: TypePartId; 
 /**
  * 独自のバイナリ形式の変換処理ができるコーデック
  */
 readonly codec: Codec<TsMember>; 
 /**
  * ...a のようにする
  */
 readonly Spread: (a: TsExpr) => TsMember; 
 /**
  * a: b のようにする
  */
 readonly KeyValue: (a: KeyValue) => TsMember } = { Spread: (tsExpr: TsExpr): TsMember => ({ _: "Spread", tsExpr }), KeyValue: (keyValue: KeyValue): TsMember => ({ _: "KeyValue", keyValue }), typePartId: "fddd2a65994fae205dd636f3a6b9f1ea" as TypePartId, codec: { encode: (value: TsMember): ReadonlyArray<number> => {
   switch (value._) {
     case "Spread": {
       return [0].concat(TsExpr.codec.encode(value.tsExpr));
     }
     case "KeyValue": {
       return [1].concat(KeyValue.codec.encode(value.keyValue));
     }
   }
 }, decode: (index: number, binary: Uint8Array): { readonly result: TsMember; readonly nextIndex: number } => {
   const patternIndex: { readonly result: number; readonly nextIndex: number } = Int32.codec.decode(index, binary);
   if (patternIndex.result === 0) {
     const result: { readonly result: TsExpr; readonly nextIndex: number } = TsExpr.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsMember.Spread(result.result), nextIndex: result.nextIndex };
   }
   if (patternIndex.result === 1) {
     const result: { readonly result: KeyValue; readonly nextIndex: number } = KeyValue.codec.decode(patternIndex.nextIndex, binary);
     return { result: TsMember.KeyValue(result.result), nextIndex: result.nextIndex };
   }
   throw new Error("存在しないパターンを指定された 型を更新してください");
 } } };
 
 
 